/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/game.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/characters/Player.js":
/*!**********************************!*\
  !*** ./src/characters/Player.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _phaser = __webpack_require__(/*! ../phaser */ \"./src/phaser.js\");\n\nvar _phaser2 = _interopRequireDefault(_phaser);\n\nvar _InputBindings = __webpack_require__(/*! ../input/InputBindings */ \"./src/input/InputBindings.js\");\n\nvar _InputBindings2 = _interopRequireDefault(_InputBindings);\n\nvar _Gun = __webpack_require__(/*! ../weapons/Gun */ \"./src/weapons/Gun.js\");\n\nvar _Gun2 = _interopRequireDefault(_Gun);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Player = function () {\n  function Player(game) {\n    _classCallCheck(this, Player);\n\n    this.game = game;\n    this.input = new _InputBindings2.default(game);\n    this.speed = 150;\n\n    // STATS:\n    this.shotsFired = 0;\n    this.shotsHit = 0;\n    this.enemiesKilled = 0;\n\n    this.sprite = game.physics.add.sprite(0, 0, 'player').setMaxVelocity(500).setFriction(400, 200).setCollideWorldBounds(true);\n\n    this.gun = new _Gun2.default(game, this, 200);\n  }\n\n  _createClass(Player, [{\n    key: 'update',\n    value: function update() {\n      this.addMovementInput();\n      this.addRotationInput();\n\n      if (this.input.pointer.isDown) this.gun.fire();\n    }\n  }, {\n    key: 'addRotationInput',\n    value: function addRotationInput() {\n      this.sprite.rotation = _phaser2.default.Math.Angle.Between(this.sprite.x, this.sprite.y, this.input.pointer.x + this.game.cameras.main.scrollX, this.input.pointer.y + this.game.cameras.main.scrollY);\n    }\n  }, {\n    key: 'sprint',\n    value: function sprint() {\n      // SPRINT\n      if (this.input.SHIFT.isDown) {\n        if (this.speed < 150) {\n          this.speed = 150;\n        }\n      } else {\n        this.speed = 75;\n      }\n    }\n  }, {\n    key: 'addMovementInput',\n    value: function addMovementInput() {\n      // Check if sprinting:\n      this.sprint();\n\n      // UP && LEFT\n      if (this.input.W.isDown && this.input.A.isDown) {\n        this.sprite.setVelocity(-this.speed, -this.speed);\n        this.sprite.rotation = 3.14 / 360 * 2 * 210;\n      }\n      // UP && RIGHT\n      else if (this.input.W.isDown && this.input.D.isDown) {\n          this.sprite.setVelocity(this.speed, -this.speed);\n          this.sprite.rotation = 3.14 / 360 * 2 * -45;\n        }\n        // DOWN && LEFT\n        else if (this.input.S.isDown && this.input.A.isDown) {\n            this.sprite.setVelocity(-this.speed, this.speed);\n            this.sprite.rotation = 3.14 / 360 * 2 * 120;\n          }\n          // DOWN && RIGHT\n          else if (this.input.S.isDown && this.input.D.isDown) {\n              this.sprite.setVelocity(this.speed, this.speed);\n              this.sprite.rotation = 3.14 / 360 * 2 * 45;\n            }\n            // UP\n            else if (this.input.W.isDown) {\n                this.sprite.setVelocity(0, -this.speed);\n                this.sprite.rotation = 3.14 / 360 * 2 * -90;\n              }\n              // DOWN\n              else if (this.input.S.isDown) {\n                  this.sprite.setVelocity(0, this.speed);\n                  this.sprite.rotation = 3.14 / 2;\n                }\n                // LEFT\n                else if (this.input.A.isDown) {\n                    this.sprite.setVelocity(-this.speed, 0);\n                    this.sprite.rotation = -3.14;\n                  }\n                  // RIGHT\n                  else if (this.input.D.isDown) {\n                      this.sprite.setVelocity(this.speed, 0);\n                      this.sprite.rotation = 0;\n                    } else {\n                      this.sprite.setVelocity(0);\n                    }\n    }\n  }]);\n\n  return Player;\n}();\n\nexports.default = Player;\n\n//# sourceURL=webpack:///./src/characters/Player.js?");

/***/ }),

/***/ "./src/characters/Zombie.js":
/*!**********************************!*\
  !*** ./src/characters/Zombie.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _phaser = __webpack_require__(/*! ../phaser */ \"./src/phaser.js\");\n\nvar _phaser2 = _interopRequireDefault(_phaser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Zombie = function () {\n  function Zombie(index, level, game, player) {\n    _classCallCheck(this, Zombie);\n\n    this.index = index;\n    this.level = level;\n    this.game = game;\n    this.player = player;\n    this.bullets = game.bullets;\n    this.spriteImage = this.level % 2 === 0 ? 'zombie2' : 'zombie1';\n\n    this.isAlive = true;\n    this.health = this.level * 1;\n    this.speed = (Math.random() + 1) * (this.level * 20);\n\n    // Get a random spawn point on the map:\n    var spawnLoc = this.game.physics.world.bounds.getRandomPoint();\n\n    // Add the sprite and world collision:\n    this.sprite = game.physics.add.sprite(spawnLoc.x, spawnLoc.y, this.spriteImage).setName(index.toString()).setCollideWorldBounds(true).setDepth(0);\n\n    this.sprite.setScale(1 + this.level / 10);\n  }\n\n  _createClass(Zombie, [{\n    key: 'update',\n    value: function update() {\n      // Move to player:\n      this.game.physics.moveTo(this.sprite, this.player.sprite.x, this.player.sprite.y, this.speed);\n\n      // Rotate towards player:\n      this.sprite.rotation = _phaser2.default.Math.Angle.Between(this.sprite.x, this.sprite.y, this.player.sprite.x, this.player.sprite.y);\n    }\n  }, {\n    key: 'damage',\n    value: function damage() {\n      if (this.health > 1) {\n        this.health--;\n      } else {\n        this.kill();\n      }\n    }\n  }, {\n    key: 'kill',\n    value: function kill() {\n      this.game.effectManager.addCorpse(this.sprite.x, this.sprite.y);\n      this.player.enemiesKilled++;\n      this.isAlive = false;\n      this.sprite.destroy();\n    }\n  }]);\n\n  return Zombie;\n}();\n\nexports.default = Zombie;\n\n//# sourceURL=webpack:///./src/characters/Zombie.js?");

/***/ }),

/***/ "./src/effects/EffectManager.js":
/*!**************************************!*\
  !*** ./src/effects/EffectManager.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EffectManager = function () {\n  function EffectManager(game) {\n    _classCallCheck(this, EffectManager);\n\n    this.game = game;\n\n    this.maxCorpses = 10;\n    this.corpses = [];\n  }\n\n  _createClass(EffectManager, [{\n    key: 'addCorpse',\n    value: function addCorpse(x, y) {\n      if (this.corpses.length > this.maxCorpses) {\n        this.corpses[0].destroy();\n        this.corpses.shift();\n      }\n\n      var corpse = this.game.add.sprite(x, y, 'corpse').setDepth(-1);\n      this.corpses.push(corpse);\n    }\n  }, {\n    key: 'playGunshot',\n    value: function playGunshot() {\n      this.game.sound.add('gunshot').play();\n    }\n  }]);\n\n  return EffectManager;\n}();\n\nexports.default = EffectManager;\n\n//# sourceURL=webpack:///./src/effects/EffectManager.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _phaser = __webpack_require__(/*! ./phaser */ \"./src/phaser.js\");\n\nvar _phaser2 = _interopRequireDefault(_phaser);\n\nvar _MainScene = __webpack_require__(/*! ./scenes/MainScene */ \"./src/scenes/MainScene.js\");\n\nvar _MainScene2 = _interopRequireDefault(_MainScene);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar config = {\n  type: _phaser2.default.AUTO,\n  width: window.innerWidth,\n  height: window.innerHeight,\n  backgroundColor: '#000',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      debug: false,\n      setBounds: {\n        x: 0,\n        y: 0,\n        width: 2000,\n        height: 2000,\n        thickness: 12\n      }\n    }\n  },\n  scene: [_MainScene2.default]\n};\n\nvar game = new _phaser2.default.Game(config);\n\n//# sourceURL=webpack:///./src/game.js?");

/***/ }),

/***/ "./src/input/InputBindings.js":
/*!************************************!*\
  !*** ./src/input/InputBindings.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar InputBindings = function InputBindings(game) {\n  _classCallCheck(this, InputBindings);\n\n  // MOUSE\n  this.pointer = game.input.activePointer;\n\n  // KEYBOARD\n  this.W = game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);\n  this.A = game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);\n  this.S = game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);\n  this.D = game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);\n  this.SHIFT = game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);\n  this.PAUSE = game.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);\n};\n\nexports.default = InputBindings;\n\n//# sourceURL=webpack:///./src/input/InputBindings.js?");

/***/ }),

/***/ "./src/modes/TimeSurvival.js":
/*!***********************************!*\
  !*** ./src/modes/TimeSurvival.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Zombie = __webpack_require__(/*! ../characters/Zombie */ \"./src/characters/Zombie.js\");\n\nvar _Zombie2 = _interopRequireDefault(_Zombie);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TimeSurvival = function () {\n  function TimeSurvival(game, player) {\n    _classCallCheck(this, TimeSurvival);\n\n    this.game = game;\n    this.player = player;\n    this.timeSurvived = -1;\n    this.nextUpdate = 0;\n    this.enemies = [];\n    this.enemiesTotal = 30;\n    this.enemiesAlive = null;\n    this.difficulty = 1;\n  }\n\n  _createClass(TimeSurvival, [{\n    key: 'init',\n    value: function init() {\n      for (var i = 0; i < 5; i++) {\n        this.spawnEnemy();\n      }\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this = this;\n\n      if (this.enemiesAlive < this.enemiesTotal) this.spawnEnemy();\n\n      // INCREMENT TIME SURVIVED\n      if (this.game.time.now > this.nextUpdate) {\n        this.nextUpdate = this.game.time.now + 1000; // 1 second\n        this.difficulty = 1 + this.timeSurvived / 100;\n        this.timeSurvived++;\n        // this.enemiesTotal = parseInt(this.timeSurvived / 5);\n      }\n\n      // UPDATE ENEMIES ALIVE\n      this.enemiesAlive = 0;\n\n      var _loop = function _loop(i) {\n\n        if (_this.enemies[i].isAlive) {\n          _this.enemiesAlive++;\n\n          // Disabled for performance.\n          // this.physics.collide(this.enemies[i].zombie, this.player, () => {\n          //     if (this.playerHealth >= 1) this.playerHealth -= 0.1;\n          // });\n\n          _this.game.physics.add.collider(_this.enemies[i].sprite, _this.player.gun.bullets, function (enemy, bullet) {\n            bullet.destroy();\n            _this.player.shotsHit++;\n            _this.enemies[i].damage();\n          });\n\n          _this.enemies[i].update();\n        }\n      };\n\n      for (var i = 0; i < this.enemies.length; i++) {\n        _loop(i);\n      }\n    }\n  }, {\n    key: 'spawnEnemy',\n    value: function spawnEnemy() {\n      this.enemies.push(new _Zombie2.default(1, Math.floor(Math.random() * this.difficulty + 1), this.game, this.player));\n\n      // Disabled for performance:\n      // this.physics.add.overlap(this.enemies[i].zombie, this.player);\n    }\n  }]);\n\n  return TimeSurvival;\n}();\n\nexports.default = TimeSurvival;\n\n//# sourceURL=webpack:///./src/modes/TimeSurvival.js?");

/***/ }),

/***/ "./src/phaser.js":
/*!***********************!*\
  !*** ./src/phaser.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};(function webpackUniversalModuleDefinition(root,factory){if(( false?undefined:_typeof(exports))==='object'&&( false?undefined:_typeof(module))==='object')module.exports=factory();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(window,function(){return(/******/function(modules){// webpackBootstrap\n/******/// The module cache\n/******/var installedModules={};/******//******/// The require function\n/******/function __webpack_require__(moduleId){/******//******/// Check if module is in cache\n/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/// Create a new module (and put it into the cache)\n/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******//******/// Execute the module function\n/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******//******/// Flag the module as loaded\n/******/module.l=true;/******//******/// Return the exports of the module\n/******/return module.exports;/******/}/******//******//******/// expose the modules object (__webpack_modules__)\n/******/__webpack_require__.m=modules;/******//******/// expose the module cache\n/******/__webpack_require__.c=installedModules;/******//******/// define getter function for harmony exports\n/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{/******/configurable:false,/******/enumerable:true,/******/get:getter/******/});/******/}/******/};/******//******/// define __esModule on exports\n/******/__webpack_require__.r=function(exports){/******/Object.defineProperty(exports,'__esModule',{value:true});/******/};/******//******/// getDefaultExport function for compatibility with non-harmony modules\n/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******//******/// Object.prototype.hasOwnProperty.call\n/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******//******/// __webpack_public_path__\n/******/__webpack_require__.p=\"\";/******//******//******/// Load entry module and return exports\n/******/return __webpack_require__(__webpack_require__.s=1045);/******/}(/************************************************************************//******/[/* 0 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\nfunction hasGetterOrSetter(def){return!!def.get&&typeof def.get==='function'||!!def.set&&typeof def.set==='function';}function getProperty(definition,k,isClassDescriptor){//  This may be a lightweight object, OR it might be a property that was defined previously.\n//  For simple class descriptors we can just assume its NOT previously defined.\nvar def=isClassDescriptor?definition[k]:Object.getOwnPropertyDescriptor(definition,k);if(!isClassDescriptor&&def.value&&_typeof(def.value)==='object'){def=def.value;}//  This might be a regular property, or it may be a getter/setter the user defined in a class.\nif(def&&hasGetterOrSetter(def)){if(typeof def.enumerable==='undefined'){def.enumerable=true;}if(typeof def.configurable==='undefined'){def.configurable=true;}return def;}else{return false;}}function hasNonConfigurable(obj,k){var prop=Object.getOwnPropertyDescriptor(obj,k);if(!prop){return false;}if(prop.value&&_typeof(prop.value)==='object'){prop=prop.value;}if(prop.configurable===false){return true;}return false;}function extend(ctor,definition,isClassDescriptor,extend){for(var k in definition){if(!definition.hasOwnProperty(k)){continue;}var def=getProperty(definition,k,isClassDescriptor);if(def!==false){//  If Extends is used, we will check its prototype to see if the final variable exists.\nvar parent=extend||ctor;if(hasNonConfigurable(parent.prototype,k)){//  Just skip the final property\nif(Class.ignoreFinals){continue;}//  We cannot re-define a property that is configurable=false.\n//  So we will consider them final and throw an error. This is by\n//  default so it is clear to the developer what is happening.\n//  You can set ignoreFinals to true if you need to extend a class\n//  which has configurable=false; it will simply not re-define final properties.\nthrow new Error('cannot override final property \\''+k+'\\', set Class.ignoreFinals = true to skip');}Object.defineProperty(ctor.prototype,k,def);}else{ctor.prototype[k]=definition[k];}}}function mixin(myClass,mixins){if(!mixins){return;}if(!Array.isArray(mixins)){mixins=[mixins];}for(var i=0;i<mixins.length;i++){extend(myClass,mixins[i].prototype||mixins[i]);}}/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class  Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */function Class(definition){if(!definition){definition={};}//  The variable name here dictates what we see in Chrome debugger\nvar initialize;var Extends;if(definition.initialize){if(typeof definition.initialize!=='function'){throw new Error('initialize must be a function');}initialize=definition.initialize;//  Usually we should avoid 'delete' in V8 at all costs.\n//  However, its unlikely to make any performance difference\n//  here since we only call this on class creation (i.e. not object creation).\ndelete definition.initialize;}else if(definition.Extends){var base=definition.Extends;initialize=function initialize(){base.apply(this,arguments);};}else{initialize=function initialize(){};}if(definition.Extends){initialize.prototype=Object.create(definition.Extends.prototype);initialize.prototype.constructor=initialize;//  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\nExtends=definition.Extends;delete definition.Extends;}else{initialize.prototype.constructor=initialize;}//  Grab the mixins, if they are specified...\nvar mixins=null;if(definition.Mixins){mixins=definition.Mixins;delete definition.Mixins;}//  First, mixin if we can.\nmixin(initialize,mixins);//  Now we grab the actual definition which defines the overrides.\nextend(initialize,definition,true,Extends);return initialize;}Class.extend=extend;Class.mixin=mixin;Class.ignoreFinals=false;module.exports=Class;/***/},/* 1 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var DataManager=__webpack_require__(107);var EventEmitter=__webpack_require__(14);/**\r\n * @classdesc\r\n * The base class that all Game Objects extend.\r\n * You don't create GameObjects directly and they cannot be added to the display list.\r\n * Instead, use them as the base for your own custom classes.\r\n *\r\n * @class GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.\r\n */var GameObject=new Class({Extends:EventEmitter,initialize:function GameObject(scene,type){EventEmitter.call(this);/**\r\n         * The Scene to which this Game Object belongs.\r\n         * Game Objects can only belong to one Scene.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * A textual representation of this Game Object, i.e. `sprite`.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.type=type;/**\r\n         * The parent Container of this Game Object, if it has one.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#parentContainer\r\n         * @type {Phaser.GameObjects.Container}\r\n         * @since 3.4.0\r\n         */this.parentContainer=null;/**\r\n         * The name of this Game Object.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.name='';/**\r\n         * The active state of this Game Object.\r\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n         * An active object is one which is having its logic and internal systems updated.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.active=true;/**\r\n         * The Tab Index of the Game Object.\r\n         * Reserved for future use by plugins and the Input Manager.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#tabIndex\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */this.tabIndex=-1;/**\r\n         * A Data Manager.\r\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.data=null;/**\r\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#renderFlags\r\n         * @type {integer}\r\n         * @default 15\r\n         * @since 3.0.0\r\n         */this.renderFlags=15;/**\r\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n         * Not usually set directly. Instead call `Camera.ignore`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#cameraFilter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.cameraFilter=0;/**\r\n         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.\r\n         * Not usually set directly. Instead call `GameObject.setInteractive()`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#input\r\n         * @type {?Phaser.Input.InteractiveObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.input=null;/**\r\n         * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#body\r\n         * @type {?object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.body=null;//  Tell the Scene to re-sort the children\nthis.scene.sys.queueDepthSort();},/**\r\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This GameObject.\r\n     */setActive:function setActive(value){this.active=value;return this;},/**\r\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - The name to be given to this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This GameObject.\r\n     */setName:function setName(value){this.name=value;return this;},/**\r\n     * Adds a DataManager to this object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setDataEnabled\r\n     * @since 3.0.0\r\n     * @see Phaser.Data.DataManager\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This GameObject.\r\n     */setDataEnabled:function setDataEnabled(){if(!this.data){this.data=new DataManager(this);}return this;},/**\r\n     * This is a quick chainable alias to the `DataProxy.set` method.\r\n     * It allows you to set a key and value in this Game Objects data store.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the property to be stored.\r\n     * @param {*} value - The value to store with the key. Can be a string, number, array or object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This GameObject.\r\n     */setData:function setData(key,value){if(!this.data){this.data=new DataManager(this);}this.data.set(key,value);return this;},/**\r\n     * This is a quick alias to the `DataProxy.get` method to remain consistent with `setData`.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the property to be retrieved.\r\n     *\r\n     * @return {*} The data, if present in the Data Store.\r\n     */getData:function getData(key){if(!this.data){this.data=new DataManager(this);}return this.data.get(key);},/**\r\n     * Pass this Game Object to the Input Manager to enable it for Input.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setInteractive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} [shape] - A geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {HitAreaCallback} [callback] - A callback to be invoked when the Game Object is interacted with.\r\n     * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This GameObject.\r\n     */setInteractive:function setInteractive(shape,callback,dropZone){this.scene.sys.input.enable(this,shape,callback,dropZone);return this;},/**\r\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#update\r\n     * @since 3.0.0\r\n     */update:function update(){},/**\r\n     * Returns a JSON representation of the Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONGameObject} A JSON representation of the Game Object.\r\n     */toJSON:function toJSON(){return Components.ToJSON(this);},/**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */willRender:function willRender(){return GameObject.RENDER_MASK===this.renderFlags;},/**\r\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n     * root of the display list (which is index 0 in the returned array).\r\n     * \r\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n     * this Game Object and all of its ancestors.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getIndexList\r\n     * @since 3.4.0\r\n     *\r\n     * @return {integer[]} An array of display list position indexes.\r\n     */getIndexList:function getIndexList(){// eslint-disable-next-line consistent-this\nvar child=this;var parent=this.parentContainer;var indexes=[];while(parent){// indexes.unshift([parent.getIndex(child), parent.name]);\nindexes.unshift(parent.getIndex(child));child=parent;if(!parent.parentContainer){break;}else{parent=parent.parentContainer;}}// indexes.unshift([this.scene.sys.displayList.getIndex(child), 'root']);\nindexes.unshift(this.scene.sys.displayList.getIndex(child));return indexes;},/**\r\n     * Destroys this Game Object removing it from the Display List and Update List and\r\n     * severing all ties to parent resources.\r\n     *\r\n     * Also removes itself from the Input Manager and Physics Manager if previously enabled.\r\n     *\r\n     * Use this to remove a Game Object from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection by the browser.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){//  This Game Object had already been destroyed\nif(!this.scene){return;}if(this.preDestroy){this.preDestroy.call(this);}this.emit('destroy',this);var sys=this.scene.sys;sys.displayList.remove(this);sys.updateList.remove(this);if(this.input){sys.input.clear(this);this.input=undefined;}if(this.data){this.data.destroy();this.data=undefined;}if(this.body){this.body.destroy();this.body=undefined;}//  Tell the Scene to re-sort the children\nsys.queueDepthSort();this.active=false;this.visible=false;this.scene=undefined;this.parentContainer=undefined;this.removeAllListeners();}});/**\r\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\r\n *\r\n * @constant {integer} RENDER_MASK\r\n * @memberOf Phaser.GameObjects.GameObject\r\n * @default\r\n */GameObject.RENDER_MASK=15;module.exports=GameObject;/***/},/* 2 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}\r\n *\r\n * @function Phaser.Utils.Object.GetFastValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to search\r\n * @param {string} key - The key for the property on source. Must exist at the top level of the source object (no periods)\r\n * @param {*} [defaultValue] - The default value to use if the key does not exist.\r\n *\r\n * @return {*} The value if found; otherwise, defaultValue (null if none provided)\r\n */var GetFastValue=function GetFastValue(source,key,defaultValue){var t=typeof source==='undefined'?'undefined':_typeof(source);if(!source||t==='number'||t==='string'){return defaultValue;}else if(source.hasOwnProperty(key)&&source[key]!==undefined){return source[key];}else{return defaultValue;}};module.exports=GetFastValue;/***/},/* 3 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */var NOOP=function NOOP(){//  NOOP\n};module.exports=NOOP;/***/},/* 4 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Point\r\n * @memberOf Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - The x coordinate of this Point.\r\n * @param {number} [y=x] - The y coordinate of this Point.\r\n */var Point=new Class({initialize:function Point(x,y){if(x===undefined){x=0;}if(y===undefined){y=x;}/**\r\n         * The x coordinate of this Point.\r\n         *\r\n         * @name Phaser.Geom.Point#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * The y coordinate of this Point.\r\n         *\r\n         * @name Phaser.Geom.Point#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y=y;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Point#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x coordinate of this Point.\r\n     * @param {number} [y=x] - The y coordinate of this Point.\r\n     *\r\n     * @return {Phaser.Geom.Point} This Point object.\r\n     */setTo:function setTo(x,y){if(x===undefined){x=0;}if(y===undefined){y=x;}this.x=x;this.y=y;return this;}});module.exports=Point;/***/},/* 5 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Source object\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\n//  The default value to use if the key doesn't exist\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Object.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - [description]\r\n * @param {string} key - [description]\r\n * @param {*} defaultValue - [description]\r\n *\r\n * @return {*} [description]\r\n */var GetValue=function GetValue(source,key,defaultValue){if(!source||typeof source==='number'){return defaultValue;}else if(source.hasOwnProperty(key)){return source[key];}else if(key.indexOf('.')){var keys=key.split('.');var parent=source;var value=defaultValue;//  Use for loop here so we can break early\nfor(var i=0;i<keys.length;i++){if(parent.hasOwnProperty(keys[i])){//  Yes it has a key property, let's carry on down\nvalue=parent[keys[i]];parent=parent[keys[i]];}else{//  Can't go any further, so reset to default\nvalue=defaultValue;break;}}return value;}else{return defaultValue;}};module.exports=GetValue;/***/},/* 6 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class=__webpack_require__(0);/**\r\n * @typedef {object} Vector2Like\r\n *\r\n * @property {number} x - [description]\r\n * @property {number} y - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Vector2\r\n * @memberOf Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - [description]\r\n * @param {number} [y] - [description]\r\n */var Vector2=new Class({initialize:function Vector2(x,y){/**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x=0;/**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y=0;if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.x=x.x||0;this.y=x.y||0;}else{if(y===undefined){y=x;}this.x=x||0;this.y=y||0;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} A clone of this Vector2.\r\n     */clone:function clone(){return new Vector2(this.x,this.y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */copy:function copy(src){this.x=src.x||0;this.y=src.y||0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#setFromObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Vector2Like} obj - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */setFromObject:function setFromObject(obj){this.x=obj.x||0;this.y=obj.y||0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */set:function set(x,y){if(y===undefined){y=x;}this.x=x;this.y=y;return this;},/**\r\n     * This method is an alias for `Vector2.set`.\r\n     *\r\n     * @method Phaser.Math.Vector2#setTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */setTo:function setTo(x,y){return this.set(x,y);},/**\r\n     * Sets the `x` and `y` values of this object from a given polar coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector2#setToPolar\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} azimuth - The angular coordinate, in radians.\r\n     * @param {float} [radius=1] - The radial coordinate (length).\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */setToPolar:function setToPolar(azimuth,radius){if(radius==null){radius=1;}this.x=Math.cos(azimuth)*radius;this.y=Math.sin(azimuth)*radius;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} v - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */equals:function equals(v){return this.x===v.x&&this.y===v.y;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */angle:function angle(){// computes the angle in radians with respect to the positive x-axis\nvar angle=Math.atan2(this.y,this.x);if(angle<0){angle+=2*Math.PI;}return angle;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */add:function add(src){this.x+=src.x;this.y+=src.y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */subtract:function subtract(src){this.x-=src.x;this.y-=src.y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */multiply:function multiply(src){this.x*=src.x;this.y*=src.y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */scale:function scale(value){if(isFinite(value)){this.x*=value;this.y*=value;}else{this.x=0;this.y=0;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */divide:function divide(src){this.x/=src.x;this.y/=src.y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */negate:function negate(){this.x=-this.x;this.y=-this.y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */distance:function distance(src){var dx=src.x-this.x;var dy=src.y-this.y;return Math.sqrt(dx*dx+dy*dy);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */distanceSq:function distanceSq(src){var dx=src.x-this.x;var dy=src.y-this.y;return dx*dx+dy*dy;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */length:function length(){var x=this.x;var y=this.y;return Math.sqrt(x*x+y*y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */lengthSq:function lengthSq(){var x=this.x;var y=this.y;return x*x+y*y;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */normalize:function normalize(){var x=this.x;var y=this.y;var len=x*x+y*y;if(len>0){len=1/Math.sqrt(len);this.x=x*len;this.y=y*len;}return this;},/**\r\n    * Right-hand normalize (make unit length) this Vector\r\n    *//**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#normalizeRightHand\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */normalizeRightHand:function normalizeRightHand(){var x=this.x;this.x=this.y*-1;this.y=x;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */dot:function dot(src){return this.x*src.x+this.y*src.y;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */cross:function cross(src){return this.x*src.y-this.y*src.x;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - [description]\r\n     * @param {number} [t=0] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */lerp:function lerp(src,t){if(t===undefined){t=0;}var ax=this.x;var ay=this.y;this.x=ax+t*(src.x-ax);this.y=ay+t*(src.y-ay);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */transformMat3:function transformMat3(mat){var x=this.x;var y=this.y;var m=mat.val;this.x=m[0]*x+m[3]*y+m[6];this.y=m[1]*x+m[4]*y+m[7];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */transformMat4:function transformMat4(mat){var x=this.x;var y=this.y;var m=mat.val;this.x=m[0]*x+m[4]*y+m[12];this.y=m[1]*x+m[5]*y+m[13];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector2#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */reset:function reset(){this.x=0;this.y=0;return this;}});/**\r\n * A static zero Vector2 for use by reference.\r\n *\r\n * @method Phaser.Math.Vector2.ZERO\r\n * @since 3.1.0\r\n */Vector2.ZERO=new Vector2();module.exports=Vector2;/***/},/* 7 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var types={};var FileTypesManager={install:function install(loader){for(var key in types){loader[key]=types[key];}},register:function register(key,factoryFunction){types[key]=factoryFunction;// console.log('FileTypesManager.register', key);\n},destroy:function destroy(){types={};}};module.exports=FileTypesManager;/***/},/* 8 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MATH=__webpack_require__(16);var GetValue=__webpack_require__(5);//  Allowed types:\n//  Implicit\n//  {\n//      x: 4\n//  }\n//\n//  From function\n//  {\n//      x: function ()\n//  }\n//\n//  Randomly pick one element from the array\n//  {\n//      x: [a, b, c, d, e, f]\n//  }\n//\n//  Random integer between min and max:\n//  {\n//      x: { randInt: [min, max] }\n//  }\n//\n//  Random float between min and max:\n//  {\n//      x: { randFloat: [min, max] }\n//  }\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Object.GetAdvancedValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - [description]\r\n * @param {string} key - [description]\r\n * @param {*} defaultValue - [description]\r\n *\r\n * @return {*} [description]\r\n */var GetAdvancedValue=function GetAdvancedValue(source,key,defaultValue){var value=GetValue(source,key,null);if(value===null){return defaultValue;}else if(Array.isArray(value)){return MATH.RND.pick(value);}else if((typeof value==='undefined'?'undefined':_typeof(value))==='object'){if(value.hasOwnProperty('randInt')){return MATH.RND.integerInRange(value.randInt[0],value.randInt[1]);}else if(value.hasOwnProperty('randFloat')){return MATH.RND.realInRange(value.randFloat[0],value.randFloat[1]);}}else if(typeof value==='function'){return value(key);}return value;};module.exports=GetAdvancedValue;/***/},/* 9 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var PluginManager=__webpack_require__(13);/**\r\n * @classdesc\r\n * The Game Object Factory is a Scene plugin that allows you to quickly create many common\r\n * types of Game Objects and have them automatically registered with the Scene.\r\n *\r\n * Game Objects directly register themselves with the Factory and inject their own creation\r\n * methods into the class.\r\n *\r\n * @class GameObjectFactory\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object Factory belongs.\r\n */var GameObjectFactory=new Class({initialize:function GameObjectFactory(scene){/**\r\n         * The Scene to which this Game Object Factory belongs.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * A reference to the Scene.Systems.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * A reference to the Scene Display List.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.displayList;/**\r\n         * A reference to the Scene Update List.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#updateList;\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.updateList;},/**\r\n     * Boots the plugin.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#boot\r\n     * @private\r\n     * @since 3.0.0\r\n     */boot:function boot(){this.displayList=this.systems.displayList;this.updateList=this.systems.updateList;var eventEmitter=this.systems.events;eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * Adds an existing Game Object to this Scene.\r\n     * \r\n     * If the Game Object renders, it will be added to the Display List.\r\n     * If it has a `preUpdate` method, it will be added to the Update List.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#existing\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The child to be added to this Scene.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that was added.\r\n     */existing:function existing(child){if(child.renderCanvas||child.renderWebGL){this.displayList.add(child);}if(child.preUpdate){this.updateList.add(child);}return child;},/**\r\n     * Shuts this plugin down.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){},/**\r\n     * Destroys this plugin.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.scene=null;this.displayList=null;this.updateList=null;}});//  Static method called directly by the Game Object factory functions\nGameObjectFactory.register=function(factoryType,factoryFunction){if(!GameObjectFactory.prototype.hasOwnProperty(factoryType)){GameObjectFactory.prototype[factoryType]=factoryFunction;}};PluginManager.register('GameObjectFactory',GameObjectFactory,'add');module.exports=GameObjectFactory;/***/},/* 10 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Contains=__webpack_require__(27);var GetPoint=__webpack_require__(173);var GetPoints=__webpack_require__(365);var Line=__webpack_require__(108);var Random=__webpack_require__(170);/**\r\n * @classdesc\r\n * Encapsulates a 2D rectangle defined by its corner point in the top-left and its extends in x (width) and y (height)\r\n *\r\n * @class Rectangle\r\n * @memberOf Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - [description]\r\n * @param {number} [y=0] - [description]\r\n * @param {number} [width=0] - [description]\r\n * @param {number} [height=0] - [description]\r\n */var Rectangle=new Class({initialize:function Rectangle(x,y,width,height){if(x===undefined){x=0;}if(y===undefined){y=0;}if(width===undefined){width=0;}if(height===undefined){height=0;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Rectangle#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Rectangle#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y=y;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Rectangle#width\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.width=width;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Rectangle#height\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.height=height;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */contains:function contains(x,y){return Contains(this,x,y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [output,$return]\r\n     *\r\n     * @param {float} position - [description]\r\n     * @param {(Phaser.Geom.Point|object)} [output] - [description]\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} [description]\r\n     */getPoint:function getPoint(position,output){return GetPoint(this,position,output);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\r\n     *\r\n     * @param {integer} quantity - [description]\r\n     * @param {number} [stepRate] - [description]\r\n     * @param {(array|Phaser.Geom.Point[])} [output] - [description]\r\n     *\r\n     * @return {(array|Phaser.Geom.Point[])} [description]\r\n     */getPoints:function getPoints(quantity,stepRate,output){return GetPoints(this,quantity,stepRate,output);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [point,$return]\r\n     *\r\n     * @param {Phaser.Geom.Point} [point] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Point} [description]\r\n     */getRandomPoint:function getRandomPoint(point){return Random(this,point);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} This Rectangle object.\r\n     */setTo:function setTo(x,y,width,height){this.x=x;this.y=y;this.width=width;this.height=height;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#setEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} This Rectangle object.\r\n     */setEmpty:function setEmpty(){return this.setTo(0,0,0,0);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} This Rectangle object.\r\n     */setPosition:function setPosition(x,y){if(y===undefined){y=x;}this.x=x;this.y=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} [height=width] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} This Rectangle object.\r\n     */setSize:function setSize(width,height){if(height===undefined){height=width;}this.width=width;this.height=height;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Rectangle#isEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isEmpty:function isEmpty(){return this.width<=0||this.height<=0;},/**\r\n     * Returns a Line object that corresponds to the top of this Rectangle.\r\n     *\r\n     * @method Phaser.Geom.Rectangle#getLineA\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to the top of this Rectangle.\r\n     */getLineA:function getLineA(line){if(line===undefined){line=new Line();}line.setTo(this.x,this.y,this.right,this.y);return line;},/**\r\n     * Returns a Line object that corresponds to the right of this Rectangle.\r\n     *\r\n     * @method Phaser.Geom.Rectangle#getLineB\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to the right of this Rectangle.\r\n     */getLineB:function getLineB(line){if(line===undefined){line=new Line();}line.setTo(this.right,this.y,this.right,this.bottom);return line;},/**\r\n     * Returns a Line object that corresponds to the bottom of this Rectangle.\r\n     *\r\n     * @method Phaser.Geom.Rectangle#getLineC\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to the bottom of this Rectangle.\r\n     */getLineC:function getLineC(line){if(line===undefined){line=new Line();}line.setTo(this.right,this.bottom,this.x,this.bottom);return line;},/**\r\n     * Returns a Line object that corresponds to the left of this Rectangle.\r\n     *\r\n     * @method Phaser.Geom.Rectangle#getLineD\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to the left of this Rectangle.\r\n     */getLineD:function getLineD(line){if(line===undefined){line=new Line();}line.setTo(this.x,this.bottom,this.x,this.y);return line;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Rectangle#left\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */left:{get:function get(){return this.x;},set:function set(value){if(value>=this.right){this.width=0;}else{this.width=this.right-value;}this.x=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Rectangle#right\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */right:{get:function get(){return this.x+this.width;},set:function set(value){if(value<=this.x){this.width=0;}else{this.width=value-this.x;}}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Rectangle#top\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */top:{get:function get(){return this.y;},set:function set(value){if(value>=this.bottom){this.height=0;}else{this.height=this.bottom-value;}this.y=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Rectangle#bottom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottom:{get:function get(){return this.y+this.height;},set:function set(value){if(value<=this.y){this.height=0;}else{this.height=value-this.y;}}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Rectangle#centerX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */centerX:{get:function get(){return this.x+this.width/2;},set:function set(value){this.x=value-this.width/2;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Rectangle#centerY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */centerY:{get:function get(){return this.y+this.height/2;},set:function set(value){this.y=value-this.height/2;}}});module.exports=Rectangle;/***/},/* 11 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var PluginManager=__webpack_require__(13);/**\r\n * @classdesc\r\n * The Game Object Creator is a Scene plugin that allows you to quickly create many common\r\n * types of Game Objects and return them. Unlike the Game Object Factory, they are not automatically\r\n * added to the Scene.\r\n *\r\n * Game Objects directly register themselves with the Creator and inject their own creation\r\n * methods into the class.\r\n *\r\n * @class GameObjectCreator\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object Factory belongs.\r\n */var GameObjectCreator=new Class({initialize:function GameObjectCreator(scene){/**\r\n         * The Scene to which this Game Object Creator belongs.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectCreator#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * A reference to the Scene.Systems.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectCreator#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * A reference to the Scene Display List.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectCreator#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.displayList;/**\r\n         * A reference to the Scene Update List.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectCreator#updateList;\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.updateList;},/**\r\n     * Boots the plugin.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectCreator#boot\r\n     * @private\r\n     * @since 3.0.0\r\n     */boot:function boot(){this.displayList=this.systems.displayList;this.updateList=this.systems.updateList;var eventEmitter=this.systems.events;eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * Shuts this plugin down.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectCreator#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){},/**\r\n     * Destroys this plugin.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectCreator#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.scene=null;this.displayList=null;this.updateList=null;}});//  Static method called directly by the Game Object creator functions\nGameObjectCreator.register=function(factoryType,factoryFunction){if(!GameObjectCreator.prototype.hasOwnProperty(factoryType)){GameObjectCreator.prototype[factoryType]=factoryFunction;}};PluginManager.register('GameObjectCreator',GameObjectCreator,'make');module.exports=GameObjectCreator;/***/},/* 12 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.GameObjects.Components\r\n */module.exports={Alpha:__webpack_require__(962),Animation:__webpack_require__(394),BlendMode:__webpack_require__(961),ComputedSize:__webpack_require__(960),Depth:__webpack_require__(959),Flip:__webpack_require__(958),GetBounds:__webpack_require__(957),MatrixStack:__webpack_require__(956),Origin:__webpack_require__(955),Pipeline:__webpack_require__(362),ScaleMode:__webpack_require__(954),ScrollFactor:__webpack_require__(953),Size:__webpack_require__(952),Texture:__webpack_require__(951),Tint:__webpack_require__(950),ToJSON:__webpack_require__(949),Transform:__webpack_require__(948),TransformMatrix:__webpack_require__(78),Visible:__webpack_require__(947)};/***/},/* 13 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var plugins={};/**\r\n * @classdesc\r\n * The PluginManager is global and belongs to the Game instance, not a Scene.\r\n * It handles the installation and removal of all global and Scene based plugins.\r\n * Plugins automatically register themselves with the PluginManager in their respective classes.\r\n *\r\n * @class PluginManager\r\n * @memberOf Phaser.Boot\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - [description]\r\n */var PluginManager=new Class({initialize:function PluginManager(game){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Boot.PluginManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game=game;game.events.once('boot',this.boot,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Boot.PluginManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){this.game.events.once('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Boot.PluginManager#installGlobal\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scenes.Systems} sys - [description]\r\n     * @param {array} globalPlugins - [description]\r\n     */installGlobal:function installGlobal(sys,globalPlugins){var game=sys.game;var scene=sys.scene;var map=sys.settings.map;//  Reference the GlobalPlugins from Game into Scene.Systems\nfor(var i=0;i<globalPlugins.length;i++){var pluginKey=globalPlugins[i];// console.log('PluginManager.global', pluginKey);\nif(game[pluginKey]){sys[pluginKey]=game[pluginKey];//  Scene level injection\nif(map.hasOwnProperty(pluginKey)){scene[map[pluginKey]]=sys[pluginKey];}}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Boot.PluginManager#installLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scenes.Systems} sys - [description]\r\n     * @param {array} scenePlugins - [description]\r\n     */installLocal:function installLocal(sys,scenePlugins){var scene=sys.scene;var map=sys.settings.map;var isBooted=sys.settings.isBooted;for(var i=0;i<scenePlugins.length;i++){var pluginKey=scenePlugins[i];if(!plugins[pluginKey]){continue;}var source=plugins[pluginKey];var plugin=new source.plugin(scene);sys[source.mapping]=plugin;//  Scene level injection\nif(map.hasOwnProperty(source.mapping)){scene[map[source.mapping]]=plugin;}//  Scene is already booted, usually because this method is being called at run-time, so boot the plugin\nif(isBooted){plugin.boot();}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Boot.PluginManager#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     */remove:function remove(key){delete plugins[key];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Boot.PluginManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.game=null;}});/**\r\n * Static method called directly by the Plugins\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method PluginManager.register\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - [description]\r\n * @param {object} plugin - [description]\r\n * @param {string} mapping - [description]\r\n */PluginManager.register=function(key,plugin,mapping){plugins[key]={plugin:plugin,mapping:mapping};};module.exports=PluginManager;/***/},/* 14 *//***/function(module,exports,__webpack_require__){\"use strict\";var has=Object.prototype.hasOwnProperty,prefix='~';/**\r\n * Constructor to create a storage for our `EE` objects.\r\n * An `Events` instance is a plain object whose properties are event names.\r\n *\r\n * @constructor\r\n * @private\r\n */function Events(){}//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif(Object.create){Events.prototype=Object.create(null);//\n// This hack is needed because the `__proto__` property is still inherited in\n// some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n//\nif(!new Events().__proto__)prefix=false;}/**\r\n * Representation of a single event listener.\r\n *\r\n * @param {Function} fn The listener function.\r\n * @param {*} context The context to invoke the listener with.\r\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\r\n * @constructor\r\n * @private\r\n */function EE(fn,context,once){this.fn=fn;this.context=context;this.once=once||false;}/**\r\n * Add a listener for a given event.\r\n *\r\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\r\n * @param {(String|Symbol)} event The event name.\r\n * @param {Function} fn The listener function.\r\n * @param {*} context The context to invoke the listener with.\r\n * @param {Boolean} once Specify if the listener is a one-time listener.\r\n * @returns {EventEmitter}\r\n * @private\r\n */function addListener(emitter,event,fn,context,once){if(typeof fn!=='function'){throw new TypeError('The listener must be a function');}var listener=new EE(fn,context||emitter,once),evt=prefix?prefix+event:event;if(!emitter._events[evt])emitter._events[evt]=listener,emitter._eventsCount++;else if(!emitter._events[evt].fn)emitter._events[evt].push(listener);else emitter._events[evt]=[emitter._events[evt],listener];return emitter;}/**\r\n * Clear event by name.\r\n *\r\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\r\n * @param {(String|Symbol)} evt The Event name.\r\n * @private\r\n */function clearEvent(emitter,evt){if(--emitter._eventsCount===0)emitter._events=new Events();else delete emitter._events[evt];}/**\r\n * Minimal `EventEmitter` interface that is molded against the Node.js\r\n * `EventEmitter` interface.\r\n *\r\n * @constructor\r\n * @public\r\n */function EventEmitter(){this._events=new Events();this._eventsCount=0;}/**\r\n * Return an array listing the events for which the emitter has registered\r\n * listeners.\r\n *\r\n * @returns {Array}\r\n * @public\r\n */EventEmitter.prototype.eventNames=function eventNames(){var names=[],events,name;if(this._eventsCount===0)return names;for(name in events=this._events){if(has.call(events,name))names.push(prefix?name.slice(1):name);}if(Object.getOwnPropertySymbols){return names.concat(Object.getOwnPropertySymbols(events));}return names;};/**\r\n * Return the listeners registered for a given event.\r\n *\r\n * @param {(String|Symbol)} event The event name.\r\n * @returns {Array} The registered listeners.\r\n * @public\r\n */EventEmitter.prototype.listeners=function listeners(event){var evt=prefix?prefix+event:event,handlers=this._events[evt];if(!handlers)return[];if(handlers.fn)return[handlers.fn];for(var i=0,l=handlers.length,ee=new Array(l);i<l;i++){ee[i]=handlers[i].fn;}return ee;};/**\r\n * Return the number of listeners listening to a given event.\r\n *\r\n * @param {(String|Symbol)} event The event name.\r\n * @returns {Number} The number of listeners.\r\n * @public\r\n */EventEmitter.prototype.listenerCount=function listenerCount(event){var evt=prefix?prefix+event:event,listeners=this._events[evt];if(!listeners)return 0;if(listeners.fn)return 1;return listeners.length;};/**\r\n * Calls each of the listeners registered for a given event.\r\n *\r\n * @param {(String|Symbol)} event The event name.\r\n * @returns {Boolean} `true` if the event had listeners, else `false`.\r\n * @public\r\n */EventEmitter.prototype.emit=function emit(event,a1,a2,a3,a4,a5){var evt=prefix?prefix+event:event;if(!this._events[evt])return false;var listeners=this._events[evt],len=arguments.length,args,i;if(listeners.fn){if(listeners.once)this.removeListener(event,listeners.fn,undefined,true);switch(len){case 1:return listeners.fn.call(listeners.context),true;case 2:return listeners.fn.call(listeners.context,a1),true;case 3:return listeners.fn.call(listeners.context,a1,a2),true;case 4:return listeners.fn.call(listeners.context,a1,a2,a3),true;case 5:return listeners.fn.call(listeners.context,a1,a2,a3,a4),true;case 6:return listeners.fn.call(listeners.context,a1,a2,a3,a4,a5),true;}for(i=1,args=new Array(len-1);i<len;i++){args[i-1]=arguments[i];}listeners.fn.apply(listeners.context,args);}else{var length=listeners.length,j;for(i=0;i<length;i++){if(listeners[i].once)this.removeListener(event,listeners[i].fn,undefined,true);switch(len){case 1:listeners[i].fn.call(listeners[i].context);break;case 2:listeners[i].fn.call(listeners[i].context,a1);break;case 3:listeners[i].fn.call(listeners[i].context,a1,a2);break;case 4:listeners[i].fn.call(listeners[i].context,a1,a2,a3);break;default:if(!args)for(j=1,args=new Array(len-1);j<len;j++){args[j-1]=arguments[j];}listeners[i].fn.apply(listeners[i].context,args);}}}return true;};/**\r\n * Add a listener for a given event.\r\n *\r\n * @param {(String|Symbol)} event The event name.\r\n * @param {Function} fn The listener function.\r\n * @param {*} [context=this] The context to invoke the listener with.\r\n * @returns {EventEmitter} `this`.\r\n * @public\r\n */EventEmitter.prototype.on=function on(event,fn,context){return addListener(this,event,fn,context,false);};/**\r\n * Add a one-time listener for a given event.\r\n *\r\n * @param {(String|Symbol)} event The event name.\r\n * @param {Function} fn The listener function.\r\n * @param {*} [context=this] The context to invoke the listener with.\r\n * @returns {EventEmitter} `this`.\r\n * @public\r\n */EventEmitter.prototype.once=function once(event,fn,context){return addListener(this,event,fn,context,true);};/**\r\n * Remove the listeners of a given event.\r\n *\r\n * @param {(String|Symbol)} event The event name.\r\n * @param {Function} fn Only remove the listeners that match this function.\r\n * @param {*} context Only remove the listeners that have this context.\r\n * @param {Boolean} once Only remove one-time listeners.\r\n * @returns {EventEmitter} `this`.\r\n * @public\r\n */EventEmitter.prototype.removeListener=function removeListener(event,fn,context,once){var evt=prefix?prefix+event:event;if(!this._events[evt])return this;if(!fn){clearEvent(this,evt);return this;}var listeners=this._events[evt];if(listeners.fn){if(listeners.fn===fn&&(!once||listeners.once)&&(!context||listeners.context===context)){clearEvent(this,evt);}}else{for(var i=0,events=[],length=listeners.length;i<length;i++){if(listeners[i].fn!==fn||once&&!listeners[i].once||context&&listeners[i].context!==context){events.push(listeners[i]);}}//\n// Reset the array, or remove it completely if we have no more listeners.\n//\nif(events.length)this._events[evt]=events.length===1?events[0]:events;else clearEvent(this,evt);}return this;};/**\r\n * Remove all listeners, or those of the specified event.\r\n *\r\n * @param {(String|Symbol)} [event] The event name.\r\n * @returns {EventEmitter} `this`.\r\n * @public\r\n */EventEmitter.prototype.removeAllListeners=function removeAllListeners(event){var evt;if(event){evt=prefix?prefix+event:event;if(this._events[evt])clearEvent(this,evt);}else{this._events=new Events();this._eventsCount=0;}return this;};//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.addListener=EventEmitter.prototype.on;//\n// Expose the prefix.\n//\nEventEmitter.prefixed=prefix;//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter=EventEmitter;//\n// Expose the module.\n//\nif(true){module.exports=EventEmitter;}/***/},/* 15 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetFastValue=__webpack_require__(2);/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n * -1 for an index.\r\n * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n * at least one side.\r\n * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n * have at least one interesting face.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */var GetTilesWithin=function GetTilesWithin(tileX,tileY,width,height,filteringOptions,layer){if(tileX===undefined){tileX=0;}if(tileY===undefined){tileY=0;}if(width===undefined){width=layer.width;}if(height===undefined){height=layer.height;}var isNotEmpty=GetFastValue(filteringOptions,'isNotEmpty',false);var isColliding=GetFastValue(filteringOptions,'isColliding',false);var hasInterestingFace=GetFastValue(filteringOptions,'hasInterestingFace',false);// Clip x, y to top left of map, while shrinking width/height to match.\nif(tileX<0){width+=tileX;tileX=0;}if(tileY<0){height+=tileY;tileY=0;}// Clip width and height to bottom right of map.\nif(tileX+width>layer.width){width=Math.max(layer.width-tileX,0);}if(tileY+height>layer.height){height=Math.max(layer.height-tileY,0);}var results=[];for(var ty=tileY;ty<tileY+height;ty++){for(var tx=tileX;tx<tileX+width;tx++){var tile=layer.data[ty][tx];if(tile!==null){if(isNotEmpty&&tile.index===-1){continue;}if(isColliding&&!tile.collides){continue;}if(hasInterestingFace&&!tile.hasInterestingFace){continue;}results.push(tile);}}}return results;};module.exports=GetTilesWithin;/***/},/* 16 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RND=__webpack_require__(963);var MATH_CONST={/**\r\n     * The value of PI * 2.\r\n     * \r\n     * @name Phaser.Math.PI2\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */PI2:Math.PI*2,/**\r\n     * The value of PI * 0.5.\r\n     * \r\n     * @name Phaser.Math.TAU\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */TAU:Math.PI*0.5,/**\r\n     * An epsilon value (1.0e-6)\r\n     * \r\n     * @name Phaser.Math.EPSILON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */EPSILON:1.0e-6,/**\r\n     * For converting degrees to radians (PI / 180)\r\n     * \r\n     * @name Phaser.Math.DEG_TO_RAD\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */DEG_TO_RAD:Math.PI/180,/**\r\n     * For converting radians to degrees (180 / PI)\r\n     * \r\n     * @name Phaser.Math.RAD_TO_DEG\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */RAD_TO_DEG:180/Math.PI,/**\r\n     * An instance of the Random Number Generator.\r\n     * \r\n     * @name Phaser.Math.RND\r\n     * @type {Phaser.Math.RandomDataGenerator}\r\n     * @since 3.0.0\r\n     */RND:new RND()};module.exports=MATH_CONST;/***/},/* 17 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FILE_CONST={/**\r\n     * The Loader is idle.\r\n     * \r\n     * @name Phaser.Loader.LOADER_IDLE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LOADER_IDLE:0,/**\r\n     * The Loader is actively loading.\r\n     * \r\n     * @name Phaser.Loader.LOADER_LOADING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LOADER_LOADING:1,/**\r\n     * The Loader is processing files is has loaded.\r\n     * \r\n     * @name Phaser.Loader.LOADER_PROCESSING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LOADER_PROCESSING:2,/**\r\n     * The Loader has completed loading and processing.\r\n     * \r\n     * @name Phaser.Loader.LOADER_COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LOADER_COMPLETE:3,/**\r\n     * The Loader is shutting down.\r\n     * \r\n     * @name Phaser.Loader.LOADER_SHUTDOWN\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LOADER_SHUTDOWN:4,/**\r\n     * The Loader has been destroyed.\r\n     * \r\n     * @name Phaser.Loader.LOADER_DESTROYED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LOADER_DESTROYED:5,/**\r\n     * File is in the load queue but not yet started\r\n     * \r\n     * @name Phaser.Loader.FILE_PENDING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_PENDING:10,/**\r\n     * File has been started to load by the loader (onLoad called)\r\n     * \r\n     * @name Phaser.Loader.FILE_LOADING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_LOADING:11,/**\r\n     * File has loaded successfully, awaiting processing    \r\n     * \r\n     * @name Phaser.Loader.FILE_LOADED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_LOADED:12,/**\r\n     * File failed to load\r\n     * \r\n     * @name Phaser.Loader.FILE_FAILED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_FAILED:13,/**\r\n     * File is being processed (onProcess callback)\r\n     * \r\n     * @name Phaser.Loader.FILE_PROCESSING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_PROCESSING:14,/**\r\n     * File is waiting for its linkfile to load.\r\n     * \r\n     * @name Phaser.Loader.FILE_WAITING_LINKFILE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_WAITING_LINKFILE:15,/**\r\n     * The File has errored somehow during processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_ERRORED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_ERRORED:16,/**\r\n     * File has finished processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_COMPLETE:17,/**\r\n     * File has been destroyed\r\n     * \r\n     * @name Phaser.Loader.FILE_DESTROYED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_DESTROYED:18,/**\r\n     * File was populated from local data and doesn't need an HTTP request\r\n     * \r\n     * @name Phaser.Loader.FILE_POPULATED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FILE_POPULATED:19,/**\r\n     * A special Texture Atlas const.\r\n     * \r\n     * @name Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */TEXTURE_ATLAS_JSON_ARRAY:20,/**\r\n     * A special Texture Atlas const.\r\n     * \r\n     * @name Phaser.Loader.TEXTURE_ATLAS_JSON_HASH\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */TEXTURE_ATLAS_JSON_HASH:21};module.exports=FILE_CONST;/***/},/* 18 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var IsPlainObject=__webpack_require__(381);// @param {boolean} deep - Perform a deep copy?\n// @param {object} target - The target object to copy to.\n// @return {object} The extended object.\n/**\r\n * This is a slightly modified version of http://api.jquery.com/jQuery.extend/\r\n *\r\n * @function Phaser.Utils.Object.Extend\r\n * @since 3.0.0\r\n *\r\n * @return {object} [description]\r\n */var Extend=function Extend(){var options,name,src,copy,copyIsArray,clone,target=arguments[0]||{},i=1,length=arguments.length,deep=false;// Handle a deep copy situation\nif(typeof target==='boolean'){deep=target;target=arguments[1]||{};// skip the boolean and the target\ni=2;}// extend Phaser if only one argument is passed\nif(length===i){target=this;--i;}for(;i<length;i++){// Only deal with non-null/undefined values\nif((options=arguments[i])!=null){// Extend the base object\nfor(name in options){src=target[name];copy=options[name];// Prevent never-ending loop\nif(target===copy){continue;}// Recurse if we're merging plain objects or arrays\nif(deep&&copy&&(IsPlainObject(copy)||(copyIsArray=Array.isArray(copy)))){if(copyIsArray){copyIsArray=false;clone=src&&Array.isArray(src)?src:[];}else{clone=src&&IsPlainObject(src)?src:{};}// Never move original objects, clone them\ntarget[name]=Extend(deep,clone,copy);// Don't bring in undefined values\n}else if(copy!==undefined){target[name]=copy;}}}}// Return the modified object\nreturn target;};module.exports=Extend;/***/},/* 19 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var GetFastValue=__webpack_require__(2);var GetURL=__webpack_require__(125);var MergeXHRSettings=__webpack_require__(124);var XHRLoader=__webpack_require__(228);var XHRSettings=__webpack_require__(95);/**\r\n * @callback FileProcessCallback\r\n *\r\n * @param {Phaser.Loader.File} file - [description]\r\n *//**\r\n * @typedef {object} FileConfig\r\n *\r\n * @property {(string|false)} [type=false] - The file type string (image, json, etc) for sorting within the Loader.\r\n * @property {(string|false)} [key=false] - Unique cache key (unique within its file type)\r\n * @property {string} [url] - The URL of the file, not including baseURL.\r\n * @property {string} [path=''] - [description]\r\n * @property {string} [extension=''] - [description]\r\n * @property {XMLHttpRequestResponseType} [responseType] - [description]\r\n * @property {(XHRSettingsObject|false)} [xhrSettings=false] - [description]\r\n * @property {object} [config] - A config object that can be used by file types to store transitional data.\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class File\r\n * @memberOf Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {FileConfig} fileConfig - [description]\r\n */var File=new Class({initialize:function File(fileConfig){/**\r\n         * The file type string (image, json, etc) for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.type=GetFastValue(fileConfig,'type',false);/**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.File#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.key=GetFastValue(fileConfig,'key',false);if(!this.type||!this.key){throw new Error('Error calling \\'Loader.'+this.type+'\\' invalid key provided.');}/**\r\n         * The URL of the file, not including baseURL.\r\n         *\r\n         * @name Phaser.Loader.File#url\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.url=GetFastValue(fileConfig,'url');if(this.url===undefined){this.url=GetFastValue(fileConfig,'path','')+this.key+'.'+GetFastValue(fileConfig,'extension','');}else if(typeof this.url!=='function'){this.url=GetFastValue(fileConfig,'path','').concat(this.url);}/**\r\n         * Set when the Loader calls 'load' on this file.\r\n         *\r\n         * @name Phaser.Loader.File#src\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.src='';/**\r\n         * The merged XHRSettings for this file.\r\n         *\r\n         * @name Phaser.Loader.File#xhrSettings\r\n         * @type {XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */this.xhrSettings=XHRSettings(GetFastValue(fileConfig,'responseType',undefined));if(GetFastValue(fileConfig,'xhrSettings',false)){this.xhrSettings=MergeXHRSettings(this.xhrSettings,GetFastValue(fileConfig,'xhrSettings',{}));}/**\r\n         * The LoaderPlugin instance that is loading this file.\r\n         *\r\n         * @name Phaser.Loader.File#loader\r\n         * @type {?Phaser.Loader.LoaderPlugin}\r\n         * @since 3.0.0\r\n         */this.loader=null;/**\r\n         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.\r\n         *\r\n         * @name Phaser.Loader.File#xhrLoader\r\n         * @type {?XMLHttpRequest}\r\n         * @since 3.0.0\r\n         */this.xhrLoader=null;/**\r\n         * The current state of the file. One of the FILE_CONST values.\r\n         *\r\n         * @name Phaser.Loader.File#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.state=typeof this.url==='function'?CONST.FILE_POPULATED:CONST.FILE_PENDING;/**\r\n         * The total size of this file.\r\n         * Set by onProgress and only if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesTotal\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.bytesTotal=0;/**\r\n         * Updated as the file loads.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesLoaded\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */this.bytesLoaded=-1;/**\r\n         * A percentage value between 0 and 1 indicating how much of this file has loaded.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#percentComplete\r\n         * @type {float}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */this.percentComplete=-1;/**\r\n         * For CORs based loading.\r\n         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)\r\n         *\r\n         * @name Phaser.Loader.File#crossOrigin\r\n         * @type {(string|undefined)}\r\n         * @since 3.0.0\r\n         */this.crossOrigin=undefined;/**\r\n         * The processed file data, stored in here after the file has loaded.\r\n         *\r\n         * @name Phaser.Loader.File#data\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */this.data=undefined;/**\r\n         * A config object that can be used by file types to store transitional data.\r\n         *\r\n         * @name Phaser.Loader.File#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.config=GetFastValue(fileConfig,'config',{});/**\r\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n         * to the linked file. Set and used internally by the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#linkFile\r\n         * @type {?Phaser.Loader.File}\r\n         * @since 3.0.0\r\n         */this.linkFile=undefined;/**\r\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n         * to the type of linked association. Set and used internally by the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#linkType\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.linkType='';/**\r\n         * If this is a link file, is this the parent or the sibbling?\r\n         *\r\n         * @name Phaser.Loader.File#linkParent\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.linkParent=false;},/**\r\n     * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n     * to the linked file. Set and used internally by the Loader.\r\n     *\r\n     * @method Phaser.Loader.File#setLinkFile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} fileB - The linked file.\r\n     * @param {string} linkType - The type of association.\r\n     */setLinkFile:function setLinkFile(fileB,linkType){this.linkFile=fileB;fileB.linkFile=this;this.linkType=linkType;fileB.linkType=linkType;this.linkParent=true;},/**\r\n     * Resets the XHRLoader instance.\r\n     *\r\n     * @method Phaser.Loader.File#resetXHR\r\n     * @since 3.0.0\r\n     */resetXHR:function resetXHR(){if(this.xhrLoader){this.xhrLoader.onload=undefined;this.xhrLoader.onerror=undefined;this.xhrLoader.onprogress=undefined;}},/**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onProgress, etc are called based on the XHR events.\r\n     *\r\n     * @method Phaser.Loader.File#load\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that will load this File.\r\n     */load:function load(loader){this.loader=loader;if(this.state===CONST.FILE_POPULATED){this.onComplete();loader.nextFile(this);}else{this.src=GetURL(this,loader.baseURL);if(this.src.indexOf('data:')===0){console.warn('Local data URIs are not supported: '+this.key);}else{this.xhrLoader=XHRLoader(this,loader.xhr);}}},/**\r\n     * Called when the file finishes loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onLoad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */onLoad:function onLoad(event){this.resetXHR();if(event.target&&event.target.status!==200){this.loader.nextFile(this,false);}else{this.loader.nextFile(this,true);}},/**\r\n     * Called if the file errors while loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onError\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.\r\n     */onError:function onError(){this.resetXHR();this.loader.nextFile(this,false);},/**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onProgress\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent.\r\n     */onProgress:function onProgress(event){if(event.lengthComputable){this.bytesLoaded=event.loaded;this.bytesTotal=event.total;this.percentComplete=Math.min(this.bytesLoaded/this.bytesTotal,1);// console.log(this.percentComplete + '% (' + this.bytesLoaded + ' bytes)');\nthis.loader.emit('fileprogress',this,this.percentComplete);}},/**\r\n     * Usually overridden by the FileTypes and is called by Loader.finishedLoading.\r\n     * The callback is Loader.processUpdate\r\n     *\r\n     * @method Phaser.Loader.File#onProcess\r\n     * @since 3.0.0\r\n     *\r\n     * @param {FileProcessCallback} callback - The callback to invoke to process this File.\r\n     */onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.onComplete();callback(this);},/**\r\n     * Called with the File has completed loading.\r\n     * Checks on the state of its linkfile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onComplete\r\n     * @since 3.0.0\r\n     */onComplete:function onComplete(){if(this.linkFile){if(this.linkFile.state===CONST.FILE_WAITING_LINKFILE){//  The linkfile has finished processing, and is waiting for this file, so let's do them both\nthis.state=CONST.FILE_COMPLETE;this.linkFile.state=CONST.FILE_COMPLETE;}else{//  The linkfile still hasn't finished loading and/or processing yet\nthis.state=CONST.FILE_WAITING_LINKFILE;}}else{this.state=CONST.FILE_COMPLETE;}}});/**\r\n * Static method for creating object URL using URL API and setting it as image 'src' attribute.\r\n * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.\r\n *\r\n * @method Phaser.Loader.File.createObjectURL\r\n * @static\r\n * @param {Image} image - Image object which 'src' attribute should be set to object URL.\r\n * @param {Blob} blob - A Blob object to create an object URL for.\r\n * @param {string} defaultType - Default mime type used if blob type is not available.\r\n */File.createObjectURL=function(image,blob,defaultType){if(typeof URL==='function'){image.src=URL.createObjectURL(blob);}else{var reader=new FileReader();reader.onload=function(){image.removeAttribute('crossOrigin');image.src='data:'+(blob.type||defaultType)+';base64,'+reader.result.split(',')[1];};reader.onerror=image.onerror;reader.readAsDataURL(blob);}};/**\r\n * Static method for releasing an existing object URL which was previously created\r\n * by calling {@link File#createObjectURL} method.\r\n *\r\n * @method Phaser.Loader.File.revokeObjectURL\r\n * @static\r\n * @param {Image} image - Image object which 'src' attribute should be revoked.\r\n */File.revokeObjectURL=function(image){if(typeof URL==='function'){URL.revokeObjectURL(image.src);}};module.exports=File;/***/},/* 20 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BlendModes=__webpack_require__(64);var GetAdvancedValue=__webpack_require__(8);var ScaleModes=__webpack_require__(82);/**\r\n * @typedef {object} GameObjectConfig\r\n *\r\n * @property {number} [x=0] - [description]\r\n * @property {number} [y=0] - [description]\r\n * @property {number} [depth=0] - [description]\r\n * @property {boolean} [flipX=false] - [description]\r\n * @property {boolean} [flipY=false] - [description]\r\n * @property {?(number|object)} [scale=null] - [description]\r\n * @property {?(number|object)} [scrollFactor=null] - [description]\r\n * @property {number} [rotation=0] - [description]\r\n * @property {?number} [angle=null] - [description]\r\n * @property {number} [alpha=1] - [description]\r\n * @property {?(number|object)} [origin=null] - [description]\r\n * @property {number} [scaleMode=ScaleModes.DEFAULT] - [description]\r\n * @property {number} [blendMode=BlendModes.DEFAULT] - [description]\r\n * @property {boolean} [visible=true] - [description]\r\n * @property {boolean} [add=true] - [description]\r\n *//**\r\n * Builds a Game Object using the provided configuration object.\r\n *\r\n * @function Phaser.GameObjects.BuildGameObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n * @param {GameObjectConfig} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The built Game Object.\r\n */var BuildGameObject=function BuildGameObject(scene,gameObject,config){//  Position\ngameObject.x=GetAdvancedValue(config,'x',0);gameObject.y=GetAdvancedValue(config,'y',0);gameObject.depth=GetAdvancedValue(config,'depth',0);//  Flip\ngameObject.flipX=GetAdvancedValue(config,'flipX',false);gameObject.flipY=GetAdvancedValue(config,'flipY',false);//  Scale\n//  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}\nvar scale=GetAdvancedValue(config,'scale',null);if(typeof scale==='number'){gameObject.setScale(scale);}else if(scale!==null){gameObject.scaleX=GetAdvancedValue(scale,'x',1);gameObject.scaleY=GetAdvancedValue(scale,'y',1);}//  ScrollFactor\n//  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}\nvar scrollFactor=GetAdvancedValue(config,'scrollFactor',null);if(typeof scrollFactor==='number'){gameObject.setScrollFactor(scrollFactor);}else if(scrollFactor!==null){gameObject.scrollFactorX=GetAdvancedValue(scrollFactor,'x',1);gameObject.scrollFactorY=GetAdvancedValue(scrollFactor,'y',1);}//  Rotation\ngameObject.rotation=GetAdvancedValue(config,'rotation',0);var angle=GetAdvancedValue(config,'angle',null);if(angle!==null){gameObject.angle=angle;}//  Alpha\ngameObject.alpha=GetAdvancedValue(config,'alpha',1);//  Origin\n//  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}\nvar origin=GetAdvancedValue(config,'origin',null);if(typeof origin==='number'){gameObject.setOrigin(origin);}else if(origin!==null){var ox=GetAdvancedValue(origin,'x',0.5);var oy=GetAdvancedValue(origin,'y',0.5);gameObject.setOrigin(ox,oy);}//  ScaleMode\ngameObject.scaleMode=GetAdvancedValue(config,'scaleMode',ScaleModes.DEFAULT);//  BlendMode\ngameObject.blendMode=GetAdvancedValue(config,'blendMode',BlendModes.NORMAL);//  Visible\ngameObject.visible=GetAdvancedValue(config,'visible',true);//  Add to Scene\nvar add=GetAdvancedValue(config,'add',true);if(add){scene.sys.displayList.add(gameObject);}if(gameObject.preUpdate){scene.sys.updateList.add(gameObject);}return gameObject;};module.exports=BuildGameObject;/***/},/* 21 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Takes an array of Game Objects, or any objects that have a public property as defined in `key`,\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `PropertyValueSet(group.getChildren(), key, value, step)`\r\n *\r\n * @function Phaser.Actions.PropertyValueSet\r\n * @since 3.3.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {string} key - The property to be updated.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var PropertyValueSet=function PropertyValueSet(items,key,value,step,index,direction){if(step===undefined){step=0;}if(index===undefined){index=0;}if(direction===undefined){direction=1;}var i;var t=0;var end=items.length;if(direction===1){//  Start to End\nfor(i=index;i<end;i++){items[i][key]=value+t*step;t++;}}else{//  End to Start\nfor(i=index;i>=0;i--){items[i][key]=value+t*step;t++;}}return items;};module.exports=PropertyValueSet;/***/},/* 22 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Global consts.\r\n * \r\n * @ignore\r\n */var CONST={/**\r\n     * Phaser Release Version\r\n     * \r\n     * @name Phaser.VERSION\r\n     * @readOnly\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */VERSION:'3.4.0',BlendModes:__webpack_require__(64),ScaleModes:__webpack_require__(82),/**\r\n     * AUTO Detect Renderer.\r\n     * \r\n     * @name Phaser.AUTO\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */AUTO:0,/**\r\n     * Canvas Renderer.\r\n     * \r\n     * @name Phaser.CANVAS\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */CANVAS:1,/**\r\n     * WebGL Renderer.\r\n     * \r\n     * @name Phaser.WEBGL\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */WEBGL:2,/**\r\n     * Headless Renderer.\r\n     * \r\n     * @name Phaser.HEADLESS\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */HEADLESS:3,/**\r\n     * In Phaser the value -1 means 'forever' in lots of cases, this const allows you to use it instead\r\n     * to help you remember what the value is doing in your code.\r\n     * \r\n     * @name Phaser.FOREVER\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */FOREVER:-1,/**\r\n     * Direction constant.\r\n     * \r\n     * @name Phaser.NONE\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */NONE:4,/**\r\n     * Direction constant.\r\n     * \r\n     * @name Phaser.UP\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */UP:5,/**\r\n     * Direction constant.\r\n     * \r\n     * @name Phaser.DOWN\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */DOWN:6,/**\r\n     * Direction constant.\r\n     * \r\n     * @name Phaser.LEFT\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LEFT:7,/**\r\n     * Direction constant.\r\n     * \r\n     * @name Phaser.RIGHT\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */RIGHT:8};module.exports=CONST;/***/},/* 23 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(22);var Smoothing=__webpack_require__(158);// The pool into which the canvas elements are placed.\nvar pool=[];//  Automatically apply smoothing(false) to created Canvas elements\nvar _disableContextSmoothing=false;/**\r\n * The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.\r\n *\r\n * This singleton is instantiated as soon as Phaser loads,\r\n * before a Phaser.Game instance has even been created.\r\n * Which means all instances of Phaser Games on the same page\r\n * can share the one single pool\r\n *\r\n * @namespace Phaser.Display.Canvas.CanvasPool\r\n * @since 3.0.0\r\n */var CanvasPool=function CanvasPool(){/**\r\n     * Creates a new Canvas DOM element, or pulls one from the pool if free.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} parent - The parent of the Canvas object.\r\n     * @param {integer} [width=1] - The width of the Canvas.\r\n     * @param {integer} [height=1] - The height of the Canvas.\r\n     * @param {integer} [canvasType=Phaser.CANVAS] - The type of the Canvas. Either `Phaser.CANVAS` or `Phaser.WEBGL`.\r\n     *\r\n     * @return {HTMLCanvasElement} [description]\r\n     */var create=function create(parent,width,height,canvasType){if(width===undefined){width=1;}if(height===undefined){height=1;}if(canvasType===undefined){canvasType=CONST.CANVAS;}var canvas;var container=first(canvasType);if(container===null){container={parent:parent,canvas:document.createElement('canvas'),type:canvasType};pool.push(container);canvas=container.canvas;}else{container.parent=parent;canvas=container.canvas;}canvas.width=width;canvas.height=height;if(_disableContextSmoothing&&canvasType===CONST.CANVAS){Smoothing.disable(canvas.getContext('2d'));}return canvas;};/**\r\n     * Creates a new Canvas DOM element, or pulls one from the pool if free.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.create2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} parent - The parent of the Canvas object.\r\n     * @param {integer} [width=1] - The width of the Canvas.\r\n     * @param {integer} [height=1] - The height of the Canvas.\r\n     *\r\n     * @return {HTMLCanvasElement} [description]\r\n     */var create2D=function create2D(parent,width,height){return create(parent,width,height,CONST.CANVAS);};/**\r\n     * Creates a new Canvas DOM element, or pulls one from the pool if free.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.createWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} parent - The parent of the Canvas object.\r\n     * @param {integer} [width=1] - The width of the Canvas.\r\n     * @param {integer} [height=1] - The height of the Canvas.\r\n     *\r\n     * @return {HTMLCanvasElement} [description]\r\n     */var createWebGL=function createWebGL(parent,width,height){return create(parent,width,height,CONST.WEBGL);};/**\r\n     * Gets the first free canvas index from the pool.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.first\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [canvasType=Phaser.CANVAS] - The type of the Canvas. Either `Phaser.CANVAS` or `Phaser.WEBGL`.\r\n     *\r\n     * @return {HTMLCanvasElement} [description]\r\n     */var first=function first(canvasType){if(canvasType===undefined){canvasType=CONST.CANVAS;}for(var i=0;i<pool.length;i++){var container=pool[i];if(!container.parent&&container.type===canvasType){return container;}}return null;};/**\r\n     * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.\r\n     * The canvas has its width and height set to 1, and its parent attribute nulled.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} parent - [description]\r\n     */var remove=function remove(parent){//  Check to see if the parent is a canvas object\nvar isCanvas=parent instanceof HTMLCanvasElement;pool.forEach(function(container){if(isCanvas&&container.canvas===parent||!isCanvas&&container.parent===parent){// console.log('CanvasPool.remove found and removed');\ncontainer.parent=null;container.canvas.width=1;container.canvas.height=1;}});};/**\r\n     * Gets the total number of used canvas elements in the pool.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.total\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */var total=function total(){var c=0;pool.forEach(function(container){if(container.parent){c++;}});return c;};/**\r\n     * Gets the total number of free canvas elements in the pool.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.free\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */var free=function free(){return pool.length-total();};/**\r\n     * Disable context smoothing on any new Canvas element created.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.disableSmoothing\r\n     * @since 3.0.0\r\n     */var disableSmoothing=function disableSmoothing(){_disableContextSmoothing=true;};/**\r\n     * Enable context smoothing on any new Canvas element created.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.enableSmoothing\r\n     * @since 3.0.0\r\n     */var enableSmoothing=function enableSmoothing(){_disableContextSmoothing=false;};return{create2D:create2D,create:create,createWebGL:createWebGL,disableSmoothing:disableSmoothing,enableSmoothing:enableSmoothing,first:first,free:free,pool:pool,remove:remove,total:total};};//  If we export the called function here, it'll only be invoked once (not every time it's required).\nmodule.exports=CanvasPool();/***/},/* 24 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Tilemaps.Formats\r\n */module.exports={/**\r\n     * CSV Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.CSV\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */CSV:0,/**\r\n     * Tiled JSON Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.TILED_JSON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */TILED_JSON:1,/**\r\n     * 2D Array Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.ARRAY_2D\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */ARRAY_2D:2,/**\r\n     * Weltmeister (Impact.js) Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.WELTMEISTER\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */WELTMEISTER:3};/***/},/* 25 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Takes an array of Game Objects, or any objects that have a public property as defined in `key`,\r\n * and then adds the given value to it.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `PropertyValueInc(group.getChildren(), key, value, step)`\r\n *\r\n * @function Phaser.Actions.PropertyValueInc\r\n * @since 3.3.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {string} key - The property to be updated.\r\n * @param {number} value - The amount to be added to the property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var PropertyValueInc=function PropertyValueInc(items,key,value,step,index,direction){if(step===undefined){step=0;}if(index===undefined){index=0;}if(direction===undefined){direction=1;}var i;var t=0;var end=items.length;if(direction===1){//  Start to End\nfor(i=index;i<end;i++){items[i][key]+=value+t*step;t++;}}else{//  End to Start\nfor(i=index;i>=0;i--){items[i][key]+=value+t*step;t++;}}return items;};module.exports=PropertyValueInc;/***/},/* 26 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTileAt=__webpack_require__(90);var GetTilesWithin=__webpack_require__(15);/**\r\n * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n * is mostly used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CalculateFacesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var CalculateFacesWithin=function CalculateFacesWithin(tileX,tileY,width,height,layer){var above=null;var below=null;var left=null;var right=null;var tiles=GetTilesWithin(tileX,tileY,width,height,null,layer);for(var i=0;i<tiles.length;i++){var tile=tiles[i];if(tile){if(tile.collides){above=GetTileAt(tile.x,tile.y-1,true,layer);below=GetTileAt(tile.x,tile.y+1,true,layer);left=GetTileAt(tile.x-1,tile.y,true,layer);right=GetTileAt(tile.x+1,tile.y,true,layer);tile.faceTop=above&&above.collides?false:true;tile.faceBottom=below&&below.collides?false:true;tile.faceLeft=left&&left.collides?false:true;tile.faceRight=right&&right.collides?false:true;}else{tile.resetFaces();}}}};module.exports=CalculateFacesWithin;/***/},/* 27 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Contains=function Contains(rect,x,y){if(rect.width<=0||rect.height<=0){return false;}return rect.x<=x&&rect.x+rect.width>=x&&rect.y<=y&&rect.y+rect.height>=y;};module.exports=Contains;/***/},/* 28 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Check to see if the Circle contains the given x / y coordinates.\r\n *\r\n * @function Phaser.Geom.Circle.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to check.\r\n * @param {number} x - The x coordinate to check within the circle.\r\n * @param {number} y - The y coordinate to check within the circle.\r\n *\r\n * @return {boolean} True if the coordinates are within the circle, otherwise false.\r\n */var Contains=function Contains(circle,x,y){//  Check if x/y are within the bounds first\nif(circle.radius>0&&x>=circle.left&&x<=circle.right&&y>=circle.top&&y<=circle.bottom){var dx=(circle.x-x)*(circle.x-x);var dy=(circle.y-y)*(circle.y-y);return dx+dy<=circle.radius*circle.radius;}else{return false;}};module.exports=Contains;/***/},/* 29 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Positions the Game Object so that the top of its bounds aligns with the given coordinate.\r\n *\r\n * @function Phaser.Display.Bounds.SetTop\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be re-positioned.\r\n * @param {number} value - The coordinate to position the Game Object bounds on.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was positioned.\r\n */var SetTop=function SetTop(gameObject,value){gameObject.y=value+gameObject.height*gameObject.originY;return gameObject;};module.exports=SetTop;/***/},/* 30 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the top coordinate from the bounds of the Game Object.\r\n *\r\n * @function Phaser.Display.Bounds.GetTop\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to get the bounds value from.\r\n *\r\n * @return {number} The top coordinate of the bounds of the Game Object.\r\n */var GetTop=function GetTop(gameObject){return gameObject.y-gameObject.height*gameObject.originY;};module.exports=GetTop;/***/},/* 31 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Positions the Game Object so that the left of its bounds aligns with the given coordinate.\r\n *\r\n * @function Phaser.Display.Bounds.SetRight\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be re-positioned.\r\n * @param {number} value - The coordinate to position the Game Object bounds on.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was positioned.\r\n */var SetRight=function SetRight(gameObject,value){gameObject.x=value-gameObject.width+gameObject.width*gameObject.originX;return gameObject;};module.exports=SetRight;/***/},/* 32 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the right coordinate from the bounds of the Game Object.\r\n *\r\n * @function Phaser.Display.Bounds.GetRight\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to get the bounds value from.\r\n *\r\n * @return {number} The right coordinate of the bounds of the Game Object.\r\n */var GetRight=function GetRight(gameObject){return gameObject.x+gameObject.width-gameObject.width*gameObject.originX;};module.exports=GetRight;/***/},/* 33 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Positions the Game Object so that the left of its bounds aligns with the given coordinate.\r\n *\r\n * @function Phaser.Display.Bounds.SetLeft\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be re-positioned.\r\n * @param {number} value - The coordinate to position the Game Object bounds on.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was positioned.\r\n */var SetLeft=function SetLeft(gameObject,value){gameObject.x=value+gameObject.width*gameObject.originX;return gameObject;};module.exports=SetLeft;/***/},/* 34 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the left coordinate from the bounds of the Game Object.\r\n *\r\n * @function Phaser.Display.Bounds.GetLeft\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to get the bounds value from.\r\n *\r\n * @return {number} The left coordinate of the bounds of the Game Object.\r\n */var GetLeft=function GetLeft(gameObject){return gameObject.x-gameObject.width*gameObject.originX;};module.exports=GetLeft;/***/},/* 35 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Positions the Game Object so that the bottom of its bounds aligns with the given coordinate.\r\n *\r\n * @function Phaser.Display.Bounds.SetBottom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be re-positioned.\r\n * @param {number} value - The coordinate to position the Game Object bounds on.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was positioned.\r\n */var SetBottom=function SetBottom(gameObject,value){gameObject.y=value-gameObject.height+gameObject.height*gameObject.originY;return gameObject;};module.exports=SetBottom;/***/},/* 36 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the bottom coordinate from the bounds of the Game Object.\r\n *\r\n * @function Phaser.Display.Bounds.GetBottom\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to get the bounds value from.\r\n *\r\n * @return {number} The bottom coordinate of the bounds of the Game Object.\r\n */var GetBottom=function GetBottom(gameObject){return gameObject.y+gameObject.height-gameObject.height*gameObject.originY;};module.exports=GetBottom;/***/},/* 37 *//***/function(module,exports){/**\r\n* The `Matter.Common` module contains utility functions that are common to all modules.\r\n*\r\n* @class Common\r\n*/var Common={};module.exports=Common;(function(){Common._nextId=0;Common._seed=0;Common._nowStartTime=+new Date();/**\r\n     * Extends the object in the first argument using the object in the second argument.\r\n     * @method extend\r\n     * @param {} obj\r\n     * @param {boolean} deep\r\n     * @return {} obj extended\r\n     */Common.extend=function(obj,deep){var argsStart,args,deepClone;if(typeof deep==='boolean'){argsStart=2;deepClone=deep;}else{argsStart=1;deepClone=true;}for(var i=argsStart;i<arguments.length;i++){var source=arguments[i];if(source){for(var prop in source){if(deepClone&&source[prop]&&source[prop].constructor===Object){if(!obj[prop]||obj[prop].constructor===Object){obj[prop]=obj[prop]||{};Common.extend(obj[prop],deepClone,source[prop]);}else{obj[prop]=source[prop];}}else{obj[prop]=source[prop];}}}}return obj;};/**\r\n     * Creates a new clone of the object, if deep is true references will also be cloned.\r\n     * @method clone\r\n     * @param {} obj\r\n     * @param {bool} deep\r\n     * @return {} obj cloned\r\n     */Common.clone=function(obj,deep){return Common.extend({},deep,obj);};/**\r\n     * Returns the list of keys for the given object.\r\n     * @method keys\r\n     * @param {} obj\r\n     * @return {string[]} keys\r\n     */Common.keys=function(obj){if(Object.keys)return Object.keys(obj);// avoid hasOwnProperty for performance\nvar keys=[];for(var key in obj){keys.push(key);}return keys;};/**\r\n     * Returns the list of values for the given object.\r\n     * @method values\r\n     * @param {} obj\r\n     * @return {array} Array of the objects property values\r\n     */Common.values=function(obj){var values=[];if(Object.keys){var keys=Object.keys(obj);for(var i=0;i<keys.length;i++){values.push(obj[keys[i]]);}return values;}// avoid hasOwnProperty for performance\nfor(var key in obj){values.push(obj[key]);}return values;};/**\r\n     * Gets a value from `base` relative to the `path` string.\r\n     * @method get\r\n     * @param {} obj The base object\r\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\r\n     * @param {number} [begin] Path slice begin\r\n     * @param {number} [end] Path slice end\r\n     * @return {} The object at the given path\r\n     */Common.get=function(obj,path,begin,end){path=path.split('.').slice(begin,end);for(var i=0;i<path.length;i+=1){obj=obj[path[i]];}return obj;};/**\r\n     * Sets a value on `base` relative to the given `path` string.\r\n     * @method set\r\n     * @param {} obj The base object\r\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\r\n     * @param {} val The value to set\r\n     * @param {number} [begin] Path slice begin\r\n     * @param {number} [end] Path slice end\r\n     * @return {} Pass through `val` for chaining\r\n     */Common.set=function(obj,path,val,begin,end){var parts=path.split('.').slice(begin,end);Common.get(obj,path,0,-1)[parts[parts.length-1]]=val;return val;};/**\r\n     * Shuffles the given array in-place.\r\n     * The function uses a seeded random generator.\r\n     * @method shuffle\r\n     * @param {array} array\r\n     * @return {array} array shuffled randomly\r\n     */Common.shuffle=function(array){for(var i=array.length-1;i>0;i--){var j=Math.floor(Common.random()*(i+1));var temp=array[i];array[i]=array[j];array[j]=temp;}return array;};/**\r\n     * Randomly chooses a value from a list with equal probability.\r\n     * The function uses a seeded random generator.\r\n     * @method choose\r\n     * @param {array} choices\r\n     * @return {object} A random choice object from the array\r\n     */Common.choose=function(choices){return choices[Math.floor(Common.random()*choices.length)];};/**\r\n     * Returns true if the object is a HTMLElement, otherwise false.\r\n     * @method isElement\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\r\n     */Common.isElement=function(obj){return obj instanceof HTMLElement;};/**\r\n     * Returns true if the object is an array.\r\n     * @method isArray\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is an array, otherwise false\r\n     */Common.isArray=function(obj){return Object.prototype.toString.call(obj)==='[object Array]';};/**\r\n     * Returns true if the object is a function.\r\n     * @method isFunction\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is a function, otherwise false\r\n     */Common.isFunction=function(obj){return typeof obj===\"function\";};/**\r\n     * Returns true if the object is a plain object.\r\n     * @method isPlainObject\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is a plain object, otherwise false\r\n     */Common.isPlainObject=function(obj){return(typeof obj==='undefined'?'undefined':_typeof(obj))==='object'&&obj.constructor===Object;};/**\r\n     * Returns true if the object is a string.\r\n     * @method isString\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is a string, otherwise false\r\n     */Common.isString=function(obj){return Object.prototype.toString.call(obj)==='[object String]';};/**\r\n     * Returns the given value clamped between a minimum and maximum value.\r\n     * @method clamp\r\n     * @param {number} value\r\n     * @param {number} min\r\n     * @param {number} max\r\n     * @return {number} The value clamped between min and max inclusive\r\n     */Common.clamp=function(value,min,max){if(value<min)return min;if(value>max)return max;return value;};/**\r\n     * Returns the sign of the given value.\r\n     * @method sign\r\n     * @param {number} value\r\n     * @return {number} -1 if negative, +1 if 0 or positive\r\n     */Common.sign=function(value){return value<0?-1:1;};/**\r\n     * Returns the current timestamp since the time origin (e.g. from page load).\r\n     * The result will be high-resolution including decimal places if available.\r\n     * @method now\r\n     * @return {number} the current timestamp\r\n     */Common.now=function(){if(window.performance){if(window.performance.now){return window.performance.now();}else if(window.performance.webkitNow){return window.performance.webkitNow();}}return new Date()-Common._nowStartTime;};/**\r\n     * Returns a random value between a minimum and a maximum value inclusive.\r\n     * The function uses a seeded random generator.\r\n     * @method random\r\n     * @param {number} min\r\n     * @param {number} max\r\n     * @return {number} A random number between min and max inclusive\r\n     */Common.random=function(min,max){min=typeof min!==\"undefined\"?min:0;max=typeof max!==\"undefined\"?max:1;return min+_seededRandom()*(max-min);};var _seededRandom=function _seededRandom(){// https://en.wikipedia.org/wiki/Linear_congruential_generator\nCommon._seed=(Common._seed*9301+49297)%233280;return Common._seed/233280;};/**\r\n     * Converts a CSS hex colour string into an integer.\r\n     * @method colorToNumber\r\n     * @param {string} colorString\r\n     * @return {number} An integer representing the CSS hex string\r\n     */Common.colorToNumber=function(colorString){colorString=colorString.replace('#','');if(colorString.length==3){colorString=colorString.charAt(0)+colorString.charAt(0)+colorString.charAt(1)+colorString.charAt(1)+colorString.charAt(2)+colorString.charAt(2);}return parseInt(colorString,16);};/**\r\n     * The console logging level to use, where each level includes all levels above and excludes the levels below.\r\n     * The default level is 'debug' which shows all console messages.  \r\n     *\r\n     * Possible level values are:\r\n     * - 0 = None\r\n     * - 1 = Debug\r\n     * - 2 = Info\r\n     * - 3 = Warn\r\n     * - 4 = Error\r\n     * @property Common.logLevel\r\n     * @type {Number}\r\n     * @default 1\r\n     */Common.logLevel=1;/**\r\n     * Shows a `console.log` message only if the current `Common.logLevel` allows it.\r\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n     * @method log\r\n     * @param ...objs {} The objects to log.\r\n     */Common.log=function(){if(console&&Common.logLevel>0&&Common.logLevel<=3){console.log.apply(console,['matter-js:'].concat(Array.prototype.slice.call(arguments)));}};/**\r\n     * Shows a `console.info` message only if the current `Common.logLevel` allows it.\r\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n     * @method info\r\n     * @param ...objs {} The objects to log.\r\n     */Common.info=function(){if(console&&Common.logLevel>0&&Common.logLevel<=2){console.info.apply(console,['matter-js:'].concat(Array.prototype.slice.call(arguments)));}};/**\r\n     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\r\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n     * @method warn\r\n     * @param ...objs {} The objects to log.\r\n     */Common.warn=function(){if(console&&Common.logLevel>0&&Common.logLevel<=3){console.warn.apply(console,['matter-js:'].concat(Array.prototype.slice.call(arguments)));}};/**\r\n     * Returns the next unique sequential ID.\r\n     * @method nextId\r\n     * @return {Number} Unique sequential ID\r\n     */Common.nextId=function(){return Common._nextId++;};/**\r\n     * A cross browser compatible indexOf implementation.\r\n     * @method indexOf\r\n     * @param {array} haystack\r\n     * @param {object} needle\r\n     * @return {number} The position of needle in haystack, otherwise -1.\r\n    Common.indexOf = function(haystack, needle) {\r\n        if (haystack.indexOf)\r\n            return haystack.indexOf(needle);\r\n\r\n        for (var i = 0; i < haystack.length; i++) {\r\n            if (haystack[i] === needle)\r\n                return i;\r\n        }\r\n\r\n        return -1;\r\n    };\r\n     *//**\r\n     * A cross browser compatible array map implementation.\r\n     * @method map\r\n     * @param {array} list\r\n     * @param {function} func\r\n     * @return {array} Values from list transformed by func.\r\n     */Common.map=function(list,func){if(list.map){return list.map(func);}var mapped=[];for(var i=0;i<list.length;i+=1){mapped.push(func(list[i]));}return mapped;};/**\r\n     * Takes a directed graph and returns the partially ordered set of vertices in topological order.\r\n     * Circular dependencies are allowed.\r\n     * @method topologicalSort\r\n     * @param {object} graph\r\n     * @return {array} Partially ordered set of vertices in topological order.\r\n     */Common.topologicalSort=function(graph){// https://github.com/mgechev/javascript-algorithms\n// Copyright (c) Minko Gechev (MIT license)\n// Modifications: tidy formatting and naming\nvar result=[],visited=[],temp=[];for(var node in graph){if(!visited[node]&&!temp[node]){_topologicalSort(node,visited,temp,graph,result);}}return result;};var _topologicalSort=function _topologicalSort(node,visited,temp,graph,result){var neighbors=graph[node]||[];temp[node]=true;for(var i=0;i<neighbors.length;i+=1){var neighbor=neighbors[i];if(temp[neighbor]){// skip circular dependencies\ncontinue;}if(!visited[neighbor]){_topologicalSort(neighbor,visited,temp,graph,result);}}temp[node]=false;visited[node]=true;result.push(node);};/**\r\n     * Takes _n_ functions as arguments and returns a new function that calls them in order.\r\n     * The arguments applied when calling the new function will also be applied to every function passed.\r\n     * The value of `this` refers to the last value returned in the chain that was not `undefined`.\r\n     * Therefore if a passed function does not return a value, the previously returned value is maintained.\r\n     * After all passed functions have been called the new function returns the last returned value (if any).\r\n     * If any of the passed functions are a chain, then the chain will be flattened.\r\n     * @method chain\r\n     * @param ...funcs {function} The functions to chain.\r\n     * @return {function} A new function that calls the passed functions in order.\r\n     */Common.chain=function(){var funcs=[];for(var i=0;i<arguments.length;i+=1){var func=arguments[i];if(func._chained){// flatten already chained functions\nfuncs.push.apply(funcs,func._chained);}else{funcs.push(func);}}var chain=function chain(){// https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\nvar lastResult,args=new Array(arguments.length);for(var i=0,l=arguments.length;i<l;i++){args[i]=arguments[i];}for(i=0;i<funcs.length;i+=1){var result=funcs[i].apply(lastResult,args);if(typeof result!=='undefined'){lastResult=result;}}return lastResult;};chain._chained=funcs;return chain;};/**\r\n     * Chains a function to excute before the original function on the given `path` relative to `base`.\r\n     * See also docs for `Common.chain`.\r\n     * @method chainPathBefore\r\n     * @param {} base The base object\r\n     * @param {string} path The path relative to `base`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */Common.chainPathBefore=function(base,path,func){return Common.set(base,path,Common.chain(func,Common.get(base,path)));};/**\r\n     * Chains a function to excute after the original function on the given `path` relative to `base`.\r\n     * See also docs for `Common.chain`.\r\n     * @method chainPathAfter\r\n     * @param {} base The base object\r\n     * @param {string} path The path relative to `base`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */Common.chainPathAfter=function(base,path,func){return Common.set(base,path,Common.chain(Common.get(base,path),func));};})();/***/},/* 38 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Renderer.WebGL.Utils\r\n * @since 3.0.0\r\n */module.exports={/**\r\n     * [description]\r\n     *\r\n     * @function Phaser.Renderer.WebGL.Utils.getTintFromFloats\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} r - [description]\r\n     * @param {number} g - [description]\r\n     * @param {number} b - [description]\r\n     * @param {number} a - [description]\r\n     * \r\n     * @return {number} [description]\r\n     */getTintFromFloats:function getTintFromFloats(r,g,b,a){var ur=(r*255.0|0)&0xFF;var ug=(g*255.0|0)&0xFF;var ub=(b*255.0|0)&0xFF;var ua=(a*255.0|0)&0xFF;return(ua<<24|ur<<16|ug<<8|ub)>>>0;},/**\r\n     * [description]\r\n     *\r\n     * @function Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} rgb - [description]\r\n     * @param {number} a - [description]\r\n     * \r\n     * @return {number} [description]\r\n     */getTintAppendFloatAlpha:function getTintAppendFloatAlpha(rgb,a){var ua=(a*255.0|0)&0xFF;return(ua<<24|rgb)>>>0;},/**\r\n     * [description]\r\n     *\r\n     * @function Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlphaAndSwap\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} rgb - [description]\r\n     * @param {number} a - [description]\r\n     * \r\n     * @return {number} [description]\r\n     */getTintAppendFloatAlphaAndSwap:function getTintAppendFloatAlphaAndSwap(rgb,a){var ur=(rgb>>16|0)&0xff;var ug=(rgb>>8|0)&0xff;var ub=(rgb|0)&0xff;var ua=(a*255.0|0)&0xFF;return(ua<<24|ub<<16|ug<<8|ur)>>>0;},/**\r\n     * [description]\r\n     *\r\n     * @function Phaser.Renderer.WebGL.Utils.getFloatsFromUintRGB\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} rgb - [description]\r\n     * \r\n     * @return {number} [description]\r\n     */getFloatsFromUintRGB:function getFloatsFromUintRGB(rgb){var ur=(rgb>>16|0)&0xff;var ug=(rgb>>8|0)&0xff;var ub=(rgb|0)&0xff;return[ur/255.0,ug/255.0,ub/255.0];},/**\r\n     * [description]\r\n     *\r\n     * @function Phaser.Renderer.WebGL.Utils.getComponentCount\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} attributes - [description]\r\n     * @param {WebGLRenderingContext} glContext - [description]\r\n     * \r\n     * @return {number} [description]\r\n     */getComponentCount:function getComponentCount(attributes,glContext){var count=0;for(var index=0;index<attributes.length;++index){var element=attributes[index];if(element.type===glContext.FLOAT){count+=element.size;}else{count+=1;// We'll force any other type to be 32 bit. for now\n}}return count;}};/***/},/* 39 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldY - [description]\r\n * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n * nearest integer.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {number} The Y location in tile units.\r\n */var WorldToTileY=function WorldToTileY(worldY,snapToFloor,camera,layer){if(snapToFloor===undefined){snapToFloor=true;}var tileHeight=layer.baseTileHeight;var tilemapLayer=layer.tilemapLayer;if(tilemapLayer){if(camera===undefined){camera=tilemapLayer.scene.cameras.main;}// Find the world position relative to the static or dynamic layer's top left origin,\n// factoring in the camera's vertical scroll\nworldY=worldY-(tilemapLayer.y+camera.scrollY*(1-tilemapLayer.scrollFactorY));tileHeight*=tilemapLayer.scaleY;}return snapToFloor?Math.floor(worldY/tileHeight):worldY/tileHeight;};module.exports=WorldToTileY;/***/},/* 40 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileX\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - [description]\r\n * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n * nearest integer.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {number} The X location in tile units.\r\n */var WorldToTileX=function WorldToTileX(worldX,snapToFloor,camera,layer){if(snapToFloor===undefined){snapToFloor=true;}var tileWidth=layer.baseTileWidth;var tilemapLayer=layer.tilemapLayer;if(tilemapLayer){if(camera===undefined){camera=tilemapLayer.scene.cameras.main;}// Find the world position relative to the static or dynamic layer's top left origin,\n// factoring in the camera's horizontal scroll\nworldX=worldX-(tilemapLayer.x+camera.scrollX*(1-tilemapLayer.scrollFactorX));tileWidth*=tilemapLayer.scaleX;}return snapToFloor?Math.floor(worldX/tileWidth):worldX/tileWidth;};module.exports=WorldToTileX;/***/},/* 41 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var GameObject=__webpack_require__(1);var SpriteRender=__webpack_require__(897);/**\r\n * @classdesc\r\n * A Sprite Game Object.\r\n *\r\n * A Sprite Game Object is used for the display of both static and animated images in your game.\r\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\r\n * and animated.\r\n *\r\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\r\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\r\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\r\n *\r\n * @class Sprite\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var Sprite=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.Depth,Components.Flip,Components.GetBounds,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.ScrollFactor,Components.Size,Components.Texture,Components.Tint,Components.Transform,Components.Visible,SpriteRender],initialize:function Sprite(scene,x,y,texture,frame){GameObject.call(this,scene,'Sprite');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Sprite#anims\r\n         * @type {Phaser.GameObjects.Components.Animation}\r\n         * @since 3.0.0\r\n         */this.anims=new Components.Animation(this);this.setTexture(texture,frame);this.setPosition(x,y);this.setSizeToFrame();this.setOriginFromFrame();this.initPipeline('TextureTintPipeline');},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */preUpdate:function preUpdate(time,delta){this.anims.update(time,delta);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#play\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {boolean} [ignoreIfPlaying=false] - [description]\r\n     * @param {integer} [startFrame=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite} This Game Object.\r\n     */play:function play(key,ignoreIfPlaying,startFrame){this.anims.play(key,ignoreIfPlaying,startFrame);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Sprite#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONGameObject} A JSON representation of the Game Object.\r\n     */toJSON:function toJSON(){var data=Components.ToJSON(this);//  Extra Sprite data is added here\nreturn data;}});module.exports=Sprite;/***/},/* 42 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetColor=__webpack_require__(162);var GetColor32=__webpack_require__(346);/**\r\n * @classdesc\r\n * The Color class holds a single color value and allows for easy modification and reading of it.\r\n *\r\n * @class Color\r\n * @memberOf Phaser.Display\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [red=0] - The red color value. A number between 0 and 255.\r\n * @param {integer} [green=0] - The green color value. A number between 0 and 255.\r\n * @param {integer} [blue=0] - The blue color value. A number between 0 and 255.\r\n * @param {integer} [alpha=255] - The alpha value. A number between 0 and 255.\r\n */var Color=new Class({initialize:function Color(red,green,blue,alpha){if(red===undefined){red=0;}if(green===undefined){green=0;}if(blue===undefined){blue=0;}if(alpha===undefined){alpha=255;}/**\r\n         * The internal red color value.\r\n         *\r\n         * @name Phaser.Display.Color#r\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.r=0;/**\r\n         * The internal green color value.\r\n         *\r\n         * @name Phaser.Display.Color#g\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.g=0;/**\r\n         * The internal blue color value.\r\n         *\r\n         * @name Phaser.Display.Color#b\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.b=0;/**\r\n         * The internal alpha color value.\r\n         *\r\n         * @name Phaser.Display.Color#a\r\n         * @type {number}\r\n         * @private\r\n         * @default 255\r\n         * @since 3.0.0\r\n         */this.a=255;/**\r\n         * An array containing the calculated color values for WebGL use.\r\n         *\r\n         * @name Phaser.Display.Color#gl\r\n         * @type {number[]}\r\n         * @since 3.0.0\r\n         */this.gl=[0,0,0,1];/**\r\n         * Pre-calculated internal color value.\r\n         *\r\n         * @name Phaser.Display.Color#_color\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._color=0;/**\r\n         * Pre-calculated internal color32 value.\r\n         *\r\n         * @name Phaser.Display.Color#_color32\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._color32=0;/**\r\n         * Pre-calculated internal color rgb string value.\r\n         *\r\n         * @name Phaser.Display.Color#_rgba\r\n         * @type {string}\r\n         * @private\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this._rgba='';this.setTo(red,green,blue,alpha);},/**\r\n     * Sets this color to be transparent. Sets all values to zero.\r\n     *\r\n     * @method Phaser.Display.Color#transparent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Display.Color} This Color object.\r\n     */transparent:function transparent(){this.red=0;this.green=0;this.blue=0;this.alpha=0;return this.update();},/**\r\n     * Sets the color of this Color component.\r\n     *\r\n     * @method Phaser.Display.Color#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} red - The red color value. A number between 0 and 255.\r\n     * @param {integer} green - The green color value. A number between 0 and 255.\r\n     * @param {integer} blue - The blue color value. A number between 0 and 255.\r\n     * @param {integer} [alpha=255] - The alpha value. A number between 0 and 255.\r\n     *\r\n     * @return {Phaser.Display.Color} This Color object.\r\n     */setTo:function setTo(red,green,blue,alpha){if(alpha===undefined){alpha=255;}this.red=red;this.green=green;this.blue=blue;this.alpha=alpha;return this.update();},/**\r\n     * Sets the red, green, blue and alpha GL values of this Color component.\r\n     *\r\n     * @method Phaser.Display.Color#setGLTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} red - The red color value. A number between 0 and 1.\r\n     * @param {float} green - The green color value. A number between 0 and 1.\r\n     * @param {float} blue - The blue color value. A number between 0 and 1.\r\n     * @param {float} [alpha=1] - The alpha value. A number between 0 and 1.\r\n     *\r\n     * @return {Phaser.Display.Color} This Color object.\r\n     */setGLTo:function setGLTo(red,green,blue,alpha){if(alpha===undefined){alpha=1;}this.redGL=red;this.greenGL=green;this.blueGL=blue;this.alphaGL=alpha;return this.update();},/**\r\n     * Sets the color based on the color object given.\r\n     *\r\n     * @method Phaser.Display.Color#setFromRGB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {InputColorObject} color - An object containing `r`, `g`, `b` and optionally `a` values in the range 0 to 255.\r\n     *\r\n     * @return {Phaser.Display.Color} This Color object.\r\n     */setFromRGB:function setFromRGB(color){this.red=color.r;this.green=color.g;this.blue=color.b;if(color.hasOwnProperty('a')){this.alpha=color.a;}return this.update();},/**\r\n     * Updates the internal cache values.\r\n     *\r\n     * @method Phaser.Display.Color#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Display.Color} This Color object.\r\n     */update:function update(){this._color=GetColor(this.r,this.g,this.b);this._color32=GetColor32(this.r,this.g,this.b,this.a);this._rgba='rgba('+this.r+','+this.g+','+this.b+','+this.a/255+')';return this;},/**\r\n     * Returns a new Color component using the values from this one.\r\n     *\r\n     * @method Phaser.Display.Color#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Display.Color} A new Color object.\r\n     */clone:function clone(){return new Color(this.r,this.g,this.b,this.a);},/**\r\n     * The color of this Color component, not including the alpha channel.\r\n     *\r\n     * @name Phaser.Display.Color#color\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */color:{get:function get(){return this._color;}},/**\r\n     * The color of this Color component, including the alpha channel.\r\n     *\r\n     * @name Phaser.Display.Color#color32\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */color32:{get:function get(){return this._color32;}},/**\r\n     * The color of this Color component as a string which can be used in CSS color values.\r\n     *\r\n     * @name Phaser.Display.Color#rgba\r\n     * @type {string}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */rgba:{get:function get(){return this._rgba;}},/**\r\n     * The red color value, normalized to the range 0 to 1.\r\n     *\r\n     * @name Phaser.Display.Color#redGL\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */redGL:{get:function get(){return this.gl[0];},set:function set(value){this.gl[0]=Math.min(Math.abs(value),1);this.r=Math.floor(this.gl[0]*255);this.update();}},/**\r\n     * The green color value, normalized to the range 0 to 1.\r\n     *\r\n     * @name Phaser.Display.Color#greenGL\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */greenGL:{get:function get(){return this.gl[1];},set:function set(value){this.gl[1]=Math.min(Math.abs(value),1);this.g=Math.floor(this.gl[1]*255);this.update();}},/**\r\n     * The blue color value, normalized to the range 0 to 1.\r\n     *\r\n     * @name Phaser.Display.Color#blueGL\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */blueGL:{get:function get(){return this.gl[2];},set:function set(value){this.gl[2]=Math.min(Math.abs(value),1);this.b=Math.floor(this.gl[2]*255);this.update();}},/**\r\n     * The alpha color value, normalized to the range 0 to 1.\r\n     *\r\n     * @name Phaser.Display.Color#alphaGL\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */alphaGL:{get:function get(){return this.gl[3];},set:function set(value){this.gl[3]=Math.min(Math.abs(value),1);this.a=Math.floor(this.gl[3]*255);this.update();}},/**\r\n     * The red color value, normalized to the range 0 to 255.\r\n     *\r\n     * @name Phaser.Display.Color#red\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */red:{get:function get(){return this.r;},set:function set(value){value=Math.floor(Math.abs(value));this.r=Math.min(value,255);this.gl[0]=value/255;this.update();}},/**\r\n     * The green color value, normalized to the range 0 to 255.\r\n     *\r\n     * @name Phaser.Display.Color#green\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */green:{get:function get(){return this.g;},set:function set(value){value=Math.floor(Math.abs(value));this.g=Math.min(value,255);this.gl[1]=value/255;this.update();}},/**\r\n     * The blue color value, normalized to the range 0 to 255.\r\n     *\r\n     * @name Phaser.Display.Color#blue\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */blue:{get:function get(){return this.b;},set:function set(value){value=Math.floor(Math.abs(value));this.b=Math.min(value,255);this.gl[2]=value/255;this.update();}},/**\r\n     * The alpha color value, normalized to the range 0 to 255.\r\n     *\r\n     * @name Phaser.Display.Color#alpha\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */alpha:{get:function get(){return this.a;},set:function set(value){value=Math.floor(Math.abs(value));this.a=Math.min(value,255);this.gl[3]=value/255;this.update();}}});module.exports=Color;/***/},/* 43 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(16);/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.DegToRad\r\n * @since 3.0.0\r\n *\r\n * @param {integer} degrees - [description]\r\n *\r\n * @return {float} [description]\r\n */var DegToRad=function DegToRad(degrees){return degrees*CONST.DEG_TO_RAD;};module.exports=DegToRad;/***/},/* 44 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {number} min - [description]\r\n * @param {number} max - [description]\r\n *\r\n * @return {number} [description]\r\n */var Wrap=function Wrap(value,min,max){var range=max-min;return min+((value-min)%range+range)%range;};module.exports=Wrap;/***/},/* 45 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var Rectangle=__webpack_require__(236);/**\r\n * @classdesc\r\n * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data\r\n * representation, so its position information is stored without factoring in scroll, layer\r\n * scale or layer position.\r\n *\r\n * @class Tile\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The LayerData object in the Tilemap that this tile belongs to.\r\n * @param {integer} index - The unique index of this tile within the map.\r\n * @param {integer} x - The x coordinate of this tile in tile coordinates.\r\n * @param {integer} y - The y coordinate of this tile in tile coordinates.\r\n * @param {integer} width - Width of the tile in pixels.\r\n * @param {integer} height - Height of the tile in pixels.\r\n * @param {integer} baseWidth - The base width a tile in the map (in pixels). Tiled maps support\r\n * multiple tileset sizes within one map, but they are still placed at intervals of the base\r\n * tile width.\r\n * @param {integer} baseHeight - The base height of the tile in pixels (in pixels). Tiled maps\r\n * support multiple tileset sizes within one map, but they are still placed at intervals of the\r\n * base tile height.\r\n */var Tile=new Class({Mixins:[Components.Alpha,Components.Flip,Components.Visible],initialize:function Tile(layer,index,x,y,width,height,baseWidth,baseHeight){/**\r\n         * The LayerData in the Tilemap data that this tile belongs to.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.0.0\r\n         */this.layer=layer;/**\r\n         * The index of this tile within the map data corresponding to the tileset, or -1 if this\r\n         * represents a blank tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#index\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.index=index;/**\r\n         * The x map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#x\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * The y map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#y\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.y=y;/**\r\n         * The width of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.width=width;/**\r\n         * The height of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.height=height;/**\r\n         * The map's base width of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.baseWidth=baseWidth!==undefined?baseWidth:width;/**\r\n         * The map's base height of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.baseHeight=baseHeight!==undefined?baseHeight:height;/**\r\n         * The x coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelX\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.pixelX=0;/**\r\n         * The y coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelY\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.pixelY=0;this.updatePixelXY();/**\r\n         * Tile specific properties. These usually come from Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.properties={};/**\r\n         * The rotation angle of this tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.rotation=0;/**\r\n         * Whether the tile should collide with any object on the left side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.collideLeft=false;/**\r\n         * Whether the tile should collide with any object on the right side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.collideRight=false;/**\r\n         * Whether the tile should collide with any object on the top side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideUp\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.collideUp=false;/**\r\n         * Whether the tile should collide with any object on the bottom side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideDown\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.collideDown=false;/**\r\n         * Whether the tile's left edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.faceLeft=false;/**\r\n         * Whether the tile's right edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.faceRight=false;/**\r\n         * Whether the tile's top edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceTop\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.faceTop=false;/**\r\n         * Whether the tile's bottom edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceBottom\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.faceBottom=false;/**\r\n         * Tile collision callback.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallback\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */this.collisionCallback=null;/**\r\n         * The context in which the collision callback will be called.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallbackContext\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.collisionCallbackContext=this;/**\r\n         * The tint to apply to this tile. Note: tint is currently a single color value instead of\r\n         * the 4 corner tint component on other GameObjects.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#tint\r\n         * @type {number}\r\n         * @default\r\n         * @since 3.0.0\r\n         */this.tint=0xffffff;/**\r\n         * An empty object where physics-engine specific information (e.g. bodies) may be stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#physics\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.physics={};},/**\r\n     * Check if the given x and y world coordinates are within this Tile. This does not factor in\r\n     * camera scroll, layer scale or layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#containsPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to test.\r\n     * @param {number} y - The y coordinate to test.\r\n     *\r\n     * @return {boolean} True if the coordinates are within this Tile, otherwise false.\r\n     */containsPoint:function containsPoint(x,y){return!(x<this.pixelX||y<this.pixelY||x>this.right||y>this.bottom);},/**\r\n     * Copies the tile data & properties from the given tile to this tile. This copies everything\r\n     * except for position and interesting faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#containsPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile} tile - The tile to copy from.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */copy:function copy(tile){this.index=tile.index;this.alpha=tile.alpha;this.properties=tile.properties;this.visible=tile.visible;this.setFlip(tile.flipX,tile.flipY);this.tint=tile.tint;this.rotation=tile.rotation;this.collideUp=tile.collideUp;this.collideDown=tile.collideDown;this.collideLeft=tile.collideLeft;this.collideRight=tile.collideRight;this.collisionCallback=tile.collisionCallback;this.collisionCallbackContext=tile.collisionCallbackContext;return this;},/**\r\n     * The collision group for this Tile, defined within the Tileset. This returns a reference to\r\n     * the collision group stored within the Tileset, so any modification of the returned object\r\n     * will impact all tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} tileset\r\n     */getCollisionGroup:function getCollisionGroup(){return this.tileset?this.tileset.getTileCollisionGroup(this.index):null;},/**\r\n     * The tile data for this Tile, defined within the Tileset. This typically contains Tiled\r\n     * collision data, tile animations and terrain information. This returns a reference to the tile\r\n     * data stored within the Tileset, so any modification of the returned object will impact all\r\n     * tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} tileset\r\n     */getTileData:function getTileData(){return this.tileset?this.tileset.getTileData(this.index):null;},/**\r\n     * Gets the world X position of the left side of the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */getLeft:function getLeft(camera){var tilemapLayer=this.tilemapLayer;return tilemapLayer?tilemapLayer.tileToWorldX(this.x,camera):this.x*this.baseWidth;},/**\r\n     * Gets the world X position of the right side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */getRight:function getRight(camera){var tilemapLayer=this.tilemapLayer;return tilemapLayer?this.getLeft(camera)+this.width*tilemapLayer.scaleX:this.getLeft(camera)+this.width;},/**\r\n     * Gets the world Y position of the top side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */getTop:function getTop(camera){var tilemapLayer=this.tilemapLayer;// Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile in grid\n// units is the bottom left, so the y coordinate needs to be adjusted by the difference\n// between the base size and this tile's size.\nreturn tilemapLayer?tilemapLayer.tileToWorldY(this.y,camera)-(this.height-this.baseHeight)*tilemapLayer.scaleY:this.y*this.baseHeight-(this.height-this.baseHeight);},/**\r\n     * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n\r\n     * @method Phaser.Tilemaps.Tile#getBottom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */getBottom:function getBottom(camera){var tilemapLayer=this.tilemapLayer;return tilemapLayer?this.getTop(camera)+this.height*tilemapLayer.scaleY:this.getTop(camera)+this.height;},/**\r\n     * Gets the world rectangle bounding box for the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     * @param {object} [output] - [description]\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)}\r\n     */getBounds:function getBounds(camera,output){if(output===undefined){output=new Rectangle();}output.x=this.getLeft();output.y=this.getTop();output.width=this.getRight()-output.x;output.height=this.getBottom()-output.y;return output;},/**\r\n     * Gets the world X position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */getCenterX:function getCenterX(camera){return this.getLeft(camera)+this.width/2;},/**\r\n     * Gets the world Y position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */getCenterY:function getCenterY(camera){return this.getTop(camera)+this.height/2;},/**\r\n     * Clean up memory.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.collisionCallback=undefined;this.collisionCallbackContext=undefined;this.properties=undefined;},/**\r\n     * Check for intersection with this tile. This does not factor in camera scroll, layer scale or\r\n     * layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x axis in pixels.\r\n     * @param {number} y - The y axis in pixels.\r\n     * @param {number} right - The right point.\r\n     * @param {number} bottom - The bottom point.\r\n     *\r\n     * @return {boolean}\r\n     */intersects:function intersects(x,y,right,bottom){return!(right<=this.pixelX||bottom<=this.pixelY||x>=this.right||y>=this.bottom);},/**\r\n     * Checks if the tile is interesting.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#isInteresting\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} collides - If true, will consider the tile interesting if it collides on any side.\r\n     * @param {boolean} faces - If true, will consider the tile interesting if it has an interesting face.\r\n     *\r\n     * @return {boolean} True if the Tile is interesting, otherwise false.\r\n     */isInteresting:function isInteresting(collides,faces){if(collides&&faces){return this.canCollide||this.hasInterestingFace;}else if(collides){return this.collides;}else if(faces){return this.hasInterestingFace;}return false;},/**\r\n     * Reset collision status flags.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */resetCollision:function resetCollision(recalculateFaces){if(recalculateFaces===undefined){recalculateFaces=true;}this.collideLeft=false;this.collideRight=false;this.collideUp=false;this.collideDown=false;this.faceTop=false;this.faceBottom=false;this.faceLeft=false;this.faceRight=false;if(recalculateFaces){var tilemapLayer=this.tilemapLayer;if(tilemapLayer){this.tilemapLayer.calculateFacesAt(this.x,this.y);}}return this;},/**\r\n     * Reset faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetFaces\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */resetFaces:function resetFaces(){this.faceTop=false;this.faceBottom=false;this.faceLeft=false;this.faceRight=false;return this;},/**\r\n     * Sets the collision flags for each side of this tile and updates the interesting faces list.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} left - Indicating collide with any object on the left.\r\n     * @param {boolean} [right] - Indicating collide with any object on the right.\r\n     * @param {boolean} [up] - Indicating collide with any object on the top.\r\n     * @param {boolean} [down] - Indicating collide with any object on the bottom.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces\r\n     * for this tile and its neighbors.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */setCollision:function setCollision(left,right,up,down,recalculateFaces){if(right===undefined){right=left;}if(up===undefined){up=left;}if(down===undefined){down=left;}if(recalculateFaces===undefined){recalculateFaces=true;}this.collideLeft=left;this.collideRight=right;this.collideUp=up;this.collideDown=down;this.faceLeft=left;this.faceRight=right;this.faceTop=up;this.faceBottom=down;if(recalculateFaces){var tilemapLayer=this.tilemapLayer;if(tilemapLayer){this.tilemapLayer.calculateFacesAt(this.x,this.y);}}return this;},/**\r\n     * Set a callback to be called when this tile is hit by an object. The callback must true for\r\n     * collision processing to take place.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollisionCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - Callback function.\r\n     * @param {object} context - Callback will be called within this context.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */setCollisionCallback:function setCollisionCallback(callback,context){if(callback===null){this.collisionCallback=undefined;this.collisionCallbackContext=undefined;}else{this.collisionCallback=callback;this.collisionCallbackContext=context;}return this;},/**\r\n     * Sets the size of the tile and updates its pixelX and pixelY.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileWidth - The width of the tile in pixels.\r\n     * @param {integer} tileHeight - The height of the tile in pixels.\r\n     * @param {integer} baseWidth - The base width a tile in the map (in pixels).\r\n     * @param {integer} baseHeight - The base height of the tile in pixels (in pixels).\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */setSize:function setSize(tileWidth,tileHeight,baseWidth,baseHeight){if(tileWidth!==undefined){this.width=tileWidth;}if(tileHeight!==undefined){this.height=tileHeight;}if(baseWidth!==undefined){this.baseWidth=baseWidth;}if(baseHeight!==undefined){this.baseHeight=baseHeight;}this.updatePixelXY();return this;},/**\r\n     * Used internally. Updates the tile's world XY position based on the current tile size.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#updatePixelXY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */updatePixelXY:function updatePixelXY(){// Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile is the\n// bottom left, while the Phaser renderer assumes the origin is the top left. The y\n// coordinate needs to be adjusted by the difference.\nthis.pixelX=this.x*this.baseWidth;this.pixelY=this.y*this.baseHeight-(this.height-this.baseHeight);return this;},/**\r\n     * True if this tile can collide on any of its faces or has a collision callback set.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#canCollide\r\n     * @type {boolean}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */canCollide:{get:function get(){return this.collideLeft||this.collideRight||this.collideUp||this.collideDown||this.collisionCallback;}},/**\r\n     * True if this tile can collide on any of its faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collides\r\n     * @type {boolean}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */collides:{get:function get(){return this.collideLeft||this.collideRight||this.collideUp||this.collideDown;}},/**\r\n     * True if this tile has any interesting faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#hasInterestingFace\r\n     * @type {boolean}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */hasInterestingFace:{get:function get(){return this.faceTop||this.faceBottom||this.faceLeft||this.faceRight;}},/**\r\n     * The tileset that contains this Tile. This will only return null if accessed from a LayerData\r\n     * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tileset\r\n     * @type {?Phaser.Tilemaps.Tileset}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */tileset:{get:function get(){var tilemapLayer=this.tilemapLayer;return tilemapLayer?tilemapLayer.tileset:null;}},/**\r\n     * The tilemap layer that contains this Tile. This will only return null if accessed from a\r\n     * LayerData instance before the tile is placed within a StaticTilemapLayer or\r\n     * DynamicTilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemapLayer\r\n     * @type {?Phaser.Tilemaps.StaticTilemapLayer|Phaser.Tilemaps.DynamicTilemapLayer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */tilemapLayer:{get:function get(){return this.layer.tilemapLayer;}},/**\r\n     * The tilemap that contains this Tile. This will only return null if accessed from a LayerData\r\n     * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemap\r\n     * @type {?Phaser.Tilemaps.Tilemap}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */tilemap:{get:function get(){var tilemapLayer=this.tilemapLayer;return tilemapLayer?tilemapLayer.tilemap:null;}}});module.exports=Tile;/***/},/* 46 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Internally used method to set the colliding state of a tile. This does not recalculate\r\n * interesting faces.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileCollision\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.Tile} tile - [description]\r\n * @param {boolean} [collides=true] - [description]\r\n */var SetTileCollision=function SetTileCollision(tile,collides){if(collides){tile.setCollision(true,true,true,true,false);}else{tile.resetCollision(false);}};module.exports=SetTileCollision;/***/},/* 47 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Arcade Physics consts.\r\n * \r\n * @ignore\r\n */var CONST={/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.DYNAMIC_BODY\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */DYNAMIC_BODY:0,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.STATIC_BODY\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */STATIC_BODY:1,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.GROUP\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */GROUP:2,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.TILEMAPLAYER\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */TILEMAPLAYER:3,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.FACING_NONE\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */FACING_NONE:10,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.FACING_UP\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */FACING_UP:11,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.FACING_DOWN\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */FACING_DOWN:12,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.FACING_LEFT\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */FACING_LEFT:13,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Physics.Arcade.FACING_RIGHT\r\n     * @readOnly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */FACING_RIGHT:14};module.exports=CONST;/***/},/* 48 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Tests if the start and end indexes are a safe range for the given array.\r\n * \r\n * @function Phaser.Utils.Array.SafeRange\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to check.\r\n * @param {integer} startIndex - The start index.\r\n * @param {integer} endIndex - The end index.\r\n * @param {boolean} [throwError=true] - Throw an error if the range is out of bounds.\r\n *\r\n * @return {boolean} True if the range is safe, otherwise false.\r\n */var SafeRange=function SafeRange(array,startIndex,endIndex,throwError){var len=array.length;if(startIndex<0||startIndex>len||startIndex>=endIndex||endIndex>len||startIndex+endIndex>len){if(throwError){throw new Error('Range Error: Values outside acceptable range');}return false;}else{return true;}};module.exports=SafeRange;/***/},/* 49 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Distance.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - [description]\r\n * @param {number} y1 - [description]\r\n * @param {number} x2 - [description]\r\n * @param {number} y2 - [description]\r\n *\r\n * @return {number} [description]\r\n */var DistanceBetween=function DistanceBetween(x1,y1,x2,y2){var dx=x1-x2;var dy=y1-y2;return Math.sqrt(dx*dx+dy*dy);};module.exports=DistanceBetween;/***/},/* 50 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */var Clamp=function Clamp(value,min,max){return Math.max(min,Math.min(max,value));};module.exports=Clamp;/***/},/* 51 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Body` module contains methods for creating and manipulating body models.\r\n* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\r\n* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n\r\n* @class Body\r\n*/var Body={};module.exports=Body;var Vertices=__webpack_require__(93);var Vector=__webpack_require__(83);var Sleeping=__webpack_require__(203);var Common=__webpack_require__(37);var Bounds=__webpack_require__(92);var Axes=__webpack_require__(470);(function(){Body._inertiaScale=4;Body._nextCollidingGroupId=1;Body._nextNonCollidingGroupId=-1;Body._nextCategory=0x0001;/**\r\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n     * Vertices must be specified in clockwise order.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {} options\r\n     * @return {body} body\r\n     */Body.create=function(options){var defaults={id:Common.nextId(),type:'body',label:'Body',gameObject:null,parts:[],plugin:{},angle:0,vertices:Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),position:{x:0,y:0},force:{x:0,y:0},torque:0,positionImpulse:{x:0,y:0},previousPositionImpulse:{x:0,y:0},constraintImpulse:{x:0,y:0,angle:0},totalContacts:0,speed:0,angularSpeed:0,velocity:{x:0,y:0},angularVelocity:0,isSensor:false,isStatic:false,isSleeping:false,ignoreGravity:false,ignorePointer:false,motion:0,sleepThreshold:60,density:0.001,restitution:0,friction:0.1,frictionStatic:0.5,frictionAir:0.01,collisionFilter:{category:0x0001,mask:0xFFFFFFFF,group:0},slop:0.05,timeScale:1,render:{visible:true,opacity:1,sprite:{xScale:1,yScale:1,xOffset:0,yOffset:0},lineWidth:0},events:null,bounds:null,chamfer:null,circleRadius:0,positionPrev:null,anglePrev:0,parent:null,axes:null,area:0,mass:0,inertia:0,_original:null};var body=Common.extend(defaults,options);_initProperties(body,options);return body;};/**\r\n     * Returns the next unique group index for which bodies will collide.\r\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\r\n     * See `body.collisionFilter` for more information.\r\n     * @method nextGroup\r\n     * @param {bool} [isNonColliding=false]\r\n     * @return {Number} Unique group index\r\n     */Body.nextGroup=function(isNonColliding){if(isNonColliding)return Body._nextNonCollidingGroupId--;return Body._nextCollidingGroupId++;};/**\r\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\r\n     * There are 32 available. See `body.collisionFilter` for more information.\r\n     * @method nextCategory\r\n     * @return {Number} Unique category bitfield\r\n     */Body.nextCategory=function(){Body._nextCategory=Body._nextCategory<<1;return Body._nextCategory;};/**\r\n     * Initialises body properties.\r\n     * @method _initProperties\r\n     * @private\r\n     * @param {body} body\r\n     * @param {} [options]\r\n     */var _initProperties=function _initProperties(body,options){options=options||{};// init required properties (order is important)\nBody.set(body,{bounds:body.bounds||Bounds.create(body.vertices),positionPrev:body.positionPrev||Vector.clone(body.position),anglePrev:body.anglePrev||body.angle,vertices:body.vertices,parts:body.parts||[body],isStatic:body.isStatic,isSleeping:body.isSleeping,parent:body.parent||body});Vertices.rotate(body.vertices,body.angle,body.position);Axes.rotate(body.axes,body.angle);Bounds.update(body.bounds,body.vertices,body.velocity);// allow options to override the automatically calculated properties\nBody.set(body,{axes:options.axes||body.axes,area:options.area||body.area,mass:options.mass||body.mass,inertia:options.inertia||body.inertia});// render properties\nvar defaultFillStyle=body.isStatic?'#2e2b44':Common.choose(['#006BA6','#0496FF','#FFBC42','#D81159','#8F2D56']),defaultStrokeStyle='#000';body.render.fillStyle=body.render.fillStyle||defaultFillStyle;body.render.strokeStyle=body.render.strokeStyle||defaultStrokeStyle;body.render.sprite.xOffset+=-(body.bounds.min.x-body.position.x)/(body.bounds.max.x-body.bounds.min.x);body.render.sprite.yOffset+=-(body.bounds.min.y-body.position.y)/(body.bounds.max.y-body.bounds.min.y);};/**\r\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\r\n     * Prefer to use the actual setter functions in performance critical situations.\r\n     * @method set\r\n     * @param {body} body\r\n     * @param {object} settings A map of properties and values to set on the body.\r\n     */Body.set=function(body,settings){var property,value;if(typeof settings==='string'){property=settings;settings={};settings[property]=value;}for(property in settings){if(!settings.hasOwnProperty(property))continue;value=settings[property];switch(property){case'isStatic':Body.setStatic(body,value);break;case'isSleeping':Sleeping.set(body,value);break;case'mass':Body.setMass(body,value);break;case'density':Body.setDensity(body,value);break;case'inertia':Body.setInertia(body,value);break;case'vertices':Body.setVertices(body,value);break;case'position':Body.setPosition(body,value);break;case'angle':Body.setAngle(body,value);break;case'velocity':Body.setVelocity(body,value);break;case'angularVelocity':Body.setAngularVelocity(body,value);break;case'parts':Body.setParts(body,value);break;default:body[property]=value;}}};/**\r\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\r\n     * @method setStatic\r\n     * @param {body} body\r\n     * @param {bool} isStatic\r\n     */Body.setStatic=function(body,isStatic){for(var i=0;i<body.parts.length;i++){var part=body.parts[i];part.isStatic=isStatic;if(isStatic){part._original={restitution:part.restitution,friction:part.friction,mass:part.mass,inertia:part.inertia,density:part.density,inverseMass:part.inverseMass,inverseInertia:part.inverseInertia};part.restitution=0;part.friction=1;part.mass=part.inertia=part.density=Infinity;part.inverseMass=part.inverseInertia=0;part.positionPrev.x=part.position.x;part.positionPrev.y=part.position.y;part.anglePrev=part.angle;part.angularVelocity=0;part.speed=0;part.angularSpeed=0;part.motion=0;}else if(part._original){part.restitution=part._original.restitution;part.friction=part._original.friction;part.mass=part._original.mass;part.inertia=part._original.inertia;part.density=part._original.density;part.inverseMass=part._original.inverseMass;part.inverseInertia=part._original.inverseInertia;part._original=null;}}};/**\r\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\r\n     * @method setMass\r\n     * @param {body} body\r\n     * @param {number} mass\r\n     */Body.setMass=function(body,mass){var moment=body.inertia/(body.mass/6);body.inertia=moment*(mass/6);body.inverseInertia=1/body.inertia;body.mass=mass;body.inverseMass=1/body.mass;body.density=body.mass/body.area;};/**\r\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\r\n     * @method setDensity\r\n     * @param {body} body\r\n     * @param {number} density\r\n     */Body.setDensity=function(body,density){Body.setMass(body,density*body.area);body.density=density;};/**\r\n     * Sets the moment of inertia (i.e. second moment of area) of the body of the body. \r\n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\r\n     * @method setInertia\r\n     * @param {body} body\r\n     * @param {number} inertia\r\n     */Body.setInertia=function(body,inertia){body.inertia=inertia;body.inverseInertia=1/body.inertia;};/**\r\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\r\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\r\n     * They are then automatically translated to world space based on `body.position`.\r\n     *\r\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\r\n     * Vertices must form a convex hull, concave hulls are not supported.\r\n     *\r\n     * @method setVertices\r\n     * @param {body} body\r\n     * @param {vector[]} vertices\r\n     */Body.setVertices=function(body,vertices){// change vertices\nif(vertices[0].body===body){body.vertices=vertices;}else{body.vertices=Vertices.create(vertices,body);}// update properties\nbody.axes=Axes.fromVertices(body.vertices);body.area=Vertices.area(body.vertices);Body.setMass(body,body.density*body.area);// orient vertices around the centre of mass at origin (0, 0)\nvar centre=Vertices.centre(body.vertices);Vertices.translate(body.vertices,centre,-1);// update inertia while vertices are at origin (0, 0)\nBody.setInertia(body,Body._inertiaScale*Vertices.inertia(body.vertices,body.mass));// update geometry\nVertices.translate(body.vertices,body.position);Bounds.update(body.bounds,body.vertices,body.velocity);};/**\r\n     * Sets the parts of the `body` and updates mass, inertia and centroid.\r\n     * Each part will have its parent set to `body`.\r\n     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\r\n     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\r\n     * @method setParts\r\n     * @param {body} body\r\n     * @param [body] parts\r\n     * @param {bool} [autoHull=true]\r\n     */Body.setParts=function(body,parts,autoHull){var i;// add all the parts, ensuring that the first part is always the parent body\nparts=parts.slice(0);body.parts.length=0;body.parts.push(body);body.parent=body;for(i=0;i<parts.length;i++){var part=parts[i];if(part!==body){part.parent=body;body.parts.push(part);}}if(body.parts.length===1)return;autoHull=typeof autoHull!=='undefined'?autoHull:true;// find the convex hull of all parts to set on the parent body\nif(autoHull){var vertices=[];for(i=0;i<parts.length;i++){vertices=vertices.concat(parts[i].vertices);}Vertices.clockwiseSort(vertices);var hull=Vertices.hull(vertices),hullCentre=Vertices.centre(hull);Body.setVertices(body,hull);Vertices.translate(body.vertices,hullCentre);}// sum the properties of all compound parts of the parent body\nvar total=_totalProperties(body);body.area=total.area;body.parent=body;body.position.x=total.centre.x;body.position.y=total.centre.y;body.positionPrev.x=total.centre.x;body.positionPrev.y=total.centre.y;Body.setMass(body,total.mass);Body.setInertia(body,total.inertia);Body.setPosition(body,total.centre);};/**\r\n     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.\r\n     * @method setPosition\r\n     * @param {body} body\r\n     * @param {vector} position\r\n     */Body.setPosition=function(body,position){var delta=Vector.sub(position,body.position);body.positionPrev.x+=delta.x;body.positionPrev.y+=delta.y;for(var i=0;i<body.parts.length;i++){var part=body.parts[i];part.position.x+=delta.x;part.position.y+=delta.y;Vertices.translate(part.vertices,delta);Bounds.update(part.bounds,part.vertices,body.velocity);}};/**\r\n     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.\r\n     * @method setAngle\r\n     * @param {body} body\r\n     * @param {number} angle\r\n     */Body.setAngle=function(body,angle){var delta=angle-body.angle;body.anglePrev+=delta;for(var i=0;i<body.parts.length;i++){var part=body.parts[i];part.angle+=delta;Vertices.rotate(part.vertices,delta,body.position);Axes.rotate(part.axes,delta);Bounds.update(part.bounds,part.vertices,body.velocity);if(i>0){Vector.rotateAbout(part.position,delta,body.position,part.position);}}};/**\r\n     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n     * @method setVelocity\r\n     * @param {body} body\r\n     * @param {vector} velocity\r\n     */Body.setVelocity=function(body,velocity){body.positionPrev.x=body.position.x-velocity.x;body.positionPrev.y=body.position.y-velocity.y;body.velocity.x=velocity.x;body.velocity.y=velocity.y;body.speed=Vector.magnitude(body.velocity);};/**\r\n     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n     * @method setAngularVelocity\r\n     * @param {body} body\r\n     * @param {number} velocity\r\n     */Body.setAngularVelocity=function(body,velocity){body.anglePrev=body.angle-velocity;body.angularVelocity=velocity;body.angularSpeed=Math.abs(body.angularVelocity);};/**\r\n     * Moves a body by a given vector relative to its current position, without imparting any velocity.\r\n     * @method translate\r\n     * @param {body} body\r\n     * @param {vector} translation\r\n     */Body.translate=function(body,translation){Body.setPosition(body,Vector.add(body.position,translation));};/**\r\n     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.\r\n     * @method rotate\r\n     * @param {body} body\r\n     * @param {number} rotation\r\n     * @param {vector} [point]\r\n     */Body.rotate=function(body,rotation,point){if(!point){Body.setAngle(body,body.angle+rotation);}else{var cos=Math.cos(rotation),sin=Math.sin(rotation),dx=body.position.x-point.x,dy=body.position.y-point.y;Body.setPosition(body,{x:point.x+(dx*cos-dy*sin),y:point.y+(dx*sin+dy*cos)});Body.setAngle(body,body.angle+rotation);}};/**\r\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\r\n     * @method scale\r\n     * @param {body} body\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} [point]\r\n     */Body.scale=function(body,scaleX,scaleY,point){point=point||body.position;for(var i=0;i<body.parts.length;i++){var part=body.parts[i];// scale position\npart.position.x=point.x+(part.position.x-point.x)*scaleX;part.position.y=point.y+(part.position.y-point.y)*scaleY;// scale vertices\nVertices.scale(part.vertices,scaleX,scaleY,point);// update properties\npart.axes=Axes.fromVertices(part.vertices);if(!body.isStatic){part.area=Vertices.area(part.vertices);Body.setMass(part,body.density*part.area);// update inertia (requires vertices to be at origin)\nVertices.translate(part.vertices,{x:-part.position.x,y:-part.position.y});Body.setInertia(part,Vertices.inertia(part.vertices,part.mass));Vertices.translate(part.vertices,{x:part.position.x,y:part.position.y});}// update bounds\nBounds.update(part.bounds,part.vertices,body.velocity);}// handle circles\nif(body.circleRadius){if(scaleX===scaleY){body.circleRadius*=scaleX;}else{// body is no longer a circle\nbody.circleRadius=null;}}if(!body.isStatic){var total=_totalProperties(body);body.area=total.area;Body.setMass(body,total.mass);Body.setInertia(body,total.inertia);}};/**\r\n     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.\r\n     * @method update\r\n     * @param {body} body\r\n     * @param {number} deltaTime\r\n     * @param {number} timeScale\r\n     * @param {number} correction\r\n     */Body.update=function(body,deltaTime,timeScale,correction){var deltaTimeSquared=Math.pow(deltaTime*timeScale*body.timeScale,2);// from the previous step\nvar frictionAir=1-body.frictionAir*timeScale*body.timeScale,velocityPrevX=body.position.x-body.positionPrev.x,velocityPrevY=body.position.y-body.positionPrev.y;// update velocity with Verlet integration\nbody.velocity.x=velocityPrevX*frictionAir*correction+body.force.x/body.mass*deltaTimeSquared;body.velocity.y=velocityPrevY*frictionAir*correction+body.force.y/body.mass*deltaTimeSquared;body.positionPrev.x=body.position.x;body.positionPrev.y=body.position.y;body.position.x+=body.velocity.x;body.position.y+=body.velocity.y;// update angular velocity with Verlet integration\nbody.angularVelocity=(body.angle-body.anglePrev)*frictionAir*correction+body.torque/body.inertia*deltaTimeSquared;body.anglePrev=body.angle;body.angle+=body.angularVelocity;// track speed and acceleration\nbody.speed=Vector.magnitude(body.velocity);body.angularSpeed=Math.abs(body.angularVelocity);// transform the body geometry\nfor(var i=0;i<body.parts.length;i++){var part=body.parts[i];Vertices.translate(part.vertices,body.velocity);if(i>0){part.position.x+=body.velocity.x;part.position.y+=body.velocity.y;}if(body.angularVelocity!==0){Vertices.rotate(part.vertices,body.angularVelocity,body.position);Axes.rotate(part.axes,body.angularVelocity);if(i>0){Vector.rotateAbout(part.position,body.angularVelocity,body.position,part.position);}}Bounds.update(part.bounds,part.vertices,body.velocity);}};/**\r\n     * Applies a force to a body from a given world-space position, including resulting torque.\r\n     * @method applyForce\r\n     * @param {body} body\r\n     * @param {vector} position\r\n     * @param {vector} force\r\n     */Body.applyForce=function(body,position,force){body.force.x+=force.x;body.force.y+=force.y;var offset={x:position.x-body.position.x,y:position.y-body.position.y};body.torque+=offset.x*force.y-offset.y*force.x;};/**\r\n     * Returns the sums of the properties of all compound parts of the parent body.\r\n     * @method _totalProperties\r\n     * @private\r\n     * @param {body} body\r\n     * @return {}\r\n     */var _totalProperties=function _totalProperties(body){// from equations at:\n// https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n// http://output.to/sideway/default.asp?qno=121100087\nvar properties={mass:0,area:0,inertia:0,centre:{x:0,y:0}};// sum the properties of all compound parts of the parent body\nfor(var i=body.parts.length===1?0:1;i<body.parts.length;i++){var part=body.parts[i],mass=part.mass!==Infinity?part.mass:1;properties.mass+=part.mass;properties.area+=part.area;properties.inertia+=part.inertia;properties.centre=Vector.add(properties.centre,Vector.mult(part.position,mass));}properties.centre=Vector.div(properties.centre,properties.mass);return properties;};/*\r\n    *\r\n    *  Events Documentation\r\n    *\r\n    *//**\r\n    * Fired when a body starts sleeping (where `this` is the body).\r\n    *\r\n    * @event sleepStart\r\n    * @this {body} The body that has started sleeping\r\n    * @param {} event An event object\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//**\r\n    * Fired when a body ends sleeping (where `this` is the body).\r\n    *\r\n    * @event sleepEnd\r\n    * @this {body} The body that has ended sleeping\r\n    * @param {} event An event object\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    *//**\r\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\r\n     *\r\n     * @property id\r\n     * @type number\r\n     *//**\r\n     * A `String` denoting the type of object.\r\n     *\r\n     * @property type\r\n     * @type string\r\n     * @default \"body\"\r\n     * @readOnly\r\n     *//**\r\n     * An arbitrary `String` name to help the user identify and manage bodies.\r\n     *\r\n     * @property label\r\n     * @type string\r\n     * @default \"Body\"\r\n     *//**\r\n     * An array of bodies that make up this body. \r\n     * The first body in the array must always be a self reference to the current body instance.\r\n     * All bodies in the `parts` array together form a single rigid compound body.\r\n     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\r\n     * Parts themselves should never be added to a `World`, only the parent body should be.\r\n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\r\n     *\r\n     * @property parts\r\n     * @type body[]\r\n     *//**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     *//**\r\n     * A self reference if the body is _not_ a part of another body.\r\n     * Otherwise this is a reference to the body that this is a part of.\r\n     * See `body.parts`.\r\n     *\r\n     * @property parent\r\n     * @type body\r\n     *//**\r\n     * A `Number` specifying the angle of the body, in radians.\r\n     *\r\n     * @property angle\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * An array of `Vector` objects that specify the convex hull of the rigid body.\r\n     * These should be provided about the origin `(0, 0)`. E.g.\r\n     *\r\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n     *\r\n     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).\r\n     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. \r\n     *\r\n     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).\r\n     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.\r\n     *\r\n     * @property vertices\r\n     * @type vector[]\r\n     *//**\r\n     * A `Vector` that specifies the current world-space position of the body.\r\n     *\r\n     * @property position\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     *//**\r\n     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.\r\n     *\r\n     * @property force\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     *//**\r\n     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.\r\n     *\r\n     * @property torque\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).\r\n     *\r\n     * @readOnly\r\n     * @property speed\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).\r\n     *\r\n     * @readOnly\r\n     * @property angularSpeed\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. \r\n     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).\r\n     *\r\n     * @readOnly\r\n     * @property velocity\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     *//**\r\n     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. \r\n     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).\r\n     *\r\n     * @readOnly\r\n     * @property angularVelocity\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\r\n     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.\r\n     *\r\n     * @property isStatic\r\n     * @type boolean\r\n     * @default false\r\n     *//**\r\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\r\n     *\r\n     * @property isSensor\r\n     * @type boolean\r\n     * @default false\r\n     *//**\r\n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\r\n     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.\r\n     *\r\n     * @property isSleeping\r\n     * @type boolean\r\n     * @default false\r\n     *//**\r\n     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.\r\n     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.\r\n     *\r\n     * @readOnly\r\n     * @property motion\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\r\n     *\r\n     * @property sleepThreshold\r\n     * @type number\r\n     * @default 60\r\n     *//**\r\n     * A `Number` that defines the density of the body, that is its mass per unit area.\r\n     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.\r\n     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).\r\n     *\r\n     * @property density\r\n     * @type number\r\n     * @default 0.001\r\n     *//**\r\n     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.\r\n     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).\r\n     *\r\n     * @property mass\r\n     * @type number\r\n     *//**\r\n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\r\n     * If you modify this value, you must also modify the `body.mass` property.\r\n     *\r\n     * @property inverseMass\r\n     * @type number\r\n     *//**\r\n     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.\r\n     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.\r\n     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).\r\n     *\r\n     * @property inertia\r\n     * @type number\r\n     *//**\r\n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\r\n     * If you modify this value, you must also modify the `body.inertia` property.\r\n     *\r\n     * @property inverseInertia\r\n     * @type number\r\n     *//**\r\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\r\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \r\n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\r\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\r\n     *\r\n     *     Math.max(bodyA.restitution, bodyB.restitution)\r\n     *\r\n     * @property restitution\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\r\n     * A value of `0` means that the body may slide indefinitely.\r\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\r\n     *\r\n     * The effects of the value may be non-linear. \r\n     * High values may be unstable depending on the body.\r\n     * The engine uses a Coulomb friction model including static and kinetic friction.\r\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\r\n     *\r\n     *     Math.min(bodyA.friction, bodyB.friction)\r\n     *\r\n     * @property friction\r\n     * @type number\r\n     * @default 0.1\r\n     *//**\r\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \r\n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\r\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\r\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\r\n     *\r\n     * @property frictionStatic\r\n     * @type number\r\n     * @default 0.5\r\n     *//**\r\n     * A `Number` that defines the air friction of the body (air resistance). \r\n     * A value of `0` means the body will never slow as it moves through space.\r\n     * The higher the value, the faster a body slows when moving through space.\r\n     * The effects of the value are non-linear. \r\n     *\r\n     * @property frictionAir\r\n     * @type number\r\n     * @default 0.01\r\n     *//**\r\n     * An `Object` that specifies the collision filtering properties of this body.\r\n     *\r\n     * Collisions between two bodies will obey the following rules:\r\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\r\n     *   they will always collide if the value is positive, and they will never collide\r\n     *   if the value is negative.\r\n     * - If the two bodies have different values of `collisionFilter.group` or if one\r\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\r\n     *\r\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\r\n     * value is used as a bit field and the category should have only one bit set, meaning that\r\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\r\n     * different collision categories available.\r\n     *\r\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\r\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\r\n     *\r\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\r\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\r\n     * are both true.\r\n     *\r\n     * @property collisionFilter\r\n     * @type object\r\n     *//**\r\n     * An Integer `Number`, that specifies the collision group this body belongs to.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.group\r\n     * @type object\r\n     * @default 0\r\n     *//**\r\n     * A bit field that specifies the collision category this body belongs to.\r\n     * The category value should have only one bit set, for example `0x0001`.\r\n     * This means there are up to 32 unique collision categories available.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.category\r\n     * @type object\r\n     * @default 1\r\n     *//**\r\n     * A bit mask that specifies the collision categories this body may collide with.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.mask\r\n     * @type object\r\n     * @default -1\r\n     *//**\r\n     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.\r\n     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.\r\n     * The default should generally suffice, although very large bodies may require larger values for stable stacking.\r\n     *\r\n     * @property slop\r\n     * @type number\r\n     * @default 0.05\r\n     *//**\r\n     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\r\n     *\r\n     * @property timeScale\r\n     * @type number\r\n     * @default 1\r\n     *//**\r\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\r\n     *\r\n     * @property render\r\n     * @type object\r\n     *//**\r\n     * A flag that indicates if the body should be rendered.\r\n     *\r\n     * @property render.visible\r\n     * @type boolean\r\n     * @default true\r\n     *//**\r\n     * Sets the opacity to use when rendering.\r\n     *\r\n     * @property render.opacity\r\n     * @type number\r\n     * @default 1\r\n    *//**\r\n     * An `Object` that defines the sprite properties to use when rendering, if any.\r\n     *\r\n     * @property render.sprite\r\n     * @type object\r\n     *//**\r\n     * An `String` that defines the path to the image to use as the sprite texture, if any.\r\n     *\r\n     * @property render.sprite.texture\r\n     * @type string\r\n     *//**\r\n     * A `Number` that defines the scaling in the x-axis for the sprite, if any.\r\n     *\r\n     * @property render.sprite.xScale\r\n     * @type number\r\n     * @default 1\r\n     *//**\r\n     * A `Number` that defines the scaling in the y-axis for the sprite, if any.\r\n     *\r\n     * @property render.sprite.yScale\r\n     * @type number\r\n     * @default 1\r\n     *//**\r\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\r\n      *\r\n      * @property render.sprite.xOffset\r\n      * @type number\r\n      * @default 0\r\n      *//**\r\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\r\n      *\r\n      * @property render.sprite.yOffset\r\n      * @type number\r\n      * @default 0\r\n      *//**\r\n     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\r\n     * A value of `0` means no outline will be rendered.\r\n     *\r\n     * @property render.lineWidth\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\r\n     * It is the same as when using a canvas, so it accepts CSS style property values.\r\n     *\r\n     * @property render.fillStyle\r\n     * @type string\r\n     * @default a random colour\r\n     *//**\r\n     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\r\n     * It is the same as when using a canvas, so it accepts CSS style property values.\r\n     *\r\n     * @property render.strokeStyle\r\n     * @type string\r\n     * @default a random colour\r\n     *//**\r\n     * An array of unique axis vectors (edge normals) used for collision detection.\r\n     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.\r\n     * They are constantly updated by `Body.update` during the simulation.\r\n     *\r\n     * @property axes\r\n     * @type vector[]\r\n     *//**\r\n     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.\r\n     *\r\n     * @property area\r\n     * @type string\r\n     * @default \r\n     *//**\r\n     * A `Bounds` object that defines the AABB region for the body.\r\n     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.\r\n     *\r\n     * @property bounds\r\n     * @type bounds\r\n     */})();/***/},/* 52 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ImageFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n * @param {object} config - [description]\r\n */var ImageFile=new Class({Extends:File,initialize:// this.load.image('pic', 'assets/pics/taikodrummaster.jpg');\n// this.load.image({ key: 'pic', file: 'assets/pics/taikodrummaster.jpg' });\n// this.load.image({\n//     key: 'bunny',\n//     file: 'assets/sprites/bunny.png',\n//     xhr: {\n//         user: 'root',\n//         password: 'th3G1bs0n',\n//         timeout: 30,\n//         header: 'Content-Type',\n//         headerValue: 'text/xml'\n//     }\n// });\n// this.load.image({ key: 'bunny' });\n// this.load.image({ key: 'bunny', extension: 'jpg' });\nfunction ImageFile(key,url,path,xhrSettings,config){var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'image',extension:GetFastValue(key,'extension','png'),responseType:'blob',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings),config:GetFastValue(key,'config',config)};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=new Image();this.data.crossOrigin=this.crossOrigin;var _this=this;this.data.onload=function(){File.revokeObjectURL(_this.data);_this.onComplete();callback(_this);};this.data.onerror=function(){File.revokeObjectURL(_this.data);_this.state=CONST.FILE_ERRORED;callback(_this);};File.createObjectURL(this.data,this.xhrLoader.response,'image/png');}});/**\r\n * Adds an Image file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Image File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#image\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('image',function(key,url,xhrSettings){var urls;var fileA;var fileB;if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nurls=GetFastValue(key[i],'file',url);if(Array.isArray(urls)&&urls.length===2){fileA=this.addFile(new ImageFile(key[i],urls[0],this.path,xhrSettings));fileB=this.addFile(new ImageFile(key[i],urls[1],this.path,xhrSettings));fileA.setLinkFile(fileB,'dataimage');}else{this.addFile(new ImageFile(key[i],url,this.path,xhrSettings));}}}else{urls=GetFastValue(key,'file',url);if(Array.isArray(urls)&&urls.length===2){fileA=this.addFile(new ImageFile(key,urls[0],this.path,xhrSettings));fileB=this.addFile(new ImageFile(key,urls[1],this.path,xhrSettings));fileA.setLinkFile(fileB,'dataimage');}else{this.addFile(new ImageFile(key,url,this.path,xhrSettings));}}//  For method chaining\nreturn this;});module.exports=ImageFile;/***/},/* 53 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class JSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var JSONFile=new Class({Extends:File,initialize://  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\nfunction JSONFile(key,url,path,xhrSettings){var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'json',extension:GetFastValue(key,'extension','json'),responseType:'text',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings)};File.call(this,fileConfig);if(_typeof(fileConfig.url)==='object'){//  Object provided instead of a URL, so no need to actually load it (populate data with value)\nthis.data=fileConfig.url;this.state=CONST.FILE_POPULATED;}},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=JSON.parse(this.xhrLoader.responseText);this.onComplete();callback(this);}});/**\r\n * Adds a JSON file to the current load queue.\r\n *\r\n * Note: This method will only be available if the JSON File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#json\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('json',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new JSONFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new JSONFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=JSONFile;/***/},/* 54 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Contains=__webpack_require__(56);var GetPoint=__webpack_require__(234);var GetPoints=__webpack_require__(233);var Line=__webpack_require__(108);var Random=__webpack_require__(168);/**\r\n * @classdesc\r\n * A triangle is a plane created by connecting three points.\r\n * The first two arguments specify the first point, the middle two arguments\r\n * specify the second point, and the last two arguments specify the third point.\r\n *\r\n * @class Triangle\r\n * @memberOf Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x1=0] - [description]\r\n * @param {number} [y1=0] - [description]\r\n * @param {number} [x2=0] - [description]\r\n * @param {number} [y2=0] - [description]\r\n * @param {number} [x3=0] - [description]\r\n * @param {number} [y3=0] - [description]\r\n */var Triangle=new Class({initialize:function Triangle(x1,y1,x2,y2,x3,y3){if(x1===undefined){x1=0;}if(y1===undefined){y1=0;}if(x2===undefined){x2=0;}if(y2===undefined){y2=0;}if(x3===undefined){x3=0;}if(y3===undefined){y3=0;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Triangle#x1\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x1=x1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Triangle#y1\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y1=y1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Triangle#x2\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x2=x2;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Triangle#y2\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y2=y2;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Triangle#x3\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x3=x3;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Triangle#y3\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y3=y3;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Triangle#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */contains:function contains(x,y){return Contains(this,x,y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Triangle#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [output,$return]\r\n     *\r\n     * @param {float} position - [description]\r\n     * @param {(Phaser.Geom.Point|object)} [output] - [description]\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} [description]\r\n     */getPoint:function getPoint(position,output){return GetPoint(this,position,output);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Triangle#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\r\n     *\r\n     * @param {integer} quantity - [description]\r\n     * @param {number} [stepRate] - [description]\r\n     * @param {(array|Phaser.Geom.Point[])} [output] - [description]\r\n     *\r\n     * @return {(array|Phaser.Geom.Point[])} [description]\r\n     */getPoints:function getPoints(quantity,stepRate,output){return GetPoints(this,quantity,stepRate,output);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Triangle#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [point,$return]\r\n     *\r\n     * @param {Phaser.Geom.Point} [point] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Point} [description]\r\n     */getRandomPoint:function getRandomPoint(point){return Random(this,point);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Triangle#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x1=0] - [description]\r\n     * @param {number} [y1=0] - [description]\r\n     * @param {number} [x2=0] - [description]\r\n     * @param {number} [y2=0] - [description]\r\n     * @param {number} [x3=0] - [description]\r\n     * @param {number} [y3=0] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Triangle} This Triangle object.\r\n     */setTo:function setTo(x1,y1,x2,y2,x3,y3){if(x1===undefined){x1=0;}if(y1===undefined){y1=0;}if(x2===undefined){x2=0;}if(y2===undefined){y2=0;}if(x3===undefined){x3=0;}if(y3===undefined){y3=0;}this.x1=x1;this.y1=y1;this.x2=x2;this.y2=y2;this.x3=x3;this.y3=y3;return this;},/**\r\n     * Returns a Line object that corresponds to Line A of this Triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#getLineA\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to line A of this Triangle.\r\n     */getLineA:function getLineA(line){if(line===undefined){line=new Line();}line.setTo(this.x1,this.y1,this.x2,this.y2);return line;},/**\r\n     * Returns a Line object that corresponds to Line B of this Triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#getLineB\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to line B of this Triangle.\r\n     */getLineB:function getLineB(line){if(line===undefined){line=new Line();}line.setTo(this.x2,this.y2,this.x3,this.y3);return line;},/**\r\n     * Returns a Line object that corresponds to Line C of this Triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#getLineC\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to line C of this Triangle.\r\n     */getLineC:function getLineC(line){if(line===undefined){line=new Line();}line.setTo(this.x3,this.y3,this.x1,this.y1);return line;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Triangle#left\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */left:{get:function get(){return Math.min(this.x1,this.x2,this.x3);},set:function set(value){var diff=0;if(this.x1<=this.x2&&this.x1<=this.x3){diff=this.x1-value;}else if(this.x2<=this.x1&&this.x2<=this.x3){diff=this.x2-value;}else{diff=this.x3-value;}this.x1-=diff;this.x2-=diff;this.x3-=diff;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Triangle#right\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */right:{get:function get(){return Math.max(this.x1,this.x2,this.x3);},set:function set(value){var diff=0;if(this.x1>=this.x2&&this.x1>=this.x3){diff=this.x1-value;}else if(this.x2>=this.x1&&this.x2>=this.x3){diff=this.x2-value;}else{diff=this.x3-value;}this.x1-=diff;this.x2-=diff;this.x3-=diff;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Triangle#top\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */top:{get:function get(){return Math.min(this.y1,this.y2,this.y3);},set:function set(value){var diff=0;if(this.y1<=this.y2&&this.y1<=this.y3){diff=this.y1-value;}else if(this.y2<=this.y1&&this.y2<=this.y3){diff=this.y2-value;}else{diff=this.y3-value;}this.y1-=diff;this.y2-=diff;this.y3-=diff;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Geom.Triangle#bottom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottom:{get:function get(){return Math.max(this.y1,this.y2,this.y3);},set:function set(value){var diff=0;if(this.y1>=this.y2&&this.y1>=this.y3){diff=this.y1-value;}else if(this.y2>=this.y1&&this.y2>=this.y3){diff=this.y2-value;}else{diff=this.y3-value;}this.y1-=diff;this.y2-=diff;this.y3-=diff;}}});module.exports=Triangle;/***/},/* 55 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Angle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var Angle=function Angle(line){return Math.atan2(line.y2-line.y1,line.x2-line.x1);};module.exports=Angle;/***/},/* 56 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  http://www.blackpawn.com/texts/pointinpoly/\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Contains=function Contains(triangle,x,y){var v0x=triangle.x3-triangle.x1;var v0y=triangle.y3-triangle.y1;var v1x=triangle.x2-triangle.x1;var v1y=triangle.y2-triangle.y1;var v2x=x-triangle.x1;var v2y=y-triangle.y1;var dot00=v0x*v0x+v0y*v0y;var dot01=v0x*v1x+v0y*v1y;var dot02=v0x*v2x+v0y*v2y;var dot11=v1x*v1x+v1y*v1y;var dot12=v1x*v2x+v1y*v2y;// Compute barycentric coordinates\nvar b=dot00*dot11-dot01*dot01;var inv=b===0?0:1/b;var u=(dot11*dot02-dot01*dot12)*inv;var v=(dot00*dot12-dot01*dot02)*inv;return u>=0&&v>=0&&u+v<1;};module.exports=Contains;/***/},/* 57 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Shallow Object Clone. Will not clone nested objects.\r\n *\r\n * @function Phaser.Utils.Object.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj - the object from which to clone\r\n *\r\n * @return {object} a new object with the same properties as the input obj\r\n */var Clone=function Clone(obj){var clone={};for(var key in obj){if(Array.isArray(obj[key])){clone[key]=obj[key].slice(0);}else{clone[key]=obj[key];}}return clone;};module.exports=Clone;/***/},/* 58 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var FromPoints=__webpack_require__(157);var Rectangle=__webpack_require__(10);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * A Base Curve class, which all other curve types extend.\r\n *\r\n * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n *\r\n * @class Curve\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} type - [description]\r\n */var Curve=new Class({initialize:function Curve(type){/**\r\n         * String based identifier for the type of curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.type=type;/**\r\n         * The default number of divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#defaultDivisions\r\n         * @type {integer}\r\n         * @default 5\r\n         * @since 3.0.0\r\n         */this.defaultDivisions=5;/**\r\n         * The quantity of arc length divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#arcLengthDivisions\r\n         * @type {integer}\r\n         * @default 100\r\n         * @since 3.0.0\r\n         */this.arcLengthDivisions=100;/**\r\n         * An array of cached arc length values.\r\n         *\r\n         * @name Phaser.Curves.Curve#cacheArcLengths\r\n         * @type {number[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.cacheArcLengths=[];/**\r\n         * Does the data of this curve need updating?\r\n         *\r\n         * @name Phaser.Curves.Curve#needsUpdate\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.needsUpdate=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Curve#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.active=true;/**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2A\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tmpVec2A=new Vector2();/**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2B\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tmpVec2B=new Vector2();},/**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.Curve#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [out,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n     * @param {integer} [pointsTotal=32] - The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n     */draw:function draw(graphics,pointsTotal){if(pointsTotal===undefined){pointsTotal=32;}//  So you can chain graphics calls\nreturn graphics.strokePoints(this.getPoints(pointsTotal));},/**\r\n     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n     *\r\n     * You can control the accuracy of the bounds. The value given is used to work out how many points\r\n     * to plot across the curve. Higher values are more accurate at the cost of calculation speed.\r\n     *\r\n     * @method Phaser.Curves.Curve#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in. If falsey a new object will be created.\r\n     * @param {integer} [accuracy=16] - The accuracy of the bounds calculations.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n     */getBounds:function getBounds(out,accuracy){if(!out){out=new Rectangle();}if(accuracy===undefined){accuracy=16;}var len=this.getLength();if(accuracy>len){accuracy=len/2;}//  The length of the curve in pixels\n//  So we'll have 1 spaced point per 'accuracy' pixels\nvar spaced=Math.max(1,Math.round(len/accuracy));return FromPoints(this.getSpacedPoints(spaced),out);},/**\r\n     * Returns an array of points, spaced out X distance pixels apart.\r\n     * The smaller the distance, the larger the array will be.\r\n     *\r\n     * @method Phaser.Curves.Curve#getDistancePoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} distance - The distance, in pixels, between each point along the curve.\r\n     *\r\n     * @return {Phaser.Geom.Point[]} An Array of Point objects.\r\n     */getDistancePoints:function getDistancePoints(distance){var len=this.getLength();var spaced=Math.max(1,len/distance);return this.getSpacedPoints(spaced);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getEndPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} out - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getEndPoint:function getEndPoint(out){if(out===undefined){out=new Vector2();}return this.getPointAt(1,out);},// Get total curve arc length\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getLength:function getLength(){var lengths=this.getLengths();return lengths[lengths.length-1];},// Get list of cumulative segment lengths\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number[]} [description]\r\n     */getLengths:function getLengths(divisions){if(divisions===undefined){divisions=this.arcLengthDivisions;}if(this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current;var last=this.getPoint(0,this._tmpVec2A);var sum=0;cache.push(0);for(var p=1;p<=divisions;p++){current=this.getPoint(p/divisions,this._tmpVec2B);sum+=current.distance(last);cache.push(sum);last.copy(current);}this.cacheArcLengths=cache;return cache;// { sums: cache, sum:sum }; Sum is in the last element.\n},// Get point at relative position in curve according to arc length\n// - u [0 .. 1]\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} u - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getPointAt:function getPointAt(u,out){var t=this.getUtoTmapping(u);return this.getPoint(t,out);},// Get sequence of points using getPoint( t )\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */getPoints:function getPoints(divisions){if(divisions===undefined){divisions=this.defaultDivisions;}var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getRandomPoint:function getRandomPoint(out){if(out===undefined){out=new Vector2();}return this.getPoint(Math.random(),out);},// Get sequence of points using getPointAt( u )\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getSpacedPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */getSpacedPoints:function getSpacedPoints(divisions){if(divisions===undefined){divisions=this.defaultDivisions;}var points=[];for(var d=0;d<=divisions;d++){var t=this.getUtoTmapping(d/divisions,null,divisions);points.push(this.getPoint(t));}return points;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getStartPoint:function getStartPoint(out){if(out===undefined){out=new Vector2();}return this.getPointAt(0,out);},// Returns a unit vector tangent at t\n// In case any sub curve does not implement its tangent derivation,\n// 2 points a small delta apart will be used to find its gradient\n// which seems to give a reasonable approximation\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangent\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getTangent:function getTangent(t,out){if(out===undefined){out=new Vector2();}var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger\nif(t1<0){t1=0;}if(t2>1){t2=1;}this.getPoint(t1,this._tmpVec2A);this.getPoint(t2,out);return out.subtract(this._tmpVec2A).normalize();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangentAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} u - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getTangentAt:function getTangentAt(u,out){var t=this.getUtoTmapping(u);return this.getTangent(t,out);},//  Given a distance in pixels, get a t to find p.\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTFromDistance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {float} [description]\r\n     */getTFromDistance:function getTFromDistance(distance,divisions){if(distance<=0){return 0;}return this.getUtoTmapping(0,distance,divisions);},// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getUtoTmapping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} u - [description]\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */getUtoTmapping:function getUtoTmapping(u,distance,divisions){var arcLengths=this.getLengths(divisions);var i=0;var il=arcLengths.length;var targetArcLength;// The targeted u distance value to get\nif(distance){//  Cannot overshoot the curve\ntargetArcLength=Math.min(distance,arcLengths[il-1]);}else{targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance\nvar low=0;var high=il-1;var comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\ncomparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;}}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points\nvar lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points\nvar segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t\nreturn(i+segmentFraction)/(il-1);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#updateArcLengths\r\n     * @since 3.0.0\r\n     */updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.getLengths();}});module.exports=Curve;/***/},/* 59 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Vector3\r\n * @memberOf Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - [description]\r\n * @param {number} [y] - [description]\r\n * @param {number} [z] - [description]\r\n */var Vector3=new Class({initialize:function Vector3(x,y,z){/**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         *//**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         *//**\r\n         * The z component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.x=x.x||0;this.y=x.y||0;this.z=x.z||0;}else{this.x=x||0;this.y=y||0;this.z=z||0;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#up\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */up:function up(){this.x=0;this.y=1;this.z=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} A new Vector3 object containing this Vectors values.\r\n     */clone:function clone(){return new Vector3(this.x,this.y,this.z);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#crossVectors\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} a - [description]\r\n     * @param {Phaser.Math.Vector3} b - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */crossVectors:function crossVectors(a,b){var ax=a.x;var ay=a.y;var az=a.z;var bx=b.x;var by=b.y;var bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector3 to compare against.\r\n     *\r\n     * @return {boolean} True if the two vectors strictly match, otherwise false.\r\n     */equals:function equals(v){return this.x===v.x&&this.y===v.y&&this.z===v.z;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */copy:function copy(src){this.x=src.x;this.y=src.y;this.z=src.z||0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - [description]\r\n     * @param {number} [y] - [description]\r\n     * @param {number} [z] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */set:function set(x,y,z){if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.x=x.x||0;this.y=x.y||0;this.z=x.z||0;}else{this.x=x||0;this.y=y||0;this.z=z||0;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */add:function add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z||0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */subtract:function subtract(v){this.x-=v.x;this.y-=v.y;this.z-=v.z||0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */multiply:function multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z||1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} scale - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */scale:function scale(_scale){if(isFinite(_scale)){this.x*=_scale;this.y*=_scale;this.z*=_scale;}else{this.x=0;this.y=0;this.z=0;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */divide:function divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z||1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */distance:function distance(v){var dx=v.x-this.x;var dy=v.y-this.y;var dz=v.z-this.z||0;return Math.sqrt(dx*dx+dy*dy+dz*dz);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */distanceSq:function distanceSq(v){var dx=v.x-this.x;var dy=v.y-this.y;var dz=v.z-this.z||0;return dx*dx+dy*dy+dz*dz;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */length:function length(){var x=this.x;var y=this.y;var z=this.z;return Math.sqrt(x*x+y*y+z*z);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */lengthSq:function lengthSq(){var x=this.x;var y=this.y;var z=this.z;return x*x+y*y+z*z;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */normalize:function normalize(){var x=this.x;var y=this.y;var z=this.z;var len=x*x+y*y+z*z;if(len>0){len=1/Math.sqrt(len);this.x=x*len;this.y=y*len;this.z=z*len;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */cross:function cross(v){var ax=this.x;var ay=this.y;var az=this.z;var bx=v.x;var by=v.y;var bz=v.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - [description]\r\n     * @param {number} [t=0] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */lerp:function lerp(v,t){if(t===undefined){t=0;}var ax=this.x;var ay=this.y;var az=this.z;this.x=ax+t*(v.x-ax);this.y=ay+t*(v.y-ay);this.z=az+t*(v.z-az);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */transformMat3:function transformMat3(mat){var x=this.x;var y=this.y;var z=this.z;var m=mat.val;this.x=x*m[0]+y*m[3]+z*m[6];this.y=x*m[1]+y*m[4]+z*m[7];this.z=x*m[2]+y*m[5]+z*m[8];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */transformMat4:function transformMat4(mat){var x=this.x;var y=this.y;var z=this.z;var m=mat.val;this.x=m[0]*x+m[4]*y+m[8]*z+m[12];this.y=m[1]*x+m[5]*y+m[9]*z+m[13];this.z=m[2]*x+m[6]*y+m[10]*z+m[14];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#transformCoordinates\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */transformCoordinates:function transformCoordinates(mat){var x=this.x;var y=this.y;var z=this.z;var m=mat.val;var tx=x*m[0]+y*m[4]+z*m[8]+m[12];var ty=x*m[1]+y*m[5]+z*m[9]+m[13];var tz=x*m[2]+y*m[6]+z*m[10]+m[14];var tw=x*m[3]+y*m[7]+z*m[11]+m[15];this.x=tx/tw;this.y=ty/tw;this.z=tz/tw;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#transformQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */transformQuat:function transformQuat(q){// benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\nvar x=this.x;var y=this.y;var z=this.z;var qx=q.x;var qy=q.y;var qz=q.z;var qw=q.w;// calculate quat * vec\nvar ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat\nthis.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;},/**\r\n     * Multiplies this Vector3 by the specified matrix, applying a W divide. This is useful for projection,\r\n     * e.g. unprojecting a 2D point into 3D space.\r\n     *\r\n     * @method Phaser.Math.Vector3#project\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */project:function project(mat){var x=this.x;var y=this.y;var z=this.z;var m=mat.val;var a00=m[0];var a01=m[1];var a02=m[2];var a03=m[3];var a10=m[4];var a11=m[5];var a12=m[6];var a13=m[7];var a20=m[8];var a21=m[9];var a22=m[10];var a23=m[11];var a30=m[12];var a31=m[13];var a32=m[14];var a33=m[15];var lw=1/(x*a03+y*a13+z*a23+a33);this.x=(x*a00+y*a10+z*a20+a30)*lw;this.y=(x*a01+y*a11+z*a21+a31)*lw;this.z=(x*a02+y*a12+z*a22+a32)*lw;return this;},/**\r\n     * Unproject this point from 2D space to 3D space.\r\n     * The point should have its x and y properties set to\r\n     * 2D screen space, and the z either at 0 (near plane)\r\n     * or 1 (far plane). The provided matrix is assumed to already\r\n     * be combined, i.e. projection * view * model.\r\n     *\r\n     * After this operation, this vector's (x, y, z) components will\r\n     * represent the unprojected 3D coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector3#unproject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} viewport - Screen x, y, width and height in pixels.\r\n     * @param {Phaser.Math.Matrix4} invProjectionView - Combined projection and view matrix.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */unproject:function unproject(viewport,invProjectionView){var viewX=viewport.x;var viewY=viewport.y;var viewWidth=viewport.z;var viewHeight=viewport.w;var x=this.x-viewX;var y=viewHeight-this.y-1-viewY;var z=this.z;this.x=2*x/viewWidth-1;this.y=2*y/viewHeight-1;this.z=2*z-1;return this.project(invProjectionView);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector3#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3 object.\r\n     */reset:function reset(){this.x=0;this.y=0;this.z=0;return this;}});/*\r\nVector3.Zero = function ()\r\n{\r\n    return new Vector3(0, 0, 0);\r\n};\r\n\r\nVector3.Up = function ()\r\n{\r\n    return new Vector3(0, 1.0, 0);\r\n};\r\n\r\nVector3.Copy = function (source)\r\n{\r\n    return new Vector3(source.x, source.y, source.z);\r\n};\r\n\r\nVector3.TransformCoordinates = function (vector, transformation)\r\n{\r\n    var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + (vector.z * transformation.m[8]) + transformation.m[12];\r\n    var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + (vector.z * transformation.m[9]) + transformation.m[13];\r\n    var z = (vector.x * transformation.m[2]) + (vector.y * transformation.m[6]) + (vector.z * transformation.m[10]) + transformation.m[14];\r\n    var w = (vector.x * transformation.m[3]) + (vector.y * transformation.m[7]) + (vector.z * transformation.m[11]) + transformation.m[15];\r\n\r\n    return new Vector3(x / w, y / w, z / w);\r\n};\r\n\r\nVector3.TransformNormal = function (vector, transformation)\r\n{\r\n    var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + (vector.z * transformation.m[8]);\r\n    var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + (vector.z * transformation.m[9]);\r\n    var z = (vector.x * transformation.m[2]) + (vector.y * transformation.m[6]) + (vector.z * transformation.m[10]);\r\n\r\n    return new Vector3(x, y, z);\r\n};\r\n\r\nVector3.Dot = function (left, right)\r\n{\r\n    return (left.x * right.x + left.y * right.y + left.z * right.z);\r\n};\r\n\r\nVector3.Cross = function (left, right)\r\n{\r\n    var x = left.y * right.z - left.z * right.y;\r\n    var y = left.z * right.x - left.x * right.z;\r\n    var z = left.x * right.y - left.y * right.x;\r\n\r\n    return new Vector3(x, y, z);\r\n};\r\n\r\nVector3.Normalize = function (vector)\r\n{\r\n    var newVector = Vector3.Copy(vector);\r\n    newVector.normalize();\r\n\r\n    return newVector;\r\n};\r\n\r\nVector3.Distance = function (value1, value2)\r\n{\r\n    return Math.sqrt(Vector3.DistanceSquared(value1, value2));\r\n};\r\n\r\nVector3.DistanceSquared = function (value1, value2)\r\n{\r\n    var x = value1.x - value2.x;\r\n    var y = value1.y - value2.y;\r\n    var z = value1.z - value2.z;\r\n\r\n    return (x * x) + (y * y) + (z * z);\r\n};\r\n*/module.exports=Vector3;/***/},/* 60 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the center y coordinate from the bounds of the Game Object.\r\n *\r\n * @function Phaser.Display.Bounds.GetCenterY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to get the bounds value from.\r\n *\r\n * @return {number} The center y coordinate of the bounds of the Game Object.\r\n */var GetCenterY=function GetCenterY(gameObject){return gameObject.y-gameObject.height*gameObject.originY+gameObject.height*0.5;};module.exports=GetCenterY;/***/},/* 61 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Positions the Game Object so that the center top of its bounds aligns with the given coordinate.\r\n *\r\n * @function Phaser.Display.Bounds.SetCenterY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be re-positioned.\r\n * @param {number} y - The coordinate to position the Game Object bounds on.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was positioned.\r\n */var SetCenterY=function SetCenterY(gameObject,y){var offsetY=gameObject.height*gameObject.originY;gameObject.y=y+offsetY-gameObject.height*0.5;return gameObject;};module.exports=SetCenterY;/***/},/* 62 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Positions the Game Object so that the center top of its bounds aligns with the given coordinate.\r\n *\r\n * @function Phaser.Display.Bounds.SetCenterX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be re-positioned.\r\n * @param {number} x - The coordinate to position the Game Object bounds on.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was positioned.\r\n */var SetCenterX=function SetCenterX(gameObject,x){var offsetX=gameObject.width*gameObject.originX;gameObject.x=x+offsetX-gameObject.width*0.5;return gameObject;};module.exports=SetCenterX;/***/},/* 63 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the center x coordinate from the bounds of the Game Object.\r\n *\r\n * @function Phaser.Display.Bounds.GetCenterX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to get the bounds value from.\r\n *\r\n * @return {number} The center x coordinate of the bounds of the Game Object.\r\n */var GetCenterX=function GetCenterX(gameObject){return gameObject.x-gameObject.width*gameObject.originX+gameObject.width*0.5;};module.exports=GetCenterX;/***/},/* 64 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Phaser Blend Modes.\r\n * \r\n * @name Phaser.BlendModes\r\n * @enum {integer}\r\n * @memberOf Phaser\r\n * @readOnly\r\n * @since 3.0.0\r\n */module.exports={/**\r\n     * Skips the Blend Mode check in the renderer.\r\n     * \r\n     * @name Phaser.BlendModes.SKIP_CHECK\r\n     */SKIP_CHECK:-1,/**\r\n     * Normal blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.NORMAL\r\n     */NORMAL:0,/**\r\n     * Add blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.ADD\r\n     */ADD:1,/**\r\n     * Multiply blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.MULTIPLY\r\n     */MULTIPLY:2,/**\r\n     * Screen blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.SCREEN\r\n     */SCREEN:3,/**\r\n     * Overlay blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.OVERLAY\r\n     */OVERLAY:4,/**\r\n     * Darken blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.DARKEN\r\n     */DARKEN:5,/**\r\n     * Lighten blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.LIGHTEN\r\n     */LIGHTEN:6,/**\r\n     * Color Dodge blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR_DODGE\r\n     */COLOR_DODGE:7,/**\r\n     * Color Burn blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR_BURN\r\n     */COLOR_BURN:8,/**\r\n     * Hard Light blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.HARD_LIGHT\r\n     */HARD_LIGHT:9,/**\r\n     * Soft Light blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.SOFT_LIGHT\r\n     */SOFT_LIGHT:10,/**\r\n     * Difference blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.DIFFERENCE\r\n     */DIFFERENCE:11,/**\r\n     * Exclusion blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.EXCLUSION\r\n     */EXCLUSION:12,/**\r\n     * Hue blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.HUE\r\n     */HUE:13,/**\r\n     * Saturation blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.SATURATION\r\n     */SATURATION:14,/**\r\n     * Color blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR\r\n     */COLOR:15,/**\r\n     * Luminosity blend mode.\r\n     * \r\n     * @name Phaser.BlendModes.LUMINOSITY\r\n     */LUMINOSITY:16};/***/},/* 65 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @callback EachSetCallback\r\n * @generic E - [entry]\r\n *\r\n * @param {*} entry - [description]\r\n * @param {number} index - [description]\r\n *\r\n * @return {?boolean} [description]\r\n *//**\r\n * @classdesc\r\n * A Set is a collection of unique elements.\r\n *\r\n * @class Set\r\n * @memberOf Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n * @genericUse {T[]} - [elements]\r\n *\r\n * @param {Array.<*>} [elements] - [description]\r\n */var Set=new Class({initialize:function Set(elements){/**\r\n         * [description]\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Set#entries\r\n         * @type {Array.<*>}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.entries=[];if(Array.isArray(elements)){for(var i=0;i<elements.length;i++){this.set(elements[i]);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - [description]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */set:function set(value){if(this.entries.indexOf(value)===-1){this.entries.push(value);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value,$return]\r\n     *\r\n     * @param {string} property - [description]\r\n     * @param {*} value - [description]\r\n     *\r\n     * @return {*} [description]\r\n     */get:function get(property,value){for(var i=0;i<this.entries.length;i++){var entry=this.entries[i];if(entry[property]===value){return entry;}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} [description]\r\n     */getArray:function getArray(){return this.entries.slice(0);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - [description]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */delete:function _delete(value){var index=this.entries.indexOf(value);if(index>-1){this.entries.splice(index,1);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#dump\r\n     * @since 3.0.0\r\n     */dump:function dump(){// eslint-disable-next-line no-console\nconsole.group('Set');for(var i=0;i<this.entries.length;i++){var entry=this.entries[i];console.log(entry);}// eslint-disable-next-line no-console\nconsole.groupEnd();},/**\r\n     * For when you know this Set will be modified during the iteration.\r\n     *\r\n     * @method Phaser.Structs.Set#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - [description]\r\n     * @param {*} callbackScope - [description]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */each:function each(callback,callbackScope){var i;var temp=this.entries.slice();var len=temp.length;if(callbackScope){for(i=0;i<len;i++){if(callback.call(callbackScope,temp[i],i)===false){break;}}}else{for(i=0;i<len;i++){if(callback(temp[i],i)===false){break;}}}return this;},/**\r\n     * For when you absolutely know this Set won't be modified during the iteration.\r\n     *\r\n     * @method Phaser.Structs.Set#iterate\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - [description]\r\n     * @param {*} callbackScope - [description]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */iterate:function iterate(callback,callbackScope){var i;var len=this.entries.length;if(callbackScope){for(i=0;i<len;i++){if(callback.call(callbackScope,this.entries[i],i)===false){break;}}}else{for(i=0;i<len;i++){if(callback(this.entries[i],i)===false){break;}}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#iterateLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {string} callbackKey - [description]\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */iterateLocal:function iterateLocal(callbackKey){var i;var args=[];for(i=1;i<arguments.length;i++){args.push(arguments[i]);}var len=this.entries.length;for(i=0;i<len;i++){var entry=this.entries[i];entry[callbackKey].apply(entry,args);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */clear:function clear(){this.entries.length=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {*} value - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */contains:function contains(value){return this.entries.indexOf(value)>-1;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#union\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - [description]\r\n     *\r\n     * @return {Phaser.Structs.Set} [description]\r\n     */union:function union(set){var newSet=new Set();set.entries.forEach(function(value){newSet.set(value);});this.entries.forEach(function(value){newSet.set(value);});return newSet;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#intersect\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - [description]\r\n     *\r\n     * @return {Phaser.Structs.Set} [description]\r\n     */intersect:function intersect(set){var newSet=new Set();this.entries.forEach(function(value){if(set.contains(value)){newSet.set(value);}});return newSet;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Set#difference\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - [description]\r\n     *\r\n     * @return {Phaser.Structs.Set} [description]\r\n     */difference:function difference(set){var newSet=new Set();this.entries.forEach(function(value){if(!set.contains(value)){newSet.set(value);}});return newSet;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Structs.Set#size\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */size:{get:function get(){return this.entries.length;},set:function set(value){return this.entries.length=value;}}});module.exports=Set;/***/},/* 66 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * A class for representing data about a map. Maps are parsed from CSV, Tiled, etc. into this\r\n * format. A Tilemap object get a copy of this data and then unpacks the needed properties into\r\n * itself.\r\n *\r\n * @class MapData\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} [config] - [description]\r\n */var MapData=new Class({initialize:function MapData(config){if(config===undefined){config={};}/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.name=GetFastValue(config,'name','map');/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=GetFastValue(config,'width',0);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=GetFastValue(config,'height',0);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.tileWidth=GetFastValue(config,'tileWidth',0);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.tileHeight=GetFastValue(config,'tileHeight',0);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.widthInPixels=GetFastValue(config,'widthInPixels',this.width*this.tileWidth);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.heightInPixels=GetFastValue(config,'heightInPixels',this.height*this.tileHeight);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#format\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.format=GetFastValue(config,'format',null);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#orientation\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.orientation=GetFastValue(config,'orientation','orthogonal');/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#version\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.version=GetFastValue(config,'version','1');/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.properties=GetFastValue(config,'properties',{});/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#layers\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.layers=GetFastValue(config,'layers',[]);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.images=GetFastValue(config,'images',[]);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#objects\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.objects=GetFastValue(config,'objects',{});/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#collision\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.collision=GetFastValue(config,'collision',{});/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#tilesets\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.tilesets=GetFastValue(config,'tilesets',[]);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#imageCollections\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.imageCollections=GetFastValue(config,'imageCollections',[]);/**\r\n         * [description]\r\n         * \r\n         * @name Phaser.Tilemaps.MapData#tiles\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.tiles=GetFastValue(config,'tiles',[]);}});module.exports=MapData;/***/},/* 67 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,\r\n * etc. into this format. Tilemap, StaticTilemapLayer and DynamicTilemapLayer have a reference\r\n * to this data and use it to look up and perform operations on tiles.\r\n *\r\n * @class LayerData\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} [config] - [description]\r\n */var LayerData=new Class({initialize:function LayerData(config){if(config===undefined){config={};}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.name=GetFastValue(config,'name','layer');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.x=GetFastValue(config,'x',0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.y=GetFastValue(config,'y',0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=GetFastValue(config,'width',0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=GetFastValue(config,'height',0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.tileWidth=GetFastValue(config,'tileWidth',0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.tileHeight=GetFastValue(config,'tileHeight',0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#baseTileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.baseTileWidth=GetFastValue(config,'baseTileWidth',this.tileWidth);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#baseTileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.baseTileHeight=GetFastValue(config,'baseTileHeight',this.tileHeight);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.widthInPixels=GetFastValue(config,'widthInPixels',this.width*this.baseTileWidth);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.heightInPixels=GetFastValue(config,'heightInPixels',this.height*this.baseTileHeight);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#alpha\r\n         * @type {float}\r\n         * @since 3.0.0\r\n         */this.alpha=GetFastValue(config,'alpha',1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#visible\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.visible=GetFastValue(config,'visible',true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.properties=GetFastValue(config,'properties',{});/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#indexes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.indexes=GetFastValue(config,'indexes',[]);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#collideIndexes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.collideIndexes=GetFastValue(config,'collideIndexes',[]);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#callbacks\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.callbacks=GetFastValue(config,'callbacks',[]);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#bodies\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.bodies=GetFastValue(config,'bodies',[]);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#data\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.data=GetFastValue(config,'data',[]);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tilemapLayer\r\n         * @type {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)}\r\n         * @since 3.0.0\r\n         */this.tilemapLayer=GetFastValue(config,'tilemapLayer',null);}});module.exports=LayerData;/***/},/* 68 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Checks if the given tile coordinates are within the bounds of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsInLayerBounds\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - [description]\r\n * @param {integer} tileY - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {boolean}\r\n */var IsInLayerBounds=function IsInLayerBounds(tileX,tileY,layer){return tileX>=0&&tileX<layer.width&&tileY>=0&&tileY<layer.height;};module.exports=IsInLayerBounds;/***/},/* 69 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var TWEEN_CONST={/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.CREATED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */CREATED:0,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.INIT\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */INIT:1,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.DELAY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */DELAY:2,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.OFFSET_DELAY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */OFFSET_DELAY:3,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.PENDING_RENDER\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */PENDING_RENDER:4,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.PLAYING_FORWARD\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */PLAYING_FORWARD:5,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.PLAYING_BACKWARD\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */PLAYING_BACKWARD:6,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.HOLD_DELAY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */HOLD_DELAY:7,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.REPEAT_DELAY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */REPEAT_DELAY:8,/**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */COMPLETE:9,//  Tween specific (starts from 20 to cleanly allow extra TweenData consts in the future)\n/**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.PENDING_ADD\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */PENDING_ADD:20,/**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.PAUSED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */PAUSED:21,/**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.LOOP_DELAY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LOOP_DELAY:22,/**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.ACTIVE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */ACTIVE:23,/**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.COMPLETE_DELAY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */COMPLETE_DELAY:24,/**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.PENDING_REMOVE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */PENDING_REMOVE:25,/**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.REMOVED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */REMOVED:26};module.exports=TWEEN_CONST;/***/},/* 70 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.GetBoolean\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - [description]\r\n * @param {string} key - [description]\r\n * @param {*} defaultValue - [description]\r\n *\r\n * @return {*} [description]\r\n */var GetBoolean=function GetBoolean(source,key,defaultValue){if(!source){return defaultValue;}else if(source.hasOwnProperty(key)){return source[key];}else{return defaultValue;}};module.exports=GetBoolean;/***/},/* 71 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Object.HasValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - [description]\r\n * @param {string} key - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var HasValue=function HasValue(source,key){return source.hasOwnProperty(key);};module.exports=HasValue;/***/},/* 72 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var EaseMap=__webpack_require__(750);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.GetEaseFunction\r\n * @since 3.0.0\r\n *\r\n * @param {(string|function)} ease - [description]\r\n * @param {array} easeParams - [description]\r\n *\r\n * @return {function} [description]\r\n */var GetEaseFunction=function GetEaseFunction(ease,easeParams){if(typeof ease==='string'&&EaseMap.hasOwnProperty(ease)){if(easeParams){var cloneParams=easeParams.slice(0);cloneParams.unshift(0);return function(v){cloneParams[0]=v;return EaseMap[ease].apply(this,cloneParams);};}else{//  String based look-up\nreturn EaseMap[ease];}}else if(typeof ease==='function'){//  Custom function\nreturn ease;}else if(Array.isArray(ease)&&ease.length===4){//  Bezier function (TODO)\n}return EaseMap.Power0;};module.exports=GetEaseFunction;/***/},/* 73 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var GameObject=__webpack_require__(1);var ImageRender=__webpack_require__(755);/**\r\n * @classdesc\r\n * An Image Game Object.\r\n *\r\n * An Image is a light-weight Game Object useful for the display of static images in your game,\r\n * such as logos, backgrounds, scenery or other non-animated elements. Images can have input\r\n * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an\r\n * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.\r\n *\r\n * @class Image\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var Image=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.Depth,Components.Flip,Components.GetBounds,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.ScrollFactor,Components.Size,Components.Texture,Components.Tint,Components.Transform,Components.Visible,ImageRender],initialize:function Image(scene,x,y,texture,frame){GameObject.call(this,scene,'Image');this.setTexture(texture,frame);this.setPosition(x,y);this.setSizeToFrame();this.setOriginFromFrame();this.initPipeline('TextureTintPipeline');}});module.exports=Image;/***/},/* 74 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Actions=__webpack_require__(380);var Class=__webpack_require__(0);var GetFastValue=__webpack_require__(2);var GetValue=__webpack_require__(5);var Range=__webpack_require__(280);var Set=__webpack_require__(65);var Sprite=__webpack_require__(41);/**\r\n * @callback GroupCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} item - [description]\r\n *//**\r\n * @callback GroupMultipleCreateCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject[]} items - [description]\r\n *//**\r\n * @typedef {object} GroupConfig\r\n *\r\n * @property {object} [classType=Sprite] - [description]\r\n * @property {boolean} [active=true] - [description]\r\n * @property {number} [maxSize=-1] - [description]\r\n * @property {?string} [defaultKey=null] - [description]\r\n * @property {?(string|integer)} [defaultFrame=null] - [description]\r\n * @property {boolean} [runChildUpdate=false] - [description]\r\n * @property {?GroupCallback} [createCallback=null] - [description]\r\n * @property {?GroupCallback} [removeCallback=null] - [description]\r\n * @property {?GroupMultipleCreateCallback} [createMultipleCallback=null] - [description]\r\n *//**\r\n * @typedef {object} GroupCreateConfig\r\n *\r\n * @property {object} [classType] - [description]\r\n * @property {string} [key] - [description]\r\n * @property {?(string|integer)} [frame=null] - [description]\r\n * @property {boolean} [visible=true] - [description]\r\n * @property {boolean} [active=true] - [description]\r\n * @property {number} [repeat=0] - [description]\r\n * @property {boolean} [randomKey=false] - [description]\r\n * @property {boolean} [randomFrame=false] - [description]\r\n * @property {boolean} [yoyo=false] - [description]\r\n * @property {number} [frameQuantity=1] - [description]\r\n * @property {number} [max=1] - [description]\r\n * @property {object} [setXY] - [description]\r\n * @property {number} [setXY.x=0] - [description]\r\n * @property {number} [setXY.y=0] - [description]\r\n * @property {number} [setXY.stepX=0] - [description]\r\n * @property {number} [setXY.stepY=0] - [description]\r\n * @property {object} [setRotation] - [description]\r\n * @property {number} [setRotation.value=0] - [description]\r\n * @property {number} [setRotation.step=0] - [description]\r\n * @property {object} [setScale] - [description]\r\n * @property {number} [setScale.x=0] - [description]\r\n * @property {number} [setScale.y=0] - [description]\r\n * @property {number} [setScale.stepX=0] - [description]\r\n * @property {number} [setScale.stepY=0] - [description]\r\n * @property {object} [setAlpha] - [description]\r\n * @property {number} [setAlpha.value=0] - [description]\r\n * @property {number} [setAlpha.step=0] - [description]\r\n * @property {*} [hitArea] - [description]\r\n * @property {HitAreaCallback} [hitAreaCallback] - [description]\r\n * @property {(false|GridAlignConfig)} [gridAlign=false] - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n *  children can be either an array of children, or a config object\r\n *  config can be either a config object, or undefined if passed as the children argument instead\r\n *\r\n * @class Group\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {?(Phaser.GameObjects.GameObject[]|GroupConfig)} children - [description]\r\n * @param {GroupConfig} [config] - [description]\r\n */var Group=new Class({initialize:function Group(scene,children,config){if(config===undefined&&!Array.isArray(children)&&(typeof children==='undefined'?'undefined':_typeof(children))==='object'){config=children;children=null;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#children\r\n         * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}\r\n         * @since 3.0.0\r\n         */this.children=new Set(children);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#isParent\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.isParent=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#classType\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.classType=GetFastValue(config,'classType',Sprite);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#active\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.active=GetFastValue(config,'active',true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#maxSize\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.maxSize=GetFastValue(config,'maxSize',-1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#defaultKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.defaultKey=GetFastValue(config,'defaultKey',null);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#defaultFrame\r\n         * @type {(string|integer)}\r\n         * @since 3.0.0\r\n         */this.defaultFrame=GetFastValue(config,'defaultFrame',null);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#runChildUpdate\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.runChildUpdate=GetFastValue(config,'runChildUpdate',false);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#createCallback\r\n         * @type {?GroupCallback}\r\n         * @since 3.0.0\r\n         */this.createCallback=GetFastValue(config,'createCallback',null);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#removeCallback\r\n         * @type {?GroupCallback}\r\n         * @since 3.0.0\r\n         */this.removeCallback=GetFastValue(config,'removeCallback',null);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Group#createMultipleCallback\r\n         * @type {?GroupMultipleCreateCallback}\r\n         * @since 3.0.0\r\n         */this.createMultipleCallback=GetFastValue(config,'createMultipleCallback',null);if(config){this.createMultiple(config);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n     * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame=defaultFrame] - An optional frame from the Texture this Game Object is rendering with.\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of this Game Object.\r\n     * @param {boolean} [active=true] - The {@link Phaser.GameObjects.GameObject#active} state of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */create:function create(x,y,key,frame,visible,active){if(x===undefined){x=0;}if(y===undefined){y=0;}if(key===undefined){key=this.defaultKey;}if(frame===undefined){frame=this.defaultFrame;}if(visible===undefined){visible=true;}if(active===undefined){active=true;}//  Pool?\nif(this.isFull()){return null;}var child=new this.classType(this.scene,x,y,key,frame);this.scene.sys.displayList.add(child);if(child.preUpdate){this.scene.sys.updateList.add(child);}child.visible=visible;child.setActive(active);this.add(child);return child;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {GroupCreateConfig} config - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} [description]\r\n     */createMultiple:function createMultiple(config){if(!Array.isArray(config)){config=[config];}var output=[];for(var i=0;i<config.length;i++){var entries=this.createFromConfig(config[i]);output=output.concat(entries);}return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#createFromConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @param {GroupCreateConfig} options - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} [description]\r\n     */createFromConfig:function createFromConfig(options){this.classType=GetFastValue(options,'classType',this.classType);var key=GetFastValue(options,'key',undefined);var frame=GetFastValue(options,'frame',null);var visible=GetFastValue(options,'visible',true);var active=GetFastValue(options,'active',true);var entries=[];//  Can't do anything without at least a key\nif(key===undefined){return entries;}else{if(!Array.isArray(key)){key=[key];}if(!Array.isArray(frame)){frame=[frame];}}//  Build an array of key frame pairs to loop through\nvar repeat=GetFastValue(options,'repeat',0);var randomKey=GetFastValue(options,'randomKey',false);var randomFrame=GetFastValue(options,'randomFrame',false);var yoyo=GetFastValue(options,'yoyo',false);var quantity=GetFastValue(options,'frameQuantity',1);var max=GetFastValue(options,'max',0);//  If a grid is set we use that to override the quantity?\nvar range=Range(key,frame,{max:max,qty:quantity,random:randomKey,randomB:randomFrame,repeat:repeat,yoyo:yoyo});for(var c=0;c<range.length;c++){entries.push(this.create(0,0,range[c].a,range[c].b,visible,active));}//  Post-creation options (applied only to those items created in this call):\nvar x=GetValue(options,'setXY.x',0);var y=GetValue(options,'setXY.y',0);var stepX=GetValue(options,'setXY.stepX',0);var stepY=GetValue(options,'setXY.stepY',0);Actions.SetXY(entries,x,y,stepX,stepY);var rotation=GetValue(options,'setRotation.value',0);var stepRotation=GetValue(options,'setRotation.step',0);Actions.SetRotation(entries,rotation,stepRotation);var scaleX=GetValue(options,'setScale.x',1);var scaleY=GetValue(options,'setScale.y',scaleX);var stepScaleX=GetValue(options,'setScale.stepX',0);var stepScaleY=GetValue(options,'setScale.stepY',0);Actions.SetScale(entries,scaleX,scaleY,stepScaleX,stepScaleY);var alpha=GetValue(options,'setAlpha.value',1);var stepAlpha=GetValue(options,'setAlpha.step',0);Actions.SetAlpha(entries,alpha,stepAlpha);var hitArea=GetFastValue(options,'hitArea',null);var hitAreaCallback=GetFastValue(options,'hitAreaCallback',null);if(hitArea){Actions.SetHitArea(entries,hitArea,hitAreaCallback);}var grid=GetFastValue(options,'gridAlign',false);if(grid){Actions.GridAlign(entries,grid);}if(this.createMultipleCallback){this.createMultipleCallback.call(this,entries);}return entries;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */preUpdate:function preUpdate(time,delta){if(!this.runChildUpdate||this.children.size===0){return;}//  Because a Group child may mess with the length of the Group during its update\nvar temp=this.children.entries.slice();for(var i=0;i<temp.length;i++){var item=temp[i];if(item.active){item.update(time,delta);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     * @param {boolean} [addToScene=false] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */add:function add(child,addToScene){if(addToScene===undefined){addToScene=false;}this.children.set(child);if(this.createCallback){this.createCallback.call(this,child);}if(addToScene){this.scene.sys.displayList.add(child);if(child.preUpdate){this.scene.sys.updateList.add(child);}}child.on('destroy',this.remove,this);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#addMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} children - [description]\r\n     * @param {boolean} [addToScene=false] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */addMultiple:function addMultiple(children,addToScene){if(addToScene===undefined){addToScene=false;}if(Array.isArray(children)){for(var i=0;i<children.length;i++){this.add(children[i],addToScene);}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     * @param {boolean} [removeFromScene=false] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */remove:function remove(child,removeFromScene){if(removeFromScene===undefined){removeFromScene=false;}this.children.delete(child);if(this.removeCallback){this.removeCallback.call(this,child);}if(removeFromScene){this.scene.sys.displayList.remove(child);if(child.preUpdate){this.scene.sys.updateList.remove(child);}}child.off('destroy',this.remove,this);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [removeFromScene=false] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */clear:function clear(removeFromScene){if(removeFromScene===undefined){removeFromScene=false;}var children=this.children;for(var i=0;i<children.size;i++){var gameObject=children.entries[i];gameObject.off('destroy',this.remove,this);if(removeFromScene){this.scene.sys.displayList.remove(gameObject);if(gameObject.preUpdate){this.scene.sys.updateList.remove(gameObject);}}}this.children.clear();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */contains:function contains(child){return this.children.contains(child);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#getChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} [description]\r\n     */getChildren:function getChildren(){return this.children.entries;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */getLength:function getLength(){return this.children.size;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirst\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [state=false] - [description]\r\n     * @param {boolean} [createIfNull=false] - [description]\r\n     * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n     * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame=defaultFrame] - An optional frame from the Texture this Game Object is rendering with.\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of this Game Object.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} [description]\r\n     */getFirst:function getFirst(state,createIfNull,x,y,key,frame,visible){if(state===undefined){state=false;}if(createIfNull===undefined){createIfNull=false;}var gameObject;var children=this.children.entries;for(var i=0;i<children.length;i++){gameObject=children[i];if(gameObject.active===state){if(typeof x==='number'){gameObject.x=x;}if(typeof y==='number'){gameObject.y=y;}return gameObject;}}//  Got this far? We need to create or bail\nif(createIfNull){return this.create(x,y,key,frame,visible);}else{return null;}},/**\r\n     * Scans the Group for the first child that has an `active` state set to `false` and returns it.\r\n     * \r\n     * If no child is found then it will create a new one using the arguments given to this method.\r\n     * Unless a new child is being created the arguments are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n     * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame=defaultFrame] - An optional frame from the Texture this Game Object is rendering with.\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */get:function get(x,y,key,frame,visible){return this.getFirst(false,true,x,y,key,frame,visible);},/**\r\n     * Scans the Group for the first child that has an `active` state set to `true` and returns it.\r\n     * \r\n     * If no child is found, and `createIfNull` is `true`, then it will create a new one using the arguments given to this method.\r\n     * Unless a new child is being created the arguments are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} createIfNull - [description]\r\n     * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n     * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame=defaultFrame] - An optional frame from the Texture this Game Object is rendering with.\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */getFirstAlive:function getFirstAlive(createIfNull,x,y,key,frame,visible){return this.getFirst(true,createIfNull,x,y,key,frame,visible);},/**\r\n     * Scans the Group for the first child that has an `active` state set to `false` and returns it.\r\n     * \r\n     * If no child is found, and `createIfNull` is `true`, then it will create a new one using the arguments given to this method.\r\n     * Unless a new child is being created the arguments are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstDead\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} createIfNull - [description]\r\n     * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n     * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame=defaultFrame] - An optional frame from the Texture this Game Object is rendering with.\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */getFirstDead:function getFirstDead(createIfNull,x,y,key,frame,visible){return this.getFirst(false,createIfNull,x,y,key,frame,visible);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#playAnimation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {string} startFrame - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */playAnimation:function playAnimation(key,startFrame){Actions.PlayAnimation(this.children.entries,key,startFrame);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#isFull\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isFull:function isFull(){if(this.maxSize===-1){return false;}else{return this.children.size===this.maxSize;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#countActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */countActive:function countActive(value){if(value===undefined){value=true;}var total=0;for(var i=0;i<this.children.size;i++){if(this.children.entries[i].active===value){total++;}}return total;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#getTotalUsed\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */getTotalUsed:function getTotalUsed(){return this.countActive();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#getTotalFree\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */getTotalFree:function getTotalFree(){var used=this.getTotalUsed();var capacity=this.maxSize===-1?999999999999:this.maxSize;return capacity-used;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     * @param {number} step - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */setDepth:function setDepth(value,step){Actions.SetDepth(this.children.entries,value,step);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#kill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     */kill:function kill(gameObject){if(this.children.contains(gameObject)){gameObject.setActive(false);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#killAndHide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     */killAndHide:function killAndHide(gameObject){if(this.children.contains(gameObject)){gameObject.setActive(false);gameObject.setVisible(false);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#toggleVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */toggleVisible:function toggleVisible(){Actions.ToggleVisible(this.children.entries);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Group#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [destroyChildren=false] - Call `GameObject.destroy` on all children of this Group?\r\n     */destroy:function destroy(destroyChildren){if(destroyChildren===undefined){destroyChildren=false;}if(destroyChildren){var children=this.children;for(var i=0;i<children.size;i++){var gameObject=children.entries[i];//  Remove the event hook first or it'll go all recursive hell on us\ngameObject.off('destroy',this.remove,this);gameObject.destroy();}}this.children.clear();this.scene=undefined;this.children=undefined;}});module.exports=Group;/***/},/* 75 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Check to see if the Ellipse contains the given x / y coordinates.\r\n *\r\n * @function Phaser.Geom.Ellipse.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to check.\r\n * @param {number} x - The x coordinate to check within the ellipse.\r\n * @param {number} y - The y coordinate to check within the ellipse.\r\n *\r\n * @return {boolean} True if the coordinates are within the ellipse, otherwise false.\r\n */var Contains=function Contains(ellipse,x,y){if(ellipse.width<=0||ellipse.height<=0){return false;}//  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5\nvar normx=(x-ellipse.x)/ellipse.width;var normy=(y-ellipse.y)/ellipse.height;normx*=normx;normy*=normy;return normx+normy<0.25;};module.exports=Contains;/***/},/* 76 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Scene consts.\r\n * \r\n * @ignore\r\n */var CONST={/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.PENDING\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */PENDING:0,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.INIT\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */INIT:1,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.START\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */START:2,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.LOADING\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */LOADING:3,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.CREATING\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */CREATING:4,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.RUNNING\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */RUNNING:5,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.PAUSED\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */PAUSED:6,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.SLEEPING\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */SLEEPING:7,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.SHUTDOWN\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */SHUTDOWN:8,/**\r\n     * Scene state.\r\n     * \r\n     * @name Phaser.Scenes.DESTROYED\r\n     * @readOnly\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */DESTROYED:9};module.exports=CONST;/***/},/* 77 *//***/function(module,exports,__webpack_require__){/* WEBPACK VAR INJECTION */(function(process){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Determines the operating system of the device running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.os` from within any Scene.\r\n * \r\n * @typedef {object} Phaser.Device.OS\r\n * @since 3.0.0\r\n * \r\n * @property {boolean} android - Is running on android?\r\n * @property {boolean} chromeOS - Is running on chromeOS?\r\n * @property {boolean} cocoonJS - Is the game running under CocoonJS?\r\n * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?\r\n * @property {boolean} cordova - Is the game running under Apache Cordova?\r\n * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?\r\n * @property {boolean} desktop - Is running on a desktop?\r\n * @property {boolean} ejecta - Is the game running under Ejecta?\r\n * @property {boolean} electron - Is the game running under GitHub Electron?\r\n * @property {boolean} iOS - Is running on iOS?\r\n * @property {boolean} iPad - Is running on iPad?\r\n * @property {boolean} iPhone - Is running on iPhone?\r\n * @property {boolean} kindle - Is running on an Amazon Kindle?\r\n * @property {boolean} linux - Is running on linux?\r\n * @property {boolean} macOS - Is running on macOS?\r\n * @property {boolean} node - Is the game running under Node.js?\r\n * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?\r\n * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView\r\n * @property {boolean} windows - Is running on windows?\r\n * @property {boolean} windowsPhone - Is running on a Windows Phone?\r\n * @property {number} iOSVersion - If running in iOS this will contain the major version number.\r\n * @property {number} pixelRatio - PixelRatio of the host device?\r\n */var OS={android:false,chromeOS:false,cocoonJS:false,cocoonJSApp:false,cordova:false,crosswalk:false,desktop:false,ejecta:false,electron:false,iOS:false,iOSVersion:0,iPad:false,iPhone:false,kindle:false,linux:false,macOS:false,node:false,nodeWebkit:false,pixelRatio:1,webApp:false,windows:false,windowsPhone:false};function init(){var ua=navigator.userAgent;if(/Windows/.test(ua)){OS.windows=true;}else if(/Mac OS/.test(ua)){OS.macOS=true;}else if(/Linux/.test(ua)){OS.linux=true;}else if(/Android/.test(ua)){OS.android=true;}else if(/iP[ao]d|iPhone/i.test(ua)){OS.iOS=true;navigator.appVersion.match(/OS (\\d+)/);OS.iOSVersion=parseInt(RegExp.$1,10);}else if(/Kindle/.test(ua)||/\\bKF[A-Z][A-Z]+/.test(ua)||/Silk.*Mobile Safari/.test(ua)){OS.kindle=true;// This will NOT detect early generations of Kindle Fire, I think there is no reliable way...\n// E.g. \"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_3; en-us; Silk/1.1.0-80) AppleWebKit/533.16 (KHTML, like Gecko) Version/5.0 Safari/533.16 Silk-Accelerated=true\"\n}else if(/CrOS/.test(ua)){OS.chromeOS=true;}if(/Windows Phone/i.test(ua)||/IEMobile/i.test(ua)){OS.android=false;OS.iOS=false;OS.macOS=false;OS.windows=true;OS.windowsPhone=true;}var silk=/Silk/.test(ua);if(OS.windows||OS.macOS||OS.linux&&!silk||OS.chromeOS){OS.desktop=true;}//  Windows Phone / Table reset\nif(OS.windowsPhone||/Windows NT/i.test(ua)&&/Touch/i.test(ua)){OS.desktop=false;}//  WebApp mode in iOS\nif(navigator.standalone){OS.webApp=true;}if(window.cordova!==undefined){OS.cordova=true;}if(typeof process!=='undefined'&&typeof process.versions.node!=='undefined'){OS.node=true;}if(OS.node&&_typeof(process.versions)==='object'){OS.nodeWebkit=!!process.versions['node-webkit'];OS.electron=!!process.versions.electron;}if(navigator.isCocoonJS){OS.cocoonJS=true;try{OS.cocoonJSApp=typeof CocoonJS!=='undefined';}catch(error){OS.cocoonJSApp=false;}}if(window.ejecta!==undefined){OS.ejecta=true;}if(/Crosswalk/.test(ua)){OS.crosswalk=true;}OS.iPhone=ua.toLowerCase().indexOf('iphone')!==-1;OS.iPad=ua.toLowerCase().indexOf('ipad')!==-1;OS.pixelRatio=window['devicePixelRatio']||1;return OS;}module.exports=init();/* WEBPACK VAR INJECTION */}).call(this,__webpack_require__(849));/***/},/* 78 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TransformMatrix\r\n * @memberOf Phaser.GameObjects.Components\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [a=1] - The Scale X value.\r\n * @param {number} [b=0] - The Shear Y value.\r\n * @param {number} [c=0] - The Shear X value.\r\n * @param {number} [d=1] - The Scale Y value.\r\n * @param {number} [tx=0] - The Translate X value.\r\n * @param {number} [ty=0] - The Translate Y value.\r\n */var TransformMatrix=new Class({initialize:function TransformMatrix(a,b,c,d,tx,ty){if(a===undefined){a=1;}if(b===undefined){b=0;}if(c===undefined){c=0;}if(d===undefined){d=1;}if(tx===undefined){tx=0;}if(ty===undefined){ty=0;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TransformMatrix#matrix\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.matrix=new Float32Array([a,b,c,d,tx,ty,0,0,1]);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TransformMatrix#decomposedMatrix\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.decomposedMatrix={translateX:0,translateY:0,scaleX:1,scaleY:1,rotation:0};},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#a\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */a:{get:function get(){return this.matrix[0];},set:function set(value){this.matrix[0]=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#b\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */b:{get:function get(){return this.matrix[1];},set:function set(value){this.matrix[1]=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#c\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */c:{get:function get(){return this.matrix[2];},set:function set(value){this.matrix[2]=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#d\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */d:{get:function get(){return this.matrix[3];},set:function set(value){this.matrix[3]=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#tx\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */tx:{get:function get(){return this.matrix[4];},set:function set(value){this.matrix[4]=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#ty\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */ty:{get:function get(){return this.matrix[5];},set:function set(value){this.matrix[5]=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#rotation\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */rotation:{get:function get(){return Math.acos(this.a/this.scaleX)*(Math.atan(-this.c/this.a)<0?-1:1);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleX\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */scaleX:{get:function get(){return Math.sqrt(this.a*this.a+this.c*this.c);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleY\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */scaleY:{get:function get(){return Math.sqrt(this.b*this.b+this.d*this.d);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#loadIdentity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */loadIdentity:function loadIdentity(){var matrix=this.matrix;matrix[0]=1;matrix[1]=0;matrix[2]=0;matrix[3]=1;matrix[4]=0;matrix[5]=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */translate:function translate(x,y){var matrix=this.matrix;matrix[4]=matrix[0]*x+matrix[2]*y+matrix[4];matrix[5]=matrix[1]*x+matrix[3]*y+matrix[5];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */scale:function scale(x,y){var matrix=this.matrix;matrix[0]*=x;matrix[1]*=x;matrix[2]*=y;matrix[3]*=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radian - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */rotate:function rotate(radian){var radianSin=Math.sin(radian);var radianCos=Math.cos(radian);var matrix=this.matrix;var a=matrix[0];var b=matrix[1];var c=matrix[2];var d=matrix[3];matrix[0]=a*radianCos+c*radianSin;matrix[1]=b*radianCos+d*radianSin;matrix[2]=a*-radianSin+c*radianCos;matrix[3]=b*-radianSin+d*radianCos;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} rhs - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */multiply:function multiply(rhs){var matrix=this.matrix;var otherMatrix=rhs.matrix;var a0=matrix[0];var b0=matrix[1];var c0=matrix[2];var d0=matrix[3];var tx0=matrix[4];var ty0=matrix[5];var a1=otherMatrix[0];var b1=otherMatrix[1];var c1=otherMatrix[2];var d1=otherMatrix[3];var tx1=otherMatrix[4];var ty1=otherMatrix[5];matrix[0]=a1*a0+b1*c0;matrix[1]=a1*b0+b1*d0;matrix[2]=c1*a0+d1*c0;matrix[3]=c1*b0+d1*d0;matrix[4]=tx1*a0+ty1*c0+tx0;matrix[5]=tx1*b0+ty1*d0+ty0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#transform\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} a - The Scale X value.\r\n     * @param {number} b - The Shear Y value.\r\n     * @param {number} c - The Shear X value.\r\n     * @param {number} d - The Scale Y value.\r\n     * @param {number} tx - The Translate X value.\r\n     * @param {number} ty - The Translate Y value.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */transform:function transform(a,b,c,d,tx,ty){var matrix=this.matrix;var a0=matrix[0];var b0=matrix[1];var c0=matrix[2];var d0=matrix[3];var tx0=matrix[4];var ty0=matrix[5];matrix[0]=a*a0+b*c0;matrix[1]=a*b0+b*d0;matrix[2]=c*a0+d*c0;matrix[3]=c*b0+d*d0;matrix[4]=tx*a0+ty*c0+tx0;matrix[5]=tx*b0+ty*d0+ty0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#transformPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - [description]\r\n     *\r\n     * @return {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} [description]\r\n     */transformPoint:function transformPoint(x,y,point){if(point===undefined){point={x:0,y:0};}var matrix=this.matrix;var a=matrix[0];var b=matrix[1];var c=matrix[2];var d=matrix[3];var tx=matrix[4];var ty=matrix[5];point.x=x*a+y*c+tx;point.y=x*b+y*d+ty;return point;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */invert:function invert(){var matrix=this.matrix;var a=matrix[0];var b=matrix[1];var c=matrix[2];var d=matrix[3];var tx=matrix[4];var ty=matrix[5];var n=a*d-b*c;matrix[0]=d/n;matrix[1]=-b/n;matrix[2]=-c/n;matrix[3]=a/n;matrix[4]=(c*ty-d*tx)/n;matrix[5]=-(a*ty-b*tx)/n;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#setTransform\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} a - [description]\r\n     * @param {number} b - [description]\r\n     * @param {number} c - [description]\r\n     * @param {number} d - [description]\r\n     * @param {number} tx - [description]\r\n     * @param {number} ty - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */setTransform:function setTransform(a,b,c,d,tx,ty){var matrix=this.matrix;matrix[0]=a;matrix[1]=b;matrix[2]=c;matrix[3]=d;matrix[4]=tx;matrix[5]=ty;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#decomposeMatrix\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */decomposeMatrix:function decomposeMatrix(){var decomposedMatrix=this.decomposedMatrix;var matrix=this.matrix;//  a = scale X (1)\n//  b = shear Y (0)\n//  c = shear X (0)\n//  d = scale Y (1)\nvar a=matrix[0];var b=matrix[1];var c=matrix[2];var d=matrix[3];var a2=a*a;var b2=b*b;var c2=c*c;var d2=d*d;var sx=Math.sqrt(a2+c2);var sy=Math.sqrt(b2+d2);decomposedMatrix.translateX=matrix[4];decomposedMatrix.translateY=matrix[5];decomposedMatrix.scaleX=sx;decomposedMatrix.scaleY=sy;decomposedMatrix.rotation=Math.acos(a/sx)*(Math.atan(-c/a)<0?-1:1);return decomposedMatrix;},/**\r\n     * Identity + Translate + Rotate + Scale\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyITRS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} rotation - [description]\r\n     * @param {number} scaleX - [description]\r\n     * @param {number} scaleY - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} This TransformMatrix.\r\n     */applyITRS:function applyITRS(x,y,rotation,scaleX,scaleY){var matrix=this.matrix;var radianSin=Math.sin(rotation);var radianCos=Math.cos(rotation);// Translate\nmatrix[4]=x;matrix[5]=y;// Rotate and Scale\nmatrix[0]=radianCos*scaleX;matrix[1]=radianSin*scaleX;matrix[2]=-radianSin*scaleY;matrix[3]=radianCos*scaleY;return this;},/**\r\n     * Destroys this Transform Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#destroy\r\n     * @since 3.4.0\r\n     */destroy:function destroy(){this.matrix=null;this.decomposedMatrix=null;}});module.exports=TransformMatrix;/***/},/* 79 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Length\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var Length=function Length(line){return Math.sqrt((line.x2-line.x1)*(line.x2-line.x1)+(line.y2-line.y1)*(line.y2-line.y1));};module.exports=Length;/***/},/* 80 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clamp=__webpack_require__(50);/**\r\n * Return a value based on the range between `min` and `max` and the percentage given.\r\n *\r\n * @function Phaser.Math.FromPercent\r\n * @since 3.0.0\r\n *\r\n * @param {float} percent - A value between 0 and 1 representing the percentage.\r\n * @param {number} min - [description]\r\n * @param {number} [max] - [description]\r\n *\r\n * @return {number} [description]\r\n */var FromPercent=function FromPercent(percent,min,max){percent=Clamp(percent,0,1);return(max-min)*percent;};module.exports=FromPercent;/***/},/* 81 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Contains=__webpack_require__(28);var GetPoint=__webpack_require__(368);var GetPoints=__webpack_require__(367);var Random=__webpack_require__(174);/**\r\n * @classdesc\r\n * A Circle object.\r\n *\r\n * This is a geometry object, containing numerical values and related methods to inspect and modify them.\r\n * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.\r\n * To render a Circle you should look at the capabilities of the Graphics class.\r\n *\r\n * @class Circle\r\n * @memberOf Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - The x position of the center of the circle.\r\n * @param {number} [y=0] - The y position of the center of the circle.\r\n * @param {number} [radius=0] - The radius of the circle.\r\n */var Circle=new Class({initialize:function Circle(x,y,radius){if(x===undefined){x=0;}if(y===undefined){y=0;}if(radius===undefined){radius=0;}/**\r\n         * The x position of the center of the circle.\r\n         *\r\n         * @name Phaser.Geom.Circle#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * The y position of the center of the circle.\r\n         *\r\n         * @name Phaser.Geom.Circle#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y=y;/**\r\n         * The internal radius of the circle.\r\n         *\r\n         * @name Phaser.Geom.Circle#_radius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._radius=radius;/**\r\n         * The internal diameter of the circle.\r\n         *\r\n         * @name Phaser.Geom.Circle#_diameter\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._diameter=radius*2;},/**\r\n     * Check to see if the Circle contains the given x / y coordinates.\r\n     *\r\n     * @method Phaser.Geom.Circle#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to check within the circle.\r\n     * @param {number} y - The y coordinate to check within the circle.\r\n     *\r\n     * @return {boolean} True if the coordinates are within the circle, otherwise false.\r\n     */contains:function contains(x,y){return Contains(this,x,y);},/**\r\n     * Returns a Point object containing the coordinates of a point on the circumference of the Circle\r\n     * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\r\n     * at 180 degrees around the circle.\r\n     *\r\n     * @method Phaser.Geom.Circle#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [out,$return]\r\n     *\r\n     * @param {float} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.\r\n     * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the circle.\r\n     */getPoint:function getPoint(position,point){return GetPoint(this,position,point);},/**\r\n     * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,\r\n     * based on the given quantity or stepRate values.\r\n     *\r\n     * @method Phaser.Geom.Circle#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\r\n     *\r\n     * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n     * @param {number} [stepRate] - Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.\r\n     * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n     *\r\n     * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the circle.\r\n     */getPoints:function getPoints(quantity,stepRate,output){return GetPoints(this,quantity,stepRate,output);},/**\r\n     * Returns a uniformly distributed random point from anywhere within the Circle.\r\n     *\r\n     * @method Phaser.Geom.Circle#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [point,$return]\r\n     *\r\n     * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\r\n     */getRandomPoint:function getRandomPoint(point){return Random(this,point);},/**\r\n     * Sets the x, y and radius of this circle.\r\n     *\r\n     * @method Phaser.Geom.Circle#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the center of the circle.\r\n     * @param {number} [y=0] - The y position of the center of the circle.\r\n     * @param {number} [radius=0] - The radius of the circle.\r\n     *\r\n     * @return {Phaser.Geom.Circle} This Circle object.\r\n     */setTo:function setTo(x,y,radius){this.x=x;this.y=y;this._radius=radius;this._diameter=radius*2;return this;},/**\r\n     * Sets this Circle to be empty with a radius of zero.\r\n     * Does not change its position.\r\n     *\r\n     * @method Phaser.Geom.Circle#setEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Geom.Circle} This Circle object.\r\n     */setEmpty:function setEmpty(){this._radius=0;this._diameter=0;return this;},/**\r\n     * Sets the position of this Circle.\r\n     *\r\n     * @method Phaser.Geom.Circle#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the center of the circle.\r\n     * @param {number} [y=0] - The y position of the center of the circle.\r\n     *\r\n     * @return {Phaser.Geom.Circle} This Circle object.\r\n     */setPosition:function setPosition(x,y){if(y===undefined){y=x;}this.x=x;this.y=y;return this;},/**\r\n     * Checks to see if the Circle is empty: has a radius of zero.\r\n     *\r\n     * @method Phaser.Geom.Circle#isEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if the Circle is empty, otherwise false.\r\n     */isEmpty:function isEmpty(){return this._radius<=0;},/**\r\n     * The radius of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#radius\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */radius:{get:function get(){return this._radius;},set:function set(value){this._radius=value;this._diameter=value*2;}},/**\r\n     * The diameter of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#diameter\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */diameter:{get:function get(){return this._diameter;},set:function set(value){this._diameter=value;this._radius=value*0.5;}},/**\r\n     * The left position of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#left\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */left:{get:function get(){return this.x-this._radius;},set:function set(value){this.x=value+this._radius;}},/**\r\n     * The right position of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#right\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */right:{get:function get(){return this.x+this._radius;},set:function set(value){this.x=value-this._radius;}},/**\r\n     * The top position of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#top\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */top:{get:function get(){return this.y-this._radius;},set:function set(value){this.y=value+this._radius;}},/**\r\n     * The bottom position of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#bottom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottom:{get:function get(){return this.y+this._radius;},set:function set(value){this.y=value-this._radius;}}});module.exports=Circle;/***/},/* 82 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Phaser Scale Modes.\r\n * \r\n * @name Phaser.ScaleModes\r\n * @enum {integer}\r\n * @memberOf Phaser\r\n * @readOnly\r\n * @since 3.0.0\r\n */module.exports={/**\r\n     * Default Scale Mode (Linear).\r\n     * \r\n     * @name Phaser.ScaleModes.DEFAULT\r\n     */DEFAULT:0,/**\r\n     * Linear Scale Mode.\r\n     * \r\n     * @name Phaser.ScaleModes.LINEAR\r\n     */LINEAR:0,/**\r\n     * Nearest Scale Mode.\r\n     * \r\n     * @name Phaser.ScaleModes.NEAREST\r\n     */NEAREST:1};/***/},/* 83 *//***/function(module,exports){/**\r\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\r\n* Vectors are the basis of all the geometry related operations in the engine.\r\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Vector\r\n*/// TODO: consider params for reusing vector objects\nvar Vector={};module.exports=Vector;(function(){/**\r\n     * Creates a new vector.\r\n     * @method create\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @return {vector} A new vector\r\n     */Vector.create=function(x,y){return{x:x||0,y:y||0};};/**\r\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\r\n     * @method clone\r\n     * @param {vector} vector\r\n     * @return {vector} A new cloned vector\r\n     */Vector.clone=function(vector){return{x:vector.x,y:vector.y};};/**\r\n     * Returns the magnitude (length) of a vector.\r\n     * @method magnitude\r\n     * @param {vector} vector\r\n     * @return {number} The magnitude of the vector\r\n     */Vector.magnitude=function(vector){return Math.sqrt(vector.x*vector.x+vector.y*vector.y);};/**\r\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\r\n     * @method magnitudeSquared\r\n     * @param {vector} vector\r\n     * @return {number} The squared magnitude of the vector\r\n     */Vector.magnitudeSquared=function(vector){return vector.x*vector.x+vector.y*vector.y;};/**\r\n     * Rotates the vector about (0, 0) by specified angle.\r\n     * @method rotate\r\n     * @param {vector} vector\r\n     * @param {number} angle\r\n     * @param {vector} [output]\r\n     * @return {vector} The vector rotated about (0, 0)\r\n     */Vector.rotate=function(vector,angle,output){var cos=Math.cos(angle),sin=Math.sin(angle);if(!output)output={};var x=vector.x*cos-vector.y*sin;output.y=vector.x*sin+vector.y*cos;output.x=x;return output;};/**\r\n     * Rotates the vector about a specified point by specified angle.\r\n     * @method rotateAbout\r\n     * @param {vector} vector\r\n     * @param {number} angle\r\n     * @param {vector} point\r\n     * @param {vector} [output]\r\n     * @return {vector} A new vector rotated about the point\r\n     */Vector.rotateAbout=function(vector,angle,point,output){var cos=Math.cos(angle),sin=Math.sin(angle);if(!output)output={};var x=point.x+((vector.x-point.x)*cos-(vector.y-point.y)*sin);output.y=point.y+((vector.x-point.x)*sin+(vector.y-point.y)*cos);output.x=x;return output;};/**\r\n     * Normalises a vector (such that its magnitude is `1`).\r\n     * @method normalise\r\n     * @param {vector} vector\r\n     * @return {vector} A new vector normalised\r\n     */Vector.normalise=function(vector){var magnitude=Vector.magnitude(vector);if(magnitude===0)return{x:0,y:0};return{x:vector.x/magnitude,y:vector.y/magnitude};};/**\r\n     * Returns the dot-product of two vectors.\r\n     * @method dot\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @return {number} The dot product of the two vectors\r\n     */Vector.dot=function(vectorA,vectorB){return vectorA.x*vectorB.x+vectorA.y*vectorB.y;};/**\r\n     * Returns the cross-product of two vectors.\r\n     * @method cross\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @return {number} The cross product of the two vectors\r\n     */Vector.cross=function(vectorA,vectorB){return vectorA.x*vectorB.y-vectorA.y*vectorB.x;};/**\r\n     * Returns the cross-product of three vectors.\r\n     * @method cross3\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @param {vector} vectorC\r\n     * @return {number} The cross product of the three vectors\r\n     */Vector.cross3=function(vectorA,vectorB,vectorC){return(vectorB.x-vectorA.x)*(vectorC.y-vectorA.y)-(vectorB.y-vectorA.y)*(vectorC.x-vectorA.x);};/**\r\n     * Adds the two vectors.\r\n     * @method add\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @param {vector} [output]\r\n     * @return {vector} A new vector of vectorA and vectorB added\r\n     */Vector.add=function(vectorA,vectorB,output){if(!output)output={};output.x=vectorA.x+vectorB.x;output.y=vectorA.y+vectorB.y;return output;};/**\r\n     * Subtracts the two vectors.\r\n     * @method sub\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @param {vector} [output]\r\n     * @return {vector} A new vector of vectorA and vectorB subtracted\r\n     */Vector.sub=function(vectorA,vectorB,output){if(!output)output={};output.x=vectorA.x-vectorB.x;output.y=vectorA.y-vectorB.y;return output;};/**\r\n     * Multiplies a vector and a scalar.\r\n     * @method mult\r\n     * @param {vector} vector\r\n     * @param {number} scalar\r\n     * @return {vector} A new vector multiplied by scalar\r\n     */Vector.mult=function(vector,scalar){return{x:vector.x*scalar,y:vector.y*scalar};};/**\r\n     * Divides a vector and a scalar.\r\n     * @method div\r\n     * @param {vector} vector\r\n     * @param {number} scalar\r\n     * @return {vector} A new vector divided by scalar\r\n     */Vector.div=function(vector,scalar){return{x:vector.x/scalar,y:vector.y/scalar};};/**\r\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\r\n     * @method perp\r\n     * @param {vector} vector\r\n     * @param {bool} [negate=false]\r\n     * @return {vector} The perpendicular vector\r\n     */Vector.perp=function(vector,negate){negate=negate===true?-1:1;return{x:negate*-vector.y,y:negate*vector.x};};/**\r\n     * Negates both components of a vector such that it points in the opposite direction.\r\n     * @method neg\r\n     * @param {vector} vector\r\n     * @return {vector} The negated vector\r\n     */Vector.neg=function(vector){return{x:-vector.x,y:-vector.y};};/**\r\n     * Returns the angle in radians between the two vectors relative to the x-axis.\r\n     * @method angle\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @return {number} The angle in radians\r\n     */Vector.angle=function(vectorA,vectorB){return Math.atan2(vectorB.y-vectorA.y,vectorB.x-vectorA.x);};/**\r\n     * Temporary vector pool (not thread-safe).\r\n     * @property _temp\r\n     * @type {vector[]}\r\n     * @private\r\n     */Vector._temp=[Vector.create(),Vector.create(),Vector.create(),Vector.create(),Vector.create(),Vector.create()];})();/***/},/* 84 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clone=__webpack_require__(57);/**\r\n * Creates a new Object using all values from obj1 and obj2.\r\n * If a value exists in both obj1 and obj2, the value in obj1 is used.\r\n *\r\n * @function Phaser.Utils.Object.Merge\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj1 - [description]\r\n * @param {object} obj2 - [description]\r\n *\r\n * @return {object} [description]\r\n */var Merge=function Merge(obj1,obj2){var clone=Clone(obj1);for(var key in obj2){if(!clone.hasOwnProperty(key)){clone[key]=obj2[key];}}return clone;};module.exports=Merge;/***/},/* 85 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Defaults=__webpack_require__(114);var GetAdvancedValue=__webpack_require__(8);var GetBoolean=__webpack_require__(70);var GetEaseFunction=__webpack_require__(72);var GetNewValue=__webpack_require__(86);var GetProps=__webpack_require__(187);var GetTargets=__webpack_require__(116);var GetValue=__webpack_require__(5);var GetValueOp=__webpack_require__(115);var Tween=__webpack_require__(113);var TweenData=__webpack_require__(112);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.TweenBuilder\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)} parent - [description]\r\n * @param {object} config - [description]\r\n * @param {Phaser.Tweens.TweenConfigDefaults} defaults - [description]\r\n *\r\n * @return {Phaser.Tweens.Tween} [description]\r\n */var TweenBuilder=function TweenBuilder(parent,config,defaults){if(defaults===undefined){defaults=Defaults;}//  Create arrays of the Targets and the Properties\nvar targets=defaults.targets?defaults.targets:GetTargets(config);// var props = (defaults.props) ? defaults.props : GetProps(config);\nvar props=GetProps(config);//  Default Tween values\nvar delay=GetNewValue(config,'delay',defaults.delay);var duration=GetNewValue(config,'duration',defaults.duration);var easeParams=GetValue(config,'easeParams',defaults.easeParams);var ease=GetEaseFunction(GetValue(config,'ease',defaults.ease),easeParams);var hold=GetNewValue(config,'hold',defaults.hold);var repeat=GetNewValue(config,'repeat',defaults.repeat);var repeatDelay=GetNewValue(config,'repeatDelay',defaults.repeatDelay);var yoyo=GetBoolean(config,'yoyo',defaults.yoyo);var flipX=GetBoolean(config,'flipX',defaults.flipX);var flipY=GetBoolean(config,'flipY',defaults.flipY);var data=[];//  Loop through every property defined in the Tween, i.e.: props { x, y, alpha }\nfor(var p=0;p<props.length;p++){var key=props[p].key;var value=props[p].value;//  Create 1 TweenData per target, per property\nfor(var t=0;t<targets.length;t++){var ops=GetValueOp(key,value);var tweenData=TweenData(targets[t],key,ops.getEnd,ops.getStart,GetEaseFunction(GetValue(value,'ease',ease),easeParams),GetNewValue(value,'delay',delay),GetNewValue(value,'duration',duration),GetBoolean(value,'yoyo',yoyo),GetNewValue(value,'hold',hold),GetNewValue(value,'repeat',repeat),GetNewValue(value,'repeatDelay',repeatDelay),GetBoolean(value,'flipX',flipX),GetBoolean(value,'flipY',flipY));data.push(tweenData);}}var tween=new Tween(parent,data,targets);tween.offset=GetAdvancedValue(config,'offset',null);tween.completeDelay=GetAdvancedValue(config,'completeDelay',0);tween.loop=Math.round(GetAdvancedValue(config,'loop',0));tween.loopDelay=Math.round(GetAdvancedValue(config,'loopDelay',0));tween.paused=GetBoolean(config,'paused',false);tween.useFrames=GetBoolean(config,'useFrames',false);//  Set the Callbacks\nvar scope=GetValue(config,'callbackScope',tween);//  Callback parameters: 0 = a reference to the Tween itself, 1 = the target/s of the Tween, ... your own params\nvar tweenArray=[tween,null];var callbacks=Tween.TYPES;for(var i=0;i<callbacks.length;i++){var type=callbacks[i];var callback=GetValue(config,type,false);if(callback){var callbackScope=GetValue(config,type+'Scope',scope);var callbackParams=GetValue(config,type+'Params',[]);//  The null is reset to be the Tween target\ntween.setCallback(type,callback,tweenArray.concat(callbackParams),callbackScope);}}return tween;};module.exports=TweenBuilder;/***/},/* 86 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.GetNewValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - [description]\r\n * @param {string} key - [description]\r\n * @param {*} defaultValue - [description]\r\n *\r\n * @return {function} [description]\r\n */var GetNewValue=function GetNewValue(source,key,defaultValue){var valueCallback;if(source.hasOwnProperty(key)){var t=_typeof(source[key]);if(t==='function'){valueCallback=function valueCallback(index,totalTargets,target){return source[key](index,totalTargets,target);};}else{valueCallback=function valueCallback(){return source[key];};}}else if(typeof defaultValue==='function'){valueCallback=defaultValue;}else{valueCallback=function valueCallback(){return defaultValue;};}return valueCallback;};module.exports=GetNewValue;/***/},/* 87 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * A Tileset is a combination of an image containing the tiles and a container for data about\r\n * each tile.\r\n *\r\n * @class Tileset\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tileset in the map data.\r\n * @param {integer} firstgid - The first tile index this tileset contains.\r\n * @param {integer} [tileWidth=32] - Width of each tile (in pixels).\r\n * @param {integer} [tileHeight=32] - Height of each tile (in pixels).\r\n * @param {integer} [tileMargin=0] - The margin around all tiles in the sheet (in pixels).\r\n * @param {integer} [tileSpacing=0] - The spacing between each tile in the sheet (in pixels).\r\n * @param {object} [tileProperties={}] - Custom properties defined per tile in the Tileset.\r\n * These typically are custom properties created in Tiled when editing a tileset.\r\n * @param {object} [tileData={}] - Data stored per tile. These typically are created in Tiled\r\n * when editing a tileset, e.g. from Tiled's tile collision editor or terrain editor.\r\n */var Tileset=new Class({initialize:function Tileset(name,firstgid,tileWidth,tileHeight,tileMargin,tileSpacing,tileProperties,tileData){if(tileWidth===undefined||tileWidth<=0){tileWidth=32;}if(tileHeight===undefined||tileHeight<=0){tileHeight=32;}if(tileMargin===undefined){tileMargin=0;}if(tileSpacing===undefined){tileSpacing=0;}if(tileProperties===undefined){tileProperties={};}if(tileData===undefined){tileData={};}/**\r\n         * The name of the Tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.name=name;/**\r\n         * The starting index of the first tile index this Tileset contains.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#firstgid\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.firstgid=firstgid;/**\r\n         * The width of each tile (in pixels). Use setTileSize to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileWidth\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.tileWidth=tileWidth;/**\r\n         * The height of each tile (in pixels). Use setTileSize to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileHeight\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.tileHeight=tileHeight;/**\r\n         * The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileMargin\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.tileMargin=tileMargin;/**\r\n         * The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileSpacing\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.tileSpacing=tileSpacing;/**\r\n         * Tileset-specific properties per tile that are typically defined in the Tiled editor in the\r\n         * Tileset editor.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileProperties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.tileProperties=tileProperties;/**\r\n         * Tileset-specific data per tile that are typically defined in the Tiled editor, e.g. within\r\n         * the Tileset collision editor. This is where collision objects and terrain are stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.tileData=tileData;/**\r\n         * The cached image that contains the individual tiles. Use setImage to set.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#image\r\n         * @type {?Phaser.Textures.Texture}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.image=null;/**\r\n         * The number of tile rows in the the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#rows\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.rows=0;/**\r\n         * The number of tile columns in the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#columns\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.columns=0;/**\r\n         * The total number of tiles in the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#total\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.total=0;/**\r\n         * The look-up table to specific tile image texture coordinates (UV in pixels). Each element\r\n         * contains the coordinates for a tile in an object of the form {x, y}.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#texCoordinates\r\n         * @type {object[]}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n        */this.texCoordinates=[];},/**\r\n     * Get a tiles properties that are stored in the Tileset. Returns null if tile index is not\r\n     * contained in this Tileset. This is typically defined in Tiled under the Tileset editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileProperties\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?(object|undefined)}\r\n     */getTileProperties:function getTileProperties(tileIndex){if(!this.containsTileIndex(tileIndex)){return null;}return this.tileProperties[tileIndex-this.firstgid];},/**\r\n     * Get a tile's data that is stored in the Tileset. Returns null if tile index is not contained\r\n     * in this Tileset. This is typically defined in Tiled and will contain both Tileset collision\r\n     * info and terrain mapping.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object|undefined}\r\n     */getTileData:function getTileData(tileIndex){if(!this.containsTileIndex(tileIndex)){return null;}return this.tileData[tileIndex-this.firstgid];},/**\r\n     * Get a tile's collision group that is stored in the Tileset. Returns null if tile index is not\r\n     * contained in this Tileset. This is typically defined within Tiled's tileset collision editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object}\r\n     */getTileCollisionGroup:function getTileCollisionGroup(tileIndex){var data=this.getTileData(tileIndex);return data&&data.objectgroup?data.objectgroup:null;},/**\r\n     * Returns true if and only if this Tileset contains the given tile index.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#containsTileIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {boolean}\r\n     */containsTileIndex:function containsTileIndex(tileIndex){return tileIndex>=this.firstgid&&tileIndex<this.firstgid+this.total;},/**\r\n     * Returns the texture coordinates (UV in pixels) in the Tileset image for the given tile index.\r\n     * Returns null if tile index is not contained in this Tileset.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileTextureCoordinates\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object} Object in the form { x, y } representing the top-left UV coordinate\r\n     * within the Tileset image.\r\n     */getTileTextureCoordinates:function getTileTextureCoordinates(tileIndex){if(!this.containsTileIndex(tileIndex)){return null;}return this.texCoordinates[tileIndex-this.firstgid];},/**\r\n     * Sets the image associated with this Tileset and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.Texture} texture - The image that contains the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */setImage:function setImage(texture){this.image=texture;this.updateTileData(this.image.source[0].width,this.image.source[0].height);return this;},/**\r\n     * Sets the tile width & height and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileWidth] - The width of a tile in pixels.\r\n     * @param {integer} [tileHeight] - The height of a tile in pixels.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */setTileSize:function setTileSize(tileWidth,tileHeight){if(tileWidth!==undefined){this.tileWidth=tileWidth;}if(tileHeight!==undefined){this.tileHeight=tileHeight;}if(this.image){this.updateTileData(this.image.source[0].width,this.image.source[0].height);}return this;},/**\r\n     * Sets the tile margin & spacing and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setSpacing\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [margin] - The margin around the tiles in the sheet (in pixels).\r\n     * @param {integer} [spacing] - The spacing between the tiles in the sheet (in pixels).\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */setSpacing:function setSpacing(margin,spacing){if(margin!==undefined){this.tileMargin=margin;}if(spacing!==undefined){this.tileSpacing=spacing;}if(this.image){this.updateTileData(this.image.source[0].width,this.image.source[0].height);}return this;},/**\r\n     * Updates tile texture coordinates and tileset data.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#updateTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} imageWidth - The (expected) width of the image to slice.\r\n     * @param {integer} imageHeight - The (expected) height of the image to slice.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */updateTileData:function updateTileData(imageWidth,imageHeight){var rowCount=(imageHeight-this.tileMargin*2+this.tileSpacing)/(this.tileHeight+this.tileSpacing);var colCount=(imageWidth-this.tileMargin*2+this.tileSpacing)/(this.tileWidth+this.tileSpacing);if(rowCount%1!==0||colCount%1!==0){console.warn('Tileset '+this.name+' image tile area is not an even multiple of tile size');}// In Tiled a tileset image that is not an even multiple of the tile dimensions is truncated\n// - hence the floor when calculating the rows/columns.\nrowCount=Math.floor(rowCount);colCount=Math.floor(colCount);this.rows=rowCount;this.columns=colCount;// In Tiled, \"empty\" spaces in a tileset count as tiles and hence count towards the gid\nthis.total=rowCount*colCount;this.texCoordinates.length=0;var tx=this.tileMargin;var ty=this.tileMargin;for(var y=0;y<this.rows;y++){for(var x=0;x<this.columns;x++){this.texCoordinates.push({x:tx,y:ty});tx+=this.tileWidth+this.tileSpacing;}tx=this.tileMargin;ty+=this.tileHeight+this.tileSpacing;}return this;}});module.exports=Tileset;/***/},/* 88 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldY\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileY - [description]\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {number}\r\n */var TileToWorldY=function TileToWorldY(tileY,camera,layer){var tileHeight=layer.baseTileHeight;var tilemapLayer=layer.tilemapLayer;var layerWorldY=0;if(tilemapLayer){if(camera===undefined){camera=tilemapLayer.scene.cameras.main;}layerWorldY=tilemapLayer.y+camera.scrollY*(1-tilemapLayer.scrollFactorY);tileHeight*=tilemapLayer.scaleY;}return layerWorldY+tileY*tileHeight;};module.exports=TileToWorldY;/***/},/* 89 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldX\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - [description]\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {number}\r\n */var TileToWorldX=function TileToWorldX(tileX,camera,layer){var tileWidth=layer.baseTileWidth;var tilemapLayer=layer.tilemapLayer;var layerWorldX=0;if(tilemapLayer){if(camera===undefined){camera=tilemapLayer.scene.cameras.main;}layerWorldX=tilemapLayer.x+camera.scrollX*(1-tilemapLayer.scrollFactorX);tileWidth*=tilemapLayer.scaleX;}return layerWorldX+tileX*tileWidth;};module.exports=TileToWorldX;/***/},/* 90 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var IsInLayerBounds=__webpack_require__(68);/**\r\n * Gets a tile at the given tile coordinates from the given layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).\r\n * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile\r\n * object with an index of -1.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates\r\n * were invalid.\r\n */var GetTileAt=function GetTileAt(tileX,tileY,nonNull,layer){if(nonNull===undefined){nonNull=false;}if(IsInLayerBounds(tileX,tileY,layer)){var tile=layer.data[tileY][tileX];if(tile===null){return null;}else if(tile.index===-1){return nonNull?tile:null;}else{return tile;}}else{return null;}};module.exports=GetTileAt;/***/},/* 91 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Tilemaps.Components\r\n */module.exports={CalculateFacesAt:__webpack_require__(121),CalculateFacesWithin:__webpack_require__(26),Copy:__webpack_require__(456),CreateFromTiles:__webpack_require__(455),CullTiles:__webpack_require__(454),Fill:__webpack_require__(453),FilterTiles:__webpack_require__(452),FindByIndex:__webpack_require__(451),FindTile:__webpack_require__(450),ForEachTile:__webpack_require__(449),GetTileAt:__webpack_require__(90),GetTileAtWorldXY:__webpack_require__(448),GetTilesWithin:__webpack_require__(15),GetTilesWithinShape:__webpack_require__(447),GetTilesWithinWorldXY:__webpack_require__(446),HasTileAt:__webpack_require__(201),HasTileAtWorldXY:__webpack_require__(445),IsInLayerBounds:__webpack_require__(68),PutTileAt:__webpack_require__(120),PutTileAtWorldXY:__webpack_require__(444),PutTilesAt:__webpack_require__(443),Randomize:__webpack_require__(442),RemoveTileAt:__webpack_require__(200),RemoveTileAtWorldXY:__webpack_require__(441),RenderDebug:__webpack_require__(440),ReplaceByIndex:__webpack_require__(202),SetCollision:__webpack_require__(439),SetCollisionBetween:__webpack_require__(438),SetCollisionByExclusion:__webpack_require__(437),SetCollisionByProperty:__webpack_require__(436),SetCollisionFromCollisionGroup:__webpack_require__(435),SetTileIndexCallback:__webpack_require__(434),SetTileLocationCallback:__webpack_require__(433),Shuffle:__webpack_require__(432),SwapByIndex:__webpack_require__(431),TileToWorldX:__webpack_require__(89),TileToWorldXY:__webpack_require__(430),TileToWorldY:__webpack_require__(88),WeightedRandomize:__webpack_require__(429),WorldToTileX:__webpack_require__(40),WorldToTileXY:__webpack_require__(428),WorldToTileY:__webpack_require__(39)};/***/},/* 92 *//***/function(module,exports){/**\r\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\r\n*\r\n* @class Bounds\r\n*/var Bounds={};module.exports=Bounds;(function(){/**\r\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\r\n     * @method create\r\n     * @param {vertices} vertices\r\n     * @return {bounds} A new bounds object\r\n     */Bounds.create=function(vertices){var bounds={min:{x:0,y:0},max:{x:0,y:0}};if(vertices)Bounds.update(bounds,vertices);return bounds;};/**\r\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\r\n     * @method update\r\n     * @param {bounds} bounds\r\n     * @param {vertices} vertices\r\n     * @param {vector} velocity\r\n     */Bounds.update=function(bounds,vertices,velocity){bounds.min.x=Infinity;bounds.max.x=-Infinity;bounds.min.y=Infinity;bounds.max.y=-Infinity;for(var i=0;i<vertices.length;i++){var vertex=vertices[i];if(vertex.x>bounds.max.x)bounds.max.x=vertex.x;if(vertex.x<bounds.min.x)bounds.min.x=vertex.x;if(vertex.y>bounds.max.y)bounds.max.y=vertex.y;if(vertex.y<bounds.min.y)bounds.min.y=vertex.y;}if(velocity){if(velocity.x>0){bounds.max.x+=velocity.x;}else{bounds.min.x+=velocity.x;}if(velocity.y>0){bounds.max.y+=velocity.y;}else{bounds.min.y+=velocity.y;}}};/**\r\n     * Returns true if the bounds contains the given point.\r\n     * @method contains\r\n     * @param {bounds} bounds\r\n     * @param {vector} point\r\n     * @return {boolean} True if the bounds contain the point, otherwise false\r\n     */Bounds.contains=function(bounds,point){return point.x>=bounds.min.x&&point.x<=bounds.max.x&&point.y>=bounds.min.y&&point.y<=bounds.max.y;};/**\r\n     * Returns true if the two bounds intersect.\r\n     * @method overlaps\r\n     * @param {bounds} boundsA\r\n     * @param {bounds} boundsB\r\n     * @return {boolean} True if the bounds overlap, otherwise false\r\n     */Bounds.overlaps=function(boundsA,boundsB){return boundsA.min.x<=boundsB.max.x&&boundsA.max.x>=boundsB.min.x&&boundsA.max.y>=boundsB.min.y&&boundsA.min.y<=boundsB.max.y;};/**\r\n     * Translates the bounds by the given vector.\r\n     * @method translate\r\n     * @param {bounds} bounds\r\n     * @param {vector} vector\r\n     */Bounds.translate=function(bounds,vector){bounds.min.x+=vector.x;bounds.max.x+=vector.x;bounds.min.y+=vector.y;bounds.max.y+=vector.y;};/**\r\n     * Shifts the bounds to the given position.\r\n     * @method shift\r\n     * @param {bounds} bounds\r\n     * @param {vector} position\r\n     */Bounds.shift=function(bounds,position){var deltaX=bounds.max.x-bounds.min.x,deltaY=bounds.max.y-bounds.min.y;bounds.min.x=position.x;bounds.max.x=position.x+deltaX;bounds.min.y=position.y;bounds.max.y=position.y+deltaY;};})();/***/},/* 93 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\r\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\r\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Vertices\r\n*/var Vertices={};module.exports=Vertices;var Vector=__webpack_require__(83);var Common=__webpack_require__(37);(function(){/**\r\n     * Creates a new set of `Matter.Body` compatible vertices.\r\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\r\n     *\r\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n     *\r\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\r\n     * but with some additional references required for efficient collision detection routines.\r\n     *\r\n     * Vertices must be specified in clockwise order.\r\n     *\r\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\r\n     *\r\n     * @method create\r\n     * @param {vector[]} points\r\n     * @param {body} body\r\n     */Vertices.create=function(points,body){var vertices=[];for(var i=0;i<points.length;i++){var point=points[i],vertex={x:point.x,y:point.y,index:i,body:body,isInternal:false,contact:null};vertex.contact={vertex:vertex,normalImpulse:0,tangentImpulse:0};vertices.push(vertex);}return vertices;};/**\r\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \r\n     * into a `Matter.Vertices` object for the given `Matter.Body`.\r\n     * For parsing SVG paths, see `Svg.pathToVertices`.\r\n     * @method fromPath\r\n     * @param {string} path\r\n     * @param {body} body\r\n     * @return {vertices} vertices\r\n     */Vertices.fromPath=function(path,body){var pathPattern=/L?\\s*([\\-\\d\\.e]+)[\\s,]*([\\-\\d\\.e]+)*/ig,points=[];path.replace(pathPattern,function(match,x,y){points.push({x:parseFloat(x),y:parseFloat(y)});});return Vertices.create(points,body);};/**\r\n     * Returns the centre (centroid) of the set of vertices.\r\n     * @method centre\r\n     * @param {vertices} vertices\r\n     * @return {vector} The centre point\r\n     */Vertices.centre=function(vertices){var area=Vertices.area(vertices,true),centre={x:0,y:0},cross,temp,j;for(var i=0;i<vertices.length;i++){j=(i+1)%vertices.length;cross=Vector.cross(vertices[i],vertices[j]);temp=Vector.mult(Vector.add(vertices[i],vertices[j]),cross);centre=Vector.add(centre,temp);}return Vector.div(centre,6*area);};/**\r\n     * Returns the average (mean) of the set of vertices.\r\n     * @method mean\r\n     * @param {vertices} vertices\r\n     * @return {vector} The average point\r\n     */Vertices.mean=function(vertices){var average={x:0,y:0};for(var i=0;i<vertices.length;i++){average.x+=vertices[i].x;average.y+=vertices[i].y;}return Vector.div(average,vertices.length);};/**\r\n     * Returns the area of the set of vertices.\r\n     * @method area\r\n     * @param {vertices} vertices\r\n     * @param {bool} signed\r\n     * @return {number} The area\r\n     */Vertices.area=function(vertices,signed){var area=0,j=vertices.length-1;for(var i=0;i<vertices.length;i++){area+=(vertices[j].x-vertices[i].x)*(vertices[j].y+vertices[i].y);j=i;}if(signed)return area/2;return Math.abs(area)/2;};/**\r\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\r\n     * @method inertia\r\n     * @param {vertices} vertices\r\n     * @param {number} mass\r\n     * @return {number} The polygon's moment of inertia\r\n     */Vertices.inertia=function(vertices,mass){var numerator=0,denominator=0,v=vertices,cross,j;// find the polygon's moment of inertia, using second moment of area\n// from equations at http://www.physicsforums.com/showthread.php?t=25293\nfor(var n=0;n<v.length;n++){j=(n+1)%v.length;cross=Math.abs(Vector.cross(v[j],v[n]));numerator+=cross*(Vector.dot(v[j],v[j])+Vector.dot(v[j],v[n])+Vector.dot(v[n],v[n]));denominator+=cross;}return mass/6*(numerator/denominator);};/**\r\n     * Translates the set of vertices in-place.\r\n     * @method translate\r\n     * @param {vertices} vertices\r\n     * @param {vector} vector\r\n     * @param {number} scalar\r\n     */Vertices.translate=function(vertices,vector,scalar){var i;if(scalar){for(i=0;i<vertices.length;i++){vertices[i].x+=vector.x*scalar;vertices[i].y+=vector.y*scalar;}}else{for(i=0;i<vertices.length;i++){vertices[i].x+=vector.x;vertices[i].y+=vector.y;}}return vertices;};/**\r\n     * Rotates the set of vertices in-place.\r\n     * @method rotate\r\n     * @param {vertices} vertices\r\n     * @param {number} angle\r\n     * @param {vector} point\r\n     */Vertices.rotate=function(vertices,angle,point){if(angle===0)return;var cos=Math.cos(angle),sin=Math.sin(angle);for(var i=0;i<vertices.length;i++){var vertice=vertices[i],dx=vertice.x-point.x,dy=vertice.y-point.y;vertice.x=point.x+(dx*cos-dy*sin);vertice.y=point.y+(dx*sin+dy*cos);}return vertices;};/**\r\n     * Returns `true` if the `point` is inside the set of `vertices`.\r\n     * @method contains\r\n     * @param {vertices} vertices\r\n     * @param {vector} point\r\n     * @return {boolean} True if the vertices contains point, otherwise false\r\n     */Vertices.contains=function(vertices,point){for(var i=0;i<vertices.length;i++){var vertice=vertices[i],nextVertice=vertices[(i+1)%vertices.length];if((point.x-vertice.x)*(nextVertice.y-vertice.y)+(point.y-vertice.y)*(vertice.x-nextVertice.x)>0){return false;}}return true;};/**\r\n     * Scales the vertices from a point (default is centre) in-place.\r\n     * @method scale\r\n     * @param {vertices} vertices\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} point\r\n     */Vertices.scale=function(vertices,scaleX,scaleY,point){if(scaleX===1&&scaleY===1)return vertices;point=point||Vertices.centre(vertices);var vertex,delta;for(var i=0;i<vertices.length;i++){vertex=vertices[i];delta=Vector.sub(vertex,point);vertices[i].x=point.x+delta.x*scaleX;vertices[i].y=point.y+delta.y*scaleY;}return vertices;};/**\r\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\r\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\r\n     * @method chamfer\r\n     * @param {vertices} vertices\r\n     * @param {number[]} radius\r\n     * @param {number} quality\r\n     * @param {number} qualityMin\r\n     * @param {number} qualityMax\r\n     */Vertices.chamfer=function(vertices,radius,quality,qualityMin,qualityMax){if(typeof radius==='number'){radius=[radius];}else{radius=radius||[8];}if(!radius.length)radius=[radius];// quality defaults to -1, which is auto\nquality=typeof quality!=='undefined'?quality:-1;qualityMin=qualityMin||2;qualityMax=qualityMax||14;var newVertices=[];for(var i=0;i<vertices.length;i++){var prevVertex=vertices[i-1>=0?i-1:vertices.length-1],vertex=vertices[i],nextVertex=vertices[(i+1)%vertices.length],currentRadius=radius[i<radius.length?i:radius.length-1];if(currentRadius===0){newVertices.push(vertex);continue;}var prevNormal=Vector.normalise({x:vertex.y-prevVertex.y,y:prevVertex.x-vertex.x});var nextNormal=Vector.normalise({x:nextVertex.y-vertex.y,y:vertex.x-nextVertex.x});var diagonalRadius=Math.sqrt(2*Math.pow(currentRadius,2)),radiusVector=Vector.mult(Common.clone(prevNormal),currentRadius),midNormal=Vector.normalise(Vector.mult(Vector.add(prevNormal,nextNormal),0.5)),scaledVertex=Vector.sub(vertex,Vector.mult(midNormal,diagonalRadius));var precision=quality;if(quality===-1){// automatically decide precision\nprecision=Math.pow(currentRadius,0.32)*1.75;}precision=Common.clamp(precision,qualityMin,qualityMax);// use an even value for precision, more likely to reduce axes by using symmetry\nif(precision%2===1)precision+=1;var alpha=Math.acos(Vector.dot(prevNormal,nextNormal)),theta=alpha/precision;for(var j=0;j<precision;j++){newVertices.push(Vector.add(Vector.rotate(radiusVector,theta*j),scaledVertex));}}return newVertices;};/**\r\n     * Sorts the input vertices into clockwise order in place.\r\n     * @method clockwiseSort\r\n     * @param {vertices} vertices\r\n     * @return {vertices} vertices\r\n     */Vertices.clockwiseSort=function(vertices){var centre=Vertices.mean(vertices);vertices.sort(function(vertexA,vertexB){return Vector.angle(centre,vertexA)-Vector.angle(centre,vertexB);});return vertices;};/**\r\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\r\n     * @method isConvex\r\n     * @param {vertices} vertices\r\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\r\n     */Vertices.isConvex=function(vertices){// http://paulbourke.net/geometry/polygonmesh/\n// Copyright (c) Paul Bourke (use permitted)\nvar flag=0,n=vertices.length,i,j,k,z;if(n<3)return null;for(i=0;i<n;i++){j=(i+1)%n;k=(i+2)%n;z=(vertices[j].x-vertices[i].x)*(vertices[k].y-vertices[j].y);z-=(vertices[j].y-vertices[i].y)*(vertices[k].x-vertices[j].x);if(z<0){flag|=1;}else if(z>0){flag|=2;}if(flag===3){return false;}}if(flag!==0){return true;}else{return null;}};/**\r\n     * Returns the convex hull of the input vertices as a new array of points.\r\n     * @method hull\r\n     * @param {vertices} vertices\r\n     * @return [vertex] vertices\r\n     */Vertices.hull=function(vertices){// http://geomalgorithms.com/a10-_hull-1.html\nvar upper=[],lower=[],vertex,i;// sort vertices on x-axis (y-axis for ties)\nvertices=vertices.slice(0);vertices.sort(function(vertexA,vertexB){var dx=vertexA.x-vertexB.x;return dx!==0?dx:vertexA.y-vertexB.y;});// build lower hull\nfor(i=0;i<vertices.length;i+=1){vertex=vertices[i];while(lower.length>=2&&Vector.cross3(lower[lower.length-2],lower[lower.length-1],vertex)<=0){lower.pop();}lower.push(vertex);}// build upper hull\nfor(i=vertices.length-1;i>=0;i-=1){vertex=vertices[i];while(upper.length>=2&&Vector.cross3(upper[upper.length-2],upper[upper.length-1],vertex)<=0){upper.pop();}upper.push(vertex);}// concatenation of the lower and upper hulls gives the convex hull\n// omit last points because they are repeated at the beginning of the other list\nupper.pop();lower.pop();return upper.concat(lower);};})();/***/},/* 94 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(217);var Sprite=__webpack_require__(41);/**\r\n * @classdesc\r\n * An Arcade Physics Sprite Game Object.\r\n *\r\n * A Sprite Game Object is used for the display of both static and animated images in your game.\r\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\r\n * and animated.\r\n *\r\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\r\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\r\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\r\n *\r\n * @class Sprite\r\n * @extends Phaser.GameObjects.Sprite\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Arcade.Components.Acceleration\r\n * @extends Phaser.Physics.Arcade.Components.Angular\r\n * @extends Phaser.Physics.Arcade.Components.Bounce\r\n * @extends Phaser.Physics.Arcade.Components.Debug\r\n * @extends Phaser.Physics.Arcade.Components.Drag\r\n * @extends Phaser.Physics.Arcade.Components.Enable\r\n * @extends Phaser.Physics.Arcade.Components.Friction\r\n * @extends Phaser.Physics.Arcade.Components.Gravity\r\n * @extends Phaser.Physics.Arcade.Components.Immovable\r\n * @extends Phaser.Physics.Arcade.Components.Mass\r\n * @extends Phaser.Physics.Arcade.Components.Size\r\n * @extends Phaser.Physics.Arcade.Components.Velocity\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Animation\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var ArcadeSprite=new Class({Extends:Sprite,Mixins:[Components.Acceleration,Components.Angular,Components.Bounce,Components.Debug,Components.Drag,Components.Enable,Components.Friction,Components.Gravity,Components.Immovable,Components.Mass,Components.Size,Components.Velocity],initialize:function ArcadeSprite(scene,x,y,texture,frame){Sprite.call(this,scene,x,y,texture,frame);}});module.exports=ArcadeSprite;/***/},/* 95 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} XHRSettingsObject\r\n *\r\n * @property {XMLHttpRequestResponseType} responseType - [description]\r\n * @property {boolean} async - [description]\r\n * @property {string} user - [description]\r\n * @property {string} password - [description]\r\n * @property {number} timeout - [description]\r\n * @property {?string} header - [description]\r\n * @property {?string} headerValue - [description]\r\n * @property {(string|undefined)} overrideMimeType - [description]\r\n *//**\r\n * Creates an XHRSettings Object with default values.\r\n *\r\n * @function Phaser.Loader.XHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XMLHttpRequestResponseType} [responseType=''] - The responseType, such as 'text'.\r\n * @param {boolean} [async=true] - Should the XHR request use async or not?\r\n * @param {string} [user=''] - Optional username for the XHR request.\r\n * @param {string} [password=''] - Optional password for the XHR request.\r\n * @param {integer} [timeout=0] - Optional XHR timeout value.\r\n *\r\n * @return {XHRSettingsObject} The XHRSettings object as used by the Loader.\r\n */var XHRSettings=function XHRSettings(responseType,async,user,password,timeout){if(responseType===undefined){responseType='';}if(async===undefined){async=true;}if(user===undefined){user='';}if(password===undefined){password='';}if(timeout===undefined){timeout=0;}// Before sending a request, set the xhr.responseType to \"text\",\n// \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\n// Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\nreturn{//  Ignored by the Loader, only used by File.\nresponseType:responseType,async:async,//  credentials\nuser:user,password:password,//  timeout in ms (0 = no timeout)\ntimeout:timeout,//  setRequestHeader\nheader:undefined,headerValue:undefined,//  overrideMimeType\noverrideMimeType:undefined};};module.exports=XHRSettings;/***/},/* 96 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);//  This is based off an explanation and expanded math presented by Paul Bourke:\n//  See http:'local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.LineToLine\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line1 - [description]\r\n * @param {Phaser.Geom.Line} line2 - [description]\r\n * @param {Phaser.Geom.Point} [out] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var LineToLine=function LineToLine(line1,line2,out){if(out===undefined){out=new Point();}var x1=line1.x1;var y1=line1.y1;var x2=line1.x2;var y2=line1.y2;var x3=line2.x1;var y3=line2.y1;var x4=line2.x2;var y4=line2.y2;var numA=(x4-x3)*(y1-y3)-(y4-y3)*(x1-x3);var numB=(x2-x1)*(y1-y3)-(y2-y1)*(x1-x3);var deNom=(y4-y3)*(x2-x1)-(x4-x3)*(y2-y1);//  Make sure there is not a division by zero - this also indicates that the lines are parallel.\n//  If numA and numB were both equal to zero the lines would be on top of each other (coincidental).\n//  This check is not done because it is not necessary for this implementation (the parallel check accounts for this).\nif(deNom===0){return false;}//  Calculate the intermediate fractional point that the lines potentially intersect.\nvar uA=numA/deNom;var uB=numB/deNom;//  The fractional point will be between 0 and 1 inclusive if the lines intersect.\n//  If the fractional calculation is larger than 1 or smaller than 0 the lines would need to be longer to intersect.\nif(uA>=0&&uA<=1&&uB>=0&&uB<=1){out.x=x1+uA*(x2-x1);out.y=y1+uA*(y2-y1);return true;}return false;};module.exports=LineToLine;/***/},/* 97 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var GameObject=__webpack_require__(1);var MeshRender=__webpack_require__(671);/**\r\n * @classdesc\r\n * A Mesh Game Object.\r\n *\r\n * @class Mesh\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {float[]} vertices - An array containing the vertices data for this Mesh.\r\n * @param {float[]} uv - An array containing the uv data for this Mesh.\r\n * @param {float[]} colors - An array containing the color data for this Mesh.\r\n * @param {float[]} alphas - An array containing the alpha data for this Mesh.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var Mesh=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.Depth,Components.Flip,Components.GetBounds,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.Size,Components.Texture,Components.Transform,Components.Visible,Components.ScrollFactor,MeshRender],initialize:function Mesh(scene,x,y,vertices,uv,colors,alphas,texture,frame){GameObject.call(this,scene,'Mesh');this.setTexture(texture,frame);this.setPosition(x,y);this.setSizeToFrame();this.setOrigin();this.initPipeline('TextureTintPipeline');if(vertices.length!==uv.length){throw new Error('Mesh Vertex count must match UV count');}var verticesUB=vertices.length/2|0;if(colors.length>0&&colors.length<verticesUB){throw new Error('Mesh Color count must match Vertex count');}if(alphas.length>0&&alphas.length<verticesUB){throw new Error('Mesh Alpha count must match Vertex count');}var i;if(colors.length===0){for(i=0;i<verticesUB;++i){colors[i]=0xFFFFFF;}}if(alphas.length===0){for(i=0;i<verticesUB;++i){alphas[i]=1.0;}}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#vertices\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.vertices=new Float32Array(vertices);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#uv\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.uv=new Float32Array(uv);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#colors\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */this.colors=new Uint32Array(colors);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#alphas\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.alphas=new Float32Array(alphas);}});module.exports=Mesh;/***/},/* 98 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///! stable.js 0.1.6, https://github.com/Two-Screen/stable\n//! © 2017 Angry Bytes and contributors. MIT licensed.\n(function(){// A stable array sort, because `Array#sort()` is not guaranteed stable.\n// This is an implementation of merge sort, without recursion.\nvar stable=function stable(arr,comp){return exec(arr.slice(),comp);};stable.inplace=function(arr,comp){var result=exec(arr,comp);// This simply copies back if the result isn't in the original array,\n// which happens on an odd number of passes.\nif(result!==arr){pass(result,null,arr.length,arr);}return arr;};// Execute the sort using the input array and a second buffer as work space.\n// Returns one of those two, containing the final result.\nfunction exec(arr,comp){if(typeof comp!=='function'){comp=function comp(a,b){return String(a).localeCompare(b);};}// Short-circuit when there's nothing to sort.\nvar len=arr.length;if(len<=1){return arr;}// Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n// Chunks are the size of the left or right hand in merge sort.\n// Stop when the left-hand covers all of the array.\nvar buffer=new Array(len);for(var chk=1;chk<len;chk*=2){pass(arr,comp,chk,buffer);var tmp=arr;arr=buffer;buffer=tmp;}return arr;}// Run a single pass with the given chunk size.\nvar pass=function pass(arr,comp,chk,result){var len=arr.length;var i=0;// Step size / double chunk size.\nvar dbl=chk*2;// Bounds of the left and right chunks.\nvar l,r,e;// Iterators over the left and right chunk.\nvar li,ri;// Iterate over pairs of chunks.\nfor(l=0;l<len;l+=dbl){r=l+chk;e=r+chk;if(r>len)r=len;if(e>len)e=len;// Iterate both chunks in parallel.\nli=l;ri=r;while(true){// Compare the chunks.\nif(li<r&&ri<e){// This works for a regular `sort()` compatible comparator,\n// but also for a simple comparator like: `a > b`\nif(comp(arr[li],arr[ri])<=0){result[i++]=arr[li++];}else{result[i++]=arr[ri++];}}// Nothing to compare, just flush what's left.\nelse if(li<r){result[i++]=arr[li++];}else if(ri<e){result[i++]=arr[ri++];}// Both iterators are at the chunk ends.\nelse{break;}}}};// Export using CommonJS or to the window.\nif(true){module.exports=stable;}else{}})();/***/},/* 99 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Removes a single item from an array and returns it without creating gc, like the native splice does.\r\n * Based on code by Mike Reinstein.\r\n *\r\n * @function Phaser.Utils.Array.SpliceOne\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - [description]\r\n * @param {integer} index - [description]\r\n *\r\n * @return {*} [description]\r\n */var SpliceOne=function SpliceOne(array,index){if(index>=array.length){return;}var len=array.length-1;var item=array[index];for(var i=index;i<len;i++){array[i]=array[i+1];}array.length=len;return item;};module.exports=SpliceOne;/***/},/* 100 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */// Based on the routine from {@link http://jsfiddle.net/MrPolywhirl/NH42z/}.\nvar CheckMatrix=__webpack_require__(145);var TransposeMatrix=__webpack_require__(284);/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.RotateMatrix\r\n * @since 3.0.0\r\n *\r\n * @param {array} matrix - The array to rotate.\r\n * @param {(number|string)} [direction=90] - The amount to rotate the matrix by. The value can be given in degrees: 90, -90, 270, -270 or 180, or a string command: `rotateLeft`, `rotateRight` or `rotate180`.\r\n *\r\n * @return {array} The rotated matrix array. The source matrix should be discard for the returned matrix.\r\n */var RotateMatrix=function RotateMatrix(matrix,direction){if(direction===undefined){direction=90;}if(!CheckMatrix(matrix)){return null;}if(typeof direction!=='string'){direction=(direction%360+360)%360;}if(direction===90||direction===-270||direction==='rotateLeft'){matrix=TransposeMatrix(matrix);matrix.reverse();}else if(direction===-90||direction===270||direction==='rotateRight'){matrix.reverse();matrix=TransposeMatrix(matrix);}else if(Math.abs(direction)===180||direction==='rotate180'){for(var i=0;i<matrix.length;i++){matrix[i].reverse();}matrix.reverse();}return matrix;};module.exports=RotateMatrix;/***/},/* 101 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ArrayUtils=__webpack_require__(146);var Class=__webpack_require__(0);var NOOP=__webpack_require__(3);var StableSort=__webpack_require__(98);/**\r\n * @callback EachListCallback\r\n * @generic I - [item]\r\n *\r\n * @param {*} item - [description]\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class List\r\n * @memberOf Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n *\r\n * @param {*} parent - [description]\r\n */var List=new Class({initialize:function List(parent){/**\r\n         * The parent of this list.\r\n         *\r\n         * @name Phaser.Structs.List#parent\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */this.parent=parent;/**\r\n         * The objects that belong to this collection.\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.List#list\r\n         * @type {Array.<*>}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.list=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Structs.List#position\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.position=0;/**\r\n         * A callback that is invoked every time a child is added to this list.\r\n         *\r\n         * @name Phaser.Structs.List#addCallback\r\n         * @type {function}\r\n         * @since 3.4.0\r\n         */this.addCallback=NOOP;/**\r\n         * A callback that is invoked every time a child is removed from this list.\r\n         *\r\n         * @name Phaser.Structs.List#removeCallback\r\n         * @type {function}\r\n         * @since 3.4.0\r\n         */this.removeCallback=NOOP;/**\r\n         * The property key to sort by.\r\n         *\r\n         * @name Phaser.Structs.List#_sortKey\r\n         * @type {string}\r\n         * @since 3.4.0\r\n         */this._sortKey='';},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#add\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*|Array.<*>} child - [description]\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.addCallback if this child is added successfully.\r\n     *\r\n     * @return {*} [description]\r\n     */add:function add(child,skipCallback){if(skipCallback){return ArrayUtils.Add(this.list,child);}else{return ArrayUtils.Add(this.list,child,0,this.addCallback,this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#addAt\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - [description]\r\n     * @param {integer} [index=0] - [description]\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.addCallback if this child is added successfully.\r\n     *\r\n     * @return {*} [description]\r\n     */addAt:function addAt(child,index,skipCallback){if(skipCallback){return ArrayUtils.AddAt(this.list,child,index);}else{return ArrayUtils.AddAt(this.list,child,index,0,this.addCallback,this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#getAt\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [$return]\r\n     *\r\n     * @param {integer} index - [description]\r\n     *\r\n     * @return {*} [description]\r\n     */getAt:function getAt(index){return this.list[index];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child]\r\n     *\r\n     * @param {*} child - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */getIndex:function getIndex(child){//  Return -1 if given child isn't a child of this display list\nreturn this.list.indexOf(child);},/**\r\n     * Sort the contents of this List so the items are in order based\r\n     * on the given property. For example, `sort('alpha')` would sort the List\r\n     * contents based on the value of their `alpha` property.\r\n     *\r\n     * @method Phaser.Structs.List#sort\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [children,$return]\r\n     *\r\n     * @param {string} property - The property to lexically sort by.\r\n     *\r\n     * @return {Array.<*>} [description]\r\n     */sort:function sort(property){if(property){this._sortKey=property;StableSort.inplace(this.list,this.sortHandler);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#sortHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @genericUse {T} - [childA,childB]\r\n     *\r\n     * @param {*} childA - [description]\r\n     * @param {*} childB - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */sortHandler:function sortHandler(childA,childB){return childA[this._sortKey]-childB[this._sortKey];},/**\r\n     * Searches for the first instance of a child with its `name`\r\n     * property matching the given argument. Should more than one child have\r\n     * the same name only the first is returned.\r\n     *\r\n     * @method Phaser.Structs.List#getByName\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T | null} - [$return]\r\n     *\r\n     * @param {string} name - The name to search for.\r\n     *\r\n     * @return {?*} The first child with a matching name, or null if none were found.\r\n     */getByName:function getByName(name){return ArrayUtils.GetFirst(this.list,'name',name);},/**\r\n     * Returns a random child from the group.\r\n     *\r\n     * @method Phaser.Structs.List#getRandom\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T | null} - [$return]\r\n     *\r\n     * @param {integer} [startIndex=0] - Offset from the front of the group (lowest child).\r\n     * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.\r\n     *\r\n     * @return {?*} A random child of this Group.\r\n     */getRandom:function getRandom(startIndex,length){return ArrayUtils.GetRandom(this.list,startIndex,length);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#getFirst\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {T | null} - [$return]\r\n     *\r\n     * @param {string} property - [description]\r\n     * @param {*} value - [description]\r\n     * @param {number} [startIndex=0] - [description]\r\n     * @param {number} [endIndex] - [description]\r\n     *\r\n     * @return {?*} [description]\r\n     */getFirst:function getFirst(property,value,startIndex,endIndex){return ArrayUtils.GetFirstElement(this.list,property,value,startIndex,endIndex);},/**\r\n     * Returns all children in this List.\r\n     *\r\n     * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n     *\r\n     * For example: `getAll('parent')` would return only children that have a property called `parent`.\r\n     *\r\n     * You can also specify a value to compare the property to:\r\n     * \r\n     * `getAll('visible', true)` would return only children that have their visible property set to `true`.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this List had 100 children,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 children in the List.\r\n     *\r\n     * @method Phaser.Structs.List#getAll\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @param {string} [property] - An optional property to test against the value argument.\r\n     * @param {*} [value] - If property is set then Child.property must strictly equal this value to be included in the results.\r\n     * @param {integer} [startIndex] - The first child index to start the search from.\r\n     * @param {integer} [endIndex] - The last child index to search up until.\r\n     *\r\n     * @return {Array.<*>} [description]\r\n     */getAll:function getAll(property,value,startIndex,endIndex){return ArrayUtils.GetAll(this.list,property,value,startIndex,endIndex);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#count\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {string} property - [description]\r\n     * @param {*} value - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */count:function count(property,value){return ArrayUtils.CountAllMatching(this.list,property,value);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#swap\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child1,child2]\r\n     *\r\n     * @param {*} child1 - [description]\r\n     * @param {*} child2 - [description]\r\n     */swap:function swap(child1,child2){ArrayUtils.Swap(this.list,child1,child2);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - [description]\r\n     * @param {integer} index - [description]\r\n     *\r\n     * @return {*} [description]\r\n     */moveTo:function moveTo(child,index){return ArrayUtils.MoveTo(this.list,child,index);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - [description]\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.\r\n     *\r\n     * @return {*} [description]\r\n     */remove:function remove(child,skipCallback){if(skipCallback){return ArrayUtils.Remove(this.list,child);}else{return ArrayUtils.Remove(this.list,child,this.removeCallback,this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#removeAt\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [$return]\r\n     *\r\n     * @param {integer} index - [description]\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.\r\n     *\r\n     * @return {*} [description]\r\n     */removeAt:function removeAt(index,skipCallback){if(skipCallback){return ArrayUtils.RemoveAt(this.list,index);}else{return ArrayUtils.RemoveAt(this.list,index,this.removeCallback,this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#removeBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @param {integer} [startIndex=0] - [description]\r\n     * @param {integer} [endIndex] - [description]\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.\r\n     *\r\n     * @return {Array.<*>} [description]\r\n     */removeBetween:function removeBetween(startIndex,endIndex,skipCallback){if(skipCallback){return ArrayUtils.RemoveBetween(this.list,startIndex,endIndex);}else{return ArrayUtils.RemoveBetween(this.list,startIndex,endIndex,this.removeCallback,this);}},/**\r\n     * Removes all the items.\r\n     *\r\n     * @method Phaser.Structs.List#removeAll\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.List.<T>} - [$return]\r\n     * \r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.\r\n     *\r\n     * @return {Phaser.Structs.List} This List object.\r\n     */removeAll:function removeAll(skipCallback){var i=this.list.length;while(i--){this.remove(this.list[i],skipCallback);}return this;},/**\r\n     * Brings the given child to the top of this List.\r\n     *\r\n     * @method Phaser.Structs.List#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - [description]\r\n     *\r\n     * @return {*} [description]\r\n     */bringToTop:function bringToTop(child){return ArrayUtils.BringToTop(this.list,child);},/**\r\n     * Sends the given child to the bottom of this List.\r\n     *\r\n     * @method Phaser.Structs.List#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - [description]\r\n     *\r\n     * @return {*} [description]\r\n     */sendToBack:function sendToBack(child){return ArrayUtils.SendToBack(this.list,child);},/**\r\n     * Moves the given child up one place in this group unless it's already at the top.\r\n     *\r\n     * @method Phaser.Structs.List#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - [description]\r\n     *\r\n     * @return {*} [description]\r\n     */moveUp:function moveUp(child){ArrayUtils.MoveUp(this.list,child);return child;},/**\r\n     * Moves the given child down one place in this group unless it's already at the bottom.\r\n     *\r\n     * @method Phaser.Structs.List#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - [description]\r\n     *\r\n     * @return {*} [description]\r\n     */moveDown:function moveDown(child){ArrayUtils.MoveDown(this.list,child);return child;},/**\r\n     * Reverses the order of all children in this List.\r\n     *\r\n     * @method Phaser.Structs.List#reverse\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.List.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.List} This List object.\r\n     */reverse:function reverse(){this.list.reverse();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#shuffle\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.List.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.List} This List object.\r\n     */shuffle:function shuffle(){ArrayUtils.Shuffle(this.list);return this;},/**\r\n     * Replaces a child of this List with the given newChild. The newChild cannot be a member of this List.\r\n     *\r\n     * @method Phaser.Structs.List#replace\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [oldChild,newChild,$return]\r\n     *\r\n     * @param {*} oldChild - The child in this List that will be replaced.\r\n     * @param {*} newChild - The child to be inserted into this List.\r\n     *\r\n     * @return {*} Returns the oldChild that was replaced within this group.\r\n     */replace:function replace(oldChild,newChild){return ArrayUtils.Replace(this.list,oldChild,newChild);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#exists\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child]\r\n     *\r\n     * @param {*} child - [description]\r\n     *\r\n     * @return {boolean} True if the item is found in the list, otherwise false.\r\n     */exists:function exists(child){return this.list.indexOf(child)>-1;},/**\r\n     * Sets the property `key` to the given value on all members of this List.\r\n     *\r\n     * @method Phaser.Structs.List#setAll\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {string} property - [description]\r\n     * @param {*} value - [description]\r\n     * @param {integer} [startIndex] - The first child index to start the search from.\r\n     * @param {integer} [endIndex] - The last child index to search up until.\r\n     */setAll:function setAll(property,value,startIndex,endIndex){ArrayUtils.SetAll(this.list,property,value,startIndex,endIndex);return this;},/**\r\n     * Passes all children to the given callback.\r\n     *\r\n     * @method Phaser.Structs.List#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachListCallback.<T>} - [callback]\r\n     *\r\n     * @param {EachListCallback} callback - The function to call.\r\n     * @param {*} [thisArg] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     */each:function each(callback,context){var args=[null];for(var i=2;i<arguments.length;i++){args.push(arguments[i]);}for(i=0;i<this.list.length;i++){args[0]=this.list[i];callback.apply(context,args);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.removeAll();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.List#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.removeAll();this.list=[];this.parent=null;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Structs.List#length\r\n     * @type {integer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */length:{get:function get(){return this.list.length;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Structs.List#first\r\n     * @type {integer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */first:{get:function get(){this.position=0;if(this.list.length>0){return this.list[0];}else{return null;}}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Structs.List#last\r\n     * @type {integer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */last:{get:function get(){if(this.list.length>0){this.position=this.list.length-1;return this.list[this.position];}else{return null;}}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Structs.List#next\r\n     * @type {integer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */next:{get:function get(){if(this.position<this.list.length){this.position++;return this.list[this.position];}else{return null;}}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Structs.List#previous\r\n     * @type {integer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */previous:{get:function get(){if(this.position>0){this.position--;return this.list[this.position];}else{return null;}}}});module.exports=List;/***/},/* 102 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var EventEmitter=__webpack_require__(14);var Extend=__webpack_require__(18);var NOOP=__webpack_require__(3);/**\r\n * @classdesc\r\n * Class containing all the shared state and behavior of a sound object, independent of the implementation.\r\n *\r\n * @class BaseSound\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Sound\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Sound.BaseSoundManager} manager - Reference to the current sound manager instance.\r\n * @param {string} key - Asset key for the sound.\r\n * @param {SoundConfig} [config] - An optional config object containing default sound settings.\r\n */var BaseSound=new Class({Extends:EventEmitter,initialize:function BaseSound(manager,key,config){EventEmitter.call(this);/**\r\n         * Local reference to the sound manager.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#manager\r\n         * @type {Phaser.Sound.BaseSoundManager}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.manager=manager;/**\r\n         * Asset key for the sound.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#key\r\n         * @type {string}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.key=key;/**\r\n         * Flag indicating if sound is currently playing.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#isPlaying\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isPlaying=false;/**\r\n         * Flag indicating if sound is currently paused.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#isPaused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isPaused=false;/**\r\n         * A property that holds the value of sound's actual playback rate,\r\n         * after its rate and detune values has been combined with global\r\n         * rate and detune values.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#totalRate\r\n         * @type {number}\r\n         * @default 1\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.totalRate=1;/**\r\n         * A value representing the duration, in seconds.\r\n         * It could be total sound duration or a marker duration.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#duration\r\n         * @type {number}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.duration=this.duration||0;/**\r\n         * The total duration of the sound in seconds.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#totalDuration\r\n         * @type {number}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.totalDuration=this.totalDuration||0;/**\r\n         * A config object used to store default sound settings' values.\r\n         * Default values will be set by properties' setters.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#config\r\n         * @type {SoundConfig}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.config={mute:false,volume:1,rate:1,detune:0,seek:0,loop:false,delay:0};/**\r\n         * Reference to the currently used config.\r\n         * It could be default config or marker config.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#currentConfig\r\n         * @type {SoundConfig}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.currentConfig=this.config;this.config=Extend(this.config,config);/**\r\n         * Boolean indicating whether the sound is muted or not.\r\n         * Gets or sets the muted state of this sound.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#mute\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.mute=false;/**\r\n         * Gets or sets the volume of this sound,\r\n         * a value between 0 (silence) and 1 (full volume).\r\n         *\r\n         * @name Phaser.Sound.BaseSound#volume\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.volume=1;/**\r\n         * Property representing the position of playback for this sound, in seconds.\r\n         * Setting it to a specific value moves current playback to that position.\r\n         * The value given is clamped to the range 0 to current marker duration.\r\n         * Setting seek of a stopped sound has no effect.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#seek\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.seek=0;/**\r\n         * Flag indicating whether or not the sound or current sound marker will loop.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#loop\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.loop=false;/**\r\n         * Object containing markers definitions.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#markers\r\n         * @type {Object.<string, SoundMarker>}\r\n         * @default {}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.markers={};/**\r\n         * Currently playing marker.\r\n         * 'null' if whole sound is playing.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#currentMarker\r\n         * @type {SoundMarker}\r\n         * @default null\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.currentMarker=null;/**\r\n         * Flag indicating if destroy method was called on this sound.\r\n         *\r\n         * @name Phaser.Sound.BaseSound#pendingRemove\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.pendingRemove=false;},/**\r\n     * Adds a marker into the current sound. A marker is represented by name, start time, duration, and optionally config object.\r\n     * This allows you to bundle multiple sounds together into a single audio file and use markers to jump between them for playback.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#addMarker\r\n     * @since 3.0.0\r\n     *\r\n     * @param {SoundMarker} marker - Marker object.\r\n     *\r\n     * @return {boolean} Whether the marker was added successfully.\r\n     */addMarker:function addMarker(marker){if(!marker||!marker.name||typeof marker.name!=='string'){return false;}if(this.markers[marker.name]){// eslint-disable-next-line no-console\nconsole.error('addMarker - Marker with name \\''+marker.name+'\\' already exists for sound \\''+this.key+'\\'!');return false;}marker=Extend(true,{name:'',start:0,duration:this.totalDuration-(marker.start||0),config:{mute:false,volume:1,rate:1,detune:0,seek:0,loop:false,delay:0}},marker);this.markers[marker.name]=marker;return true;},/**\r\n     * Updates previously added marker.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#updateMarker\r\n     * @since 3.0.0\r\n     *\r\n     * @param {SoundMarker} marker - Marker object with updated values.\r\n     *\r\n     * @return {boolean} Whether the marker was updated successfully.\r\n     */updateMarker:function updateMarker(marker){if(!marker||!marker.name||typeof marker.name!=='string'){return false;}if(!this.markers[marker.name]){// eslint-disable-next-line no-console\nconsole.error('updateMarker - Marker with name \\''+marker.name+'\\' does not exist for sound \\''+this.key+'\\'!');return false;}this.markers[marker.name]=Extend(true,this.markers[marker.name],marker);return true;},/**\r\n     * Removes a marker from the sound.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#removeMarker\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} markerName - The name of the marker to remove.\r\n     *\r\n     * @return {?SoundMarker} Removed marker object or 'null' if there was no marker with provided name.\r\n     */removeMarker:function removeMarker(markerName){var marker=this.markers[markerName];if(!marker){return null;}this.markers[markerName]=null;return marker;},/**\r\n     * Play this sound, or a marked section of it.\r\n     * It always plays the sound from the start. If you want to start playback from a specific time\r\n     * you can set 'seek' setting of the config object, provided to this call, to that value.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#play\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [markerName=''] - If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound.\r\n     * @param {SoundConfig} [config] - Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.\r\n     *\r\n     * @return {boolean} Whether the sound started playing successfully.\r\n     */play:function play(markerName,config){if(markerName===undefined){markerName='';}if((typeof markerName==='undefined'?'undefined':_typeof(markerName))==='object'){config=markerName;markerName='';}if(typeof markerName!=='string'){// eslint-disable-next-line no-console\nconsole.error('Sound marker name has to be a string!');return false;}if(!markerName){this.currentMarker=null;this.currentConfig=this.config;this.duration=this.totalDuration;}else{if(!this.markers[markerName]){// eslint-disable-next-line no-console\nconsole.error('No marker with name \\''+markerName+'\\' found for sound \\''+this.key+'\\'!');return false;}this.currentMarker=this.markers[markerName];this.currentConfig=this.currentMarker.config;this.duration=this.currentMarker.duration;}this.resetConfig();this.currentConfig=Extend(this.currentConfig,config);this.isPlaying=true;this.isPaused=false;return true;},/**\r\n     * Pauses the sound.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was paused successfully.\r\n     */pause:function pause(){if(this.isPaused||!this.isPlaying){return false;}this.isPlaying=false;this.isPaused=true;return true;},/**\r\n     * Resumes the sound.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was resumed successfully.\r\n     */resume:function resume(){if(!this.isPaused||this.isPlaying){return false;}this.isPlaying=true;this.isPaused=false;return true;},/**\r\n     * Stop playing this sound.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was stopped successfully.\r\n     */stop:function stop(){if(!this.isPaused&&!this.isPlaying){return false;}this.isPlaying=false;this.isPaused=false;this.resetConfig();return true;},/**\r\n     * Method used internally for applying config values to some of the sound properties.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#applyConfig\r\n     * @protected\r\n     * @since 3.0.0\r\n     */applyConfig:function applyConfig(){this.mute=this.currentConfig.mute;this.volume=this.currentConfig.volume;this.rate=this.currentConfig.rate;this.detune=this.currentConfig.detune;this.loop=this.currentConfig.loop;},/**\r\n     * Method used internally for resetting values of some of the config properties.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#resetConfig\r\n     * @protected\r\n     * @since 3.0.0\r\n     */resetConfig:function resetConfig(){this.currentConfig.seek=0;this.currentConfig.delay=0;},/**\r\n     * Update method called automatically by sound manager on every game step.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#update\r\n     * @override\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */update:NOOP,/**\r\n     * Method used internally to calculate total playback rate of the sound.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#calculateRate\r\n     * @protected\r\n     * @since 3.0.0\r\n     */calculateRate:function calculateRate(){var cent=1.0005777895065548;// Math.pow(2, 1/1200);\nvar totalDetune=this.currentConfig.detune+this.manager.detune;var detuneRate=Math.pow(cent,totalDetune);this.totalRate=this.currentConfig.rate*this.manager.rate*detuneRate;},/**\r\n     * Destroys this sound and all associated events and marks it for removal from the sound manager.\r\n     *\r\n     * @method Phaser.Sound.BaseSound#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){if(this.pendingRemove){return;}this.emit('destroy',this);this.pendingRemove=true;this.manager=null;this.key='';this.removeAllListeners();this.isPlaying=false;this.isPaused=false;this.config=null;this.currentConfig=null;this.markers=null;this.currentMarker=null;}});module.exports=BaseSound;/***/},/* 103 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var EventEmitter=__webpack_require__(14);var NOOP=__webpack_require__(3);/**\r\n * @callback EachActiveSoundCallback\r\n *\r\n * @param {Phaser.Sound.BaseSoundManager} manager - [description]\r\n * @param {Phaser.Sound.BaseSound} sound - [description]\r\n * @param {number} index - [description]\r\n * @param {Phaser.Sound.BaseSound[]} sounds - [description]\r\n *//**\r\n * Audio sprite sound type.\r\n *\r\n * @typedef {Phaser.Sound.BaseSound} AudioSpriteSound\r\n *\r\n * @property {object} spritemap - Local reference to 'spritemap' object form json file generated by audiosprite tool.\r\n *//**\r\n * @classdesc\r\n * The sound manager is responsible for playing back audio via Web Audio API or HTML Audio tag as fallback.\r\n * The audio file type and the encoding of those files are extremely important.\r\n * \r\n * Not all browsers can play all audio formats.\r\n * \r\n * There is a good guide to what's supported [here](https://developer.mozilla.org/en-US/Apps/Fundamentals/Audio_and_video_delivery/Cross-browser_audio_basics#Audio_Codec_Support).\r\n *\r\n * @class BaseSoundManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Sound\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - Reference to the current game instance.\r\n */var BaseSoundManager=new Class({Extends:EventEmitter,initialize:function BaseSoundManager(game){EventEmitter.call(this);/**\r\n         * Local reference to game.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#game\r\n         * @type {Phaser.Game}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * An array containing all added sounds.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#sounds\r\n         * @type {Phaser.Sound.BaseSound[]}\r\n         * @default []\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.sounds=[];/**\r\n         * Global mute setting.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#mute\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.mute=false;/**\r\n         * Global volume setting.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#volume\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.volume=1;/**\r\n         * Flag indicating if sounds should be paused when game looses focus,\r\n         * for instance when user switches to another tab/program/app.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#pauseOnBlur\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.pauseOnBlur=true;game.events.on('blur',function(){if(this.pauseOnBlur){this.onBlur();}},this);game.events.on('focus',function(){if(this.pauseOnBlur){this.onFocus();}},this);game.events.once('destroy',this.destroy,this);/**\r\n         * Property that actually holds the value of global playback rate.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#_rate\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this._rate=1;/**\r\n         * Property that actually holds the value of global detune.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#_detune\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._detune=0;/**\r\n         * Mobile devices require sounds to be triggered from an explicit user action,\r\n         * such as a tap, before any sound can be loaded/played on a web page.\r\n         * Set to true if the audio system is currently locked awaiting user interaction.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#locked\r\n         * @type {boolean}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.locked=this.locked||false;/**\r\n         * Flag used internally for handling when the audio system\r\n         * has been unlocked, if there ever was a need for it.\r\n         *\r\n         * @name Phaser.Sound.BaseSoundManager#unlocked\r\n         * @type {boolean}\r\n         * @default false\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.unlocked=false;if(this.locked){this.unlock();}},/**\r\n     * Adds a new sound into the sound manager.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#add\r\n     * @override\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - Asset key for the sound.\r\n     * @param {SoundConfig} [config] - An optional config object containing default sound settings.\r\n     *\r\n     * @return {Phaser.Sound.BaseSound} The new sound instance.\r\n     */add:NOOP,/**\r\n     * Adds a new audio sprite sound into the sound manager.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#addAudioSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - Asset key for the sound.\r\n     * @param {SoundConfig} [config] - An optional config object containing default sound settings.\r\n     *\r\n     * @return {AudioSpriteSound} The new audio sprite sound instance.\r\n     */addAudioSprite:function addAudioSprite(key,config){var sound=this.add(key,config);sound.spritemap=this.game.cache.json.get(key).spritemap;for(var markerName in sound.spritemap){if(!sound.spritemap.hasOwnProperty(markerName)){continue;}var marker=sound.spritemap[markerName];sound.addMarker({name:markerName,start:marker.start,duration:marker.end-marker.start,config:config});}return sound;},/**\r\n     * Enables playing sound on the fly without the need to keep a reference to it.\r\n     * Sound will auto destroy once its playback ends.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#play\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - Asset key for the sound.\r\n     * @param {(SoundConfig|SoundMarker)} [extra] - An optional additional object containing settings to be applied to the sound. It could be either config or marker object.\r\n     *\r\n     * @return {boolean} Whether the sound started playing successfully.\r\n     */play:function play(key,extra){var sound=this.add(key);sound.once('ended',sound.destroy,sound);if(extra){if(extra.name){sound.addMarker(extra);return sound.play(extra.name);}else{return sound.play(extra);}}else{return sound.play();}},/**\r\n     * Enables playing audio sprite sound on the fly without the need to keep a reference to it.\r\n     * Sound will auto destroy once its playback ends.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#playAudioSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - Asset key for the sound.\r\n     * @param {string} spriteName - The name of the sound sprite to play.\r\n     * @param {SoundConfig} [config] - An optional config object containing default sound settings.\r\n     *\r\n     * @return {boolean} Whether the audio sprite sound started playing successfully.\r\n     */playAudioSprite:function playAudioSprite(key,spriteName,config){var sound=this.addAudioSprite(key);sound.once('ended',sound.destroy,sound);return sound.play(spriteName,config);},/**\r\n     * Removes a sound from the sound manager.\r\n     * The removed sound is destroyed before removal.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Sound.BaseSound} sound - The sound object to remove.\r\n     *\r\n     * @return {boolean} True if the sound was removed successfully, otherwise false.\r\n     */remove:function remove(sound){var index=this.sounds.indexOf(sound);if(index!==-1){sound.destroy();this.sounds.splice(index,1);return true;}return false;},/**\r\n     * Removes all sounds from the sound manager that have an asset key matching the given value.\r\n     * The removed sounds are destroyed before removal.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#removeByKey\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to match when removing sound objects.\r\n     *\r\n     * @return {number} The number of matching sound objects that were removed.\r\n     */removeByKey:function removeByKey(key){var removed=0;for(var i=this.sounds.length-1;i>=0;i--){var sound=this.sounds[i];if(sound.key===key){sound.destroy();this.sounds.splice(i,1);removed++;}}return removed;},/**\r\n     * @event Phaser.Sound.BaseSoundManager#pauseall\r\n     * @param {Phaser.Sound.BaseSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     *//**\r\n     * Pauses all the sounds in the game.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#pauseAll\r\n     * @fires Phaser.Sound.BaseSoundManager#pauseall\r\n     * @since 3.0.0\r\n     */pauseAll:function pauseAll(){this.forEachActiveSound(function(sound){sound.pause();});this.emit('pauseall',this);},/**\r\n     * @event Phaser.Sound.BaseSoundManager#resumeall\r\n     * @param {Phaser.Sound.BaseSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     *//**\r\n     * Resumes all the sounds in the game.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#resumeAll\r\n     * @fires Phaser.Sound.BaseSoundManager#resumeall\r\n     * @since 3.0.0\r\n     */resumeAll:function resumeAll(){this.forEachActiveSound(function(sound){sound.resume();});this.emit('resumeall',this);},/**\r\n     * @event Phaser.Sound.BaseSoundManager#stopall\r\n     * @param {Phaser.Sound.BaseSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     *//**\r\n     * Stops all the sounds in the game.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#stopAll\r\n     * @fires Phaser.Sound.BaseSoundManager#stopall\r\n     * @since 3.0.0\r\n     */stopAll:function stopAll(){this.forEachActiveSound(function(sound){sound.stop();});this.emit('stopall',this);},/**\r\n     * Method used internally for unlocking audio playback on devices that\r\n     * require user interaction before any sound can be played on a web page.\r\n     *\r\n     * Read more about how this issue is handled here in [this article](https://medium.com/@pgoloskokovic/unlocking-web-audio-the-smarter-way-8858218c0e09).\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#unlock\r\n     * @override\r\n     * @protected\r\n     * @since 3.0.0\r\n     */unlock:NOOP,/**\r\n     * Method used internally for pausing sound manager if\r\n     * Phaser.Sound.BaseSoundManager#pauseOnBlur is set to true.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#onBlur\r\n     * @override\r\n     * @protected\r\n     * @since 3.0.0\r\n     */onBlur:NOOP,/**\r\n     * Method used internally for resuming sound manager if\r\n     * Phaser.Sound.BaseSoundManager#pauseOnBlur is set to true.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#onFocus\r\n     * @override\r\n     * @protected\r\n     * @since 3.0.0\r\n     */onFocus:NOOP,/**\r\n     * Update method called on every game step.\r\n     * Removes destroyed sounds and updates every active sound in the game.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#update\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */update:function update(time,delta){if(this.unlocked){this.unlocked=false;this.locked=false;/**\r\n             * @event Phaser.Sound.BaseSoundManager#unlocked\r\n             * @param {Phaser.Sound.BaseSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n             */this.emit('unlocked',this);}for(var i=this.sounds.length-1;i>=0;i--){if(this.sounds[i].pendingRemove){this.sounds.splice(i,1);}}this.sounds.forEach(function(sound){sound.update(time,delta);});},/**\r\n     * Destroys all the sounds in the game and all associated events.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.removeAllListeners();this.forEachActiveSound(function(sound){sound.destroy();});this.sounds.length=0;this.sounds=null;this.game=null;},/**\r\n     * Method used internally for iterating only over active sounds and skipping sounds that are marked for removal.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#forEachActiveSound\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachActiveSoundCallback} callback - Callback function. (sound: ISound, index: number, array: ISound[]) => void\r\n     * @param {*} [scope] - Callback context.\r\n     */forEachActiveSound:function forEachActiveSound(callback,scope){var _this=this;this.sounds.forEach(function(sound,index){if(!sound.pendingRemove){callback.call(scope||_this,sound,index,_this.sounds);}});},/**\r\n     * @event Phaser.Sound.BaseSoundManager#rate\r\n     * @param {Phaser.Sound.BaseSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.BaseSoundManager#rate property.\r\n     *//**\r\n     * Sets the global playback rate at which all the sounds will be played.\r\n     * \r\n     * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed\r\n     * and 2.0 doubles the audios playback speed.\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#setRate\r\n     * @fires Phaser.Sound.BaseSoundManager#rate\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} value - Global playback rate at which all the sounds will be played.\r\n     *\r\n     * @return {Phaser.Sound.BaseSoundManager} This Sound Manager.\r\n     */setRate:function setRate(value){this.rate=value;return this;},/**\r\n     * Global playback rate at which all the sounds will be played.\r\n     * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed\r\n     * and 2.0 doubles the audio's playback speed.\r\n     *\r\n     * @name Phaser.Sound.BaseSoundManager#rate\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */rate:{get:function get(){return this._rate;},set:function set(value){this._rate=value;this.forEachActiveSound(function(sound){sound.calculateRate();});this.emit('rate',this,value);}},/**\r\n     * Sets the global detuning of all sounds in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).\r\n     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @method Phaser.Sound.BaseSoundManager#setDetune\r\n     * @fires Phaser.Sound.BaseSoundManager#detune\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} value - The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @return {Phaser.Sound.BaseSoundManager} This Sound Manager.\r\n     */setDetune:function setDetune(value){this.detune=value;return this;},/**\r\n     * @event Phaser.Sound.BaseSoundManager#detune\r\n     * @param {Phaser.Sound.BaseSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.BaseSoundManager#detune property.\r\n     *//**\r\n     * Global detuning of all sounds in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).\r\n     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @name Phaser.Sound.BaseSoundManager#detune\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */detune:{get:function get(){return this._detune;},set:function set(value){this._detune=value;this.forEachActiveSound(function(sound){sound.calculateRate();});this.emit('detune',this,value);}}});module.exports=BaseSoundManager;/***/},/* 104 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var OS=__webpack_require__(77);/**\r\n * Determines the browser type and version running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.browser` from within any Scene.\r\n * \r\n * @typedef {object} Phaser.Device.Browser\r\n * @since 3.0.0\r\n * \r\n * @property {boolean} chrome - Set to true if running in Chrome.\r\n * @property {boolean} edge - Set to true if running in Microsoft Edge browser.\r\n * @property {boolean} firefox - Set to true if running in Firefox.\r\n * @property {boolean} ie - Set to true if running in Internet Explorer 11 or less (not Edge).\r\n * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.\r\n * @property {boolean} opera - Set to true if running in Opera.\r\n * @property {boolean} safari - Set to true if running in Safari.\r\n * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)\r\n * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)\r\n * @property {number} chromeVersion - If running in Chrome this will contain the major version number.\r\n * @property {number} firefoxVersion - If running in Firefox this will contain the major version number.\r\n * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Browser.trident and Browser.tridentVersion.\r\n * @property {number} safariVersion - If running in Safari this will contain the major version number.\r\n * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}\r\n */var Browser={chrome:false,chromeVersion:0,edge:false,firefox:false,firefoxVersion:0,ie:false,ieVersion:0,mobileSafari:false,opera:false,safari:false,safariVersion:0,silk:false,trident:false,tridentVersion:0};function init(){var ua=navigator.userAgent;if(/Edge\\/\\d+/.test(ua)){Browser.edge=true;}else if(/Chrome\\/(\\d+)/.test(ua)&&!OS.windowsPhone){Browser.chrome=true;Browser.chromeVersion=parseInt(RegExp.$1,10);}else if(/Firefox\\D+(\\d+)/.test(ua)){Browser.firefox=true;Browser.firefoxVersion=parseInt(RegExp.$1,10);}else if(/AppleWebKit/.test(ua)&&OS.iOS){Browser.mobileSafari=true;}else if(/MSIE (\\d+\\.\\d+);/.test(ua)){Browser.ie=true;Browser.ieVersion=parseInt(RegExp.$1,10);}else if(/Opera/.test(ua)){Browser.opera=true;}else if(/Safari/.test(ua)&&!OS.windowsPhone){Browser.safari=true;}else if(/Trident\\/(\\d+\\.\\d+)(.*)rv:(\\d+\\.\\d+)/.test(ua)){Browser.ie=true;Browser.trident=true;Browser.tridentVersion=parseInt(RegExp.$1,10);Browser.ieVersion=parseInt(RegExp.$3,10);}//  Silk gets its own if clause because its ua also contains 'Safari'\nif(/Silk/.test(ua)){Browser.silk=true;}return Browser;}module.exports=init();/***/},/* 105 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GameObject=__webpack_require__(1);var Sprite=__webpack_require__(41);var Vector2=__webpack_require__(6);var Vector4=__webpack_require__(159);/**\r\n * @classdesc\r\n * A Sprite 3D Game Object.\r\n *\r\n * The Sprite 3D object is an encapsulation of a standard Sprite object, with additional methods to allow\r\n * it to be rendered by a 3D Camera. The Sprite can be positioned anywhere within 3D space.\r\n *\r\n * @class Sprite3D\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The x position of this Game Object.\r\n * @param {number} y - The y position of this Game Object.\r\n * @param {number} z - The z position of this Game Object.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var Sprite3D=new Class({Extends:GameObject,initialize:function Sprite3D(scene,x,y,z,texture,frame){GameObject.call(this,scene,'Sprite3D');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Sprite3D#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */this.gameObject=new Sprite(scene,0,0,texture,frame);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Sprite3D#position\r\n         * @type {Phaser.Math.Vector4}\r\n         * @since 3.0.0\r\n         */this.position=new Vector4(x,y,z);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Sprite3D#size\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.size=new Vector2(this.gameObject.width,this.gameObject.height);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Sprite3D#scale\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.scale=new Vector2(1,1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Sprite3D#adjustScaleX\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.adjustScaleX=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Sprite3D#adjustScaleY\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.adjustScaleY=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Sprite3D#_visible\r\n         * @type {boolean}\r\n         * @default true\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._visible=true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Sprite3D#project\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Sprite3D.Camera} camera - The 3D Camera onto which to project this Sprite.\r\n     */project:function project(camera){var pos=this.position;var gameObject=this.gameObject;camera.project(pos,gameObject);camera.getPointSize(pos,this.size,this.scale);if(this.scale.x<=0||this.scale.y<=0){gameObject.setVisible(false);}else{if(!gameObject.visible){gameObject.setVisible(true);}if(this.adjustScaleX){gameObject.scaleX=this.scale.x;}if(this.adjustScaleY){gameObject.scaleY=this.scale.y;}gameObject.setDepth(gameObject.z*-1);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Sprite3D#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D} This Sprite3D Object.\r\n     */setVisible:function setVisible(value){this.visible=value;return this;},/**\r\n     * The visible state of the Game Object.\r\n     *\r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     *\r\n     * @name Phaser.GameObjects.Sprite3D#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */visible:{get:function get(){return this._visible;},set:function set(value){this._visible=value;this.gameObject.visible=value;}},/**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Sprite3D#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */x:{get:function get(){return this.position.x;},set:function set(value){this.position.x=value;}},/**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Sprite3D#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */y:{get:function get(){return this.position.y;},set:function set(value){this.position.y=value;}},/**\r\n     * The z position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Sprite3D#z\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */z:{get:function get(){return this.position.z;},set:function set(value){this.position.z=value;}}});module.exports=Sprite3D;/***/},/* 106 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Shuffles the contents of the given array using the Fisher-Yates implementation.\r\n *\r\n * The original array is modified directly and returned.\r\n *\r\n * @function Phaser.Utils.Array.Shuffle\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to shuffle. This array is modified in place.\r\n *\r\n * @return {array} The shuffled array.\r\n */var Shuffle=function Shuffle(array){for(var i=array.length-1;i>0;i--){var j=Math.floor(Math.random()*(i+1));var temp=array[i];array[i]=array[j];array[j]=temp;}return array;};module.exports=Shuffle;/***/},/* 107 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @callback DataEachCallback\r\n *\r\n * @param {*} parent - The parent object of the DataManager.\r\n * @param {string} key - The key of the value.\r\n * @param {*} value - The value.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\r\n *//**\r\n * @classdesc\r\n * The Data Component features a means to store pieces of data specific to a Game Object, System or Plugin.\r\n * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,\r\n * or have a property called `events` that is an instance of it.\r\n *\r\n * @class DataManager\r\n * @memberOf Phaser.Data\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} parent - The object that this DataManager belongs to.\r\n * @param {Phaser.Events.EventEmitter} eventEmitter - The DataManager's event emitter.\r\n */var DataManager=new Class({initialize:function DataManager(parent,eventEmitter){/**\r\n         * The object that this DataManager belongs to.\r\n         *\r\n         * @name Phaser.Data.DataManager#parent\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */this.parent=parent;/**\r\n         * The DataManager's event emitter.\r\n         *\r\n         * @name Phaser.Data.DataManager#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */this.events=eventEmitter;if(!eventEmitter){this.events=parent.events?parent.events:parent;}/**\r\n         * The data list.\r\n         *\r\n         * @name Phaser.Data.DataManager#list\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */this.list={};/**\r\n         * Whether setting data is blocked for this DataManager.\r\n         *\r\n         * Used temporarily to allow 'changedata' event listeners to prevent\r\n         * specific data from being set.\r\n         *\r\n         * @name Phaser.Data.DataManager#blockSet\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.blockSet=false;/**\r\n         * Whether setting data is frozen for this DataManager.\r\n         *\r\n         * @name Phaser.Data.DataManager#_frozen\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this._frozen=false;this.events.once('destroy',this.destroy,this);},/**\r\n     * Retrieves the value for the given key, or undefined if it doesn't exist.\r\n     *\r\n     * @method Phaser.Data.DataManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the value to retrieve.\r\n     *\r\n     * @return {*} The value belonging to the given key.\r\n     */get:function get(key){return this.list[key];},/**\r\n     * Retrieves all data values.\r\n     *\r\n     * @method Phaser.Data.DataManager#getAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Object.<string, *>} All data values.\r\n     */getAll:function getAll(){var results={};for(var key in this.list){if(this.list.hasOwnProperty(key)){results[key]=this.list[key];}}return results;},/**\r\n     * Queries the DataManager for the values of keys matching the given search string.\r\n     *\r\n     * @method Phaser.Data.DataManager#query\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} search - The search string.\r\n     *\r\n     * @return {Object.<string, *>} The values of the keys matching the search string.\r\n     */query:function query(search){var results={};for(var key in this.list){if(this.list.hasOwnProperty(key)&&key.match(search)){results[key]=this.list[key];}}return results;},/**\r\n     * Sets the value for the given key.\r\n     *\r\n     * Emits the 'changedata' and 'setdata' events.\r\n     *\r\n     * @method Phaser.Data.DataManager#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to set the value for.\r\n     * @param {*} data - The value to set.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */set:function set(key,data){if(this._frozen){return this;}if(this.events.listenerCount('changedata')>0){this.blockSet=false;var _this=this;var resetFunction=function resetFunction(value){_this.blockSet=true;_this.list[key]=value;_this.events.emit('setdata',_this.parent,key,value);};this.events.emit('changedata',this.parent,key,data,resetFunction);//  One of the listeners blocked this update from being set, so abort\nif(this.blockSet){return this;}}this.list[key]=data;this.events.emit('setdata',this.parent,key,data);return this;},/**\r\n     * Passes all data entries to the given callback. Stores the result of the callback.\r\n     *\r\n     * @method Phaser.Data.DataManager#each\r\n     * @since 3.0.0\r\n     *\r\n     * @param {DataEachCallback} callback - The function to call.\r\n     * @param {*} [scope] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */each:function each(callback,scope){var args=[this.parent,null,undefined];for(var i=1;i<arguments.length;i++){args.push(arguments[i]);}for(var key in this.list){args[1]=key;args[2]=this.list[key];callback.apply(scope,args);}return this;},/**\r\n     * Merge the given data object into this DataManager's data object.\r\n     *\r\n     * @method Phaser.Data.DataManager#merge\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Object.<string, *>} data - The data to merge.\r\n     * @param {boolean} overwrite - Whether to overwrite existing data. Defaults to true.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */merge:function merge(data,overwrite){if(overwrite===undefined){overwrite=true;}//  Merge data from another component into this one\nfor(var key in data){if(data.hasOwnProperty(key)&&(overwrite||!overwrite&&!this.has(key))){this.list[key]=data[key];}}return this;},/**\r\n     * Remove the value for the given key.\r\n     *\r\n     * @method Phaser.Data.DataManager#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to remove\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */remove:function remove(key){if(!this._frozen&&this.has(key)){var data=this.list[key];delete this.list[key];this.events.emit('removedata',this,key,data);}return this;},/**\r\n     * Retrieves the data associated with the given 'key', deletes it from this Data store, then returns it.\r\n     *\r\n     * @method Phaser.Data.DataManager#pop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the value to retrieve and delete.\r\n     *\r\n     * @return {*} The value of the given key.\r\n     */pop:function pop(key){var data=undefined;if(!this._frozen&&this.has(key)){data=this.list[key];delete this.list[key];this.events.emit('removedata',this,key,data);}return data;},/**\r\n     * Determines whether the given key is set in this Data store.\r\n     *\r\n     * @method Phaser.Data.DataManager#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check.\r\n     *\r\n     * @return {boolean} Whether the key is set.\r\n     */has:function has(key){return this.list.hasOwnProperty(key);},/**\r\n     * Freeze or unfreeze this Data store, to allow or prevent setting its values.\r\n     *\r\n     * @method Phaser.Data.DataManager#setFreeze\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Whether to freeze the Data store.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */setFreeze:function setFreeze(value){this._frozen=value;return this;},/**\r\n     * Delete all data in this Data store and unfreeze it.\r\n     *\r\n     * @method Phaser.Data.DataManager#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */reset:function reset(){for(var key in this.list){delete this.list[key];}this.blockSet=false;this._frozen=false;return this;},/**\r\n     * Destroy this data manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.reset();this.events.off('changedata');this.events.off('setdata');this.events.off('removedata');this.parent=null;},/**\r\n     * Freeze this Data component, so no values can be set.\r\n     *\r\n     * @name Phaser.Data.DataManager#freeze\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */freeze:{get:function get(){return this._frozen;},set:function set(value){this._frozen=value?true:false;}},/**\r\n     * Return the total number of entries in this Data component.\r\n     *\r\n     * @name Phaser.Data.DataManager#count\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */count:{get:function get(){var i=0;for(var key in this.list){if(this.list[key]!==undefined){i++;}}return i;}}});module.exports=DataManager;/***/},/* 108 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetPoint=__webpack_require__(364);var GetPoints=__webpack_require__(172);var Random=__webpack_require__(171);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * Defines a Line segment, a part of a line between two endpoints.\r\n *\r\n * @class Line\r\n * @memberOf Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x1=0] - [description]\r\n * @param {number} [y1=0] - [description]\r\n * @param {number} [x2=0] - [description]\r\n * @param {number} [y2=0] - [description]\r\n */var Line=new Class({initialize:function Line(x1,y1,x2,y2){if(x1===undefined){x1=0;}if(y1===undefined){y1=0;}if(x2===undefined){x2=0;}if(y2===undefined){y2=0;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Line#x1\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.x1=x1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Line#y1\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.y1=y1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Line#x2\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.x2=x2;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Geom.Line#y2\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.y2=y2;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Line#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [output,$return]\r\n     *\r\n     * @param {float} position - [description]\r\n     * @param {(Phaser.Geom.Point|object)} [output] - [description]\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the ellipse.\r\n     */getPoint:function getPoint(position,output){return GetPoint(this,position,output);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Line#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [output,$return]\r\n     *\r\n     * @param {integer} quantity - [description]\r\n     * @param {integer} [stepRate] - [description]\r\n     * @param {(array|Phaser.Geom.Point[])} [output] - [description]\r\n     *\r\n     * @return {(array|Phaser.Geom.Point[])} [description]\r\n     */getPoints:function getPoints(quantity,stepRate,output){return GetPoints(this,quantity,stepRate,output);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Line#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [point,$return]\r\n     *\r\n     * @param {(Phaser.Geom.Point|object)} [point] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Point} [description]\r\n     */getRandomPoint:function getRandomPoint(point){return Random(this,point);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Line#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x1=0] - [description]\r\n     * @param {number} [y1=0] - [description]\r\n     * @param {number} [x2=0] - [description]\r\n     * @param {number} [y2=0] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Line} This Line object.\r\n     */setTo:function setTo(x1,y1,x2,y2){if(x1===undefined){x1=0;}if(y1===undefined){y1=0;}if(x2===undefined){x2=0;}if(y2===undefined){y2=0;}this.x1=x1;this.y1=y1;this.x2=x2;this.y2=y2;return this;},/**\r\n     * Returns a Vector2 object that corresponds to the start of this Line.\r\n     *\r\n     * @method Phaser.Geom.Line#getPointA\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [vec2,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} A Vector2 object that corresponds to the start of this Line.\r\n     */getPointA:function getPointA(vec2){if(vec2===undefined){vec2=new Vector2();}vec2.set(this.x1,this.y1);return vec2;},/**\r\n     * Returns a Vector2 object that corresponds to the start of this Line.\r\n     *\r\n     * @method Phaser.Geom.Line#getPointB\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [vec2,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} A Vector2 object that corresponds to the start of this Line.\r\n     */getPointB:function getPointB(vec2){if(vec2===undefined){vec2=new Vector2();}vec2.set(this.x2,this.y2);return vec2;},/**\r\n     * The left position of the Line.\r\n     *\r\n     * @name Phaser.Geom.Line#left\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */left:{get:function get(){return Math.min(this.x1,this.x2);},set:function set(value){if(this.x1<=this.x2){this.x1=value;}else{this.x2=value;}}},/**\r\n     * The right position of the Line.\r\n     *\r\n     * @name Phaser.Geom.Line#right\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */right:{get:function get(){return Math.max(this.x1,this.x2);},set:function set(value){if(this.x1>this.x2){this.x1=value;}else{this.x2=value;}}},/**\r\n     * The top position of the Line.\r\n     *\r\n     * @name Phaser.Geom.Line#top\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */top:{get:function get(){return Math.min(this.y1,this.y2);},set:function set(value){if(this.y1<=this.y2){this.y1=value;}else{this.y2=value;}}},/**\r\n     * The bottom position of the Line.\r\n     *\r\n     * @name Phaser.Geom.Line#bottom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottom:{get:function get(){return Math.max(this.y1,this.y2);},set:function set(value){if(this.y1>this.y2){this.y1=value;}else{this.y2=value;}}}});module.exports=Line;/***/},/* 109 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Perimeter\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {number} [description]\r\n */var Perimeter=function Perimeter(rect){return 2*(rect.width+rect.height);};module.exports=Perimeter;/***/},/* 110 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BlendModes=__webpack_require__(64);var Circle=__webpack_require__(81);var CircleContains=__webpack_require__(28);var Class=__webpack_require__(0);var Components=__webpack_require__(12);var GameObject=__webpack_require__(1);var Rectangle=__webpack_require__(10);var RectangleContains=__webpack_require__(27);/**\r\n * @classdesc\r\n * A Zone Game Object.\r\n *\r\n * A Zone is a non-rendering rectangular Game Object that has a position and size.\r\n * It has no texture and never displays, but does live on the display list and\r\n * can be moved, scaled and rotated like any other Game Object.\r\n *\r\n * Its primary use is for creating Drop Zones and Input Hit Areas and it has a couple of helper methods\r\n * specifically for this. It is also useful for object overlap checks, or as a base for your own\r\n * non-displaying Game Objects.\r\n\r\n * The default origin is 0.5, the center of the Zone, the same as with Game Objects.\r\n *\r\n * @class Zone\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} [width=1] - The width of the Game Object.\r\n * @param {number} [height=1] - The height of the Game Object.\r\n */var Zone=new Class({Extends:GameObject,Mixins:[Components.Depth,Components.GetBounds,Components.Origin,Components.ScaleMode,Components.Transform,Components.ScrollFactor,Components.Visible],initialize:function Zone(scene,x,y,width,height){if(width===undefined){width=1;}if(height===undefined){height=width;}GameObject.call(this,scene,'Zone');this.setPosition(x,y);/**\r\n         * The native (un-scaled) width of this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.Zone#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=width;/**\r\n         * The native (un-scaled) height of this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.Zone#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=height;/**\r\n         * The Blend Mode of the Game Object.\r\n         * Although a Zone never renders, it still has a blend mode to allow it to fit seamlessly into\r\n         * display lists without causing a batch flush.\r\n         *\r\n         * @name Phaser.GameObjects.Zone#blendMode\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.blendMode=BlendModes.NORMAL;},/**\r\n     * The displayed width of this Game Object.\r\n     * This value takes into account the scale factor.\r\n     *\r\n     * @name Phaser.GameObjects.Zone#displayWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */displayWidth:{get:function get(){return this.scaleX*this.width;},set:function set(value){this.scaleX=value/this.width;}},/**\r\n     * The displayed height of this Game Object.\r\n     * This value takes into account the scale factor.\r\n     *\r\n     * @name Phaser.GameObjects.Zone#displayHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */displayHeight:{get:function get(){return this.scaleY*this.height;},set:function set(value){this.scaleY=value/this.height;}},/**\r\n     * Sets the size of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * @param {boolean} [resizeInput=true] - If this Zone has a Rectangle for a hit area this argument will resize the hit area as well.\r\n     *\r\n     * @return {Phaser.GameObjects.Zone} This Game Object.\r\n     */setSize:function setSize(width,height,resizeInput){if(resizeInput===undefined){resizeInput=true;}this.width=width;this.height=height;if(resizeInput&&this.input&&this.input.hitArea instanceof Rectangle){this.input.hitArea.width=width;this.input.hitArea.height=height;}return this;},/**\r\n     * Sets the display size of this Game Object.\r\n     * Calling this will adjust the scale.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setDisplaySize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.Zone} This Game Object.\r\n     */setDisplaySize:function setDisplaySize(width,height){this.displayWidth=width;this.displayHeight=height;return this;},/**\r\n     * Sets this Zone to be a Circular Drop Zone.\r\n     * The circle is centered on this Zones `x` and `y` coordinates.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setCircleDropZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the Circle that will form the Drop Zone.\r\n     *\r\n     * @return {Phaser.GameObjects.Zone} This Game Object.\r\n     */setCircleDropZone:function setCircleDropZone(radius){return this.setDropZone(new Circle(0,0,radius),CircleContains);},/**\r\n     * Sets this Zone to be a Rectangle Drop Zone.\r\n     * The rectangle is centered on this Zones `x` and `y` coordinates.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setRectangleDropZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of the rectangle drop zone.\r\n     * @param {number} height - The height of the rectangle drop zone.\r\n     *\r\n     * @return {Phaser.GameObjects.Zone} This Game Object.\r\n     */setRectangleDropZone:function setRectangleDropZone(width,height){var x=-(width/2);var y=-(height/2);return this.setDropZone(new Rectangle(x,y,width,height),RectangleContains);},/**\r\n     * Allows you to define your own Geometry shape to be used as a Drop Zone.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setDropZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} shape - A Geometry shape instance, such as Phaser.Geom.Ellipse, or your own custom shape.\r\n     * @param {HitAreaCallback} callback - A function that will return `true` if the given x/y coords it is sent are within the shape.\r\n     *\r\n     * @return {Phaser.GameObjects.Zone} This Game Object.\r\n     */setDropZone:function setDropZone(shape,callback){if(shape===undefined){this.setRectangleDropZone(this.width,this.height);}else if(!this.input){this.setInteractive(shape,callback,true);}return this;},/**\r\n     * A Zone does not render.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#renderCanvas\r\n     * @private\r\n     * @since 3.0.0\r\n     */renderCanvas:function renderCanvas(){},/**\r\n     * A Zone does not render.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#renderWebGL\r\n     * @private\r\n     * @since 3.0.0\r\n     */renderWebGL:function renderWebGL(){}});module.exports=Zone;/***/},/* 111 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Utils=__webpack_require__(38);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class WebGLPipeline\r\n * @memberOf Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n */var WebGLPipeline=new Class({initialize:function WebGLPipeline(config){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.name='WebGLPipeline';/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game=config.game;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#view\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */this.view=config.game.canvas;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#resolution\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.resolution=config.game.config.resolution;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=config.game.config.width*this.resolution;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=config.game.config.height*this.resolution;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.0.0\r\n         */this.gl=config.gl;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexCount\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.vertexCount=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexCapacity\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.vertexCapacity=config.vertexCapacity;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#renderer\r\n         * @type {Phaser.Renderer.WebGL.WebGLRenderer}\r\n         * @since 3.0.0\r\n         */this.renderer=config.renderer;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexData\r\n         * @type {ArrayBuffer}\r\n         * @since 3.0.0\r\n         */this.vertexData=config.vertices?config.vertices:new ArrayBuffer(config.vertexCapacity*config.vertexSize);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @since 3.0.0\r\n         */this.vertexBuffer=this.renderer.createVertexBuffer(config.vertices?config.vertices:this.vertexData.byteLength,this.gl.STREAM_DRAW);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#program\r\n         * @type {WebGLProgram}\r\n         * @since 3.0.0\r\n         */this.program=this.renderer.createProgram(config.vertShader,config.fragShader);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#attributes\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.attributes=config.attributes;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexSize\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.vertexSize=config.vertexSize;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#topology\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.topology=config.topology;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#bytes\r\n         * @type {Uint8Array}\r\n         * @since 3.0.0\r\n         */this.bytes=new Uint8Array(this.vertexData);/**\r\n         * This will store the amount of components of 32 bit length\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexComponentCount\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.vertexComponentCount=Utils.getComponentCount(config.attributes,this.gl);/**\r\n         * Indicates if the current pipeline is flushing the contents to the GPU.\r\n         * When the variable is set the flush function will be locked.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#flushLocked\r\n         * @type {boolean}\r\n         * @since 3.1.0\r\n         */this.flushLocked=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#addAttribute\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {integer} size - [description]\r\n     * @param {integer} type - [description]\r\n     * @param {boolean} normalized - [description]\r\n     * @param {integer} offset - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */addAttribute:function addAttribute(name,size,type,normalized,offset){this.attributes.push({name:name,size:size,type:this.renderer.glFormats[type],normalized:normalized,offset:offset});return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#shouldFlush\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */shouldFlush:function shouldFlush(){return this.vertexCount>=this.vertexCapacity;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} resolution - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */resize:function resize(width,height,resolution){this.width=width*resolution;this.height=height*resolution;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#bind\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */bind:function bind(){var gl=this.gl;var vertexBuffer=this.vertexBuffer;var attributes=this.attributes;var program=this.program;var renderer=this.renderer;var vertexSize=this.vertexSize;renderer.setProgram(program);renderer.setVertexBuffer(vertexBuffer);for(var index=0;index<attributes.length;++index){var element=attributes[index];var location=gl.getAttribLocation(program,element.name);if(location>=0){gl.enableVertexAttribArray(location);gl.vertexAttribPointer(location,element.size,element.type,element.normalized,vertexSize,element.offset);}else{gl.disableVertexAttribArray(location);}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onBind\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */onBind:function onBind(){// This is for updating uniform data it's called on each bind attempt.\nreturn this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onPreRender\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */onPreRender:function onPreRender(){// called once every frame\nreturn this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */onRender:function onRender(){// called for each camera\nreturn this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onPostRender\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */onPostRender:function onPostRender(){// called once every frame\nreturn this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#flush\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */flush:function flush(){if(this.flushLocked){return this;}this.flushLocked=true;var gl=this.gl;var vertexCount=this.vertexCount;var topology=this.topology;var vertexSize=this.vertexSize;if(vertexCount===0){this.flushLocked=false;return;}gl.bufferSubData(gl.ARRAY_BUFFER,0,this.bytes.subarray(0,vertexCount*vertexSize));gl.drawArrays(topology,0,vertexCount);this.vertexCount=0;this.flushLocked=false;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */destroy:function destroy(){var gl=this.gl;gl.deleteProgram(this.program);gl.deleteBuffer(this.vertexBuffer);delete this.program;delete this.vertexBuffer;delete this.gl;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat1\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {float} x - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setFloat1:function setFloat1(name,x){this.renderer.setFloat1(this.program,name,x);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat2\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {float} x - [description]\r\n     * @param {float} y - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setFloat2:function setFloat2(name,x,y){this.renderer.setFloat2(this.program,name,x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat3\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {float} x - [description]\r\n     * @param {float} y - [description]\r\n     * @param {float} z - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setFloat3:function setFloat3(name,x,y,z){this.renderer.setFloat3(this.program,name,x,y,z);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setFloat4\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {float} x - [description]\r\n     * @param {float} y - [description]\r\n     * @param {float} z - [description]\r\n     * @param {float} w - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setFloat4:function setFloat4(name,x,y,z,w){this.renderer.setFloat4(this.program,name,x,y,z,w);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setInt1\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {integer} x - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setInt1:function setInt1(name,x){this.renderer.setInt1(this.program,name,x);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setInt2\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {integer} x - [description]\r\n     * @param {integer} y - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setInt2:function setInt2(name,x,y){this.renderer.setInt2(this.program,name,x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setInt3\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {integer} x - [description]\r\n     * @param {integer} y - [description]\r\n     * @param {integer} z - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setInt3:function setInt3(name,x,y,z){this.renderer.setInt3(this.program,name,x,y,z);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setInt4\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {integer} x - [description]\r\n     * @param {integer} y - [description]\r\n     * @param {integer} z - [description]\r\n     * @param {integer} w - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setInt4:function setInt4(name,x,y,z,w){this.renderer.setInt4(this.program,name,x,y,z,w);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix2\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {boolean} transpose - [description]\r\n     * @param {Float32Array} matrix - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setMatrix2:function setMatrix2(name,transpose,matrix){this.renderer.setMatrix2(this.program,name,transpose,matrix);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix3\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {boolean} transpose - [description]\r\n     * @param {Float32Array} matrix - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setMatrix3:function setMatrix3(name,transpose,matrix){this.renderer.setMatrix3(this.program,name,transpose,matrix);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix4\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} name - [description]\r\n     * @param {boolean} transpose - [description]\r\n     * @param {Float32Array} matrix - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setMatrix4:function setMatrix4(name,transpose,matrix){this.renderer.setMatrix4(this.program,name,transpose,matrix);return this;}});module.exports=WebGLPipeline;/***/},/* 112 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} TweenDataGenConfig\r\n *\r\n * @property {function} delay - [description]\r\n * @property {function} duration - [description]\r\n * @property {function} hold - [description]\r\n * @property {function} repeat - [description]\r\n * @property {function} repeatDelay - [description]\r\n *//**\r\n * @typedef {object} Phaser.Tweens.TweenDataConfig\r\n *\r\n * @property {object} target - The target to tween.\r\n * @property {string} key - The property of the target being tweened.\r\n * @property {function} getEndValue - The returned value sets what the property will be at the END of the Tween.\r\n * @property {function} getStartValue - The returned value sets what the property will be at the START of the Tween.\r\n * @property {function} ease - The ease function this tween uses.\r\n * @property {number} [duration=0] - Duration of the tween in ms/frames, excludes time for yoyo or repeats.\r\n * @property {number} [totalDuration=0] - The total calculated duration of this TweenData (based on duration, repeat, delay and yoyo)\r\n * @property {number} [delay=0] - Time in ms/frames before tween will start.\r\n * @property {boolean} [yoyo=false] - Cause the tween to return back to its start value after hold has expired.\r\n * @property {number} [hold=0] - Time in ms/frames the tween will pause before running the yoyo or starting a repeat.\r\n * @property {integer} [repeat=0] - Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.\r\n * @property {number} [repeatDelay=0] - Time in ms/frames before the repeat will start.\r\n * @property {boolean} [flipX=false] - Automatically call toggleFlipX when the TweenData yoyos or repeats\r\n * @property {boolean} [flipY=false] - Automatically call toggleFlipY when the TweenData yoyos or repeats\r\n * @property {float} [progress=0] - Between 0 and 1 showing completion of this TweenData.\r\n * @property {float} [elapsed=0] - Delta counter\r\n * @property {integer} [repeatCounter=0] - How many repeats are left to run?\r\n * @property {number} [start=0] - Ease value data.\r\n * @property {number} [current=0] - Ease value data.\r\n * @property {number} [end=0] - Ease value data.\r\n * @property {number} [t1=0] - Time duration 1.\r\n * @property {number} [t2=0] - Time duration 2.\r\n * @property {TweenDataGenConfig} [gen] - LoadValue generation functions.\r\n * @property {integer} [state=0] - TWEEN_CONST.CREATED\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.TweenData\r\n * @since 3.0.0\r\n *\r\n * @param {object} target - [description]\r\n * @param {string} key - [description]\r\n * @param {function} getEnd - [description]\r\n * @param {function} getStart - [description]\r\n * @param {function} ease - [description]\r\n * @param {number} delay - [description]\r\n * @param {number} duration - [description]\r\n * @param {boolean} yoyo - [description]\r\n * @param {number} hold - [description]\r\n * @param {number} repeat - [description]\r\n * @param {number} repeatDelay - [description]\r\n * @param {boolean} flipX - [description]\r\n * @param {boolean} flipY - [description]\r\n *\r\n * @return {TweenDataConfig} [description]\r\n */var TweenData=function TweenData(target,key,getEnd,getStart,ease,delay,duration,yoyo,hold,repeat,repeatDelay,flipX,flipY){return{//  The target to tween\ntarget:target,//  The property of the target to tween\nkey:key,//  The returned value sets what the property will be at the END of the Tween.\ngetEndValue:getEnd,//  The returned value sets what the property will be at the START of the Tween.\ngetStartValue:getStart,//  The ease function this tween uses.\nease:ease,//  Duration of the tween in ms/frames, excludes time for yoyo or repeats.\nduration:0,//  The total calculated duration of this TweenData (based on duration, repeat, delay and yoyo)\ntotalDuration:0,//  Time in ms/frames before tween will start.\ndelay:0,//  Cause the tween to return back to its start value after hold has expired.\nyoyo:yoyo,//  Time in ms/frames the tween will pause before running the yoyo or starting a repeat.\nhold:0,//  Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.\nrepeat:0,//  Time in ms/frames before the repeat will start.\nrepeatDelay:0,//  Automatically call toggleFlipX when the TweenData yoyos or repeats\nflipX:flipX,//  Automatically call toggleFlipY when the TweenData yoyos or repeats\nflipY:flipY,//  Between 0 and 1 showing completion of this TweenData.\nprogress:0,//  Delta counter.\nelapsed:0,//  How many repeats are left to run?\nrepeatCounter:0,//  Ease Value Data:\nstart:0,current:0,end:0,//  Time Durations\nt1:0,t2:0,//  LoadValue generation functions\ngen:{delay:delay,duration:duration,hold:hold,repeat:repeat,repeatDelay:repeatDelay},//  TWEEN_CONST.CREATED\nstate:0};};module.exports=TweenData;/***/},/* 113 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GameObjectCreator=__webpack_require__(11);var GameObjectFactory=__webpack_require__(9);var TWEEN_CONST=__webpack_require__(69);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Tween\r\n * @memberOf Phaser.Tweens\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)} parent - [description]\r\n * @param {Phaser.Tweens.TweenDataConfig[]} data - [description]\r\n * @param {array} targets - [description]\r\n */var Tween=new Class({initialize:function Tween(parent,data,targets){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.Tween#parent\r\n         * @type {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)}\r\n         * @since 3.0.0\r\n         */this.parent=parent;/**\r\n         * Is the parent of this Tween a Timeline?\r\n         *\r\n         * @name Phaser.Tweens.Tween#parentIsTimeline\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.parentIsTimeline=parent.hasOwnProperty('isTimeline');/**\r\n         * An array of TweenData objects, each containing a unique property and target being tweened.\r\n         *\r\n         * @name Phaser.Tweens.Tween#data\r\n         * @type {Phaser.Tweens.TweenDataConfig[]}\r\n         * @since 3.0.0\r\n         */this.data=data;/**\r\n         * data array doesn't change, so we can cache the length\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalData\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.totalData=data.length;/**\r\n         * An array of references to the target/s this Tween is operating on\r\n         *\r\n         * @name Phaser.Tweens.Tween#targets\r\n         * @type {object[]}\r\n         * @since 3.0.0\r\n         */this.targets=targets;/**\r\n         * Cached target total (not necessarily the same as the data total)\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalTargets\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.totalTargets=targets.length;/**\r\n         * If true then duration, delay, etc values are all frame totals.\r\n         *\r\n         * @name Phaser.Tweens.Tween#useFrames\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.useFrames=false;/**\r\n         * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n         * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.\r\n         *\r\n         * @name Phaser.Tweens.Tween#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.timeScale=1;/**\r\n         * Loop this tween? Can be -1 for an infinite loop, or an integer.\r\n         * When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)\r\n         *\r\n         * @name Phaser.Tweens.Tween#loop\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.loop=0;/**\r\n         * Time in ms/frames before the tween loops.\r\n         *\r\n         * @name Phaser.Tweens.Tween#loopDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.loopDelay=0;/**\r\n         * How many loops are left to run?\r\n         *\r\n         * @name Phaser.Tweens.Tween#loopCounter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.loopCounter=0;/**\r\n         * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = -1 (as it never completes)\r\n         *\r\n         * @name Phaser.Tweens.Tween#completeDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.completeDelay=0;/**\r\n         * Countdown timer (used by timeline offset, loopDelay and completeDelay)\r\n         *\r\n         * @name Phaser.Tweens.Tween#countdown\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.countdown=0;/**\r\n         * Set only if this Tween is part of a Timeline.\r\n         *\r\n         * @name Phaser.Tweens.Tween#offset\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.offset=0;/**\r\n         * Set only if this Tween is part of a Timeline. The calculated offset amount.\r\n         *\r\n         * @name Phaser.Tweens.Tween#calculatedOffset\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.calculatedOffset=0;/**\r\n         * The current state of the tween\r\n         *\r\n         * @name Phaser.Tweens.Tween#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.state=TWEEN_CONST.PENDING_ADD;/**\r\n         * The state of the tween when it was paused (used by Resume)\r\n         *\r\n         * @name Phaser.Tweens.Tween#_pausedState\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._pausedState=TWEEN_CONST.PENDING_ADD;/**\r\n         * Does the Tween start off paused? (if so it needs to be started with Tween.play)\r\n         *\r\n         * @name Phaser.Tweens.Tween#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.paused=false;/**\r\n         * Elapsed time in ms/frames of this run through the Tween.\r\n         *\r\n         * @name Phaser.Tweens.Tween#elapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.elapsed=0;/**\r\n         * Total elapsed time in ms/frames of the entire Tween, including looping.\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalElapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.totalElapsed=0;/**\r\n         * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.\r\n         *\r\n         * @name Phaser.Tweens.Tween#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.duration=0;/**\r\n         * Value between 0 and 1. The amount through the Tween, excluding loops.\r\n         *\r\n         * @name Phaser.Tweens.Tween#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.progress=0;/**\r\n         * Time in ms/frames for the Tween to complete (including looping)\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalDuration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.totalDuration=0;/**\r\n         * Value between 0 and 1. The amount through the entire Tween, including looping.\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalProgress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.totalProgress=0;/**\r\n         * An object containing the various Tween callback references.\r\n         *\r\n         * @name Phaser.Tweens.Tween#callbacks\r\n         * @type {object}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.callbacks={onComplete:null,onLoop:null,onRepeat:null,onStart:null,onUpdate:null,onYoyo:null};this.callbackScope;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#getValue\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getValue:function getValue(){return this.data[0].current;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#setTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Tween} This Tween object.\r\n     */setTimeScale:function setTimeScale(value){this.timeScale=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#getTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getTimeScale:function getTimeScale(){return this.timeScale;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#isPlaying\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isPlaying:function isPlaying(){return this.state===TWEEN_CONST.ACTIVE;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#isPaused\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isPaused:function isPaused(){return this.state===TWEEN_CONST.PAUSED;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#hasTarget\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} target - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hasTarget:function hasTarget(target){return this.targets.indexOf(target)!==-1;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#updateTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {*} value - [description]\r\n     * @param {boolean} startToCurrent - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Tween} This Tween object.\r\n     */updateTo:function updateTo(key,value,startToCurrent){for(var i=0;i<this.totalData;i++){var tweenData=this.data[i];if(tweenData.key===key){tweenData.end=value;if(startToCurrent){tweenData.start=tweenData.current;}break;}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#restart\r\n     * @since 3.0.0\r\n     */restart:function restart(){if(this.state===TWEEN_CONST.REMOVED){this.seek(0);this.parent.makeActive(this);}else{this.stop();this.play();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#calcDuration\r\n     * @since 3.0.0\r\n     */calcDuration:function calcDuration(){var max=0;var data=this.data;for(var i=0;i<this.totalData;i++){var tweenData=data[i];//  Set t1 (duration + hold + yoyo)\ntweenData.t1=tweenData.duration+tweenData.hold;if(tweenData.yoyo){tweenData.t1+=tweenData.duration;}//  Set t2 (repeatDelay + duration + hold + yoyo)\ntweenData.t2=tweenData.t1+tweenData.repeatDelay;//  Total Duration\ntweenData.totalDuration=tweenData.delay+tweenData.t1;if(tweenData.repeat===-1){tweenData.totalDuration+=tweenData.t2*999999999999;}else if(tweenData.repeat>0){tweenData.totalDuration+=tweenData.t2*tweenData.repeat;}if(tweenData.totalDuration>max){//  Get the longest TweenData from the Tween, used to calculate the Tween TD\nmax=tweenData.totalDuration;}}//  Excludes loop values\nthis.duration=max;this.loopCounter=this.loop===-1?999999999999:this.loop;if(this.loopCounter>0){this.totalDuration=this.duration+this.completeDelay+(this.duration+this.loopDelay)*this.loopCounter;}else{this.totalDuration=this.duration+this.completeDelay;}},/**\r\n     * Called by TweenManager.preUpdate as part of its loop to check pending and active tweens.\r\n     * Should not be called directly.\r\n     *\r\n     * @method Phaser.Tweens.Tween#init\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Returns `true` if this Tween should be moved from the pending list to the active list by the Tween Manager.\r\n     */init:function init(){var data=this.data;var totalTargets=this.totalTargets;for(var i=0;i<this.totalData;i++){var tweenData=data[i];var target=tweenData.target;var gen=tweenData.gen;tweenData.delay=gen.delay(i,totalTargets,target);tweenData.duration=gen.duration(i,totalTargets,target);tweenData.hold=gen.hold(i,totalTargets,target);tweenData.repeat=gen.repeat(i,totalTargets,target);tweenData.repeatDelay=gen.repeatDelay(i,totalTargets,target);}this.calcDuration();this.progress=0;this.totalProgress=0;this.elapsed=0;this.totalElapsed=0;//  You can't have a paused Tween if it's part of a Timeline\nif(this.paused&&!this.parentIsTimeline){this.state=TWEEN_CONST.PENDING_ADD;this._pausedState=TWEEN_CONST.INIT;return false;}else{this.state=TWEEN_CONST.INIT;return true;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#nextState\r\n     * @since 3.0.0\r\n     */nextState:function nextState(){if(this.loopCounter>0){this.elapsed=0;this.progress=0;this.loopCounter--;var onLoop=this.callbacks.onLoop;if(onLoop){onLoop.params[1]=this.targets;onLoop.func.apply(onLoop.scope,onLoop.params);}this.resetTweenData(true);if(this.loopDelay>0){this.countdown=this.loopDelay;this.state=TWEEN_CONST.LOOP_DELAY;}else{this.state=TWEEN_CONST.ACTIVE;}}else if(this.completeDelay>0){this.countdown=this.completeDelay;this.state=TWEEN_CONST.COMPLETE_DELAY;}else{var onComplete=this.callbacks.onComplete;if(onComplete){onComplete.params[1]=this.targets;onComplete.func.apply(onComplete.scope,onComplete.params);}this.state=TWEEN_CONST.PENDING_REMOVE;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.Tween} This Tween object.\r\n     */pause:function pause(){if(this.state===TWEEN_CONST.PAUSED){return;}this.paused=true;this._pausedState=this.state;this.state=TWEEN_CONST.PAUSED;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#play\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} resetFromTimeline - [description]\r\n     */play:function play(resetFromTimeline){if(this.state===TWEEN_CONST.ACTIVE){return;}else if(this.state===TWEEN_CONST.PENDING_REMOVE||this.state===TWEEN_CONST.REMOVED){this.init();this.parent.makeActive(this);resetFromTimeline=true;}var onStart=this.callbacks.onStart;if(this.parentIsTimeline){this.resetTweenData(resetFromTimeline);if(this.calculatedOffset===0){if(onStart){onStart.params[1]=this.targets;onStart.func.apply(onStart.scope,onStart.params);}this.state=TWEEN_CONST.ACTIVE;}else{this.countdown=this.calculatedOffset;this.state=TWEEN_CONST.OFFSET_DELAY;}}else if(this.paused){this.paused=false;this.parent.makeActive(this);}else{this.resetTweenData(resetFromTimeline);this.state=TWEEN_CONST.ACTIVE;if(onStart){onStart.params[1]=this.targets;onStart.func.apply(onStart.scope,onStart.params);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#resetTweenData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} resetFromLoop - [description]\r\n     */resetTweenData:function resetTweenData(resetFromLoop){var data=this.data;for(var i=0;i<this.totalData;i++){var tweenData=data[i];tweenData.progress=0;tweenData.elapsed=0;tweenData.repeatCounter=tweenData.repeat===-1?999999999999:tweenData.repeat;if(resetFromLoop){tweenData.start=tweenData.getStartValue(tweenData.target,tweenData.key,tweenData.start);tweenData.end=tweenData.getEndValue(tweenData.target,tweenData.key,tweenData.end);tweenData.current=tweenData.start;tweenData.state=TWEEN_CONST.PLAYING_FORWARD;}else if(tweenData.delay>0){tweenData.elapsed=tweenData.delay;tweenData.state=TWEEN_CONST.DELAY;}else{tweenData.state=TWEEN_CONST.PENDING_RENDER;}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.Tween} This Tween object.\r\n     */resume:function resume(){if(this.state===TWEEN_CONST.PAUSED){this.paused=false;this.state=this._pausedState;}else{this.play();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#seek\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} toPosition - A value between 0 and 1.\r\n     */seek:function seek(toPosition){var data=this.data;for(var i=0;i<this.totalData;i++){//  This won't work with loop > 0 yet\nvar ms=this.totalDuration*toPosition;var tweenData=data[i];var progress=0;var elapsed=0;if(ms<=tweenData.delay){progress=0;elapsed=0;}else if(ms>=tweenData.totalDuration){progress=1;elapsed=tweenData.duration;}else if(ms>tweenData.delay&&ms<=tweenData.t1){//  Keep it zero bound\nms=Math.max(0,ms-tweenData.delay);//  Somewhere in the first playthru range\nprogress=ms/tweenData.t1;elapsed=tweenData.duration*progress;}else if(ms>tweenData.t1&&ms<tweenData.totalDuration){//  Somewhere in repeat land\nms-=tweenData.delay;ms-=tweenData.t1;// var repeats = Math.floor(ms / tweenData.t2);\n//  remainder\nms=ms/tweenData.t2%1*tweenData.t2;if(ms>tweenData.repeatDelay){progress=ms/tweenData.t1;elapsed=tweenData.duration*progress;}}tweenData.progress=progress;tweenData.elapsed=elapsed;var v=tweenData.ease(tweenData.progress);tweenData.current=tweenData.start+(tweenData.end-tweenData.start)*v;// console.log(tweenData.key, 'Seek', tweenData.target[tweenData.key], 'to', tweenData.current, 'pro', tweenData.progress, 'marker', toPosition, progress);\n// if (tweenData.current === 0)\n// {\n//     console.log('zero', tweenData.start, tweenData.end, v, 'progress', progress);\n// }\ntweenData.target[tweenData.key]=tweenData.current;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#setCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} type - [description]\r\n     * @param {function} callback - [description]\r\n     * @param {array} [params] - [description]\r\n     * @param {object} [scope] - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Tween} This Tween object.\r\n     */setCallback:function setCallback(type,callback,params,scope){this.callbacks[type]={func:callback,scope:scope,params:params};return this;},/**\r\n     * Flags the Tween as being complete, whatever stage of progress it is at.\r\n     *\r\n     * If an onComplete callback has been defined it will automatically invoke it, unless a `delay`\r\n     * argument is provided, in which case the Tween will delay for that period of time before calling the callback.\r\n     *\r\n     * If you don't need a delay, or have an onComplete callback, then call `Tween.stop` instead.\r\n     *\r\n     * @method Phaser.Tweens.Tween#complete\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} [delay=0] - The time to wait before invoking the complete callback. If zero it will fire immediately.\r\n     */complete:function complete(delay){if(delay===undefined){delay=0;}if(delay){this.countdown=delay;this.state=TWEEN_CONST.COMPLETE_DELAY;}else{var onComplete=this.callbacks.onComplete;if(onComplete){onComplete.params[1]=this.targets;onComplete.func.apply(onComplete.scope,onComplete.params);}this.state=TWEEN_CONST.PENDING_REMOVE;}},/**\r\n     * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.\r\n     *\r\n     * @method Phaser.Tweens.Tween#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} [resetTo] - A value between 0 and 1.\r\n     */stop:function stop(resetTo){if(this.state===TWEEN_CONST.ACTIVE){if(resetTo!==undefined){this.seek(resetTo);}}if(this.state!==TWEEN_CONST.REMOVED){this.state=TWEEN_CONST.PENDING_REMOVE;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestamp - [description]\r\n     * @param {number} delta - [description]\r\n     *\r\n     * @return {boolean} Returns `true` if this Tween has finished and should be removed from the Tween Manager, otherwise returns `false`.\r\n     */update:function update(timestamp,delta){if(this.state===TWEEN_CONST.PAUSED){return false;}if(this.useFrames){delta=1*this.parent.timeScale;}delta*=this.timeScale;this.elapsed+=delta;this.progress=Math.min(this.elapsed/this.duration,1);this.totalElapsed+=delta;this.totalProgress=Math.min(this.totalElapsed/this.totalDuration,1);switch(this.state){case TWEEN_CONST.ACTIVE:var stillRunning=false;for(var i=0;i<this.totalData;i++){if(this.updateTweenData(this,this.data[i],delta)){stillRunning=true;}}//  Anything still running? If not, we're done\nif(!stillRunning){this.nextState();}break;case TWEEN_CONST.LOOP_DELAY:this.countdown-=delta;if(this.countdown<=0){this.state=TWEEN_CONST.ACTIVE;}break;case TWEEN_CONST.OFFSET_DELAY:this.countdown-=delta;if(this.countdown<=0){var onStart=this.callbacks.onStart;if(onStart){onStart.params[1]=this.targets;onStart.func.apply(onStart.scope,onStart.params);}this.state=TWEEN_CONST.ACTIVE;}break;case TWEEN_CONST.COMPLETE_DELAY:this.countdown-=delta;if(this.countdown<=0){var onComplete=this.callbacks.onComplete;if(onComplete){onComplete.func.apply(onComplete.scope,onComplete.params);}this.state=TWEEN_CONST.PENDING_REMOVE;}break;}return this.state===TWEEN_CONST.PENDING_REMOVE;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#setStateFromEnd\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     * @param {Phaser.Tweens.TweenDataConfig} tweenData - [description]\r\n     * @param {number} diff - [description]\r\n     *\r\n     * @return {integer} The state of this Tween.\r\n     */setStateFromEnd:function setStateFromEnd(tween,tweenData,diff){if(tweenData.yoyo){//  We've hit the end of a Playing Forward TweenData and we have a yoyo\n//  Account for any extra time we got from the previous frame\ntweenData.elapsed=diff;tweenData.progress=diff/tweenData.duration;if(tweenData.flipX){tweenData.target.toggleFlipX();}//  Problem: The flip and callback and so on gets called for every TweenData that triggers it at the same time.\n//  If you're tweening several properties it can fire for all of them, at once.\nif(tweenData.flipY){tweenData.target.toggleFlipY();}var onYoyo=tween.callbacks.onYoyo;if(onYoyo){//  Element 1 is reserved for the target of the yoyo (and needs setting here)\nonYoyo.params[1]=tweenData.target;onYoyo.func.apply(onYoyo.scope,onYoyo.params);}tweenData.start=tweenData.getStartValue(tweenData.target,tweenData.key,tweenData.start);return TWEEN_CONST.PLAYING_BACKWARD;}else if(tweenData.repeatCounter>0){//  We've hit the end of a Playing Forward TweenData and we have a Repeat.\n//  So we're going to go right back to the start to repeat it again.\ntweenData.repeatCounter--;//  Account for any extra time we got from the previous frame\ntweenData.elapsed=diff;tweenData.progress=diff/tweenData.duration;if(tweenData.flipX){tweenData.target.toggleFlipX();}if(tweenData.flipY){tweenData.target.toggleFlipY();}var onRepeat=tween.callbacks.onRepeat;if(onRepeat){//  Element 1 is reserved for the target of the repeat (and needs setting here)\nonRepeat.params[1]=tweenData.target;onRepeat.func.apply(onRepeat.scope,onRepeat.params);}tweenData.start=tweenData.getStartValue(tweenData.target,tweenData.key,tweenData.start);tweenData.end=tweenData.getEndValue(tweenData.target,tweenData.key,tweenData.start);//  Delay?\nif(tweenData.repeatDelay>0){tweenData.elapsed=tweenData.repeatDelay-diff;tweenData.current=tweenData.start;tweenData.target[tweenData.key]=tweenData.current;return TWEEN_CONST.REPEAT_DELAY;}else{return TWEEN_CONST.PLAYING_FORWARD;}}return TWEEN_CONST.COMPLETE;},/**\r\n     * Was PLAYING_BACKWARD and has hit the start.\r\n     *\r\n     * @method Phaser.Tweens.Tween#setStateFromStart\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     * @param {Phaser.Tweens.TweenDataConfig} tweenData - [description]\r\n     * @param {number} diff - [description]\r\n     *\r\n     * @return {integer} The state of this Tween.\r\n     */setStateFromStart:function setStateFromStart(tween,tweenData,diff){if(tweenData.repeatCounter>0){tweenData.repeatCounter--;//  Account for any extra time we got from the previous frame\ntweenData.elapsed=diff;tweenData.progress=diff/tweenData.duration;if(tweenData.flipX){tweenData.target.toggleFlipX();}if(tweenData.flipY){tweenData.target.toggleFlipY();}var onRepeat=tween.callbacks.onRepeat;if(onRepeat){//  Element 1 is reserved for the target of the repeat (and needs setting here)\nonRepeat.params[1]=tweenData.target;onRepeat.func.apply(onRepeat.scope,onRepeat.params);}tweenData.end=tweenData.getEndValue(tweenData.target,tweenData.key,tweenData.start);//  Delay?\nif(tweenData.repeatDelay>0){tweenData.elapsed=tweenData.repeatDelay-diff;tweenData.current=tweenData.start;tweenData.target[tweenData.key]=tweenData.current;return TWEEN_CONST.REPEAT_DELAY;}else{return TWEEN_CONST.PLAYING_FORWARD;}}return TWEEN_CONST.COMPLETE;},//\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Tween#updateTweenData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     * @param {Phaser.Tweens.TweenDataConfig} tweenData - [description]\r\n     * @param {number} delta - Either a value in ms, or 1 if Tween.useFrames is true\r\n     *\r\n     * @return {boolean} [description]\r\n     */updateTweenData:function updateTweenData(tween,tweenData,delta){switch(tweenData.state){case TWEEN_CONST.PLAYING_FORWARD:case TWEEN_CONST.PLAYING_BACKWARD:if(!tweenData.target){tweenData.state=TWEEN_CONST.COMPLETE;break;}var elapsed=tweenData.elapsed;var duration=tweenData.duration;var diff=0;elapsed+=delta;if(elapsed>duration){diff=elapsed-duration;elapsed=duration;}var forward=tweenData.state===TWEEN_CONST.PLAYING_FORWARD;var progress=elapsed/duration;var v;if(forward){v=tweenData.ease(progress);}else{v=tweenData.ease(1-progress);}tweenData.current=tweenData.start+(tweenData.end-tweenData.start)*v;tweenData.target[tweenData.key]=tweenData.current;tweenData.elapsed=elapsed;tweenData.progress=progress;var onUpdate=tween.callbacks.onUpdate;if(onUpdate){onUpdate.params[1]=tweenData.target;onUpdate.func.apply(onUpdate.scope,onUpdate.params);}if(progress===1){if(forward){if(tweenData.hold>0){tweenData.elapsed=tweenData.hold-diff;tweenData.state=TWEEN_CONST.HOLD_DELAY;}else{tweenData.state=this.setStateFromEnd(tween,tweenData,diff);}}else{tweenData.state=this.setStateFromStart(tween,tweenData,diff);}}break;case TWEEN_CONST.DELAY:tweenData.elapsed-=delta;if(tweenData.elapsed<=0){tweenData.elapsed=Math.abs(tweenData.elapsed);tweenData.state=TWEEN_CONST.PENDING_RENDER;}break;case TWEEN_CONST.REPEAT_DELAY:tweenData.elapsed-=delta;if(tweenData.elapsed<=0){tweenData.elapsed=Math.abs(tweenData.elapsed);tweenData.state=TWEEN_CONST.PLAYING_FORWARD;}break;case TWEEN_CONST.HOLD_DELAY:tweenData.elapsed-=delta;if(tweenData.elapsed<=0){tweenData.state=this.setStateFromEnd(tween,tweenData,Math.abs(tweenData.elapsed));}break;case TWEEN_CONST.PENDING_RENDER:if(tweenData.target){tweenData.start=tweenData.getStartValue(tweenData.target,tweenData.key,tweenData.target[tweenData.key]);tweenData.end=tweenData.getEndValue(tweenData.target,tweenData.key,tweenData.start);tweenData.current=tweenData.start;tweenData.target[tweenData.key]=tweenData.start;tweenData.state=TWEEN_CONST.PLAYING_FORWARD;}else{tweenData.state=TWEEN_CONST.COMPLETE;}break;}//  Return TRUE if this TweenData still playing, otherwise return FALSE\nreturn tweenData.state!==TWEEN_CONST.COMPLETE;}});Tween.TYPES=['onComplete','onLoop','onRepeat','onStart','onUpdate','onYoyo'];/**\r\n * Creates a new Tween object.\r\n *\r\n * Note: This method will only be available Tweens have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#tween\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The Tween configuration.\r\n *\r\n * @return {Phaser.Tweens.Tween} The Tween that was created.\r\n */GameObjectFactory.register('tween',function(config){return this.scene.sys.tweens.add(config);});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/**\r\n * Creates a new Tween object and returns it.\r\n *\r\n * Note: This method will only be available if Tweens have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tween\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The Tween configuration.\r\n *\r\n * @return {Phaser.Tweens.Tween} The Tween that was created.\r\n */GameObjectCreator.register('tween',function(config){return this.scene.sys.tweens.create(config);});//  When registering a factory function 'this' refers to the GameObjectCreator context.\nmodule.exports=Tween;/***/},/* 114 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} Phaser.Tweens.TweenConfigDefaults\r\n * \r\n * @property {(object|object[])} targets - [description]\r\n * @property {number} [delay=0] - [description]\r\n * @property {number} [duration=1000] - [description]\r\n * @property {string} [ease='Power0'] - [description]\r\n * @property {array} [easeParams] - [description]\r\n * @property {number} [hold=0] - [description]\r\n * @property {number} [repeat=0] - [description]\r\n * @property {number} [repeatDelay=0] - [description]\r\n * @property {boolean} [yoyo=false] - [description]\r\n * @property {boolean} [flipX=false] - [description]\r\n * @property {boolean} [flipY=false] - [description]\r\n */var TWEEN_DEFAULTS={targets:null,delay:0,duration:1000,ease:'Power0',easeParams:null,hold:0,repeat:0,repeatDelay:0,yoyo:false,flipX:false,flipY:false};module.exports=TWEEN_DEFAULTS;/***/},/* 115 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */function hasGetStart(def){return!!def.getStart&&typeof def.getStart==='function';}function hasGetEnd(def){return!!def.getEnd&&typeof def.getEnd==='function';}function hasGetters(def){return hasGetStart(def)||hasGetEnd(def);}/**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.GetValueOp\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {*} propertyValue - [description]\r\n *\r\n * @return {function} [description]\r\n */var GetValueOp=function GetValueOp(key,propertyValue){var callbacks;//  The returned value sets what the property will be at the END of the Tween (usually called at the start of the Tween)\nvar getEnd=function getEnd(target,key,value){return value;};//  The returned value sets what the property will be at the START of the Tween (usually called at the end of the Tween)\nvar getStart=function getStart(target,key,value){return value;};var t=typeof propertyValue==='undefined'?'undefined':_typeof(propertyValue);if(t==='number'){// props: {\n//     x: 400,\n//     y: 300\n// }\ngetEnd=function getEnd(){return propertyValue;};}else if(t==='string'){// props: {\n//     x: '+=400',\n//     y: '-=300',\n//     z: '*=2',\n//     w: '/=2'\n// }\nvar op=propertyValue[0];var num=parseFloat(propertyValue.substr(2));switch(op){case'+':getEnd=function getEnd(target,key,value){return value+num;};break;case'-':getEnd=function getEnd(target,key,value){return value-num;};break;case'*':getEnd=function getEnd(target,key,value){return value*num;};break;case'/':getEnd=function getEnd(target,key,value){return value/num;};break;default:getEnd=function getEnd(){return parseFloat(propertyValue);};}}else if(t==='function'){//  The same as setting just the getEnd function and no getStart\n// props: {\n//     x: function (target, key, value) { return value + 50); },\n// }\ngetEnd=propertyValue;}else if(t==='object'&&hasGetters(propertyValue)){/*\r\n        x: {\r\n            //  Called at the start of the Tween. The returned value sets what the property will be at the END of the Tween.\r\n            getEnd: function (target, key, value)\r\n            {\r\n                return value;\r\n            },\r\n\r\n            //  Called at the end of the Tween. The returned value sets what the property will be at the START of the Tween.\r\n            getStart: function (target, key, value)\r\n            {\r\n                return value;\r\n            }\r\n        }\r\n        */if(hasGetEnd(propertyValue)){getEnd=propertyValue.getEnd;}if(hasGetStart(propertyValue)){getStart=propertyValue.getStart;}}else if(propertyValue.hasOwnProperty('value')){//  Value may still be a string, function or a number\n// props: {\n//     x: { value: 400, ... },\n//     y: { value: 300, ... }\n// }\ncallbacks=GetValueOp(key,propertyValue.value);}//  If callback not set by the else if block above then set it here and return it\nif(!callbacks){callbacks={getEnd:getEnd,getStart:getStart};}return callbacks;};module.exports=GetValueOp;/***/},/* 116 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetValue=__webpack_require__(5);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.GetTargets\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {array} [description]\r\n */var GetTargets=function GetTargets(config){var targets=GetValue(config,'targets',null);if(targets===null){return targets;}if(typeof targets==='function'){targets=targets.call();}if(!Array.isArray(targets)){targets=[targets];}return targets;};module.exports=GetTargets;/***/},/* 117 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Formats=__webpack_require__(24);var MapData=__webpack_require__(66);var Parse=__webpack_require__(199);var Tilemap=__webpack_require__(191);/**\r\n * Create a Tilemap from the given key or data. If neither is given, make a blank Tilemap. When\r\n * loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing from\r\n * a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map data. For\r\n * an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @function Phaser.Tilemaps.ParseToTilemap\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n * @param {integer} [tileWidth=32] - The width of a tile in pixels.\r\n * @param {integer} [tileHeight=32] - The height of a tile in pixels.\r\n * @param {integer} [width=10] - The width of the map in tiles.\r\n * @param {integer} [height=10] - The height of the map in tiles.\r\n * @param {integer[][]} [data] - Instead of loading from the cache, you can also load directly from\r\n * a 2D array of tile indexes.\r\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\r\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */var ParseToTilemap=function ParseToTilemap(scene,key,tileWidth,tileHeight,width,height,data,insertNull){if(tileWidth===undefined){tileWidth=32;}if(tileHeight===undefined){tileHeight=32;}if(width===undefined){width=10;}if(height===undefined){height=10;}if(insertNull===undefined){insertNull=false;}var mapData=null;if(Array.isArray(data)){var name=key!==undefined?key:'map';mapData=Parse(name,Formats.ARRAY_2D,data,tileWidth,tileHeight,insertNull);}else if(key!==undefined){var tilemapData=scene.cache.tilemap.get(key);if(!tilemapData){console.warn('No map data found for key '+key);}else{mapData=Parse(key,tilemapData.format,tilemapData.data,tileWidth,tileHeight,insertNull);}}if(mapData===null){mapData=new MapData({tileWidth:tileWidth,tileHeight:tileHeight,width:width,height:height});}return new Tilemap(scene,mapData);};module.exports=ParseToTilemap;/***/},/* 118 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Formats=__webpack_require__(24);var LayerData=__webpack_require__(67);var MapData=__webpack_require__(66);var Tile=__webpack_require__(45);/**\r\n * Parses a 2D array of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse2DArray\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {integer[][]} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {integer} tileWidth - The width of a tile in pixels.\r\n * @param {integer} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} [description]\r\n */var Parse2DArray=function Parse2DArray(name,data,tileWidth,tileHeight,insertNull){var layerData=new LayerData({tileWidth:tileWidth,tileHeight:tileHeight});var mapData=new MapData({name:name,tileWidth:tileWidth,tileHeight:tileHeight,format:Formats.ARRAY_2D,layers:[layerData]});var tiles=[];var height=data.length;var width=0;for(var y=0;y<data.length;y++){tiles[y]=[];var row=data[y];for(var x=0;x<row.length;x++){var tileIndex=parseInt(row[x],10);if(Number.isNaN(tileIndex)||tileIndex===-1){tiles[y][x]=insertNull?null:new Tile(layerData,-1,x,y,tileWidth,tileHeight);}else{tiles[y][x]=new Tile(layerData,tileIndex,x,y,tileWidth,tileHeight);}}if(width===0){width=row.length;}}mapData.width=layerData.width=width;mapData.height=layerData.height=height;mapData.widthInPixels=layerData.widthInPixels=width*tileWidth;mapData.heightInPixels=layerData.heightInPixels=height*tileHeight;layerData.data=tiles;return mapData;};module.exports=Parse2DArray;/***/},/* 119 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Internally used method to keep track of the tile indexes that collide within a layer. This\r\n * updates LayerData.collideIndexes to either contain or not contain the given `tileIndex`.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetLayerCollisionIndex\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileIndex - [description]\r\n * @param {boolean} [collides=true] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SetLayerCollisionIndex=function SetLayerCollisionIndex(tileIndex,collides,layer){var loc=layer.collideIndexes.indexOf(tileIndex);if(collides&&loc===-1){layer.collideIndexes.push(tileIndex);}else if(!collides&&loc!==-1){layer.collideIndexes.splice(loc,1);}};module.exports=SetLayerCollisionIndex;/***/},/* 120 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Tile=__webpack_require__(45);var IsInLayerBounds=__webpack_require__(68);var CalculateFacesAt=__webpack_require__(121);var SetTileCollision=__webpack_require__(46);/**\r\n * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n * location. If you pass in an index, only the index at the specified location will be changed.\r\n * Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {integer} tileX - [description]\r\n * @param {integer} tileY - [description]\r\n * @param {boolean} [recalculateFaces=true] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */var PutTileAt=function PutTileAt(tile,tileX,tileY,recalculateFaces,layer){if(!IsInLayerBounds(tileX,tileY,layer)){return null;}if(recalculateFaces===undefined){recalculateFaces=true;}var oldTile=layer.data[tileY][tileX];var oldTileCollides=oldTile&&oldTile.collides;if(tile instanceof Tile){if(layer.data[tileY][tileX]===null){layer.data[tileY][tileX]=new Tile(layer,tile.index,tileX,tileY,tile.width,tile.height);}layer.data[tileY][tileX].copy(tile);}else{var index=tile;if(layer.data[tileY][tileX]===null){layer.data[tileY][tileX]=new Tile(layer,index,tileX,tileY,layer.tileWidth,layer.tileHeight);}else{layer.data[tileY][tileX].index=index;}}// Updating colliding flag on the new tile\nvar newTile=layer.data[tileY][tileX];var collides=layer.collideIndexes.indexOf(newTile.index)!==-1;SetTileCollision(newTile,collides);// Recalculate faces only if the colliding flag at (tileX, tileY) has changed\nif(recalculateFaces&&oldTileCollides!==newTile.collides){CalculateFacesAt(tileX,tileY,layer);}return newTile;};module.exports=PutTileAt;/***/},/* 121 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTileAt=__webpack_require__(90);/**\r\n * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n * internally to optimize recalculating faces when only one tile has been changed.\r\n *\r\n * @function Phaser.Tilemaps.Components.CalculateFacesAt\r\n * @since 3.0.0\r\n * \r\n * @param {integer} tileX - The x coordinate.\r\n * @param {integer} tileY - The y coordinate.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var CalculateFacesAt=function CalculateFacesAt(tileX,tileY,layer){var tile=GetTileAt(tileX,tileY,true,layer);var above=GetTileAt(tileX,tileY-1,true,layer);var below=GetTileAt(tileX,tileY+1,true,layer);var left=GetTileAt(tileX-1,tileY,true,layer);var right=GetTileAt(tileX+1,tileY,true,layer);var tileCollides=tile&&tile.collides;// Assume the changed tile has all interesting edges\nif(tileCollides){tile.faceTop=true;tile.faceBottom=true;tile.faceLeft=true;tile.faceRight=true;}// Reset edges that are shared between tile and its neighbors\nif(above&&above.collides){if(tileCollides){tile.faceTop=false;}above.faceBottom=!tileCollides;}if(below&&below.collides){if(tileCollides){tile.faceBottom=false;}below.faceTop=!tileCollides;}if(left&&left.collides){if(tileCollides){tile.faceLeft=false;}left.faceRight=!tileCollides;}if(right&&right.collides){if(tileCollides){tile.faceRight=false;}right.faceLeft=!tileCollides;}if(tile&&!tile.collides){tile.resetFaces();}return tile;};module.exports=CalculateFacesAt;/***/},/* 122 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.\r\n* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.\r\n* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.\r\n* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composite\r\n*/var Composite={};module.exports=Composite;var Events=__webpack_require__(178);var Common=__webpack_require__(37);var Body=__webpack_require__(51);(function(){/**\r\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properites section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {} [options]\r\n     * @return {composite} A new composite\r\n     */Composite.create=function(options){return Common.extend({id:Common.nextId(),type:'composite',parent:null,isModified:false,bodies:[],constraints:[],composites:[],label:'Composite',plugin:{}},options);};/**\r\n     * Sets the composite's `isModified` flag. \r\n     * If `updateParents` is true, all parents will be set (default: false).\r\n     * If `updateChildren` is true, all children will be set (default: false).\r\n     * @method setModified\r\n     * @param {composite} composite\r\n     * @param {boolean} isModified\r\n     * @param {boolean} [updateParents=false]\r\n     * @param {boolean} [updateChildren=false]\r\n     */Composite.setModified=function(composite,isModified,updateParents,updateChildren){composite.isModified=isModified;if(updateParents&&composite.parent){Composite.setModified(composite.parent,isModified,updateParents,updateChildren);}if(updateChildren){for(var i=0;i<composite.composites.length;i++){var childComposite=composite.composites[i];Composite.setModified(childComposite,isModified,updateParents,updateChildren);}}};/**\r\n     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\r\n     * @method add\r\n     * @param {composite} composite\r\n     * @param {} object\r\n     * @return {composite} The original composite with the objects added\r\n     */Composite.add=function(composite,object){var objects=[].concat(object);Events.trigger(composite,'beforeAdd',{object:object});for(var i=0;i<objects.length;i++){var obj=objects[i];switch(obj.type){case'body':// skip adding compound parts\nif(obj.parent!==obj){Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');break;}Composite.addBody(composite,obj);break;case'constraint':Composite.addConstraint(composite,obj);break;case'composite':Composite.addComposite(composite,obj);break;case'mouseConstraint':Composite.addConstraint(composite,obj.constraint);break;}}Events.trigger(composite,'afterAdd',{object:object});return composite;};/**\r\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n     * Optionally searching its children recursively.\r\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\r\n     * @method remove\r\n     * @param {composite} composite\r\n     * @param {} object\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the objects removed\r\n     */Composite.remove=function(composite,object,deep){var objects=[].concat(object);Events.trigger(composite,'beforeRemove',{object:object});for(var i=0;i<objects.length;i++){var obj=objects[i];switch(obj.type){case'body':Composite.removeBody(composite,obj,deep);break;case'constraint':Composite.removeConstraint(composite,obj,deep);break;case'composite':Composite.removeComposite(composite,obj,deep);break;case'mouseConstraint':Composite.removeConstraint(composite,obj.constraint);break;}}Events.trigger(composite,'afterRemove',{object:object});return composite;};/**\r\n     * Adds a composite to the given composite.\r\n     * @private\r\n     * @method addComposite\r\n     * @param {composite} compositeA\r\n     * @param {composite} compositeB\r\n     * @return {composite} The original compositeA with the objects from compositeB added\r\n     */Composite.addComposite=function(compositeA,compositeB){compositeA.composites.push(compositeB);compositeB.parent=compositeA;Composite.setModified(compositeA,true,true,false);return compositeA;};/**\r\n     * Removes a composite from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeComposite\r\n     * @param {composite} compositeA\r\n     * @param {composite} compositeB\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original compositeA with the composite removed\r\n     */Composite.removeComposite=function(compositeA,compositeB,deep){var position=compositeA.composites.indexOf(compositeB);if(position!==-1){Composite.removeCompositeAt(compositeA,position);Composite.setModified(compositeA,true,true,false);}if(deep){for(var i=0;i<compositeA.composites.length;i++){Composite.removeComposite(compositeA.composites[i],compositeB,true);}}return compositeA;};/**\r\n     * Removes a composite from the given composite.\r\n     * @private\r\n     * @method removeCompositeAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the composite removed\r\n     */Composite.removeCompositeAt=function(composite,position){composite.composites.splice(position,1);Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Adds a body to the given composite.\r\n     * @private\r\n     * @method addBody\r\n     * @param {composite} composite\r\n     * @param {body} body\r\n     * @return {composite} The original composite with the body added\r\n     */Composite.addBody=function(composite,body){composite.bodies.push(body);Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Removes a body from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeBody\r\n     * @param {composite} composite\r\n     * @param {body} body\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the body removed\r\n     */Composite.removeBody=function(composite,body,deep){var position=composite.bodies.indexOf(body);if(position!==-1){Composite.removeBodyAt(composite,position);Composite.setModified(composite,true,true,false);}if(deep){for(var i=0;i<composite.composites.length;i++){Composite.removeBody(composite.composites[i],body,true);}}return composite;};/**\r\n     * Removes a body from the given composite.\r\n     * @private\r\n     * @method removeBodyAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the body removed\r\n     */Composite.removeBodyAt=function(composite,position){composite.bodies.splice(position,1);Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Adds a constraint to the given composite.\r\n     * @private\r\n     * @method addConstraint\r\n     * @param {composite} composite\r\n     * @param {constraint} constraint\r\n     * @return {composite} The original composite with the constraint added\r\n     */Composite.addConstraint=function(composite,constraint){composite.constraints.push(constraint);Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeConstraint\r\n     * @param {composite} composite\r\n     * @param {constraint} constraint\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the constraint removed\r\n     */Composite.removeConstraint=function(composite,constraint,deep){var position=composite.constraints.indexOf(constraint);if(position!==-1){Composite.removeConstraintAt(composite,position);}if(deep){for(var i=0;i<composite.composites.length;i++){Composite.removeConstraint(composite.composites[i],constraint,true);}}return composite;};/**\r\n     * Removes a body from the given composite.\r\n     * @private\r\n     * @method removeConstraintAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the constraint removed\r\n     */Composite.removeConstraintAt=function(composite,position){composite.constraints.splice(position,1);Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Removes all bodies, constraints and composites from the given composite.\r\n     * Optionally clearing its children recursively.\r\n     * @method clear\r\n     * @param {composite} composite\r\n     * @param {boolean} keepStatic\r\n     * @param {boolean} [deep=false]\r\n     */Composite.clear=function(composite,keepStatic,deep){if(deep){for(var i=0;i<composite.composites.length;i++){Composite.clear(composite.composites[i],keepStatic,true);}}if(keepStatic){composite.bodies=composite.bodies.filter(function(body){return body.isStatic;});}else{composite.bodies.length=0;}composite.constraints.length=0;composite.composites.length=0;Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\r\n     * @method allBodies\r\n     * @param {composite} composite\r\n     * @return {body[]} All the bodies\r\n     */Composite.allBodies=function(composite){var bodies=[].concat(composite.bodies);for(var i=0;i<composite.composites.length;i++){bodies=bodies.concat(Composite.allBodies(composite.composites[i]));}return bodies;};/**\r\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\r\n     * @method allConstraints\r\n     * @param {composite} composite\r\n     * @return {constraint[]} All the constraints\r\n     */Composite.allConstraints=function(composite){var constraints=[].concat(composite.constraints);for(var i=0;i<composite.composites.length;i++){constraints=constraints.concat(Composite.allConstraints(composite.composites[i]));}return constraints;};/**\r\n     * Returns all composites in the given composite, including all composites in its children, recursively.\r\n     * @method allComposites\r\n     * @param {composite} composite\r\n     * @return {composite[]} All the composites\r\n     */Composite.allComposites=function(composite){var composites=[].concat(composite.composites);for(var i=0;i<composite.composites.length;i++){composites=composites.concat(Composite.allComposites(composite.composites[i]));}return composites;};/**\r\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\r\n     * @method get\r\n     * @param {composite} composite\r\n     * @param {number} id\r\n     * @param {string} type\r\n     * @return {object} The requested object, if found\r\n     */Composite.get=function(composite,id,type){var objects,object;switch(type){case'body':objects=Composite.allBodies(composite);break;case'constraint':objects=Composite.allConstraints(composite);break;case'composite':objects=Composite.allComposites(composite).concat(composite);break;}if(!objects)return null;object=objects.filter(function(object){return object.id.toString()===id.toString();});return object.length===0?null:object[0];};/**\r\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\r\n     * @method move\r\n     * @param {compositeA} compositeA\r\n     * @param {object[]} objects\r\n     * @param {compositeB} compositeB\r\n     * @return {composite} Returns compositeA\r\n     */Composite.move=function(compositeA,objects,compositeB){Composite.remove(compositeA,objects);Composite.add(compositeB,objects);return compositeA;};/**\r\n     * Assigns new ids for all objects in the composite, recursively.\r\n     * @method rebase\r\n     * @param {composite} composite\r\n     * @return {composite} Returns composite\r\n     */Composite.rebase=function(composite){var objects=Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));for(var i=0;i<objects.length;i++){objects[i].id=Common.nextId();}Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Translates all children in the composite by a given vector relative to their current positions, \r\n     * without imparting any velocity.\r\n     * @method translate\r\n     * @param {composite} composite\r\n     * @param {vector} translation\r\n     * @param {bool} [recursive=true]\r\n     */Composite.translate=function(composite,translation,recursive){var bodies=recursive?Composite.allBodies(composite):composite.bodies;for(var i=0;i<bodies.length;i++){Body.translate(bodies[i],translation);}Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\r\n     * @method rotate\r\n     * @param {composite} composite\r\n     * @param {number} rotation\r\n     * @param {vector} point\r\n     * @param {bool} [recursive=true]\r\n     */Composite.rotate=function(composite,rotation,point,recursive){var cos=Math.cos(rotation),sin=Math.sin(rotation),bodies=recursive?Composite.allBodies(composite):composite.bodies;for(var i=0;i<bodies.length;i++){var body=bodies[i],dx=body.position.x-point.x,dy=body.position.y-point.y;Body.setPosition(body,{x:point.x+(dx*cos-dy*sin),y:point.y+(dx*sin+dy*cos)});Body.rotate(body,rotation);}Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\r\n     * @method scale\r\n     * @param {composite} composite\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} point\r\n     * @param {bool} [recursive=true]\r\n     */Composite.scale=function(composite,scaleX,scaleY,point,recursive){var bodies=recursive?Composite.allBodies(composite):composite.bodies;for(var i=0;i<bodies.length;i++){var body=bodies[i],dx=body.position.x-point.x,dy=body.position.y-point.y;Body.setPosition(body,{x:point.x+dx*scaleX,y:point.y+dy*scaleY});Body.scale(body,scaleX,scaleY);}Composite.setModified(composite,true,true,false);return composite;};/**\r\n     * Returns the union of the bounds of all of the composite's bodies.\r\n     * @method bounds\r\n     * @param {composite} composite The composite.\r\n     * @returns {bounds} The composite bounds.\r\n     */Composite.bounds=function(composite){var bodies=Matter.Composite.allBodies(composite),vertices=[];for(var i=0;i<bodies.length;i+=1){var body=bodies[i];vertices.push(body.bounds.min,body.bounds.max);}return Matter.Bounds.create(vertices);};/*\r\n    *\r\n    *  Events Documentation\r\n    *\r\n    *//**\r\n    * Fired when a call to `Composite.add` is made, before objects have been added.\r\n    *\r\n    * @event beforeAdd\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//**\r\n    * Fired when a call to `Composite.add` is made, after objects have been added.\r\n    *\r\n    * @event afterAdd\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//**\r\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\r\n    *\r\n    * @event beforeRemove\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//**\r\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\r\n    *\r\n    * @event afterRemove\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    *//**\r\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\r\n     *\r\n     * @property id\r\n     * @type number\r\n     *//**\r\n     * A `String` denoting the type of object.\r\n     *\r\n     * @property type\r\n     * @type string\r\n     * @default \"composite\"\r\n     * @readOnly\r\n     *//**\r\n     * An arbitrary `String` name to help the user identify and manage composites.\r\n     *\r\n     * @property label\r\n     * @type string\r\n     * @default \"Composite\"\r\n     *//**\r\n     * A flag that specifies whether the composite has been modified during the current step.\r\n     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.\r\n     * If you need to change it manually, you should use the `Composite.setModified` method.\r\n     *\r\n     * @property isModified\r\n     * @type boolean\r\n     * @default false\r\n     *//**\r\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\r\n     *\r\n     * @property parent\r\n     * @type composite\r\n     * @default null\r\n     *//**\r\n     * An array of `Body` that are _direct_ children of this composite.\r\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\r\n     *\r\n     * @property bodies\r\n     * @type body[]\r\n     * @default []\r\n     *//**\r\n     * An array of `Constraint` that are _direct_ children of this composite.\r\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\r\n     *\r\n     * @property constraints\r\n     * @type constraint[]\r\n     * @default []\r\n     *//**\r\n     * An array of `Composite` that are _direct_ children of this composite.\r\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\r\n     *\r\n     * @property composites\r\n     * @type composite[]\r\n     * @default []\r\n     *//**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */})();/***/},/* 123 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \r\n* with commonly used body configurations (such as rectangles, circles and other polygons).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Bodies\r\n*/// TODO: true circle bodies\nvar Bodies={};module.exports=Bodies;var Vertices=__webpack_require__(93);var Common=__webpack_require__(37);var Body=__webpack_require__(51);var Bounds=__webpack_require__(92);var Vector=__webpack_require__(83);var decomp=__webpack_require__(988);(function(){/**\r\n     * Creates a new rigid body model with a rectangle hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method rectangle\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {object} [options]\r\n     * @return {body} A new rectangle body\r\n     */Bodies.rectangle=function(x,y,width,height,options){options=options||{};var rectangle={label:'Rectangle Body',position:{x:x,y:y},vertices:Vertices.fromPath('L 0 0 L '+width+' 0 L '+width+' '+height+' L 0 '+height)};if(options.chamfer){var chamfer=options.chamfer;rectangle.vertices=Vertices.chamfer(rectangle.vertices,chamfer.radius,chamfer.quality,chamfer.qualityMin,chamfer.qualityMax);delete options.chamfer;}return Body.create(Common.extend({},rectangle,options));};/**\r\n     * Creates a new rigid body model with a trapezoid hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method trapezoid\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {number} slope\r\n     * @param {object} [options]\r\n     * @return {body} A new trapezoid body\r\n     */Bodies.trapezoid=function(x,y,width,height,slope,options){options=options||{};slope*=0.5;var roof=(1-slope*2)*width;var x1=width*slope,x2=x1+roof,x3=x2+x1,verticesPath;if(slope<0.5){verticesPath='L 0 0 L '+x1+' '+-height+' L '+x2+' '+-height+' L '+x3+' 0';}else{verticesPath='L 0 0 L '+x2+' '+-height+' L '+x3+' 0';}var trapezoid={label:'Trapezoid Body',position:{x:x,y:y},vertices:Vertices.fromPath(verticesPath)};if(options.chamfer){var chamfer=options.chamfer;trapezoid.vertices=Vertices.chamfer(trapezoid.vertices,chamfer.radius,chamfer.quality,chamfer.qualityMin,chamfer.qualityMax);delete options.chamfer;}return Body.create(Common.extend({},trapezoid,options));};/**\r\n     * Creates a new rigid body model with a circle hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method circle\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} radius\r\n     * @param {object} [options]\r\n     * @param {number} [maxSides]\r\n     * @return {body} A new circle body\r\n     */Bodies.circle=function(x,y,radius,options,maxSides){options=options||{};var circle={label:'Circle Body',circleRadius:radius};// approximate circles with polygons until true circles implemented in SAT\nmaxSides=maxSides||25;var sides=Math.ceil(Math.max(10,Math.min(maxSides,radius)));// optimisation: always use even number of sides (half the number of unique axes)\nif(sides%2===1)sides+=1;return Bodies.polygon(x,y,sides,radius,Common.extend({},circle,options));};/**\r\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method polygon\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} sides\r\n     * @param {number} radius\r\n     * @param {object} [options]\r\n     * @return {body} A new regular polygon body\r\n     */Bodies.polygon=function(x,y,sides,radius,options){options=options||{};if(sides<3)return Bodies.circle(x,y,radius,options);var theta=2*Math.PI/sides,path='',offset=theta*0.5;for(var i=0;i<sides;i+=1){var angle=offset+i*theta,xx=Math.cos(angle)*radius,yy=Math.sin(angle)*radius;path+='L '+xx.toFixed(3)+' '+yy.toFixed(3)+' ';}var polygon={label:'Polygon Body',position:{x:x,y:y},vertices:Vertices.fromPath(path)};if(options.chamfer){var chamfer=options.chamfer;polygon.vertices=Vertices.chamfer(polygon.vertices,chamfer.radius,chamfer.quality,chamfer.qualityMin,chamfer.qualityMax);delete options.chamfer;}return Body.create(Common.extend({},polygon,options));};/**\r\n     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).\r\n     * If the vertices are convex, they will pass through as supplied.\r\n     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.\r\n     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).\r\n     * By default the decomposition will discard collinear edges (to improve performance).\r\n     * It can also optionally discard any parts that have an area less than `minimumArea`.\r\n     * If the vertices can not be decomposed, the result will fall back to using the convex hull.\r\n     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method fromVertices\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param [[vector]] vertexSets\r\n     * @param {object} [options]\r\n     * @param {bool} [flagInternal=false]\r\n     * @param {number} [removeCollinear=0.01]\r\n     * @param {number} [minimumArea=10]\r\n     * @return {body}\r\n     */Bodies.fromVertices=function(x,y,vertexSets,options,flagInternal,removeCollinear,minimumArea){var body,parts,isConvex,vertices,i,j,k,v,z;options=options||{};parts=[];flagInternal=typeof flagInternal!=='undefined'?flagInternal:false;removeCollinear=typeof removeCollinear!=='undefined'?removeCollinear:0.01;minimumArea=typeof minimumArea!=='undefined'?minimumArea:10;if(!decomp){Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');}// ensure vertexSets is an array of arrays\nif(!Common.isArray(vertexSets[0])){vertexSets=[vertexSets];}for(v=0;v<vertexSets.length;v+=1){vertices=vertexSets[v];isConvex=Vertices.isConvex(vertices);if(isConvex||!decomp){if(isConvex){vertices=Vertices.clockwiseSort(vertices);}else{// fallback to convex hull when decomposition is not possible\nvertices=Vertices.hull(vertices);}parts.push({position:{x:x,y:y},vertices:vertices});}else{// initialise a decomposition\nvar concave=vertices.map(function(vertex){return[vertex.x,vertex.y];});// vertices are concave and simple, we can decompose into parts\ndecomp.makeCCW(concave);if(removeCollinear!==false)decomp.removeCollinearPoints(concave,removeCollinear);// use the quick decomposition algorithm (Bayazit)\nvar decomposed=decomp.quickDecomp(concave);// for each decomposed chunk\nfor(i=0;i<decomposed.length;i++){var chunk=decomposed[i];// convert vertices into the correct structure\nvar chunkVertices=chunk.map(function(vertices){return{x:vertices[0],y:vertices[1]};});// skip small chunks\nif(minimumArea>0&&Vertices.area(chunkVertices)<minimumArea)continue;// create a compound part\nparts.push({position:Vertices.centre(chunkVertices),vertices:chunkVertices});}}}// create body parts\nfor(i=0;i<parts.length;i++){parts[i]=Body.create(Common.extend(parts[i],options));}// flag internal edges (coincident part edges)\nif(flagInternal){var coincident_max_dist=5;for(i=0;i<parts.length;i++){var partA=parts[i];for(j=i+1;j<parts.length;j++){var partB=parts[j];if(Bounds.overlaps(partA.bounds,partB.bounds)){var pav=partA.vertices,pbv=partB.vertices;// iterate vertices of both parts\nfor(k=0;k<partA.vertices.length;k++){for(z=0;z<partB.vertices.length;z++){// find distances between the vertices\nvar da=Vector.magnitudeSquared(Vector.sub(pav[(k+1)%pav.length],pbv[z])),db=Vector.magnitudeSquared(Vector.sub(pav[k],pbv[(z+1)%pbv.length]));// if both vertices are very close, consider the edge concident (internal)\nif(da<coincident_max_dist&&db<coincident_max_dist){pav[k].isInternal=true;pbv[z].isInternal=true;}}}}}}}if(parts.length>1){// create the parent body to be returned, that contains generated compound parts\nbody=Body.create(Common.extend({parts:parts.slice(0)},options));Body.setPosition(body,{x:x,y:y});return body;}else{return parts[0];}};})();/***/},/* 124 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Extend=__webpack_require__(18);var XHRSettings=__webpack_require__(95);/**\r\n * Takes two XHRSettings Objects and creates a new XHRSettings object from them.\r\n *\r\n * The new object is seeded by the values given in the global settings, but any setting in\r\n * the local object overrides the global ones.\r\n *\r\n * @function Phaser.Loader.MergeXHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XHRSettingsObject} global - The global XHRSettings object.\r\n * @param {XHRSettingsObject} local - The local XHRSettings object.\r\n *\r\n * @return {XHRSettingsObject} A newly formed XHRSettings object.\r\n */var MergeXHRSettings=function MergeXHRSettings(global,local){var output=global===undefined?XHRSettings():Extend({},global);if(local){for(var setting in local){if(local[setting]!==undefined){output[setting]=local[setting];}}}return output;};module.exports=MergeXHRSettings;/***/},/* 125 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Given a File and a baseURL value this returns the URL the File will use to download from.\r\n *\r\n * @function Phaser.Loader.GetURL\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File object.\r\n * @param {string} baseURL - A default base URL.\r\n *\r\n * @return {string} The URL the File will use.\r\n */var GetURL=function GetURL(file,baseURL){if(!file.url){return false;}if(file.url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/)){return file.url;}else{return baseURL+file.url;}};module.exports=GetURL;/***/},/* 126 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.RotateAroundXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {number} angle - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var RotateAroundXY=function RotateAroundXY(triangle,x,y,angle){var c=Math.cos(angle);var s=Math.sin(angle);var tx=triangle.x1-x;var ty=triangle.y1-y;triangle.x1=tx*c-ty*s+x;triangle.y1=tx*s+ty*c+y;tx=triangle.x2-x;ty=triangle.y2-y;triangle.x2=tx*c-ty*s+x;triangle.y2=tx*s+ty*c+y;tx=triangle.x3-x;ty=triangle.y3-y;triangle.x3=tx*c-ty*s+x;triangle.y3=tx*s+ty*c+y;return triangle;};module.exports=RotateAroundXY;/***/},/* 127 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.GetAspectRatio\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {number} [description]\r\n */var GetAspectRatio=function GetAspectRatio(rect){return rect.height===0?NaN:rect.width/rect.height;};module.exports=GetAspectRatio;/***/},/* 128 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */// Checks whether the x and y coordinates are contained within this polygon.\n//  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Polygon.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Contains=function Contains(polygon,x,y){var inside=false;for(var i=-1,j=polygon.points.length-1;++i<polygon.points.length;j=i){var ix=polygon.points[i].x;var iy=polygon.points[i].y;var jx=polygon.points[j].x;var jy=polygon.points[j].y;if((iy<=y&&y<jy||jy<=y&&y<iy)&&x<(jx-ix)*(y-iy)/(jy-iy)+ix){inside=!inside;}}return inside;};module.exports=Contains;/***/},/* 129 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.RotateAroundXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {number} angle - [description]\r\n *\r\n * @return {Phaser.Geom.Line} [description]\r\n */var RotateAroundXY=function RotateAroundXY(line,x,y,angle){var c=Math.cos(angle);var s=Math.sin(angle);var tx=line.x1-x;var ty=line.y1-y;line.x1=tx*c-ty*s+x;line.y1=tx*s+ty*c+y;tx=line.x2-x;ty=line.y2-y;line.x2=tx*c-ty*s+x;line.y2=tx*s+ty*c+y;return line;};module.exports=RotateAroundXY;/***/},/* 130 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  http://www.blackpawn.com/texts/pointinpoly/\n//  points is an array of Point-like objects with public x/y properties\n//  returns an array containing all points that are within the triangle, or an empty array if none\n//  if 'returnFirst' is true it will return after the first point within the triangle is found\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.ContainsArray\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Point[]} points - [description]\r\n * @param {boolean} [returnFirst] - [description]\r\n * @param {array} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point[]} [description]\r\n */var ContainsArray=function ContainsArray(triangle,points,returnFirst,out){if(returnFirst===undefined){returnFirst=false;}if(out===undefined){out=[];}var v0x=triangle.x3-triangle.x1;var v0y=triangle.y3-triangle.y1;var v1x=triangle.x2-triangle.x1;var v1y=triangle.y2-triangle.y1;var dot00=v0x*v0x+v0y*v0y;var dot01=v0x*v1x+v0y*v1y;var dot11=v1x*v1x+v1y*v1y;// Compute barycentric coordinates\nvar b=dot00*dot11-dot01*dot01;var inv=b===0?0:1/b;var u;var v;var v2x;var v2y;var dot02;var dot12;var x1=triangle.x1;var y1=triangle.y1;for(var i=0;i<points.length;i++){v2x=points[i].x-x1;v2y=points[i].y-y1;dot02=v0x*v2x+v0y*v2y;dot12=v1x*v2x+v1y*v2y;u=(dot11*dot02-dot01*dot12)*inv;v=(dot00*dot12-dot01*dot02)*inv;if(u>=0&&v>=0&&u+v<1){out.push({x:points[i].x,y:points[i].y});if(returnFirst){break;}}}return out;};module.exports=ContainsArray;/***/},/* 131 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Mesh=__webpack_require__(97);/**\r\n * @classdesc\r\n * A Quad Game Object.\r\n *\r\n * A Quad is a Mesh Game Object pre-configured with two triangles arranged into a rectangle, with a single\r\n * texture spread across them.\r\n *\r\n * You can manipulate the corner points of the quad via the getters and setters such as `topLeftX`, and also\r\n * change their alpha and color values. The quad itself can be moved by adjusting the `x` and `y` properties.\r\n *\r\n * @class Quad\r\n * @extends Phaser.GameObjects.Mesh\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var Quad=new Class({Extends:Mesh,initialize:function Quad(scene,x,y,texture,frame){//  0----3\n//  |\\  B|\n//  | \\  |\n//  |  \\ |\n//  | A \\|\n//  |    \\\n//  1----2\nvar vertices=[0,0,// tl\n0,0,// bl\n0,0,// br\n0,0,// tl\n0,0,// br\n0,0// tr\n];var uv=[0,0,// tl\n0,1,// bl\n1,1,// br\n0,0,// tl\n1,1,// br\n1,0// tr\n];var colors=[0xffffff,// tl\n0xffffff,// bl\n0xffffff,// br\n0xffffff,// tl\n0xffffff,// br\n0xffffff// tr\n];var alphas=[1,// tl\n1,// bl\n1,// br\n1,// tl\n1,// br\n1// tr\n];Mesh.call(this,scene,x,y,vertices,uv,colors,alphas,texture,frame);this.resetPosition();},/**\r\n     * The top-left x vertex of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#topLeftX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */topLeftX:{get:function get(){return this.x+this.vertices[0];},set:function set(value){this.vertices[0]=value-this.x;this.vertices[6]=value-this.x;}},/**\r\n     * The top-left y vertex of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#topLeftY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */topLeftY:{get:function get(){return this.y+this.vertices[1];},set:function set(value){this.vertices[1]=value-this.y;this.vertices[7]=value-this.y;}},/**\r\n     * The top-right x vertex of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#topRightX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */topRightX:{get:function get(){return this.x+this.vertices[10];},set:function set(value){this.vertices[10]=value-this.x;}},/**\r\n     * The top-right y vertex of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#topRightY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */topRightY:{get:function get(){return this.y+this.vertices[11];},set:function set(value){this.vertices[11]=value-this.y;}},/**\r\n     * The bottom-left x vertex of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#bottomLeftX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottomLeftX:{get:function get(){return this.x+this.vertices[2];},set:function set(value){this.vertices[2]=value-this.x;}},/**\r\n     * The bottom-left y vertex of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#bottomLeftY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottomLeftY:{get:function get(){return this.y+this.vertices[3];},set:function set(value){this.vertices[3]=value-this.y;}},/**\r\n     * The bottom-right x vertex of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#bottomRightX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottomRightX:{get:function get(){return this.x+this.vertices[4];},set:function set(value){this.vertices[4]=value-this.x;this.vertices[8]=value-this.x;}},/**\r\n     * The bottom-right y vertex of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#bottomRightY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottomRightY:{get:function get(){return this.y+this.vertices[5];},set:function set(value){this.vertices[5]=value-this.y;this.vertices[9]=value-this.y;}},/**\r\n     * The top-left alpha value of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#topLeftAlpha\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */topLeftAlpha:{get:function get(){return this.alphas[0];},set:function set(value){this.alphas[0]=value;this.alphas[3]=value;}},/**\r\n     * The top-right alpha value of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#topRightAlpha\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */topRightAlpha:{get:function get(){return this.alphas[5];},set:function set(value){this.alphas[5]=value;}},/**\r\n     * The bottom-left alpha value of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#bottomLeftAlpha\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */bottomLeftAlpha:{get:function get(){return this.alphas[1];},set:function set(value){this.alphas[1]=value;}},/**\r\n     * The bottom-right alpha value of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#bottomRightAlpha\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */bottomRightAlpha:{get:function get(){return this.alphas[2];},set:function set(value){this.alphas[2]=value;this.alphas[4]=value;}},/**\r\n     * The top-left color value of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#topLeftColor\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */topLeftColor:{get:function get(){return this.colors[0];},set:function set(value){this.colors[0]=value;this.colors[3]=value;}},/**\r\n     * The top-right color value of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#topRightColor\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */topRightColor:{get:function get(){return this.colors[5];},set:function set(value){this.colors[5]=value;}},/**\r\n     * The bottom-left color value of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#bottomLeftColor\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottomLeftColor:{get:function get(){return this.colors[1];},set:function set(value){this.colors[1]=value;}},/**\r\n     * The bottom-right color value of this Quad.\r\n     *\r\n     * @name Phaser.GameObjects.Quad#bottomRightColor\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottomRightColor:{get:function get(){return this.colors[2];},set:function set(value){this.colors[2]=value;this.colors[4]=value;}},/**\r\n     * Sets the top-left vertex position of this Quad.\r\n     *\r\n     * @method Phaser.GameObjects.Quad#setTopLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate of the vertex.\r\n     * @param {number} y - The vertical coordinate of the vertex.\r\n     *\r\n     * @return {Phaser.GameObjects.Quad} This Game Object.\r\n     */setTopLeft:function setTopLeft(x,y){this.topLeftX=x;this.topLeftY=y;return this;},/**\r\n     * Sets the top-right vertex position of this Quad.\r\n     *\r\n     * @method Phaser.GameObjects.Quad#setTopRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate of the vertex.\r\n     * @param {number} y - The vertical coordinate of the vertex.\r\n     *\r\n     * @return {Phaser.GameObjects.Quad} This Game Object.\r\n     */setTopRight:function setTopRight(x,y){this.topRightX=x;this.topRightY=y;return this;},/**\r\n     * Sets the bottom-left vertex position of this Quad.\r\n     *\r\n     * @method Phaser.GameObjects.Quad#setBottomLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate of the vertex.\r\n     * @param {number} y - The vertical coordinate of the vertex.\r\n     *\r\n     * @return {Phaser.GameObjects.Quad} This Game Object.\r\n     */setBottomLeft:function setBottomLeft(x,y){this.bottomLeftX=x;this.bottomLeftY=y;return this;},/**\r\n     * Sets the bottom-right vertex position of this Quad.\r\n     *\r\n     * @method Phaser.GameObjects.Quad#setBottomRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate of the vertex.\r\n     * @param {number} y - The vertical coordinate of the vertex.\r\n     *\r\n     * @return {Phaser.GameObjects.Quad} This Game Object.\r\n     */setBottomRight:function setBottomRight(x,y){this.bottomRightX=x;this.bottomRightY=y;return this;},/**\r\n     * Resets the positions of the four corner vertices of this Quad.\r\n     *\r\n     * @method Phaser.GameObjects.Quad#resetPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Quad} This Game Object.\r\n     */resetPosition:function resetPosition(){var x=this.x;var y=this.y;var halfWidth=Math.floor(this.width/2);var halfHeight=Math.floor(this.height/2);this.setTopLeft(x-halfWidth,y-halfHeight);this.setTopRight(x+halfWidth,y-halfHeight);this.setBottomLeft(x-halfWidth,y+halfHeight);this.setBottomRight(x+halfWidth,y+halfHeight);return this;},/**\r\n     * Resets the alpha values used by this Quad back to 1.\r\n     *\r\n     * @method Phaser.GameObjects.Quad#resetAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Quad} This Game Object.\r\n     */resetAlpha:function resetAlpha(){var alphas=this.alphas;alphas[0]=1;alphas[1]=1;alphas[2]=1;alphas[3]=1;alphas[4]=1;alphas[5]=1;return this;},/**\r\n     * Resets the color values used by this Quad back to 0xffffff.\r\n     *\r\n     * @method Phaser.GameObjects.Quad#resetColors\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Quad} This Game Object.\r\n     */resetColors:function resetColors(){var colors=this.colors;colors[0]=0xffffff;colors[1]=0xffffff;colors[2]=0xffffff;colors[3]=0xffffff;colors[4]=0xffffff;colors[5]=0xffffff;return this;},/**\r\n     * Resets the position, alpha and color values used by this Quad.\r\n     *\r\n     * @method Phaser.GameObjects.Quad#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Quad} This Game Object.\r\n     */reset:function reset(){this.resetPosition();this.resetAlpha();return this.resetColors();}});module.exports=Quad;/***/},/* 132 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CanvasPool=__webpack_require__(23);var Class=__webpack_require__(0);var Components=__webpack_require__(12);var CONST=__webpack_require__(22);var GameObject=__webpack_require__(1);var GetPowerOfTwo=__webpack_require__(250);var TileSpriteRender=__webpack_require__(703);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TileSprite\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} width - The width of the Game Object.\r\n * @param {number} height - The height of the Game Object.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var TileSprite=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.Depth,Components.Flip,Components.GetBounds,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.ScrollFactor,Components.Size,Components.Texture,Components.Tint,Components.Transform,Components.Visible,TileSpriteRender],initialize:function TileSprite(scene,x,y,width,height,texture,frame){var renderer=scene.sys.game.renderer;GameObject.call(this,scene,'TileSprite');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#tilePositionX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.tilePositionX=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#tilePositionY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.tilePositionY=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#dirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.dirty=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#tileTexture\r\n         * @type {?WebGLTexture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.tileTexture=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.0.0\r\n         */this.renderer=renderer;this.setTexture(texture,frame);this.setPosition(x,y);this.setSize(width,height);this.setOriginFromFrame();this.initPipeline('TextureTintPipeline');/**\r\n         * The next power of two value from the width of the Frame.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#potWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.potWidth=GetPowerOfTwo(this.frame.width);/**\r\n         * The next power of two value from the height of the Frame.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#potHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.potHeight=GetPowerOfTwo(this.frame.height);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#canvasPattern\r\n         * @type {?CanvasPattern}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.canvasPattern=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#canvasBuffer\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */this.canvasBuffer=CanvasPool.create2D(null,this.potWidth,this.potHeight);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#canvasBufferCtx\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */this.canvasBufferCtx=this.canvasBuffer.getContext('2d');this.oldFrame=null;this.updateTileTexture();if(scene.sys.game.config.renderType===CONST.WEBGL){scene.sys.game.renderer.onContextRestored(function(renderer){var gl=renderer.gl;this.tileTexture=null;this.dirty=true;this.tileTexture=renderer.createTexture2D(0,gl.LINEAR,gl.LINEAR,gl.REPEAT,gl.REPEAT,gl.RGBA,this.canvasBuffer,this.potWidth,this.potHeight);},this);}},/**\r\n     * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTilePosition\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} [x] - The x position of this sprite's tiling texture.\r\n     * @param {number} [y] - The y position of this sprite's tiling texture.\r\n     *\r\n     * @return {Phaser.GameObjects.TileSprite} This Tile Sprite instance.\r\n     */setTilePosition:function setTilePosition(x,y){if(x!==undefined){this.tilePositionX=x;}if(y!==undefined){this.tilePositionY=y;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#updateTileTexture\r\n     * @since 3.0.0\r\n     */updateTileTexture:function updateTileTexture(){if(!this.dirty&&this.oldFrame===this.frame){return;}this.oldFrame=this.frame;this.canvasBufferCtx.clearRect(0,0,this.canvasBuffer.width,this.canvasBuffer.height);if(this.renderer.gl){this.canvasBufferCtx.drawImage(this.frame.source.image,this.frame.cutX,this.frame.cutY,this.frame.cutWidth,this.frame.cutHeight,0,0,this.potWidth,this.potHeight);this.tileTexture=this.renderer.canvasToTexture(this.canvasBuffer,this.tileTexture,this.tileTexture===null,this.scaleMode);}else{this.canvasBuffer.width=this.frame.cutWidth;this.canvasBuffer.height=this.frame.cutHeight;this.canvasBufferCtx.drawImage(this.frame.source.image,this.frame.cutX,this.frame.cutY,this.frame.cutWidth,this.frame.cutHeight,0,0,this.frame.cutWidth,this.frame.cutHeight);this.canvasPattern=this.canvasBufferCtx.createPattern(this.canvasBuffer,'repeat');}this.dirty=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){if(this.renderer){this.renderer.deleteTexture(this.tileTexture);}CanvasPool.remove(this.canvasBuffer);this.canvasPattern=null;this.canvasBufferCtx=null;this.canvasBuffer=null;this.renderer=null;this.visible=false;}});module.exports=TileSprite;/***/},/* 133 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var AddToDOM=__webpack_require__(153);var CanvasPool=__webpack_require__(23);var Class=__webpack_require__(0);var Components=__webpack_require__(12);var CONST=__webpack_require__(22);var GameObject=__webpack_require__(1);var GetTextSize=__webpack_require__(709);var GetValue=__webpack_require__(5);var RemoveFromDOM=__webpack_require__(317);var TextRender=__webpack_require__(708);var TextStyle=__webpack_require__(705);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Text\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {object} style - The text style configuration object.\r\n */var Text=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.ComputedSize,Components.Depth,Components.Flip,Components.GetBounds,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.ScrollFactor,Components.Tint,Components.Transform,Components.Visible,TextRender],initialize:function Text(scene,x,y,text,style){if(x===undefined){x=0;}if(y===undefined){y=0;}GameObject.call(this,scene,'Text');this.setPosition(x,y);this.setOrigin(0,0);this.initPipeline('TextureTintPipeline');/**\r\n         * The canvas element that the text is rendered to.\r\n         *\r\n         * @name Phaser.GameObjects.Text#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */this.canvas=CanvasPool.create(this);/**\r\n         * The context of the canvas element that the text is rendered to.\r\n         *\r\n         * @name Phaser.GameObjects.Text#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */this.context=this.canvas.getContext('2d');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Text#style\r\n         * @type {Phaser.GameObjects.Components.TextStyle}\r\n         * @since 3.0.0\r\n         */this.style=new TextStyle(this,style);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Text#autoRound\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.autoRound=true;/**\r\n         * The Regular Expression that is used to split the text up into lines, in\r\n         * multi-line text. By default this is `/(?:\\r\\n|\\r|\\n)/`.\r\n         * You can change this RegExp to be anything else that you may need.\r\n         *\r\n         * @name Phaser.GameObjects.Text#splitRegExp\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.splitRegExp=/(?:\\r\\n|\\r|\\n)/;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Text#text\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.text='';/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Text#resolution\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.resolution=1;/**\r\n         * Specify a padding value which is added to the line width and height when calculating the Text size.\r\n         * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.\r\n         *\r\n         * @name Phaser.GameObjects.Text#padding\r\n         * @type {{left:number,right:number,top:number,bottom:number}}\r\n         * @since 3.0.0\r\n         */this.padding={left:0,right:0,top:0,bottom:0};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Text#width\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.width=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Text#height\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.height=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Text#canvasTexture\r\n         * @type {HTMLCanvasElement}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.canvasTexture=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Text#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.dirty=false;this.initRTL();if(style&&style.padding){this.setPadding(style.padding);}if(style&&style.lineSpacing){this._lineSpacing=style.lineSpacing;}this.setText(text);if(scene.sys.game.config.renderType===CONST.WEBGL){scene.sys.game.renderer.onContextRestored(function(){this.canvasTexture=null;this.dirty=true;},this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#initRTL\r\n     * @since 3.0.0\r\n     */initRTL:function initRTL(){if(!this.style.rtl){return;}//  Here is where the crazy starts.\n//\n//  Due to browser implementation issues, you cannot fillText BiDi text to a canvas\n//  that is not part of the DOM. It just completely ignores the direction property.\nthis.canvas.dir='rtl';//  Experimental atm, but one day ...\nthis.context.direction='rtl';//  Add it to the DOM, but hidden within the parent canvas.\nthis.canvas.style.display='none';AddToDOM(this.canvas,this.scene.sys.canvas);//  And finally we set the x origin\nthis.originX=1;},/**\r\n     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds.\r\n     *\r\n     * @method Phaser.GameObjects.Text#runWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     *\r\n     * @return {string} The text after wrapping has been applied.\r\n     */runWordWrap:function runWordWrap(text){var style=this.style;if(style.wordWrapCallback){var wrappedLines=style.wordWrapCallback.call(style.wordWrapCallbackScope,text,this);if(Array.isArray(wrappedLines)){wrappedLines=wrappedLines.join('\\n');}return wrappedLines;}else if(style.wordWrapWidth){if(style.wordWrapUseAdvanced){return this.advancedWordWrap(text,this.context,this.style.wordWrapWidth);}else{return this.basicWordWrap(text,this.context,this.style.wordWrapWidth);}}else{return text;}},/**\r\n     * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be\r\n     * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a\r\n     * single character.\r\n     *\r\n     * @method Phaser.GameObjects.Text#advancedWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     * @param {CanvasRenderingContext2D} context - [description]\r\n     * @param {number} wordWrapWidth - [description]\r\n     *\r\n     * @return {string} The wrapped text.\r\n     */advancedWordWrap:function advancedWordWrap(text,context,wordWrapWidth){var output='';// Condense consecutive spaces and split into lines\nvar lines=text.replace(/ +/gi,' ').split(this.splitRegExp);var linesCount=lines.length;for(var i=0;i<linesCount;i++){var line=lines[i];var out='';// Trim whitespace\nline=line.replace(/^ *|\\s*$/gi,'');// If entire line is less than wordWrapWidth append the entire line and exit early\nvar lineWidth=context.measureText(line).width;if(lineWidth<wordWrapWidth){output+=line+'\\n';continue;}// Otherwise, calculate new lines\nvar currentLineWidth=wordWrapWidth;// Split into words\nvar words=line.split(' ');for(var j=0;j<words.length;j++){var word=words[j];var wordWithSpace=word+' ';var wordWidth=context.measureText(wordWithSpace).width;if(wordWidth>currentLineWidth){// Break word\nif(j===0){// Shave off letters from word until it's small enough\nvar newWord=wordWithSpace;while(newWord.length){newWord=newWord.slice(0,-1);wordWidth=context.measureText(newWord).width;if(wordWidth<=currentLineWidth){break;}}// If wordWrapWidth is too small for even a single letter, shame user\n// failure with a fatal error\nif(!newWord.length){throw new Error('This text\\'s wordWrapWidth setting is less than a single character!');}// Replace current word in array with remainder\nvar secondPart=word.substr(newWord.length);words[j]=secondPart;// Append first piece to output\nout+=newWord;}// If existing word length is 0, don't include it\nvar offset=words[j].length?j:j+1;// Collapse rest of sentence and remove any trailing white space\nvar remainder=words.slice(offset).join(' ').replace(/[ \\n]*$/gi,'');// Prepend remainder to next line\nlines[i+1]=remainder+' '+(lines[i+1]||'');linesCount=lines.length;break;// Processing on this line\n// Append word with space to output\n}else{out+=wordWithSpace;currentLineWidth-=wordWidth;}}// Append processed line to output\noutput+=out.replace(/[ \\n]*$/gi,'')+'\\n';}// Trim the end of the string\noutput=output.replace(/[\\s|\\n]*$/gi,'');return output;},/**\r\n     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds. Spaces are not collapsed and whitespace is not trimmed.\r\n     *\r\n     * @method Phaser.GameObjects.Text#basicWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     * @param {CanvasRenderingContext2D} context - [description]\r\n     * @param {number} wordWrapWidth - [description]\r\n     *\r\n     * @return {string} The wrapped text.\r\n     */basicWordWrap:function basicWordWrap(text,context,wordWrapWidth){var result='';var lines=text.split(this.splitRegExp);for(var i=0;i<lines.length;i++){var spaceLeft=wordWrapWidth;var words=lines[i].split(' ');for(var j=0;j<words.length;j++){var wordWidth=context.measureText(words[j]).width;var wordWidthWithSpace=wordWidth+context.measureText(' ').width;if(wordWidthWithSpace>spaceLeft){// Skip printing the newline if it's the first word of the line that is greater\n// than the word wrap width.\nif(j>0){result+='\\n';}result+=words[j]+' ';spaceLeft=wordWrapWidth-wordWidth;}else{spaceLeft-=wordWidthWithSpace;result+=words[j]+' ';}}if(i<lines.length-1){result+='\\n';}}return result;},/**\r\n     * Runs the given text through this Text objects word wrapping and returns the results as an\r\n     * array, where each element of the array corresponds to a wrapped line of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#getWrappedText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.\r\n     *\r\n     * @return {string[]} An array of strings with the pieces of wrapped text.\r\n     */getWrappedText:function getWrappedText(text){if(text===undefined){text=this.text;}this.style.syncFont(this.canvas,this.context);var wrappedLines=this.runWordWrap(text);return wrappedLines.split(this.splitRegExp);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this Text object.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setText:function setText(value){if(!value&&value!==0){value='';}if(Array.isArray(value)){value=value.join('\\n');}if(value!==this.text){this.text=value.toString();this.updateText();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} style - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setStyle:function setStyle(style){return this.style.setStyle(style);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFont\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} font - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setFont:function setFont(font){return this.style.setFont(font);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontFamily\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} family - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setFontFamily:function setFontFamily(family){return this.style.setFontFamily(family);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setFontSize:function setFontSize(size){return this.style.setFontSize(size);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} style - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setFontStyle:function setFontStyle(style){return this.style.setFontStyle(style);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFixedSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setFixedSize:function setFixedSize(width,height){return this.style.setFixedSize(width,height);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setBackgroundColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setBackgroundColor:function setBackgroundColor(color){return this.style.setBackgroundColor(color);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setFill:function setFill(color){return this.style.setFill(color);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setColor:function setColor(color){return this.style.setColor(color);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     * @param {number} thickness - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setStroke:function setStroke(color,thickness){return this.style.setStroke(color,thickness);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {string} color - [description]\r\n     * @param {number} blur - [description]\r\n     * @param {boolean} shadowStroke - [description]\r\n     * @param {boolean} shadowFill - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setShadow:function setShadow(x,y,color,blur,shadowStroke,shadowFill){return this.style.setShadow(x,y,color,blur,shadowStroke,shadowFill);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setShadowOffset:function setShadowOffset(x,y){return this.style.setShadowOffset(x,y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setShadowColor:function setShadowColor(color){return this.style.setShadowColor(color);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowBlur\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} blur - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setShadowBlur:function setShadowBlur(blur){return this.style.setShadowBlur(blur);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setShadowStroke:function setShadowStroke(enabled){return this.style.setShadowStroke(enabled);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setShadowFill:function setShadowFill(enabled){return this.style.setShadowFill(enabled);},/**\r\n     * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setWordWrapWidth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {?number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\r\n     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\r\n     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\r\n     * spaces and whitespace are left as is.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setWordWrapWidth:function setWordWrapWidth(width,useAdvancedWrap){return this.style.setWordWrapWidth(width,useAdvancedWrap);},/**\r\n     * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setWordWrapCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\r\n     * text. It will receive two arguments: text (the string to wrap), textObject (this Text\r\n     * instance). It should return the wrapped lines either as an array of lines or as a string with\r\n     * newline characters in place to indicate where breaks should happen.\r\n     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setWordWrapCallback:function setWordWrapCallback(callback,scope){return this.style.setWordWrapCallback(callback,scope);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setAlign\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} align - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setAlign:function setAlign(align){return this.style.setAlign(align);},/**\r\n     * 'left' can be an object.\r\n     * If only 'left' and 'top' are given they are treated as 'x' and 'y'\r\n     *\r\n     * @method Phaser.GameObjects.Text#setPadding\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} left - [description]\r\n     * @param {number} top - [description]\r\n     * @param {number} right - [description]\r\n     * @param {number} bottom - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setPadding:function setPadding(left,top,right,bottom){if((typeof left==='undefined'?'undefined':_typeof(left))==='object'){var config=left;//  If they specify x and/or y this applies to all\nvar x=GetValue(config,'x',null);if(x!==null){left=x;right=x;}else{left=GetValue(config,'left',0);right=GetValue(config,'right',left);}var y=GetValue(config,'y',null);if(y!==null){top=y;bottom=y;}else{top=GetValue(config,'top',0);bottom=GetValue(config,'bottom',top);}}else{if(left===undefined){left=0;}if(top===undefined){top=left;}if(right===undefined){right=left;}if(bottom===undefined){bottom=top;}}this.padding.left=left;this.padding.top=top;this.padding.right=right;this.padding.bottom=bottom;return this.updateText();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#setMaxLines\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [max=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */setMaxLines:function setMaxLines(max){return this.style.setMaxLines(max);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#updateText\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */updateText:function updateText(){var canvas=this.canvas;var context=this.context;var style=this.style;var resolution=this.resolution;var size=style.metrics;style.syncFont(canvas,context);var outputText=this.text;if(style.wordWrapWidth||style.wordWrapCallback){outputText=this.runWordWrap(this.text);}//  Split text into lines\nvar lines=outputText.split(this.splitRegExp);var textSize=GetTextSize(this,size,lines);var padding=this.padding;var w=textSize.width+padding.left+padding.right;var h=textSize.height+padding.top+padding.bottom;if(style.fixedWidth===0){this.width=w;}if(style.fixedHeight===0){this.height=h;}this.updateDisplayOrigin();w*=resolution;h*=resolution;w=Math.max(w,1);h=Math.max(h,1);if(canvas.width!==w||canvas.height!==h){canvas.width=w;canvas.height=h;style.syncFont(canvas,context);// Resizing resets the context\n}else{context.clearRect(0,0,w,h);}context.save();// context.scale(resolution, resolution);\nif(style.backgroundColor){context.fillStyle=style.backgroundColor;context.fillRect(0,0,w,h);}style.syncStyle(canvas,context);context.textBaseline='alphabetic';//  Apply padding\ncontext.translate(padding.left,padding.top);var linePositionX;var linePositionY;//  Draw text line by line\nfor(var i=0;i<textSize.lines;i++){linePositionX=style.strokeThickness/2;linePositionY=style.strokeThickness/2+i*textSize.lineHeight+size.ascent;if(i>0){linePositionY+=textSize.lineSpacing*i;}if(style.rtl){linePositionX=w-linePositionX;}else if(style.align==='right'){linePositionX+=textSize.width-textSize.lineWidths[i];}else if(style.align==='center'){linePositionX+=(textSize.width-textSize.lineWidths[i])/2;}if(this.autoRound){linePositionX=Math.round(linePositionX);linePositionY=Math.round(linePositionY);}if(style.strokeThickness){this.style.syncShadow(context,style.shadowStroke);context.strokeText(lines[i],linePositionX,linePositionY);}if(style.color){this.style.syncShadow(context,style.shadowFill);context.fillText(lines[i],linePositionX,linePositionY);}}context.restore();this.dirty=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#getTextMetrics\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */getTextMetrics:function getTextMetrics(){return this.style.getTextMetrics();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */toJSON:function toJSON(){var out=Components.ToJSON(this);//  Extra Text data is added here\nvar data={autoRound:this.autoRound,text:this.text,style:this.style.toJSON(),resolution:this.resolution,padding:{left:this.padding.left,right:this.padding.right,top:this.padding.top,bottom:this.padding.bottom}};out.data=data;return out;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Text#preDestroy\r\n     * @since 3.0.0\r\n     */preDestroy:function preDestroy(){if(this.style.rtl){RemoveFromDOM(this.canvas);}CanvasPool.remove(this.canvas);}});module.exports=Text;/***/},/* 134 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CanvasPool=__webpack_require__(23);var Class=__webpack_require__(0);var Components=__webpack_require__(12);var CONST=__webpack_require__(22);var GameObject=__webpack_require__(1);var Render=__webpack_require__(714);var RenderTextureCanvas=__webpack_require__(711);var RenderTextureWebGL=__webpack_require__(710);/**\r\n * @classdesc\r\n * A Render Texture.\r\n *\r\n * @class RenderTexture\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.MatrixStack\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {integer} [width=32] - The width of the Render Texture.\r\n * @param {integer} [height=32] - The height of the Render Texture.\r\n */var RenderTexture=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.ComputedSize,Components.Depth,Components.Flip,Components.GetBounds,Components.MatrixStack,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.ScrollFactor,Components.Tint,Components.Transform,Components.Visible,Render],initialize:function RenderTexture(scene,x,y,width,height){if(width===undefined){width=32;}if(height===undefined){height=32;}GameObject.call(this,scene,'RenderTexture');this.initMatrixStack();/**\r\n         * A reference to either the Canvas or WebGL Renderer that the Game instance is using.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.2.0\r\n         */this.renderer=scene.sys.game.renderer;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalTint\r\n         * @type {number}\r\n         * @default 0xffffff\r\n         * @since 3.2.0\r\n         */this.globalTint=0xffffff;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalAlpha\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.2.0\r\n         */this.globalAlpha=1;if(this.renderer.type===CONST.WEBGL){var gl=this.renderer.gl;this.gl=gl;this.fill=RenderTextureWebGL.fill;this.clear=RenderTextureWebGL.clear;this.draw=RenderTextureWebGL.draw;this.drawFrame=RenderTextureWebGL.drawFrame;this.texture=this.renderer.createTexture2D(0,gl.NEAREST,gl.NEAREST,gl.CLAMP_TO_EDGE,gl.CLAMP_TO_EDGE,gl.RGBA,null,width,height,false);this.framebuffer=this.renderer.createFramebuffer(width,height,this.texture,false);}else if(this.renderer.type===CONST.CANVAS){this.fill=RenderTextureCanvas.fill;this.clear=RenderTextureCanvas.clear;this.draw=RenderTextureCanvas.draw;this.drawFrame=RenderTextureCanvas.drawFrame;this.canvas=CanvasPool.create2D(null,width,height);this.context=this.canvas.getContext('2d');}this.setPosition(x,y);this.setSize(width,height);this.initPipeline('TextureTintPipeline');},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#destroy\r\n     * @since 3.2.0\r\n     */destroy:function destroy(){GameObject.prototype.destroy.call(this);if(this.renderer.type===CONST.WEBGL){this.renderer.deleteTexture(this.texture);this.renderer.deleteFramebuffer(this.framebuffer);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalTint\r\n     * @since 3.2.0\r\n     *\r\n     * @param {integer} tint [description]\r\n     *\r\n     * @return {Phaser.GameObjects.RenderTexture} [description]\r\n     */setGlobalTint:function setGlobalTint(tint){this.globalTint=tint;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalAlpha\r\n     * @since 3.2.0\r\n     *\r\n     * @param {float} alpha [description]\r\n     *\r\n     * @return {Phaser.GameObjects.RenderTexture} [description]\r\n     */setGlobalAlpha:function setGlobalAlpha(alpha){this.globalAlpha=alpha;return this;}/**\r\n     * Fills the Render Texture with the given color.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#fill\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} rgb - The color to fill the Render Texture with.\r\n     *\r\n     * @return {Phaser.GameObjects.RenderTexture} This Game Object.\r\n     *//**\r\n     * Clears the Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#clear\r\n     * @since 3.2.0\r\n     *\r\n     * @return {Phaser.GameObjects.RenderTexture} This Game Object.\r\n     *//**\r\n     * Draws a texture frame to the Render Texture at the given position.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#draw\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     * @param {number} x - The x position to draw the frame at.\r\n     * @param {number} y - The y position to draw the frame at.\r\n     *\r\n     * @return {Phaser.GameObjects.RenderTexture} This Game Object.\r\n     */});module.exports=RenderTexture;/***/},/* 135 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var GameObject=__webpack_require__(1);var GravityWell=__webpack_require__(271);var List=__webpack_require__(101);var ParticleEmitter=__webpack_require__(269);var Render=__webpack_require__(717);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ParticleEmitterManager\r\n * @extends Phaser.GameObjects.Particles.GameObject\r\n * @memberOf Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Particles.Components.Depth\r\n * @extends Phaser.GameObjects.Particles.Components.Visible\r\n * @extends Phaser.GameObjects.Particles.Components.Pipeline\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {string} texture - [description]\r\n * @param {(string|integer)} frame - [description]\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitter[]} emitters - [description]\r\n */var ParticleEmitterManager=new Class({Extends:GameObject,Mixins:[Components.Depth,Components.Visible,Components.Pipeline,Render],initialize://  frame is optional and can contain the emitters array or object if skipped\nfunction ParticleEmitterManager(scene,texture,frame,emitters){GameObject.call(this,scene,'ParticleEmitterManager');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#blendMode\r\n         * @type {number}\r\n         * @default -1\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.blendMode=-1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#timeScale\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.timeScale=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.texture=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.frame=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#frameNames\r\n         * @type {Phaser.Textures.Frame[]}\r\n         * @since 3.0.0\r\n         */this.frameNames=[];//  frame is optional and can contain the emitters array or object if skipped\nif(frame!==null&&((typeof frame==='undefined'?'undefined':_typeof(frame))==='object'||Array.isArray(frame))){emitters=frame;frame=null;}this.setTexture(texture,frame);this.initPipeline('TextureTintPipeline');/**\r\n         * A list of Emitters being managed by this Emitter Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#emitters\r\n             * @type {Phaser.Structs.List.<Phaser.GameObjects.Particles.ParticleEmitter>}\r\n         * @since 3.0.0\r\n         */this.emitters=new List(this);/**\r\n         * A list of Gravity Wells being managed by this Emitter Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#wells\r\n         * @type {Phaser.Structs.List.<Phaser.GameObjects.Particles.GravityWell>}\r\n         * @since 3.0.0\r\n         */this.wells=new List(this);if(emitters){//  An array of emitter configs?\nif(!Array.isArray(emitters)){emitters=[emitters];}for(var i=0;i<emitters.length;i++){this.createEmitter(emitters[i]);}}},/**\r\n     * Sets the texture and frame this Game Object will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} This Game Object.\r\n     */setTexture:function setTexture(key,frame){this.texture=this.scene.sys.textures.get(key);return this.setFrame(frame);},/**\r\n     * Sets the frame this Game Object will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} This Game Object.\r\n     */setFrame:function setFrame(frame){this.frame=this.texture.get(frame);this.frameNames=this.texture.getFramesFromTextureSource(this.frame.sourceIndex);this.defaultFrame=this.frame;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setEmitterFrames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Textures.Frame|Phaser.Textures.Frame[])} frames - [description]\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} This Game Object.\r\n     */setEmitterFrames:function setEmitterFrames(frames,emitter){if(!Array.isArray(frames)){frames=[frames];}var out=emitter.frames;out.length=0;for(var i=0;i<frames.length;i++){var frame=frames[i];if(this.frameNames.indexOf(frame)!==-1){out.push(this.texture.get(frame));}}if(out.length>0){emitter.defaultFrame=out[0];}else{emitter.defaultFrame=this.defaultFrame;}return this;},/**\r\n     * Adds an existing Particle Emitter to this Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#addEmitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Particle Emitter to add to this Emitter Manager.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter that was added to this Emitter Manager.\r\n     */addEmitter:function addEmitter(emitter){return this.emitters.add(emitter);},/**\r\n     * Creates a new Particle Emitter object, adds it to this Manager and returns a reference to it.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#createEmitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter that was created.\r\n     */createEmitter:function createEmitter(config){return this.addEmitter(new ParticleEmitter(this,config));},/**\r\n     * Adds an existing Gravity Well object to this Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#addGravityWell\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.GravityWell} well - The Gravity Well to add to this Emitter Manager.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell} The Gravity Well that was added to this Emitter Manager.\r\n     */addGravityWell:function addGravityWell(well){return this.wells.add(well);},/**\r\n     * Creates a new Gravity Well, adds it to this Manager and returns a reference to it.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#createGravityWell\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell} The Gravity Well that was created.\r\n     */createGravityWell:function createGravityWell(config){return this.addGravityWell(new GravityWell(config));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#emitParticle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} count - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} This Game Object.\r\n     */emitParticle:function emitParticle(count,x,y){var emitters=this.emitters.list;for(var i=0;i<emitters.length;i++){var emitter=emitters[i];if(emitter.active){emitter.emitParticle(count,x,y);}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#emitParticleAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {integer} count - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} This Game Object.\r\n     */emitParticleAt:function emitParticleAt(x,y,count){return this.emitParticle(count,x,y);},/**\r\n     * Pauses this Emitter Manager.\r\n     *\r\n     * This has the effect of pausing all emitters, and all particles of those emitters, currently under its control.\r\n     *\r\n     * The particles will still render, but they will not have any of their logic updated.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} This Game Object.\r\n     */pause:function pause(){this.active=false;return this;},/**\r\n     * Resumes this Emitter Manager, should it have been previously paused.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} This Game Object.\r\n     */resume:function resume(){this.active=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#getProcessors\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell[]} [description]\r\n     */getProcessors:function getProcessors(){return this.wells.getAll('active',true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */preUpdate:function preUpdate(time,delta){//  Scale the delta\ndelta*=this.timeScale;var emitters=this.emitters.list;for(var i=0;i<emitters.length;i++){var emitter=emitters[i];if(emitter.active){emitter.preUpdate(time,delta);}}}});module.exports=ParticleEmitterManager;/***/},/* 136 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse based on the given angle.\r\n *\r\n * @function Phaser.Geom.Ellipse.CircumferencePoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the circumference point on.\r\n * @param {number} angle - The angle from the center of the Ellipse to the circumference to return the point from. Given in radians.\r\n * @param {(Phaser.Geom.Point|object)} [out] - A Point, or point-like object, to store the results in. If not given a Point will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object where the `x` and `y` properties are the point on the circumference.\r\n */var CircumferencePoint=function CircumferencePoint(ellipse,angle,out){if(out===undefined){out=new Point();}var halfWidth=ellipse.width/2;var halfHeight=ellipse.height/2;out.x=ellipse.x+halfWidth*Math.cos(angle);out.y=ellipse.y+halfHeight*Math.sin(angle);return out;};module.exports=CircumferencePoint;/***/},/* 137 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Contains=__webpack_require__(75);var GetPoint=__webpack_require__(275);var GetPoints=__webpack_require__(274);var Random=__webpack_require__(169);/**\r\n * @classdesc\r\n * An Ellipse object.\r\n *\r\n * This is a geometry object, containing numerical values and related methods to inspect and modify them.\r\n * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.\r\n * To render an Ellipse you should look at the capabilities of the Graphics class.\r\n *\r\n * @class Ellipse\r\n * @memberOf Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - The x position of the center of the ellipse.\r\n * @param {number} [y=0] - The y position of the center of the ellipse.\r\n * @param {number} [width=0] - The width of the ellipse.\r\n * @param {number} [height=0] - The height of the ellipse.\r\n */var Ellipse=new Class({initialize:function Ellipse(x,y,width,height){if(x===undefined){x=0;}if(y===undefined){y=0;}if(width===undefined){width=0;}if(height===undefined){height=0;}/**\r\n         * The x position of the center of the ellipse.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * The y position of the center of the ellipse.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y=y;/**\r\n         * The width of the ellipse.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#width\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.width=width;/**\r\n         * The height of the ellipse.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#height\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.height=height;},/**\r\n     * Check to see if the Ellipse contains the given x / y coordinates.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to check within the ellipse.\r\n     * @param {number} y - The y coordinate to check within the ellipse.\r\n     *\r\n     * @return {boolean} True if the coordinates are within the ellipse, otherwise false.\r\n     */contains:function contains(x,y){return Contains(this,x,y);},/**\r\n     * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse\r\n     * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\r\n     * at 180 degrees around the circle.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [out,$return]\r\n     *\r\n     * @param {float} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.\r\n     * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the ellipse.\r\n     */getPoint:function getPoint(position,point){return GetPoint(this,position,point);},/**\r\n     * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,\r\n     * based on the given quantity or stepRate values.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n     * @param {number} [stepRate] - Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.\r\n     * @param {array} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n     *\r\n     * @return {Phaser.Geom.Point[]} An array of Point objects pertaining to the points around the circumference of the ellipse.\r\n     */getPoints:function getPoints(quantity,stepRate,output){return GetPoints(this,quantity,stepRate,output);},/**\r\n     * Returns a uniformly distributed random point from anywhere within the given Ellipse.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [point,$return]\r\n     *\r\n     * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\r\n     */getRandomPoint:function getRandomPoint(point){return Random(this,point);},/**\r\n     * Sets the x, y, width and height of this ellipse.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the center of the ellipse.\r\n     * @param {number} y - The y position of the center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     *\r\n     * @return {Phaser.Geom.Ellipse} This Ellipse object.\r\n     */setTo:function setTo(x,y,width,height){this.x=x;this.y=y;this.width=width;this.height=height;return this;},/**\r\n     * Sets this Ellipse to be empty with a width and height of zero.\r\n     * Does not change its position.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#setEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Geom.Ellipse} This Ellipse object.\r\n     */setEmpty:function setEmpty(){this.width=0;this.height=0;return this;},/**\r\n     * Sets the position of this Ellipse.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the center of the ellipse.\r\n     * @param {number} y - The y position of the center of the ellipse.\r\n     *\r\n     * @return {Phaser.Geom.Ellipse} This Ellipse object.\r\n     */setPosition:function setPosition(x,y){if(y===undefined){y=x;}this.x=x;this.y=y;return this;},/**\r\n     * Sets the size of this Ellipse.\r\n     * Does not change its position.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} [height=width] - The height of the ellipse.\r\n     *\r\n     * @return {Phaser.Geom.Ellipse} This Ellipse object.\r\n     */setSize:function setSize(width,height){if(height===undefined){height=width;}this.width=width;this.height=height;return this;},/**\r\n     * Checks to see if the Ellipse is empty: has a width or height equal to zero.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#isEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if the Ellipse is empty, otherwise false.\r\n     */isEmpty:function isEmpty(){return this.width<=0||this.height<=0;},/**\r\n     * Returns the minor radius of the ellipse. Also known as the Semi Minor Axis.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getMinorRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The minor radius.\r\n     */getMinorRadius:function getMinorRadius(){return Math.min(this.width,this.height)/2;},/**\r\n     * Returns the major radius of the ellipse. Also known as the Semi Major Axis.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getMajorRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The major radius.\r\n     */getMajorRadius:function getMajorRadius(){return Math.max(this.width,this.height)/2;},/**\r\n     * The left position of the Ellipse.\r\n     *\r\n     * @name Phaser.Geom.Ellipse#left\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */left:{get:function get(){return this.x-this.width/2;},set:function set(value){this.x=value+this.width/2;}},/**\r\n     * The right position of the Ellipse.\r\n     *\r\n     * @name Phaser.Geom.Ellipse#right\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */right:{get:function get(){return this.x+this.width/2;},set:function set(value){this.x=value-this.width/2;}},/**\r\n     * The top position of the Ellipse.\r\n     *\r\n     * @name Phaser.Geom.Ellipse#top\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */top:{get:function get(){return this.y-this.height/2;},set:function set(value){this.y=value+this.height/2;}},/**\r\n     * The bottom position of the Ellipse.\r\n     *\r\n     * @name Phaser.Geom.Ellipse#bottom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bottom:{get:function get(){return this.y+this.height/2;},set:function set(value){this.y=value-this.height/2;}}});module.exports=Ellipse;/***/},/* 138 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Camera=__webpack_require__(164);var Class=__webpack_require__(0);var Commands=__webpack_require__(150);var Components=__webpack_require__(12);var Ellipse=__webpack_require__(276);var GameObject=__webpack_require__(1);var GetValue=__webpack_require__(5);var MATH_CONST=__webpack_require__(16);var Render=__webpack_require__(757);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Graphics\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {object} options - [description]\r\n */var Graphics=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.Depth,Components.Pipeline,Components.Transform,Components.Visible,Components.ScrollFactor,Render],initialize:function Graphics(scene,options){var x=GetValue(options,'x',0);var y=GetValue(options,'y',0);GameObject.call(this,scene,'Graphics');this.setPosition(x,y);this.initPipeline('FlatTintPipeline');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#displayOriginX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.displayOriginX=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#displayOriginY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.displayOriginY=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#commandBuffer\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.commandBuffer=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultFillColor\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */this.defaultFillColor=-1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultFillAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.defaultFillAlpha=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeWidth\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.defaultStrokeWidth=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeColor\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */this.defaultStrokeColor=-1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.defaultStrokeAlpha=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#_lineWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._lineWidth=1.0;this.setDefaultStyles(options);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#setDefaultStyles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */setDefaultStyles:function setDefaultStyles(options){if(GetValue(options,'lineStyle',null)){this.defaultStrokeWidth=GetValue(options,'lineStyle.width',1);this.defaultStrokeColor=GetValue(options,'lineStyle.color',0xffffff);this.defaultStrokeAlpha=GetValue(options,'lineStyle.alpha',1);this.lineStyle(this.defaultStrokeWidth,this.defaultStrokeColor,this.defaultStrokeAlpha);}if(GetValue(options,'fillStyle',null)){this.defaultFillColor=GetValue(options,'fillStyle.color',0xffffff);this.defaultFillAlpha=GetValue(options,'fillStyle.alpha',1);this.fillStyle(this.defaultFillColor,this.defaultFillAlpha);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} lineWidth - [description]\r\n     * @param {number} color - [description]\r\n     * @param {float} [alpha=1] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */lineStyle:function lineStyle(lineWidth,color,alpha){if(alpha===undefined){alpha=1;}this.commandBuffer.push(Commands.LINE_STYLE,lineWidth,color,alpha);this._lineWidth=lineWidth;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} color - [description]\r\n     * @param {float} [alpha=1] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillStyle:function fillStyle(color,alpha){if(alpha===undefined){alpha=1;}this.commandBuffer.push(Commands.FILL_STYLE,color,alpha);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#beginPath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */beginPath:function beginPath(){this.commandBuffer.push(Commands.BEGIN_PATH);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#closePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */closePath:function closePath(){this.commandBuffer.push(Commands.CLOSE_PATH);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillPath:function fillPath(){this.commandBuffer.push(Commands.FILL_PATH);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokePath:function strokePath(){this.commandBuffer.push(Commands.STROKE_PATH);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillCircleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Circle} circle - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillCircleShape:function fillCircleShape(circle){return this.fillCircle(circle.x,circle.y,circle.radius);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeCircleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Circle} circle - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeCircleShape:function strokeCircleShape(circle){return this.strokeCircle(circle.x,circle.y,circle.radius);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} radius - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillCircle:function fillCircle(x,y,radius){this.beginPath();this.arc(x,y,radius,0,MATH_CONST.PI2);this.fillPath();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} radius - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeCircle:function strokeCircle(x,y,radius){this.beginPath();this.arc(x,y,radius,0,MATH_CONST.PI2);this.strokePath();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillRectShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} rect - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillRectShape:function fillRectShape(rect){return this.fillRect(rect.x,rect.y,rect.width,rect.height);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeRectShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} rect - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeRectShape:function strokeRectShape(rect){return this.strokeRect(rect.x,rect.y,rect.width,rect.height);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillRect:function fillRect(x,y,width,height){this.commandBuffer.push(Commands.FILL_RECT,x,y,width,height);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeRect:function strokeRect(x,y,width,height){var lineWidthHalf=this._lineWidth/2;var minx=x-lineWidthHalf;var maxx=x+lineWidthHalf;this.beginPath();this.moveTo(x,y);this.lineTo(x,y+height);this.strokePath();this.beginPath();this.moveTo(x+width,y);this.lineTo(x+width,y+height);this.strokePath();this.beginPath();this.moveTo(minx,y);this.lineTo(maxx+width,y);this.strokePath();this.beginPath();this.moveTo(minx,y+height);this.lineTo(maxx+width,y+height);this.strokePath();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPointShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - [description]\r\n     * @param {number} [size=1] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillPointShape:function fillPointShape(point,size){return this.fillPoint(point.x,point.y,size);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} [size=1] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillPoint:function fillPoint(x,y,size){if(!size||size<1){size=1;}else{x-=size/2;y-=size/2;}this.commandBuffer.push(Commands.FILL_RECT,x,y,size,size);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillTriangleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Triangle} triangle - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillTriangleShape:function fillTriangleShape(triangle){return this.fillTriangle(triangle.x1,triangle.y1,triangle.x2,triangle.y2,triangle.x3,triangle.y3);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeTriangleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Triangle} triangle - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeTriangleShape:function strokeTriangleShape(triangle){return this.strokeTriangle(triangle.x1,triangle.y1,triangle.x2,triangle.y2,triangle.x3,triangle.y3);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x0 - [description]\r\n     * @param {number} y0 - [description]\r\n     * @param {number} x1 - [description]\r\n     * @param {number} y1 - [description]\r\n     * @param {number} x2 - [description]\r\n     * @param {number} y2 - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillTriangle:function fillTriangle(x0,y0,x1,y1,x2,y2){this.commandBuffer.push(Commands.FILL_TRIANGLE,x0,y0,x1,y1,x2,y2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x0 - [description]\r\n     * @param {number} y0 - [description]\r\n     * @param {number} x1 - [description]\r\n     * @param {number} y1 - [description]\r\n     * @param {number} x2 - [description]\r\n     * @param {number} y2 - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeTriangle:function strokeTriangle(x0,y0,x1,y1,x2,y2){this.commandBuffer.push(Commands.STROKE_TRIANGLE,x0,y0,x1,y1,x2,y2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeLineShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Line} line - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeLineShape:function strokeLineShape(line){return this.lineBetween(line.x1,line.y1,line.x2,line.y2);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x1 - [description]\r\n     * @param {number} y1 - [description]\r\n     * @param {number} x2 - [description]\r\n     * @param {number} y2 - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */lineBetween:function lineBetween(x1,y1,x2,y2){this.beginPath();this.moveTo(x1,y1);this.lineTo(x2,y2);this.strokePath();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */lineTo:function lineTo(x,y){this.commandBuffer.push(Commands.LINE_TO,x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */moveTo:function moveTo(x,y){this.commandBuffer.push(Commands.MOVE_TO,x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineFxTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} rgb - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */lineFxTo:function lineFxTo(x,y,width,rgb){this.commandBuffer.push(Commands.LINE_FX_TO,x,y,width,rgb,1);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#moveFxTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} rgb - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */moveFxTo:function moveFxTo(x,y,width,rgb){this.commandBuffer.push(Commands.MOVE_FX_TO,x,y,width,rgb,1);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokePoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|Phaser.Geom.Point[])} points - [description]\r\n     * @param {boolean} [autoClose=false] - [description]\r\n     * @param {integer} [endIndex] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokePoints:function strokePoints(points,autoClose,endIndex){if(autoClose===undefined){autoClose=false;}if(endIndex===undefined){endIndex=points.length;}this.beginPath();this.moveTo(points[0].x,points[0].y);for(var i=1;i<endIndex;i++){this.lineTo(points[i].x,points[i].y);}if(autoClose){this.lineTo(points[0].x,points[0].y);}this.strokePath();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|Phaser.Geom.Point[])} points - [description]\r\n     * @param {boolean} [autoClose=false] - [description]\r\n     * @param {integer} [endIndex] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillPoints:function fillPoints(points,autoClose,endIndex){if(autoClose===undefined){autoClose=false;}if(endIndex===undefined){endIndex=points.length;}this.beginPath();this.moveTo(points[0].x,points[0].y);for(var i=1;i<endIndex;i++){this.lineTo(points[i].x,points[i].y);}if(autoClose){this.lineTo(points[0].x,points[0].y);}this.fillPath();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeEllipseShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Ellipse} ellipse - [description]\r\n     * @param {integer} [smoothness=32] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeEllipseShape:function strokeEllipseShape(ellipse,smoothness){if(smoothness===undefined){smoothness=32;}var points=ellipse.getPoints(smoothness);return this.strokePoints(points,true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {integer} [smoothness=32] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */strokeEllipse:function strokeEllipse(x,y,width,height,smoothness){if(smoothness===undefined){smoothness=32;}var ellipse=new Ellipse(x,y,width,height);var points=ellipse.getPoints(smoothness);return this.strokePoints(points,true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillEllipseShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Ellipse} ellipse - [description]\r\n     * @param {integer} [smoothness=32] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillEllipseShape:function fillEllipseShape(ellipse,smoothness){if(smoothness===undefined){smoothness=32;}var points=ellipse.getPoints(smoothness);return this.fillPoints(points,true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {integer} [smoothness=32] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */fillEllipse:function fillEllipse(x,y,width,height,smoothness){if(smoothness===undefined){smoothness=32;}var ellipse=new Ellipse(x,y,width,height);var points=ellipse.getPoints(smoothness);return this.fillPoints(points,true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#arc\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} radius - [description]\r\n     * @param {number} startAngle - [description]\r\n     * @param {number} endAngle - [description]\r\n     * @param {boolean} anticlockwise - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */arc:function arc(x,y,radius,startAngle,endAngle,anticlockwise){this.commandBuffer.push(Commands.ARC,x,y,radius,startAngle,endAngle,anticlockwise);return this;},/**\r\n     * Creates a pie-chart slice shape centered at `x`, `y` with the given radius.\r\n     * You must define the start and end angle of the slice.\r\n     *\r\n     * Setting the `anticlockwise` argument to `true` creates a shape similar to Pacman.\r\n     * Setting it to `false` creates a shape like a slice of pie.\r\n     *\r\n     * This method will begin a new path and close the path at the end of it.\r\n     * To display the actual slice you need to call either `strokePath` or `fillPath` after it.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#slice\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The horizontal center of the slice.\r\n     * @param {number} y - The vertical center of the slice.\r\n     * @param {number} radius - The radius of the slice.\r\n     * @param {number} startAngle - The start angle of the slice, given in radians.\r\n     * @param {number} endAngle - The end angle of the slice, given in radians.\r\n     * @param {boolean} [anticlockwise=false] - Draw the slice piece anticlockwise or clockwise?\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */slice:function slice(x,y,radius,startAngle,endAngle,anticlockwise){if(anticlockwise===undefined){anticlockwise=false;}this.commandBuffer.push(Commands.BEGIN_PATH);this.commandBuffer.push(Commands.MOVE_TO,x,y);this.commandBuffer.push(Commands.ARC,x,y,radius,startAngle,endAngle,anticlockwise);this.commandBuffer.push(Commands.CLOSE_PATH);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#save\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */save:function save(){this.commandBuffer.push(Commands.SAVE);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#restore\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */restore:function restore(){this.commandBuffer.push(Commands.RESTORE);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */translate:function translate(x,y){this.commandBuffer.push(Commands.TRANSLATE,x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */scale:function scale(x,y){this.commandBuffer.push(Commands.SCALE,x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radians - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */rotate:function rotate(radians){this.commandBuffer.push(Commands.ROTATE,radians);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */clear:function clear(){this.commandBuffer.length=0;if(this.defaultFillColor>-1){this.fillStyle(this.defaultFillColor,this.defaultFillAlpha);}if(this.defaultStrokeColor>-1){this.lineStyle(this.defaultStrokeWidth,this.defaultStrokeColor,this.defaultStrokeAlpha);}return this;},/**\r\n     * If key is a string it'll generate a new texture using it and add it into the\r\n     * Texture Manager (assuming no key conflict happens).\r\n     *\r\n     * If key is a Canvas it will draw the texture to that canvas context. Note that it will NOT\r\n     * automatically upload it to the GPU in WebGL mode.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#generateTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|HTMLCanvasElement)} key - [description]\r\n     * @param {integer} [width] - [description]\r\n     * @param {integer} [height] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} This Game Object.\r\n     */generateTexture:function generateTexture(key,width,height){var sys=this.scene.sys;if(width===undefined){width=sys.game.config.width;}if(height===undefined){height=sys.game.config.height;}Graphics.TargetCamera.setViewport(0,0,width,height);Graphics.TargetCamera.scrollX=this.x;Graphics.TargetCamera.scrollY=this.y;var texture;var ctx;if(typeof key==='string'){if(sys.textures.exists(key)){//  Key is a string, it DOES exist in the Texture Manager AND is a canvas, so draw to it\ntexture=sys.textures.get(key);var src=texture.getSourceImage();if(src instanceof HTMLCanvasElement){ctx=src.getContext('2d');}}else{//  Key is a string and doesn't exist in the Texture Manager, so generate and save it\ntexture=sys.textures.createCanvas(key,width,height);ctx=texture.getSourceImage().getContext('2d');}}else if(key instanceof HTMLCanvasElement){//  Key is a Canvas, so draw to it\nctx=key.getContext('2d');}if(ctx){this.renderCanvas(sys.game.renderer,this,0.0,Graphics.TargetCamera,null,ctx);if(sys.game.renderer.gl&&texture){texture.source[0].glTexture=sys.game.renderer.canvasToTexture(ctx.canvas,texture.source[0].glTexture,true,0);}}return this;}});/**\r\n * A Camera used specifically by the Graphics system for rendering to textures.\r\n *\r\n * @name Phaser.GameObjects.Graphics.TargetCamera\r\n * @type {Phaser.Cameras.Scene2D.Camera}\r\n * @since 3.1.0\r\n */Graphics.TargetCamera=new Camera(0,0,0,0);module.exports=Graphics;/***/},/* 139 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var GameObject=__webpack_require__(1);var GetBitmapTextSize=__webpack_require__(279);var Render=__webpack_require__(769);/**\r\n * @callback DisplayCallback\r\n *\r\n * @param {object} display - [description]\r\n * @param {{topLeft:number,topRight:number,bottomLeft:number,bottomRight:number}} display.tint - [description]\r\n * @param {number} display.index - [description]\r\n * @param {number} display.charCode - [description]\r\n * @param {number} display.x - [description]\r\n * @param {number} display.y - [description]\r\n * @param {number} display.scale - [description]\r\n * @param {number} display.rotation - [description]\r\n * @param {[type]} display.data - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class DynamicBitmapText\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} x - The x coordinate of this Game Object in world space.\r\n * @param {number} y - The y coordinate of this Game Object in world space.\r\n * @param {string} font - [description]\r\n * @param {(string|string[])} [text] - [description]\r\n * @param {number} [size] - [description]\r\n */var DynamicBitmapText=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.Depth,Components.Origin,Components.Pipeline,Components.ScrollFactor,Components.Texture,Components.Tint,Components.Transform,Components.Visible,Render],initialize:function DynamicBitmapText(scene,x,y,font,text,size){if(text===undefined){text='';}GameObject.call(this,scene,'DynamicBitmapText');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#font\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.font=font;var entry=this.scene.sys.cache.bitmapFont.get(font);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#fontData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.fontData=entry.data;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#text\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.text=Array.isArray(text)?text.join('\\n'):text;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#fontSize\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.fontSize=size||this.fontData.size;this.setTexture(entry.texture,entry.frame);this.setPosition(x,y);this.setOrigin(0,0);this.initPipeline('TextureTintPipeline');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#_bounds\r\n         * @type {TextBounds}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._bounds=this.getTextBounds();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#scrollX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.scrollX=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#scrollY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.scrollY=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#cropWidth\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.cropWidth=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#cropHeight\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.cropHeight=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DynamicBitmapText#displayCallback;\r\n         * @type {DisplayCallback}\r\n         * @since 3.0.0\r\n         */this.displayCallback;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DynamicBitmapText#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.DynamicBitmapText} This Game Object.\r\n     */setSize:function setSize(width,height){this.cropWidth=width;this.cropHeight=height;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DynamicBitmapText#setDisplayCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {DisplayCallback} callback - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.DynamicBitmapText} This Game Object.\r\n     */setDisplayCallback:function setDisplayCallback(callback){this.displayCallback=callback;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DynamicBitmapText#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.DynamicBitmapText} This Game Object.\r\n     */setFontSize:function setFontSize(size){this.fontSize=size;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DynamicBitmapText#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this BitmapText.\r\n     *\r\n     * @return {Phaser.GameObjects.DynamicBitmapText} This Game Object.\r\n     */setText:function setText(value){if(!value&&value!==0){value='';}if(Array.isArray(value)){value=value.join('\\n');}if(value!==this.text){this.text=value.toString();this.updateDisplayOrigin();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DynamicBitmapText#setScrollX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.DynamicBitmapText} This Game Object.\r\n     */setScrollX:function setScrollX(value){this.scrollX=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DynamicBitmapText#setScrollY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.DynamicBitmapText} This Game Object.\r\n     */setScrollY:function setScrollY(value){this.scrollY=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DynamicBitmapText#getTextBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} round - [description]\r\n     *\r\n     * @return {TextBounds} [description]\r\n     */getTextBounds:function getTextBounds(round){//  local = the BitmapText based on fontSize and 0x0 coords\n//  global = the BitmapText, taking into account scale and world position\nthis._bounds=GetBitmapTextSize(this,round);return this._bounds;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.DynamicBitmapText#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */width:{get:function get(){this.getTextBounds(false);return this._bounds.global.width;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.DynamicBitmapText#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */height:{get:function get(){this.getTextBounds(false);return this._bounds.global.height;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DynamicBitmapText#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONGameObject.<JSONBitmapText>} [description]\r\n     */toJSON:function toJSON(){var out=Components.ToJSON(this);//  Extra data is added here\nvar data={font:this.font,text:this.text,fontSize:this.fontSize};out.data=data;return out;}});module.exports=DynamicBitmapText;/***/},/* 140 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ArrayUtils=__webpack_require__(146);var Class=__webpack_require__(0);var Components=__webpack_require__(12);var GameObject=__webpack_require__(1);var Rectangle=__webpack_require__(10);var Render=__webpack_require__(772);var Union=__webpack_require__(277);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * A Container Game Object.\r\n *\r\n * WARNING: EXPERIMENTAL. There are several known cases where Containers will not behave correctly,\r\n * especially if you use a multi-camera or transformed camera set-up. We are still working on them,\r\n * but wanted to release as part of 3.4 under a beta feature flag, because in the main they work\r\n * are and worth getting used to.\r\n *\r\n * A Container, as the name implies, can 'contain' other types of Game Object.\r\n * When a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\r\n * By default it will be removed from the Display List and instead added to the Containers own internal list.\r\n *\r\n * The position of the Game Object automatically becomes relative to the position of the Container.\r\n * \r\n * When the Container is rendered, all of its children are rendered as well, in the order in which they exist\r\n * within the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\r\n *\r\n * If you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\r\n * automatically influence all children as well.\r\n *\r\n * Containers can include other Containers for deeply nested transforms.\r\n *\r\n * Containers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\r\n * The masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\r\n *\r\n * Containers can be enabled for input. Because they do not have a texture you need to provide a shape for them\r\n * to use as their hit area. Container children can also be enabled for input, independent of the Container.\r\n *\r\n * Containers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\r\n * if Container children are enabled for physics you may get unexpected results,such as offset bodies,\r\n * if the Container itself, or any of its ancestors, is positioned anywhere other than at 0x0.\r\n *\r\n * It's important to understand the impact of using Containers. They add additional processing overhead into\r\n * every one of their children. The deeper you nest them, the more the cost escalates. This is especially true\r\n * for input events. You also loose the ability to set the display depth of Container children in the same\r\n * flexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\r\n * every time you create one, try to structure your game around avoiding that where possible.\r\n *\r\n * @class Container\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.4.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.\r\n */var Container=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.ComputedSize,Components.Depth,Components.ScrollFactor,Components.Transform,Components.Visible,Render],initialize:function Container(scene,x,y,children){GameObject.call(this,scene,'Container');/**\r\n         * An array holding the children of this Container.\r\n         *\r\n         * @name Phaser.GameObjects.Container#list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @since 3.4.0\r\n         */this.list=[];/**\r\n         * Does this Container exclusively manage its children?\r\n         * \r\n         * The default is `true` which means a child added to this Container cannot\r\n         * belong in another Container, which includes the Scene display list.\r\n         * \r\n         * If you disable this then this Container will no longer exclusively manage its children.\r\n         * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n         * Game Objects without reparenting them all over the Scene.\r\n         * However, doing so will prevent children from receiving any kind of input event or have\r\n         * their physics bodies work by default, as they're no longer a single entity on the\r\n         * display list, but are being replicated where-ever this Container is.\r\n         *\r\n         * @name Phaser.GameObjects.Container#exclusive\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.4.0\r\n         */this.exclusive=true;/**\r\n         * Containers can have an optional maximum size. If set to anything above 0 it\r\n         * will constrict the addition of new Game Objects into the Container, capping off\r\n         * the maximum limit the Container can grow in size to.\r\n         *\r\n         * @name Phaser.GameObjects.Container#maxSize\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.4.0\r\n         */this.maxSize=-1;/**\r\n         * The cursor position.\r\n         *\r\n         * @name Phaser.GameObjects.Container#position\r\n         * @type {integer}\r\n         * @since 3.4.0\r\n         */this.position=0;/**\r\n         * Internal Transform Matrix used for local space conversion.\r\n         *\r\n         * @name Phaser.GameObjects.Container#localTransform\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.4.0\r\n         */this.localTransform=new Components.TransformMatrix();/**\r\n         * Internal temporary Transform Matrix used to avoid object creation.\r\n         *\r\n         * @name Phaser.GameObjects.Container#tempTransformMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.4.0\r\n         */this.tempTransformMatrix=new Components.TransformMatrix();/**\r\n         * A reference to the Scene Display List.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @private\r\n         * @since 3.4.0\r\n         */this._displayList=scene.sys.displayList;/**\r\n         * The property key to sort by.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_sortKey\r\n         * @type {string}\r\n         * @since 3.4.0\r\n         */this._sortKey='';this.setPosition(x,y);this.clearAlpha();if(children){this.add(children);}},/**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#originX\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */originX:{get:function get(){return 0.5;}},/**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#originY\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */originY:{get:function get(){return 0.5;}},/**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#displayOriginX\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */displayOriginX:{get:function get(){return this.width*0.5;}},/**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#displayOriginY\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */displayOriginY:{get:function get(){return this.height*0.5;}},/**\r\n     * Does this Container exclusively manage its children?\r\n     * \r\n     * The default is `true` which means a child added to this Container cannot\r\n     * belong in another Container, which includes the Scene display list.\r\n     * \r\n     * If you disable this then this Container will no longer exclusively manage its children.\r\n     * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n     * Game Objects without reparenting them all over the Scene.\r\n     * However, doing so will prevent children from receiving any kind of input event or have\r\n     * their physics bodies work by default, as they're no longer a single entity on the\r\n     * display list, but are being replicated where-ever this Container is.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setExclusive\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [value=true] - The exclusive state of this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container.\r\n     */setExclusive:function setExclusive(value){if(value===undefined){value=true;}this.exclusive=value;return this;},/**\r\n     * Gets the bounds of this Container. It works by iterating all children of the Container,\r\n     * getting their respective bounds, and then working out a min-max rectangle from that.\r\n     * It does not factor in if the children render or not, all are included.\r\n     * \r\n     * Depending on the quantity of children in this Container it could be a really expensive call,\r\n     * so cache it and only poll it as needed.\r\n     * \r\n     * The values are stored and returned in a Rectangle object.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getBounds\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [output] - A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} The values stored in the output object.\r\n     */getBounds:function getBounds(output){if(output===undefined){output=new Rectangle();}output.setTo(this.x,this.y,0,0);if(this.list.length>0){var children=this.list;var tempRect=new Rectangle();for(var i=0;i<children.length;i++){var entry=children[i];entry.getBounds(tempRect);Union(tempRect,output,output);}}return output;},/**\r\n     * Internal add handler.\r\n     *\r\n     * @method Phaser.GameObjects.Container#addHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just added to this Container.\r\n     */addHandler:function addHandler(gameObject){gameObject.on('destroy',this.remove,this);if(this.exclusive){this._displayList.remove(gameObject);if(gameObject.parentContainer){gameObject.parentContainer.remove(gameObject);}gameObject.parentContainer=this;}},/**\r\n     * Internal remove handler.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just removed from this Container.\r\n     */removeHandler:function removeHandler(gameObject){gameObject.off('destroy',this.remove,this);if(this.exclusive){gameObject.parentContainer=null;}},/**\r\n     * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,\r\n     * and transforms it into the space of this Container, then returns it in the output object.\r\n     *\r\n     * @method Phaser.GameObjects.Container#pointToContainer\r\n     * @since 3.4.0\r\n     *\r\n     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} source - The Source Point to be transformed.\r\n     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} [output] - A destination object to store the transformed point in. If none given a Vector2 will be created and returned.\r\n     *\r\n     * @return {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} The transformed point.\r\n     */pointToContainer:function pointToContainer(source,output){if(output===undefined){output=new Vector2();}if(this.parentContainer){return this.parentContainer.pointToContainer(source,output);}var tempMatrix=this.tempTransformMatrix;//  No need to loadIdentity because applyITRS overwrites every value anyway\ntempMatrix.applyITRS(this.x,this.y,this.rotation,this.scaleX,this.scaleY);tempMatrix.invert();tempMatrix.transformPoint(source.x,source.y,output);return output;},/**\r\n     * Returns the world transform matrix as used for Bounds checks.\r\n     * The returned matrix is a temporal and shouldn't be stored.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getBoundsTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The world transform matrix.\r\n     */getBoundsTransformMatrix:function getBoundsTransformMatrix(){var tempMatrix=this.tempTransformMatrix;tempMatrix.applyITRS(this.x,this.y,this.rotation,this.scaleX,this.scaleY);if(this.parentContainer){var parentMatrix=this.parentContainer.getTransformMatrix();tempMatrix.multiply(parentMatrix);}return tempMatrix;},/**\r\n     * Adds the given Game Object, or array of Game Objects, to this Container.\r\n     * \r\n     * Each Game Object must be unique within the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#add\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */add:function add(child){ArrayUtils.Add(this.list,child,this.maxSize,this.addHandler,this);return this;},/**\r\n     * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.\r\n     * \r\n     * Existing Game Objects in the Container are shifted up.\r\n     * \r\n     * Each Game Object must be unique within the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#addAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n     * @param {integer} [index=0] - The position to insert the Game Object/s at.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */addAt:function addAt(child,index){ArrayUtils.AddAt(this.list,child,index,this.maxSize,this.addHandler,this);return this;},/**\r\n     * Returns the Game Object at the given position in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} index - The position to get the Game Object from.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The Game Object at the specified index, or `null` if none found.\r\n     */getAt:function getAt(index){return this.list[index];},/**\r\n     * Returns the index of the given Game Object in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getIndex\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to search for in this Container.\r\n     *\r\n     * @return {integer} The index of the Game Object in this Container, or -1 if not found.\r\n     */getIndex:function getIndex(child){return this.list.indexOf(child);},/**\r\n     * Sort the contents of this Container so the items are in order based on the given property.\r\n     * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sort\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to lexically sort by.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */sort:function sort(property){if(property){this._sortKey=property;ArrayUtils.StableSort.inplace(this.list,this.sortHandler);}return this;},/**\r\n     * Internal sort handler method.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sortHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first child to sort.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second child to sort.\r\n     *\r\n     * @return {integer} The sort results.\r\n     */sortHandler:function sortHandler(childA,childB){return childA[this._sortKey]-childB[this._sortKey];},/**\r\n     * Searches for the first instance of a child with its `name` property matching the given argument.\r\n     * Should more than one child have the same name only the first is returned.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getByName\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} name - The name to search for.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The first child with a matching name, or `null` if none were found.\r\n     */getByName:function getByName(name){return ArrayUtils.GetFirst(this.list,'name',name);},/**\r\n     * Returns a random Game Object from this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getRandom\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} [startIndex=0] - An optional start index.\r\n     * @param {integer} [length] - An optional length, the total number of elements (from the startIndex) to choose from.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} A random child from the Container, or `null` if the Container is empty.\r\n     */getRandom:function getRandom(startIndex,length){return ArrayUtils.GetRandom(this.list,startIndex,length);},/**\r\n     * Gets the first Game Object in this Container.\r\n     *\r\n     * You can also specify a property and value to search for, in which case it will return the first\r\n     * Game Object in this Container with a matching property and / or value.\r\n     * \r\n     * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.\r\n     *\r\n     * You can limit the search to the `startIndex` - `endIndex` range.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getFirst\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} [property] - The property to test on each Game Object in the Container.\r\n     * @param {*} [value] - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The first matching Game Object, or `null` if none was found.\r\n     */getFirst:function getFirst(property,value,startIndex,endIndex){return ArrayUtils.GetFirstElement(this.list,property,value,startIndex,endIndex);},/**\r\n     * Returns all Game Objects in this Container.\r\n     *\r\n     * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n     *\r\n     * For example: `getAll('body')` would return only Game Objects that have a body property.\r\n     *\r\n     * You can also specify a value to compare the property to:\r\n     * \r\n     * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} [property] - The property to test on each Game Object in the Container.\r\n     * @param {any} [value] - If property is set then the `property` must strictly equal this value to be included in the results.\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of matching Game Objects from this Container.\r\n     */getAll:function getAll(property,value,startIndex,endIndex){return ArrayUtils.GetAll(this.list,property,value,startIndex,endIndex);},/**\r\n     * Returns the total number of Game Objects in this Container that have a property\r\n     * matching the given value.\r\n     * \r\n     * For example: `count('visible', true)` would count all the elements that have their visible property set.\r\n     * \r\n     * You can optionally limit the operation to the `startIndex` - `endIndex` range.\r\n     *\r\n     * @method Phaser.GameObjects.Container#count\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - [description]\r\n     * @param {any} value - [description]\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {integer} The total number of Game Objects in this Container with a property matching the given value.\r\n     */count:function count(property,value,startIndex,endIndex){return ArrayUtils.CountAllMatching(this.list,property,value,startIndex,endIndex);},/**\r\n     * Swaps the position of two Game Objects in this Container.\r\n     * Both Game Objects must belong to this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#swap\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child1 - The first Game Object to swap.\r\n     * @param {Phaser.GameObjects.GameObject} child2 - The second Game Object to swap.\r\n     * \r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */swap:function swap(child1,child2){ArrayUtils.Swap(this.list,child1,child2);return this;},/**\r\n     * Moves a Game Object to a new position within this Container.\r\n     * \r\n     * The Game Object must already be a child of this Container.\r\n     *\r\n     * The Game Object is removed from its old position and inserted into the new one.\r\n     * Therefore the Container size does not change. Other children will change position accordingly.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to move.\r\n     * @param {integer} index - The new position of the Game Object in this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */moveTo:function moveTo(child,index){ArrayUtils.MoveTo(this.list,child,index);return this;},/**\r\n     * Removes the given Game Object, or array of Game Objects, from this Container.\r\n     * \r\n     * The Game Objects must already be children of this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#remove\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to be removed from the Container.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each child successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */remove:function remove(child,destroyChild){var removed=ArrayUtils.Remove(this.list,child,this.removeHandler,this);if(destroyChild&&removed){if(!Array.isArray(removed)){removed=[removed];}for(var i=0;i<removed.length;i++){removed[i].destroy();}}return this;},/**\r\n     * Removes the Game Object at the given position in this Container.\r\n     * \r\n     * You can also optionally call `destroy` on the Game Object, if one is found.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} index - The index of the Game Object to be removed.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */removeAt:function removeAt(index,destroyChild){var removed=ArrayUtils.RemoveAt(this.list,index,this.removeHandler,this);if(destroyChild&&removed){removed.destroy();}return this;},/**\r\n     * Removes the Game Objects between the given positions in this Container.\r\n     * \r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeBetween\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */removeBetween:function removeBetween(startIndex,endIndex,destroyChild){var removed=ArrayUtils.RemoveBetween(this.list,startIndex,endIndex,this.removeHandler,this);if(destroyChild){for(var i=0;i<removed.length;i++){removed[i].destroy();}}return this;},/**\r\n     * Removes all Game Objects from this Container.\r\n     * \r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */removeAll:function removeAll(destroyChild){var removed=ArrayUtils.RemoveBetween(this.list,0,this.list.length,this.removeHandler,this);if(destroyChild){for(var i=0;i<removed.length;i++){removed[i].destroy();}}return this;},/**\r\n     * Brings the given Game Object to the top of this Container.\r\n     * This will cause it to render on-top of any other objects in the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#bringToTop\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to bring to the top of the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */bringToTop:function bringToTop(child){ArrayUtils.BringToTop(this.list,child);return this;},/**\r\n     * Sends the given Game Object to the bottom of this Container.\r\n     * This will cause it to render below any other objects in the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sendToBack\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to send to the bottom of the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */sendToBack:function sendToBack(child){ArrayUtils.SendToBack(this.list,child);return this;},/**\r\n     * Moves the given Game Object up one place in this Container, unless it's already at the top.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveUp\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */moveUp:function moveUp(child){ArrayUtils.MoveUp(this.list,child);return this;},/**\r\n     * Moves the given Game Object down one place in this Container, unless it's already at the bottom.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveDown\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */moveDown:function moveDown(child){ArrayUtils.MoveDown(this.list,child);return this;},/**\r\n     * Reverses the order of all Game Objects in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#reverse\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */reverse:function reverse(){this.list.reverse();return this;},/**\r\n     * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.\r\n     *\r\n     * @method Phaser.GameObjects.Container#shuffle\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */shuffle:function shuffle(){ArrayUtils.Shuffle(this.list);return this;},/**\r\n     * Replaces a Game Object in this Container with the new Game Object.\r\n     * The new Game Object cannot already be a child of this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#replace\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} oldChild - The Game Object in this Container that will be replaced.\r\n     * @param {Phaser.GameObjects.GameObject} newChild - The Game Object to be added to this Container.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n     *\r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */replace:function replace(oldChild,newChild,destroyChild){var moved=ArrayUtils.Replace(this.list,oldChild,newChild);if(moved){this.addHandler(newChild);this.removeHandler(oldChild);if(destroyChild){oldChild.destroy();}}return this;},/**\r\n     * Returns `true` if the given Game Object is a direct child of this Container.\r\n     * \r\n     * This check does not scan nested Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Container#exists\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to check for within this Container.\r\n     *\r\n     * @return {boolean} True if the Game Object is an immediate child of this Container, otherwise false.\r\n     */exists:function exists(child){return this.list.indexOf(child)>-1;},/**\r\n     * Sets the property to the given value on all Game Objects in this Container.\r\n     * \r\n     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property that must exist on the Game Object.\r\n     * @param {any} value - The value to get the property to.\r\n     * @param {integer} [startIndex=0] - An optional start index to search from.\r\n     * @param {integer} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     * \r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */setAll:function setAll(property,value,startIndex,endIndex){ArrayUtils.SetAll(this.list,property,value,startIndex,endIndex);return this;},/**\r\n     * @callback EachContainerCallback\r\n     * @generic I - [item]\r\n     *\r\n     * @param {*} item - [description]\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *//**\r\n     * Passes all Game Objects in this Container to the given callback.\r\n     *\r\n     * A copy of the Container is made before passing each entry to your callback.\r\n     * This protects against the callback itself modifying the Container.\r\n     * \r\n     * If you know for sure that the callback will not change the size of this Container\r\n     * then you can use the more performant `Container.iterate` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.Container#each\r\n     * @since 3.4.0\r\n     *\r\n     * @param {function} callback - The function to call.\r\n     * @param {object} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     * \r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */each:function each(callback,context){var args=[null];var i;var temp=this.list.slice();var len=temp.length;for(i=2;i<arguments.length;i++){args.push(arguments[i]);}for(i=0;i<len;i++){args[0]=temp[i];callback.apply(context,args);}return this;},/**\r\n     * Passes all Game Objects in this Container to the given callback.\r\n     *\r\n     * Only use this method when you absolutely know that the Container will not be modified during\r\n     * the iteration, i.e. by removing or adding to its contents.\r\n     *\r\n     * @method Phaser.GameObjects.Container#iterate\r\n     * @since 3.4.0\r\n     *\r\n     * @param {function} callback - The function to call.\r\n     * @param {object} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     * \r\n     * @return {Phaser.GameObjects.Container} This Container instance.\r\n     */iterate:function iterate(callback,context){var args=[null];var i;for(i=2;i<arguments.length;i++){args.push(arguments[i]);}for(i=0;i<this.list.length;i++){args[0]=this.list[i];callback.apply(context,args);}return this;},/**\r\n     * The number of Game Objects inside this Container.\r\n     *\r\n     * @name Phaser.GameObjects.Container#length\r\n     * @type {integer}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */length:{get:function get(){return this.list.length;}},/**\r\n     * Returns the first Game Object within the Container, or `null` if it is empty.\r\n     * \r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#first\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */first:{get:function get(){this.position=0;if(this.list.length>0){return this.list[0];}else{return null;}}},/**\r\n     * Returns the last Game Object within the Container, or `null` if it is empty.\r\n     * \r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#last\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */last:{get:function get(){if(this.list.length>0){this.position=this.list.length-1;return this.list[this.position];}else{return null;}}},/**\r\n     * Returns the next Game Object within the Container, or `null` if it is empty.\r\n     * \r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#next\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */next:{get:function get(){if(this.position<this.list.length){this.position++;return this.list[this.position];}else{return null;}}},/**\r\n     * Returns the previous Game Object within the Container, or `null` if it is empty.\r\n     * \r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#previous\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readOnly\r\n     * @since 3.4.0\r\n     */previous:{get:function get(){if(this.position>0){this.position--;return this.list[this.position];}else{return null;}}},/**\r\n     * Destroys this Container, removing it from the Display List.\r\n     *\r\n     * If `Container.exclusive` is `true` then it will also destroy all children.\r\n     *\r\n     * Use this to remove a Container from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.Container#destroy\r\n     * @since 3.4.0\r\n     */destroy:function destroy(){this.removeAll(this.exclusive);this.localTransform.destroy();this.tempTransformMatrix.destroy();this.list=[];this._displayList=null;GameObject.prototype.destroy.call(this);}});module.exports=Container;/***/},/* 141 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BlitterRender=__webpack_require__(776);var Bob=__webpack_require__(773);var Class=__webpack_require__(0);var Components=__webpack_require__(12);var Frame=__webpack_require__(147);var GameObject=__webpack_require__(1);var List=__webpack_require__(101);/**\r\n * @callback BlitterFromCallback\r\n *\r\n * @param {Phaser.GameObjects.Blitter} blitter - [description]\r\n * @param {integer} index - [description]\r\n *//**\r\n * @classdesc\r\n * A Blitter Game Object.\r\n *\r\n * The Blitter Game Object is a special kind of container that creates, updates and manages Bob objects.\r\n * Bobs are designed for rendering speed rather than flexibility. They consist of a texture, or frame from a texture,\r\n * a position and an alpha value. You cannot scale or rotate them. They use a batched drawing method for speed\r\n * during rendering.\r\n *\r\n * A Blitter Game Object has one texture bound to it. Bobs created by the Blitter can use any Frame from this\r\n * Texture to render with, but they cannot use any other Texture. It is this single texture-bind that allows\r\n * them their speed.\r\n *\r\n * If you have a need to blast a large volume of frames around the screen then Blitter objects are well worth\r\n * investigating. They are especially useful for using as a base for your own special effects systems.\r\n *\r\n * @class Blitter\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} [x=0] - The x coordinate of this Game Object in world space.\r\n * @param {number} [y=0] - The y coordinate of this Game Object in world space.\r\n * @param {string} [texture='__DEFAULT'] - The key of the texture this Game Object will use for rendering. The Texture must already exist in the Texture Manager.\r\n * @param {(string|integer)} [frame=0] - The Frame of the Texture that this Game Object will use. Only set if the Texture has multiple frames, such as a Texture Atlas or Sprite Sheet.\r\n */var Blitter=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.Depth,Components.Pipeline,Components.ScaleMode,Components.ScrollFactor,Components.Size,Components.Texture,Components.Transform,Components.Visible,BlitterRender],initialize:function Blitter(scene,x,y,texture,frame){GameObject.call(this,scene,'Blitter');this.setTexture(texture,frame);this.setPosition(x,y);this.initPipeline('TextureTintPipeline');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter#children\r\n         * @type {Phaser.Structs.List.<Phaser.GameObjects.Blitter.Bob>}\r\n         * @since 3.0.0\r\n         */this.children=new List();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter#renderList\r\n         * @type {Phaser.GameObjects.Blitter.Bob[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.renderList=[];this.dirty=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {(string|integer|Phaser.Textures.Frame)} [frame] - The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.\r\n     * @param {boolean} [visible=true] - Should the created Bob render or not?\r\n     * @param {integer} [index] - The position in the Blitters Display List to add the new Bob at. Defaults to the top of the list.\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} The newly created Bob object.\r\n     */create:function create(x,y,frame,visible,index){if(visible===undefined){visible=true;}if(index===undefined){index=this.children.length;}if(frame===undefined){frame=this.frame;}else if(!(frame instanceof Frame)){frame=this.texture.get(frame);}var bob=new Bob(this,x,y,frame,visible);this.children.addAt(bob,index,false);this.dirty=true;return bob;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#createFromCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {BlitterFromCallback} callback - The callback to invoke after creating a bob. It will be sent two arguments: The Bob and the index of the Bob.\r\n     * @param {integer} quantity - The quantity of Bob objects to create.\r\n     * @param {(string|integer|Phaser.Textures.Frame|string[]|integer[]|Phaser.Textures.Frame[])} [frame] - The Frame the Bobs will use. It must be part of the Blitter Texture.\r\n     * @param {boolean} [visible=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob[]} An array of Bob objects that were created.\r\n     */createFromCallback:function createFromCallback(callback,quantity,frame,visible){var bobs=this.createMultiple(quantity,frame,visible);for(var i=0;i<bobs.length;i++){var bob=bobs[i];callback.call(this,bob,i);}return bobs;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} quantity - The quantity of Bob objects to create.\r\n     * @param {(string|integer|Phaser.Textures.Frame|string[]|integer[]|Phaser.Textures.Frame[])} [frame] - The Frame the Bobs will use. It must be part of the Blitter Texture.\r\n     * @param {boolean} [visible=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob[]} An array of Bob objects that were created.\r\n     */createMultiple:function createMultiple(quantity,frame,visible){if(frame===undefined){frame=this.frame.name;}if(visible===undefined){visible=true;}if(!Array.isArray(frame)){frame=[frame];}var bobs=[];var _this=this;frame.forEach(function(singleFrame){for(var i=0;i<quantity;i++){bobs.push(_this.create(0,0,singleFrame,visible));}});return bobs;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#childCanRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Blitter.Bob} child - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */childCanRender:function childCanRender(child){return child.visible&&child.alpha>0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#getRenderList\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob[]} An array of Bob objects that will be rendered this frame.\r\n     */getRenderList:function getRenderList(){if(this.dirty){this.renderList=this.children.list.filter(this.childCanRender,this);this.dirty=false;}return this.renderList;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#clear\r\n     * @since 3.0.0\r\n     */clear:function clear(){this.children.removeAll();this.dirty=true;}});module.exports=Blitter;/***/},/* 142 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var GameObject=__webpack_require__(1);var GetBitmapTextSize=__webpack_require__(279);var ParseFromAtlas=__webpack_require__(781);var ParseRetroFont=__webpack_require__(780);var Render=__webpack_require__(779);/**\r\n * @typedef {object} TextBounds\r\n *\r\n * @property {object} local - [description]\r\n * @property {number} local.x - [description]\r\n * @property {number} local.y - [description]\r\n * @property {number} local.width - [description]\r\n * @property {number} local.height - [description]\r\n * @property {object} global - [description]\r\n * @property {number} global.x - [description]\r\n * @property {number} global.y - [description]\r\n * @property {number} global.width - [description]\r\n * @property {number} global.height - [description]\r\n *//**\r\n * @typedef {object} JSONBitmapText\r\n *\r\n * @property {string} font - [description]\r\n * @property {string} text - [description]\r\n * @property {number} fontSize - [description]\r\n * @property {number} letterSpacing - Adds/Removes spacing between characters\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class BitmapText\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * \r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} x - The x coordinate of this Game Object in world space.\r\n * @param {number} y - The y coordinate of this Game Object in world space.\r\n * @param {string} font - [description]\r\n * @param {(string|string[])} [text] - [description]\r\n * @param {number} [size] - [description]\r\n */var BitmapText=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.Depth,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.ScrollFactor,Components.Texture,Components.Tint,Components.Transform,Components.Visible,Render],initialize:function BitmapText(scene,x,y,font,text,size){if(text===undefined){text='';}GameObject.call(this,scene,'BitmapText');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#font\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.font=font;var entry=this.scene.sys.cache.bitmapFont.get(font);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#fontData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.fontData=entry.data;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#text\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.text=Array.isArray(text)?text.join('\\n'):text;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#fontSize\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.fontSize=size||this.fontData.size;/**\r\n         * Adds/Removes spacing between characters\r\n         * Can be a negative or positive number\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#letterSpacing\r\n         * @type {number}\r\n         * @since 3.4.0\r\n         */this.letterSpacing=0;this.setTexture(entry.texture,entry.frame);this.setPosition(x,y);this.setOrigin(0,0);this.initPipeline('TextureTintPipeline');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_bounds\r\n         * @type {TextBounds}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._bounds=this.getTextBounds();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.BitmapText} This Game Object.\r\n     */setFontSize:function setFontSize(size){this.fontSize=size;return this;},/**\r\n     * Sets the letter spacing between each character of this Bitmap Text.\r\n     * Can be a positive value to increase the space, or negative to reduce it.\r\n     * Spacing is applied after the kerning values have been set.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setLetterSpacing\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [spacing=0] - The amount of horizontal space to add between each character.\r\n     *\r\n     * @return {Phaser.GameObjects.BitmapText} This Game Object.\r\n     */setLetterSpacing:function setLetterSpacing(spacing){if(spacing===undefined){spacing=0;}this.letterSpacing=spacing;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this BitmapText.\r\n     *\r\n     * @return {Phaser.GameObjects.BitmapText} This Game Object.\r\n     */setText:function setText(value){if(!value&&value!==0){value='';}if(Array.isArray(value)){value=value.join('\\n');}if(value!==this.text){this.text=value.toString();this.updateDisplayOrigin();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#getTextBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} round - [description]\r\n     *\r\n     * @return {TextBounds} [description]\r\n     */getTextBounds:function getTextBounds(round){//  local = the BitmapText based on fontSize and 0x0 coords\n//  global = the BitmapText, taking into account scale and world position\nthis._bounds=GetBitmapTextSize(this,round);return this._bounds;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */width:{get:function get(){this.getTextBounds(false);return this._bounds.global.width;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */height:{get:function get(){this.getTextBounds(false);return this._bounds.global.height;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONGameObject.<JSONBitmapText>} [description]\r\n     */toJSON:function toJSON(){var out=Components.ToJSON(this);//  Extra data is added here\nvar data={font:this.font,text:this.text,fontSize:this.fontSize,letterSpacing:this.letterSpacing};out.data=data;return out;}});BitmapText.ParseRetroFont=ParseRetroFont;BitmapText.ParseFromAtlas=ParseFromAtlas;module.exports=BitmapText;/***/},/* 143 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetAdvancedValue=__webpack_require__(8);/**\r\n * Adds an Animation component to a Sprite and populates it based on the given config.\r\n *\r\n * @function Phaser.GameObjects.BuildGameObjectAnimation\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Sprite} sprite - [description]\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Sprite} The updated Sprite.\r\n */var BuildGameObjectAnimation=function BuildGameObjectAnimation(sprite,config){var animConfig=GetAdvancedValue(config,'anims',null);if(animConfig===null){return sprite;}if(typeof animConfig==='string'){//  { anims: 'key' }\nsprite.anims.play(animConfig);}else if((typeof animConfig==='undefined'?'undefined':_typeof(animConfig))==='object'){//  { anims: {\n//              key: string\n//              startFrame: [string|integer]\n//              delay: [float]\n//              repeat: [integer]\n//              repeatDelay: [float]\n//              yoyo: [boolean]\n//              play: [boolean]\n//              delayedPlay: [boolean]\n//           }\n//  }\nvar anims=sprite.anims;var key=GetAdvancedValue(animConfig,'key',undefined);var startFrame=GetAdvancedValue(animConfig,'startFrame',undefined);var delay=GetAdvancedValue(animConfig,'delay',0);var repeat=GetAdvancedValue(animConfig,'repeat',0);var repeatDelay=GetAdvancedValue(animConfig,'repeatDelay',0);var yoyo=GetAdvancedValue(animConfig,'yoyo',false);var play=GetAdvancedValue(animConfig,'play',false);var delayedPlay=GetAdvancedValue(animConfig,'delayedPlay',0);anims.delay(delay);anims.repeat(repeat);anims.repeatDelay(repeatDelay);anims.yoyo(yoyo);if(play){anims.play(key,startFrame);}else if(delayedPlay>0){anims.delayedPlay(delayedPlay,key,startFrame);}else{anims.load(key);}}return sprite;};module.exports=BuildGameObjectAnimation;/***/},/* 144 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns a Random element from the array.\r\n *\r\n * @function Phaser.Utils.Array.GetRandom\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to select the random entry from.\r\n * @param {integer} [startIndex=0] - An optional start index.\r\n * @param {integer} [length=array.length] - An optional length, the total number of elements (from the startIndex) to choose from.\r\n *\r\n * @return {object} A random element from the array, or `null` if no element could be found in the range given.\r\n */var GetRandom=function GetRandom(array,startIndex,length){if(startIndex===undefined){startIndex=0;}if(length===undefined){length=array.length;}var randomIndex=startIndex+Math.floor(Math.random()*length);return array[randomIndex]===undefined?null:array[randomIndex];};module.exports=GetRandom;/***/},/* 145 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n* A Matrix is simply an array of arrays, where each sub-array (the rows) have the same length:\r\n*\r\n* let matrix2 = [\r\n*    [ 1, 1, 1, 1, 1, 1 ],\r\n*    [ 2, 0, 0, 0, 0, 4 ],\r\n*    [ 2, 0, 1, 2, 0, 4 ],\r\n*    [ 2, 0, 3, 4, 0, 4 ],\r\n*    [ 2, 0, 0, 0, 0, 4 ],\r\n*    [ 3, 3, 3, 3, 3, 3 ]\r\n*];\r\n*//**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.CheckMatrix\r\n * @since 3.0.0\r\n *\r\n * @param {array} matrix - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var CheckMatrix=function CheckMatrix(matrix){if(!Array.isArray(matrix)||matrix.length<2||!Array.isArray(matrix[0])){return false;}//  How long is the first row?\nvar size=matrix[0].length;//  Validate the rest of the rows are the same length\nfor(var i=1;i<matrix.length;i++){if(matrix[i].length!==size){return false;}}return true;};module.exports=CheckMatrix;/***/},/* 146 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Utils.Array\r\n */module.exports={Matrix:__webpack_require__(809),Add:__webpack_require__(802),AddAt:__webpack_require__(801),BringToTop:__webpack_require__(800),CountAllMatching:__webpack_require__(799),Each:__webpack_require__(798),EachInRange:__webpack_require__(797),FindClosestInSorted:__webpack_require__(354),GetAll:__webpack_require__(796),GetFirst:__webpack_require__(795),GetRandom:__webpack_require__(144),MoveDown:__webpack_require__(794),MoveTo:__webpack_require__(793),MoveUp:__webpack_require__(792),NumberArray:__webpack_require__(283),NumberArrayStep:__webpack_require__(791),QuickSelect:__webpack_require__(281),Range:__webpack_require__(280),Remove:__webpack_require__(790),RemoveAt:__webpack_require__(789),RemoveBetween:__webpack_require__(788),RemoveRandomElement:__webpack_require__(787),Replace:__webpack_require__(786),RotateLeft:__webpack_require__(360),RotateRight:__webpack_require__(359),SafeRange:__webpack_require__(48),SendToBack:__webpack_require__(785),SetAll:__webpack_require__(784),Shuffle:__webpack_require__(106),SpliceOne:__webpack_require__(99),StableSort:__webpack_require__(98),Swap:__webpack_require__(783)};/***/},/* 147 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Extend=__webpack_require__(18);/**\r\n * @classdesc\r\n * A Frame is a section of a Texture.\r\n *\r\n * @class Frame\r\n * @memberOf Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture this Frame is a part of.\r\n * @param {(integer|string)} name - The name of this Frame. The name is unique within the Texture.\r\n * @param {integer} sourceIndex - The index of the TextureSource that this Frame is a part of.\r\n * @param {number} x - The x coordinate of the top-left of this Frame.\r\n * @param {number} y - The y coordinate of the top-left of this Frame.\r\n * @param {number} width - The width of this Frame.\r\n * @param {number} height - The height of this Frame.\r\n */var Frame=new Class({initialize:function Frame(texture,name,sourceIndex,x,y,width,height){/**\r\n         * The Texture this Frame is a part of.\r\n         *\r\n         * @name Phaser.Textures.Frame#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.0.0\r\n         */this.texture=texture;/**\r\n         * The name of this Frame.\r\n         * The name is unique within the Texture.\r\n         *\r\n         * @name Phaser.Textures.Frame#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.name=name;/**\r\n         * The TextureSource this Frame is part of.\r\n         *\r\n         * @name Phaser.Textures.Frame#source\r\n         * @type {Phaser.Textures.TextureSource}\r\n         * @since 3.0.0\r\n         */this.source=texture.source[sourceIndex];/**\r\n         * The index of the TextureSource in the Texture sources array.\r\n         *\r\n         * @name Phaser.Textures.Frame#sourceIndex\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.sourceIndex=sourceIndex;/**\r\n         * X position within the source image to cut from.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutX\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.cutX=x;/**\r\n         * Y position within the source image to cut from.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutY\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.cutY=y;/**\r\n         * The width of the area in the source image to cut.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.cutWidth=width;/**\r\n         * The height of the area in the source image to cut.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.cutHeight=height;/**\r\n         * The X rendering offset of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#x\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x=0;/**\r\n         * The Y rendering offset of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#y\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y=0;/**\r\n         * The rendering width of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.width=width;/**\r\n         * The rendering height of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.height=height;/**\r\n         * Half the width, floored.\r\n         * Precalculated for the renderer.\r\n         *\r\n         * @name Phaser.Textures.Frame#halfWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.halfWidth=Math.floor(width*0.5);/**\r\n         * Half the height, floored.\r\n         * Precalculated for the renderer.\r\n         *\r\n         * @name Phaser.Textures.Frame#halfHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.halfHeight=Math.floor(height*0.5);/**\r\n         * The x center of this frame, floored.\r\n         *\r\n         * @name Phaser.Textures.Frame#centerX\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.centerX=Math.floor(width/2);/**\r\n         * The y center of this frame, floored.\r\n         *\r\n         * @name Phaser.Textures.Frame#centerY\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.centerY=Math.floor(height/2);/**\r\n         * The horizontal pivot point of this Frame.\r\n         *\r\n         * @name Phaser.Textures.Frame#pivotX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.pivotX=0;/**\r\n         * The vertical pivot point of this Frame.\r\n         *\r\n         * @name Phaser.Textures.Frame#pivotY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.pivotY=0;/**\r\n         * Does this Frame have a custom pivot point?\r\n         *\r\n         * @name Phaser.Textures.Frame#customPivot\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.customPivot=false;/**\r\n         * **CURRENTLY UNSUPPORTED**\r\n         *\r\n         * Is this frame is rotated or not in the Texture?\r\n         * Rotation allows you to use rotated frames in texture atlas packing.\r\n         * It has nothing to do with Sprite rotation.\r\n         *\r\n         * @name Phaser.Textures.Frame#rotated\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.rotated=false;/**\r\n         * Over-rides the Renderer setting.\r\n         * -1 = use Renderer Setting\r\n         * 0 = No rounding\r\n         * 1 = Round\r\n         *\r\n         * @name Phaser.Textures.Frame#autoRound\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */this.autoRound=-1;/**\r\n         * Any Frame specific custom data can be stored here.\r\n         *\r\n         * @name Phaser.Textures.Frame#customData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.customData={};/**\r\n         * The un-modified source frame, trim and UV data.\r\n         *\r\n         * @name Phaser.Textures.Frame#data\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.data={cut:{x:x,y:y,w:width,h:height,r:x+width,b:y+height},trim:false,sourceSize:{w:width,h:height},spriteSourceSize:{x:0,y:0,w:width,h:height},uvs:{x0:0,y0:0,x1:0,y1:0,x2:0,y2:0,x3:0,y3:0},radius:0.5*Math.sqrt(width*width+height*height),drawImage:{sx:x,sy:y,sWidth:width,sHeight:height,dWidth:width,dHeight:height}};this.updateUVs();},/**\r\n     * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.\r\n     *\r\n     * @method Phaser.Textures.Frame#setTrim\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} actualWidth - The width of the frame before being trimmed.\r\n     * @param {number} actualHeight - The height of the frame before being trimmed.\r\n     * @param {number} destX - The destination X position of the trimmed frame for display.\r\n     * @param {number} destY - The destination Y position of the trimmed frame for display.\r\n     * @param {number} destWidth - The destination width of the trimmed frame for display.\r\n     * @param {number} destHeight - The destination height of the trimmed frame for display.\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */setTrim:function setTrim(actualWidth,actualHeight,destX,destY,destWidth,destHeight){var data=this.data;var ss=data.spriteSourceSize;//  Store actual values\ndata.trim=true;data.sourceSize.w=actualWidth;data.sourceSize.h=actualHeight;ss.x=destX;ss.y=destY;ss.w=destWidth;ss.h=destHeight;//  Adjust properties\nthis.x=destX;this.y=destY;this.width=destWidth;this.height=destHeight;this.halfWidth=destWidth*0.5;this.halfHeight=destHeight*0.5;this.centerX=Math.floor(destWidth/2);this.centerY=Math.floor(destHeight/2);return this.updateUVs();},/**\r\n     * Updates the internal WebGL UV cache and the drawImage cache.\r\n     *\r\n     * @method Phaser.Textures.Frame#updateUVs\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */updateUVs:function updateUVs(){var cx=this.cutX;var cy=this.cutY;var cw=this.cutWidth;var ch=this.cutHeight;//  Canvas data\nvar cd=this.data.drawImage;cd.sWidth=cw;cd.sHeight=ch;cd.dWidth=cw;cd.dHeight=ch;//  WebGL data\nvar tw=this.source.width;var th=this.source.height;var uvs=this.data.uvs;uvs.x0=cx/tw;uvs.y0=cy/th;uvs.x1=cx/tw;uvs.y1=(cy+ch)/th;uvs.x2=(cx+cw)/tw;uvs.y2=(cy+ch)/th;uvs.x3=(cx+cw)/tw;uvs.y3=cy/th;return this;},/**\r\n     * Updates the internal WebGL UV cache.\r\n     *\r\n     * @method Phaser.Textures.Frame#updateUVsInverted\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */updateUVsInverted:function updateUVsInverted(){var tw=this.source.width;var th=this.source.height;var uvs=this.data.uvs;uvs.x3=(this.cutX+this.cutHeight)/tw;uvs.y3=(this.cutY+this.cutWidth)/th;uvs.x2=this.cutX/tw;uvs.y2=(this.cutY+this.cutWidth)/th;uvs.x1=this.cutX/tw;uvs.y1=this.cutY/th;uvs.x0=(this.cutX+this.cutHeight)/tw;uvs.y0=this.cutY/th;return this;},/**\r\n     * Clones this Frame into a new Frame object.\r\n     *\r\n     * @method Phaser.Textures.Frame#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} A clone of this Frame.\r\n     */clone:function clone(){var clone=new Frame(this.texture,this.name,this.sourceIndex);clone.cutX=this.cutX;clone.cutY=this.cutY;clone.cutWidth=this.cutWidth;clone.cutHeight=this.cutHeight;clone.x=this.x;clone.y=this.y;clone.width=this.width;clone.height=this.height;clone.halfWidth=this.halfWidth;clone.halfHeight=this.halfHeight;clone.centerX=this.centerX;clone.centerY=this.centerY;clone.rotated=this.rotated;clone.data=Extend(true,clone.data,this.data);clone.updateUVs();return clone;},/**\r\n     * Destroys this Frames references.\r\n     *\r\n     * @method Phaser.Textures.Frame#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.texture=null;this.source=null;},/**\r\n     * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n     * before being packed.\r\n     *\r\n     * @name Phaser.Textures.Frame#realWidth\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */realWidth:{get:function get(){return this.data.sourceSize.w;}},/**\r\n     * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n     * before being packed.\r\n     *\r\n     * @name Phaser.Textures.Frame#realHeight\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */realHeight:{get:function get(){return this.data.sourceSize.h;}},/**\r\n     * The UV data for this Frame.\r\n     *\r\n     * @name Phaser.Textures.Frame#uvs\r\n     * @type {object}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */uvs:{get:function get(){return this.data.uvs;}},/**\r\n     * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)\r\n     *\r\n     * @name Phaser.Textures.Frame#radius\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */radius:{get:function get(){return this.data.radius;}},/**\r\n     * Is the Frame trimmed or not?\r\n     *\r\n     * @name Phaser.Textures.Frame#trimmed\r\n     * @type {boolean}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */trimmed:{get:function get(){return this.data.trim;}},/**\r\n     * The Canvas drawImage data object.\r\n     *\r\n     * @name Phaser.Textures.Frame#canvasData\r\n     * @type {object}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */canvasData:{get:function get(){return this.data.drawImage;}}});module.exports=Frame;/***/},/* 148 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(76);var GetPhysicsPlugins=__webpack_require__(825);var GetScenePlugins=__webpack_require__(824);var Plugins=__webpack_require__(315);var Settings=__webpack_require__(296);/**\r\n * @classdesc\r\n * The Scene Systems class.\r\n *\r\n * This class is available from within a Scene under the property `sys`.\r\n * It is responsible for managing all of the plugins a Scene has running, including the display list, and\r\n * handling the update step and renderer. It also contains references to global systems belonging to Game.\r\n *\r\n * @class Systems\r\n * @memberOf Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that owns this Systems instance.\r\n * @param {(string|SettingsConfig)} config - Scene specific configuration settings.\r\n */var Systems=new Class({initialize:function Systems(scene,config){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#config\r\n         * @type {(string|SettingsConfig)}\r\n         * @since 3.0.0\r\n         */this.config=config;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#settings\r\n         * @type {SettingsObject}\r\n         * @since 3.0.0\r\n         */this.settings=Settings.create(config);/**\r\n         * A handy reference to the Scene canvas / context.\r\n         *\r\n         * @name Phaser.Scenes.Systems#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */this.canvas;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */this.context;//  Global Systems - these are single-instance global managers that belong to Game\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#anims\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */this.anims;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#cache\r\n         * @type {Phaser.Cache.CacheManager}\r\n         * @since 3.0.0\r\n         */this.cache;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#plugins\r\n         * @type {Phaser.Boot.PluginManager}\r\n         * @since 3.0.0\r\n         */this.plugins;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#registry\r\n         * @type {Phaser.Data.DataManager}\r\n         * @since 3.0.0\r\n         */this.registry;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#sound\r\n         * @type {Phaser.Sound.BaseSoundManager}\r\n         * @since 3.0.0\r\n         */this.sound;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#textures\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.0.0\r\n         */this.textures;//  Core Plugins - these are non-optional Scene plugins, needed by lots of the other systems\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#add\r\n         * @type {Phaser.GameObjects.GameObjectFactory}\r\n         * @since 3.0.0\r\n         */this.add;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */this.cameras;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */this.displayList;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */this.events;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#make\r\n         * @type {Phaser.GameObjects.GameObjectCreator}\r\n         * @since 3.0.0\r\n         */this.make;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#scenePlugin\r\n         * @type {Phaser.Scenes.ScenePlugin}\r\n         * @since 3.0.0\r\n         */this.scenePlugin;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Scenes.Systems#updateList\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @since 3.0.0\r\n         */this.updateList;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Scenes.Systems#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Game} game - A reference to the Phaser Game\r\n     */init:function init(game){this.settings.status=CONST.INIT;this.game=game;this.canvas=game.canvas;this.context=game.context;var pluginManager=game.plugins;this.plugins=pluginManager;pluginManager.installGlobal(this,Plugins.Global);pluginManager.installLocal(this,Plugins.CoreScene);pluginManager.installLocal(this,GetScenePlugins(this));pluginManager.installLocal(this,GetPhysicsPlugins(this));this.events.emit('boot',this);this.settings.isBooted=true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Scenes.Systems#install\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} plugin - An array of plugins to install into this Scene.\r\n     */install:function install(plugin){if(!Array.isArray(plugin)){plugin=[plugin];}this.plugins.installLocal(this,plugin);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Scenes.Systems#step\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */step:function step(time,delta){this.events.emit('preupdate',time,delta);this.events.emit('update',time,delta);this.scene.update.call(this.scene,time,delta);this.events.emit('postupdate',time,delta);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Scenes.Systems#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     */render:function render(renderer){var displayList=this.displayList;displayList.depthSort();this.cameras.render(renderer,displayList);this.events.emit('render',renderer);},/**\r\n     * Force a sort of the display list on the next render.\r\n     *\r\n     * @method Phaser.Scenes.Systems#queueDepthSort\r\n     * @since 3.0.0\r\n     */queueDepthSort:function queueDepthSort(){this.displayList.queueDepthSort();},/**\r\n     * Immediately sorts the display list if the flag is set.\r\n     *\r\n     * @method Phaser.Scenes.Systems#depthSort\r\n     * @since 3.0.0\r\n     */depthSort:function depthSort(){this.displayList.depthSort();},/**\r\n     * Pause this Scene.\r\n     * A paused Scene still renders, it just doesn't run ANY of its update handlers or systems.\r\n     *\r\n     * @method Phaser.Scenes.Systems#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */pause:function pause(){if(this.settings.active){this.settings.status=CONST.PAUSED;this.settings.active=false;this.events.emit('pause',this);}return this;},/**\r\n     * Resume this Scene.\r\n     *\r\n     * @method Phaser.Scenes.Systems#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */resume:function resume(){if(!this.settings.active){this.settings.status=CONST.RUNNING;this.settings.active=true;this.events.emit('resume',this);}return this;},/**\r\n     * Send this Scene to sleep.\r\n     *\r\n     * A sleeping Scene doesn't run it's update step or render anything, but it also isn't destroyed,\r\n     * or have any of its systems or children removed, meaning it can be re-activated at any point.\r\n     *\r\n     * @method Phaser.Scenes.Systems#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */sleep:function sleep(){this.settings.status=CONST.SLEEPING;this.settings.active=false;this.settings.visible=false;this.events.emit('sleep',this);return this;},/**\r\n     * Wake-up this Scene if it was previously asleep.\r\n     *\r\n     * @method Phaser.Scenes.Systems#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */wake:function wake(){this.settings.status=CONST.RUNNING;this.settings.active=true;this.settings.visible=true;this.events.emit('wake',this);return this;},/**\r\n     * Is this Scene sleeping?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isSleeping:function isSleeping(){return this.settings.status===CONST.SLEEPING;},/**\r\n     * Is this Scene active?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isActive:function isActive(){return this.settings.status===CONST.RUNNING;},/**\r\n     * Is this Scene visible and rendering?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isVisible:function isVisible(){return this.settings.visible;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Scenes.Systems#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */setVisible:function setVisible(value){this.settings.visible=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Scenes.Systems#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */setActive:function setActive(value){if(value){return this.resume();}else{return this.pause();}},/**\r\n     * Start this Scene running and rendering.\r\n     * Called automatically by the SceneManager.\r\n     *\r\n     * @method Phaser.Scenes.Systems#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} data - [description]\r\n     */start:function start(data){if(data){this.settings.data=data;}this.settings.status=CONST.START;this.settings.active=true;this.settings.visible=true;this.events.emit('start',this);},/**\r\n     * Called automatically by the SceneManager if the Game resizes.\r\n     * Dispatches an event you can respond to in your game code.\r\n     *\r\n     * @method Phaser.Scenes.Systems#resize\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     */resize:function resize(width,height){this.events.emit('resize',width,height);},/**\r\n     * Shutdown this Scene and send a shutdown event to all of its systems.\r\n     *\r\n     * @method Phaser.Scenes.Systems#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.settings.status=CONST.SHUTDOWN;this.settings.active=false;this.settings.visible=false;this.events.emit('shutdown',this);},/**\r\n     * Destroy this Scene and send a destroy event all of its systems.\r\n     *\r\n     * @method Phaser.Scenes.Systems#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.settings.status=CONST.DESTROYED;this.settings.active=false;this.settings.visible=false;this.events.emit('destroy',this);}});module.exports=Systems;/***/},/* 149 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Keyboard Codes.\r\n * \r\n * @name Phaser.Input.Keyboard.KeyCodes\r\n * @enum {integer}\r\n * @memberOf Phaser.Input.Keyboard\r\n * @readOnly\r\n * @since 3.0.0\r\n */var KeyCodes={/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.BACKSPACE\r\n     */BACKSPACE:8,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.TAB\r\n     */TAB:9,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.ENTER\r\n     */ENTER:13,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.SHIFT\r\n     */SHIFT:16,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.CTRL\r\n     */CTRL:17,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.ALT\r\n     */ALT:18,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.PAUSE\r\n     */PAUSE:19,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.CAPS_LOCK\r\n     */CAPS_LOCK:20,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.ESC\r\n     */ESC:27,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.SPACE\r\n     */SPACE:32,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.PAGE_UP\r\n     */PAGE_UP:33,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.PAGE_DOWN\r\n     */PAGE_DOWN:34,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.END\r\n     */END:35,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.HOME\r\n     */HOME:36,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.LEFT\r\n     */LEFT:37,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.UP\r\n     */UP:38,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.RIGHT\r\n     */RIGHT:39,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.DOWN\r\n     */DOWN:40,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.PRINT_SCREEN\r\n     */PRINT_SCREEN:42,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.INSERT\r\n     */INSERT:45,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.DELETE\r\n     */DELETE:46,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.ZERO\r\n     */ZERO:48,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.ONE\r\n     */ONE:49,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.TWO\r\n     */TWO:50,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.THREE\r\n     */THREE:51,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.FOUR\r\n     */FOUR:52,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.FIVE\r\n     */FIVE:53,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.SIX\r\n     */SIX:54,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.SEVEN\r\n     */SEVEN:55,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.EIGHT\r\n     */EIGHT:56,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.NINE\r\n     */NINE:57,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.A\r\n     */A:65,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.B\r\n     */B:66,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.C\r\n     */C:67,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.D\r\n     */D:68,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.E\r\n     */E:69,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F\r\n     */F:70,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.G\r\n     */G:71,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.H\r\n     */H:72,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.I\r\n     */I:73,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.J\r\n     */J:74,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.K\r\n     */K:75,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.L\r\n     */L:76,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.M\r\n     */M:77,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.N\r\n     */N:78,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.O\r\n     */O:79,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.P\r\n     */P:80,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.Q\r\n     */Q:81,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.R\r\n     */R:82,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.S\r\n     */S:83,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.T\r\n     */T:84,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.U\r\n     */U:85,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.V\r\n     */V:86,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.W\r\n     */W:87,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.X\r\n     */X:88,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.Y\r\n     */Y:89,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.Z\r\n     */Z:90,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F1\r\n     */F1:112,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F2\r\n     */F2:113,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F3\r\n     */F3:114,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F4\r\n     */F4:115,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F5\r\n     */F5:116,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F6\r\n     */F6:117,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F7\r\n     */F7:118,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F8\r\n     */F8:119,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F9\r\n     */F9:120,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F10\r\n     */F10:121,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F11\r\n     */F11:122,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.F12\r\n     */F12:123,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.SEMICOLON\r\n     */SEMICOLON:186,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.PLUS\r\n     */PLUS:187,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.COMMA\r\n     */COMMA:188,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.MINUS\r\n     */MINUS:189,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.PERIOD\r\n     */PERIOD:190,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.FORWARD_SLASH\r\n     */FORWARD_SLASH:191,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.BACK_SLASH\r\n     */BACK_SLASH:220,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.QUOTES\r\n     */QUOTES:222,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.BACKTICK\r\n     */BACKTICK:192,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.OPEN_BRACKET\r\n     */OPEN_BRACKET:219,/**\r\n     * @name Phaser.Input.Keyboard.KeyCodes.CLOSED_BRACKET\r\n     */CLOSED_BRACKET:221};module.exports=KeyCodes;/***/},/* 150 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.GameObjects.Graphics.Commands\r\n */module.exports={ARC:0,BEGIN_PATH:1,CLOSE_PATH:2,FILL_RECT:3,LINE_TO:4,MOVE_TO:5,LINE_STYLE:6,FILL_STYLE:7,FILL_PATH:8,STROKE_PATH:9,FILL_TRIANGLE:10,STROKE_TRIANGLE:11,LINE_FX_TO:12,MOVE_FX_TO:13,SAVE:14,RESTORE:15,TRANSLATE:16,SCALE:17,ROTATE:18};/***/},/* 151 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Checks if the given `width` and `height` are a power of two.\r\n * Useful for checking texture dimensions.\r\n *\r\n * @function Phaser.Math.Pow2.IsSizePowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} width - The width.\r\n * @param {number} height - The height.\r\n *\r\n * @return {boolean} `true` if `width` and `height` are a power of two, otherwise `false`.\r\n */var IsSizePowerOfTwo=function IsSizePowerOfTwo(width,height){return width>0&&(width&width-1)===0&&height>0&&(height&height-1)===0;};module.exports=IsSizePowerOfTwo;/***/},/* 152 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var OS=__webpack_require__(77);var Browser=__webpack_require__(104);var CanvasPool=__webpack_require__(23);/**\r\n * Determines the features of the browser running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.features` from within any Scene.\r\n * \r\n * @typedef {object} Phaser.Device.Features\r\n * @since 3.0.0\r\n * \r\n * @property {?boolean} canvasBitBltShift - True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.\r\n * @property {boolean} canvas - Is canvas available?\r\n * @property {boolean} file - Is file available?\r\n * @property {boolean} fileSystem - Is fileSystem available?\r\n * @property {boolean} getUserMedia - Does the device support the getUserMedia API?\r\n * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)\r\n * @property {boolean} localStorage - Is localStorage available?\r\n * @property {boolean} pointerLock - Is Pointer Lock available?\r\n * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?\r\n * @property {boolean} vibration - Does the device support the Vibration API?\r\n * @property {boolean} webGL - Is webGL available?\r\n * @property {boolean} worker - Is worker available?\r\n */var Features={canvas:false,canvasBitBltShift:null,file:false,fileSystem:false,getUserMedia:true,littleEndian:false,localStorage:false,pointerLock:false,support32bit:false,vibration:false,webGL:false,worker:false};// Check Little or Big Endian system.\n// @author Matt DesLauriers (@mattdesl)\nfunction checkIsLittleEndian(){var a=new ArrayBuffer(4);var b=new Uint8Array(a);var c=new Uint32Array(a);b[0]=0xa1;b[1]=0xb2;b[2]=0xc3;b[3]=0xd4;if(c[0]===0xd4c3b2a1){return true;}if(c[0]===0xa1b2c3d4){return false;}else{//  Could not determine endianness\nreturn null;}}function init(){Features.canvas=!!window['CanvasRenderingContext2D']||OS.cocoonJS;try{Features.localStorage=!!localStorage.getItem;}catch(error){Features.localStorage=false;}Features.file=!!window['File']&&!!window['FileReader']&&!!window['FileList']&&!!window['Blob'];Features.fileSystem=!!window['requestFileSystem'];var isUint8=false;var testWebGL=function testWebGL(){if(window['WebGLRenderingContext']){try{var canvas=CanvasPool.createWebGL(this);if(OS.cocoonJS){canvas.screencanvas=false;}var ctx=canvas.getContext('webgl')||canvas.getContext('experimental-webgl');var canvas2D=CanvasPool.create2D(this);var ctx2D=canvas2D.getContext('2d');//  Can't be done on a webgl context\nvar image=ctx2D.createImageData(1,1);//  Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.\n//  @author Matt DesLauriers (@mattdesl)\nisUint8=image.data instanceof Uint8ClampedArray;CanvasPool.remove(canvas);CanvasPool.remove(canvas2D);return!!ctx;}catch(e){return false;}}return false;};Features.webGL=testWebGL();Features.worker=!!window['Worker'];Features.pointerLock='pointerLockElement'in document||'mozPointerLockElement'in document||'webkitPointerLockElement'in document;navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia||navigator.oGetUserMedia;window.URL=window.URL||window.webkitURL||window.mozURL||window.msURL;Features.getUserMedia=Features.getUserMedia&&!!navigator.getUserMedia&&!!window.URL;// Older versions of firefox (< 21) apparently claim support but user media does not actually work\nif(Browser.firefox&&Browser.firefoxVersion<21){Features.getUserMedia=false;}// Excludes iOS versions as they generally wrap UIWebView (eg. Safari WebKit) and it\n// is safer to not try and use the fast copy-over method.\nif(!OS.iOS&&(Browser.ie||Browser.firefox||Browser.chrome)){Features.canvasBitBltShift=true;}// Known not to work\nif(Browser.safari||Browser.mobileSafari){Features.canvasBitBltShift=false;}navigator.vibrate=navigator.vibrate||navigator.webkitVibrate||navigator.mozVibrate||navigator.msVibrate;if(navigator.vibrate){Features.vibration=true;}if(typeof ArrayBuffer!=='undefined'&&typeof Uint8Array!=='undefined'&&typeof Uint32Array!=='undefined'){Features.littleEndian=checkIsLittleEndian();}Features.support32bit=typeof ArrayBuffer!=='undefined'&&typeof Uint8ClampedArray!=='undefined'&&typeof Int32Array!=='undefined'&&Features.littleEndian!==null&&isUint8;return Features;}module.exports=init();/***/},/* 153 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Adds the given element to the DOM. If a parent is provided the element is added as a child of the parent, providing it was able to access it.\r\n * If no parent was given or falls back to using `document.body`.\r\n *\r\n * @function Phaser.DOM.AddToDOM\r\n * @since 3.0.0\r\n *\r\n * @param {HTMLElement} element - The element to be added to the DOM. Usually a Canvas object.\r\n * @param {(string|HTMLElement)} [parent] - The parent in which to add the element. Can be a string which is passed to `getElementById` or an actual DOM object.\r\n * @param {boolean} [overflowHidden=true] - Whether or not to hide overflowing content inside the parent.\r\n *\r\n * @return {HTMLElement} The element that was added to the DOM.\r\n */var AddToDOM=function AddToDOM(element,parent,overflowHidden){if(overflowHidden===undefined){overflowHidden=true;}var target;if(parent){if(typeof parent==='string'){//  Hopefully an element ID\ntarget=document.getElementById(parent);}else if((typeof parent==='undefined'?'undefined':_typeof(parent))==='object'&&parent.nodeType===1){//  Quick test for a HTMLelement\ntarget=parent;}}//  Fallback, covers an invalid ID and a non HTMLelement object\nif(!target){target=document.body;}if(overflowHidden&&target.style){target.style.overflow='hidden';}target.appendChild(element);return element;};module.exports=AddToDOM;/***/},/* 154 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Calculates a linear (interpolation) value over t.\r\n *\r\n * @function Phaser.Math.Linear\r\n * @since 3.0.0\r\n *\r\n * @param {number} p0 - The first point\r\n * @param {number} p1 - The second point\r\n * @param {float} t -The percentage between p0 and p1 to return represented as a number between 0 and 1.\r\n *\r\n * @return {number} The step t% of the way between p0 and p1\r\n */var Linear=function Linear(p0,p1,t){return(p1-p0)*t+p0;};module.exports=Linear;/***/},/* 155 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - [description]\r\n * @param {number} p0 - [description]\r\n * @param {number} p1 - [description]\r\n * @param {number} p2 - [description]\r\n * @param {number} p3 - [description]\r\n *\r\n * @return {number} [description]\r\n */var CatmullRom=function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;};module.exports=CatmullRom;/***/},/* 156 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(16);/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.RadToDeg\r\n * @since 3.0.0\r\n *\r\n * @param {float} radians - [description]\r\n *\r\n * @return {integer} [description]\r\n */var RadToDeg=function RadToDeg(radians){return radians*CONST.RAD_TO_DEG;};module.exports=RadToDeg;/***/},/* 157 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);//  points is an array of Point-like objects,\n//  either 2 dimensional arrays, or objects with public x/y properties:\n//  var points = [\n//      [100, 200],\n//      [200, 400],\n//      { x: 30, y: 60 }\n//  ]\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.FromPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {array} points - [description]\r\n * @param {Phaser.Geom.Rectangle} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var FromPoints=function FromPoints(points,out){if(out===undefined){out=new Rectangle();}if(points.length===0){return out;}var minX=Number.MAX_VALUE;var minY=Number.MAX_VALUE;var maxX=Number.MIN_SAFE_INTEGER;var maxY=Number.MIN_SAFE_INTEGER;var p;var px;var py;for(var i=0;i<points.length;i++){p=points[i];if(Array.isArray(p)){px=p[0];py=p[1];}else{px=p.x;py=p.y;}minX=Math.min(minX,px);minY=Math.min(minY,py);maxX=Math.max(maxX,px);maxY=Math.max(maxY,py);}out.x=minX;out.y=minY;out.width=maxX-minX;out.height=maxY-minY;return out;};module.exports=FromPoints;/***/},/* 158 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Browser specific prefix, so not going to change between contexts, only between browsers\nvar prefix='';/**\r\n * @namespace Phaser.Display.Canvas.Smoothing\r\n * @since 3.0.0\r\n */var Smoothing=function Smoothing(){/**\r\n     * Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.\r\n     *\r\n     * @function Phaser.Display.Canvas.Smoothing.getPrefix\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(CanvasRenderingContext2D|WebGLRenderingContext)} context - [description]\r\n     *\r\n     * @return {string} [description]\r\n     */var getPrefix=function getPrefix(context){var vendors=['i','webkitI','msI','mozI','oI'];for(var i=0;i<vendors.length;i++){var s=vendors[i]+'mageSmoothingEnabled';if(s in context){return s;}}return null;};/**\r\n     * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.\r\n     * By default browsers have image smoothing enabled, which isn't always what you visually want, especially\r\n     * when using pixel art in a game. Note that this sets the property on the context itself, so that any image\r\n     * drawn to the context will be affected. This sets the property across all current browsers but support is\r\n     * patchy on earlier browsers, especially on mobile.\r\n     *\r\n     * @function Phaser.Display.Canvas.Smoothing.enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(CanvasRenderingContext2D|WebGLRenderingContext)} context - [description]\r\n     *\r\n     * @return {(CanvasRenderingContext2D|WebGLRenderingContext)} [description]\r\n     */var enable=function enable(context){if(prefix===''){prefix=getPrefix(context);}if(prefix){context[prefix]=true;}return context;};/**\r\n     * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.\r\n     * By default browsers have image smoothing enabled, which isn't always what you visually want, especially\r\n     * when using pixel art in a game. Note that this sets the property on the context itself, so that any image\r\n     * drawn to the context will be affected. This sets the property across all current browsers but support is\r\n     * patchy on earlier browsers, especially on mobile.\r\n     *\r\n     * @function Phaser.Display.Canvas.Smoothing.disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(CanvasRenderingContext2D|WebGLRenderingContext)} context - [description]\r\n     *\r\n     * @return {(CanvasRenderingContext2D|WebGLRenderingContext)} [description]\r\n     */var disable=function disable(context){if(prefix===''){prefix=getPrefix(context);}if(prefix){context[prefix]=false;}return context;};/**\r\n     * Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.\r\n     * Returns null if no smoothing prefix is available.\r\n     *\r\n     * @function Phaser.Display.Canvas.Smoothing.isEnabled\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(CanvasRenderingContext2D|WebGLRenderingContext)} context - [description]\r\n     *\r\n     * @return {?boolean} [description]\r\n     */var isEnabled=function isEnabled(context){return prefix!==null?context[prefix]:null;};return{disable:disable,enable:enable,getPrefix:getPrefix,isEnabled:isEnabled};};module.exports=Smoothing();/***/},/* 159 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Vector4\r\n * @memberOf Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - [description]\r\n * @param {number} [y] - [description]\r\n * @param {number} [z] - [description]\r\n * @param {number} [w] - [description]\r\n */var Vector4=new Class({initialize:function Vector4(x,y,z,w){/**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         *//**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         *//**\r\n         * The z component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         *//**\r\n         * The w component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#w\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.x=x.x||0;this.y=x.y||0;this.z=x.z||0;this.w=x.w||0;}else{this.x=x||0;this.y=y||0;this.z=z||0;this.w=w||0;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} [description]\r\n     */clone:function clone(){return new Vector4(this.x,this.y,this.z,this.w);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */copy:function copy(src){this.x=src.x;this.y=src.y;this.z=src.z||0;this.w=src.w||0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */equals:function equals(v){return this.x===v.x&&this.y===v.y&&this.z===v.z&&this.w===v.w;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     * @param {number} w - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */set:function set(x,y,z,w){if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.x=x.x||0;this.y=x.y||0;this.z=x.z||0;this.w=x.w||0;}else{this.x=x||0;this.y=y||0;this.z=z||0;this.w=w||0;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */add:function add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z||0;this.w+=v.w||0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */subtract:function subtract(v){this.x-=v.x;this.y-=v.y;this.z-=v.z||0;this.w-=v.w||0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */scale:function scale(_scale2){this.x*=_scale2;this.y*=_scale2;this.z*=_scale2;this.w*=_scale2;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */length:function length(){var x=this.x;var y=this.y;var z=this.z;var w=this.w;return Math.sqrt(x*x+y*y+z*z+w*w);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */lengthSq:function lengthSq(){var x=this.x;var y=this.y;var z=this.z;var w=this.w;return x*x+y*y+z*z+w*w;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */normalize:function normalize(){var x=this.x;var y=this.y;var z=this.z;var w=this.w;var len=x*x+y*y+z*z+w*w;if(len>0){len=1/Math.sqrt(len);this.x=x*len;this.y=y*len;this.z=z*len;this.w=w*len;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - [description]\r\n     * @param {number} [t=0] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */lerp:function lerp(v,t){if(t===undefined){t=0;}var ax=this.x;var ay=this.y;var az=this.z;var aw=this.w;this.x=ax+t*(v.x-ax);this.y=ay+t*(v.y-ay);this.z=az+t*(v.z-az);this.w=aw+t*(v.w-aw);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */multiply:function multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z||1;this.w*=v.w||1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */divide:function divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z||1;this.w/=v.w||1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */distance:function distance(v){var dx=v.x-this.x;var dy=v.y-this.y;var dz=v.z-this.z||0;var dw=v.w-this.w||0;return Math.sqrt(dx*dx+dy*dy+dz*dz+dw*dw);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */distanceSq:function distanceSq(v){var dx=v.x-this.x;var dy=v.y-this.y;var dz=v.z-this.z||0;var dw=v.w-this.w||0;return dx*dx+dy*dy+dz*dz+dw*dw;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */transformMat4:function transformMat4(mat){var x=this.x;var y=this.y;var z=this.z;var w=this.w;var m=mat.val;this.x=m[0]*x+m[4]*y+m[8]*z+m[12]*w;this.y=m[1]*x+m[5]*y+m[9]*z+m[13]*w;this.z=m[2]*x+m[6]*y+m[10]*z+m[14]*w;this.w=m[3]*x+m[7]*y+m[11]*z+m[15]*w;return this;},//  TODO: is this really the same as Vector3?\n//  Also, what about this: http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#transformQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */transformQuat:function transformQuat(q){// benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\nvar x=this.x;var y=this.y;var z=this.z;var qx=q.x;var qy=q.y;var qz=q.z;var qw=q.w;// calculate quat * vec\nvar ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat\nthis.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Vector4#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4 object.\r\n     */reset:function reset(){this.x=0;this.y=0;this.z=0;this.w=0;return this;}});//  TODO: Check if these are required internally, if not, remove.\nVector4.prototype.sub=Vector4.prototype.subtract;Vector4.prototype.mul=Vector4.prototype.multiply;Vector4.prototype.div=Vector4.prototype.divide;Vector4.prototype.dist=Vector4.prototype.distance;Vector4.prototype.distSq=Vector4.prototype.distanceSq;Vector4.prototype.len=Vector4.prototype.length;Vector4.prototype.lenSq=Vector4.prototype.lengthSq;module.exports=Vector4;/***/},/* 160 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class=__webpack_require__(0);var EPSILON=0.000001;/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Matrix4\r\n * @memberOf Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Matrix4} [m] - [description]\r\n */var Matrix4=new Class({initialize:function Matrix4(m){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Math.Matrix4#val\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.val=new Float32Array(16);if(m){//  Assume Matrix4 with val:\nthis.copy(m);}else{//  Default to identity\nthis.identity();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} A new Matrix4 object.\r\n     */clone:function clone(){return new Matrix4(this);},//  TODO - Should work with basic values\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */set:function set(src){return this.copy(src);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */copy:function copy(src){var out=this.val;var a=src.val;out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];out[9]=a[9];out[10]=a[10];out[11]=a[11];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} a - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */fromArray:function fromArray(a){var out=this.val;out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];out[9]=a[9];out[10]=a[10];out[11]=a[11];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#zero\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */zero:function zero(){var out=this.val;out[0]=0;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=0;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=0;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#xyz\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */xyz:function xyz(x,y,z){this.identity();var out=this.val;out[12]=x;out[13]=y;out[14]=z;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#scaling\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */scaling:function scaling(x,y,z){this.zero();var out=this.val;out[0]=x;out[5]=y;out[10]=z;out[15]=1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */identity:function identity(){var out=this.val;out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=1;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=1;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#transpose\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */transpose:function transpose(){var a=this.val;var a01=a[1];var a02=a[2];var a03=a[3];var a12=a[6];var a13=a[7];var a23=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=a01;a[6]=a[9];a[7]=a[13];a[8]=a02;a[9]=a12;a[11]=a[14];a[12]=a03;a[13]=a13;a[14]=a23;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */invert:function invert(){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];var a30=a[12];var a31=a[13];var a32=a[14];var a33=a[15];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;// Calculate the determinant\nvar det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;if(!det){return null;}det=1/det;a[0]=(a11*b11-a12*b10+a13*b09)*det;a[1]=(a02*b10-a01*b11-a03*b09)*det;a[2]=(a31*b05-a32*b04+a33*b03)*det;a[3]=(a22*b04-a21*b05-a23*b03)*det;a[4]=(a12*b08-a10*b11-a13*b07)*det;a[5]=(a00*b11-a02*b08+a03*b07)*det;a[6]=(a32*b02-a30*b05-a33*b01)*det;a[7]=(a20*b05-a22*b02+a23*b01)*det;a[8]=(a10*b10-a11*b08+a13*b06)*det;a[9]=(a01*b08-a00*b10-a03*b06)*det;a[10]=(a30*b04-a31*b02+a33*b00)*det;a[11]=(a21*b02-a20*b04-a23*b00)*det;a[12]=(a11*b07-a10*b09-a12*b06)*det;a[13]=(a00*b09-a01*b07+a02*b06)*det;a[14]=(a31*b01-a30*b03-a32*b00)*det;a[15]=(a20*b03-a21*b01+a22*b00)*det;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#adjoint\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */adjoint:function adjoint(){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];var a30=a[12];var a31=a[13];var a32=a[14];var a33=a[15];a[0]=a11*(a22*a33-a23*a32)-a21*(a12*a33-a13*a32)+a31*(a12*a23-a13*a22);a[1]=-(a01*(a22*a33-a23*a32)-a21*(a02*a33-a03*a32)+a31*(a02*a23-a03*a22));a[2]=a01*(a12*a33-a13*a32)-a11*(a02*a33-a03*a32)+a31*(a02*a13-a03*a12);a[3]=-(a01*(a12*a23-a13*a22)-a11*(a02*a23-a03*a22)+a21*(a02*a13-a03*a12));a[4]=-(a10*(a22*a33-a23*a32)-a20*(a12*a33-a13*a32)+a30*(a12*a23-a13*a22));a[5]=a00*(a22*a33-a23*a32)-a20*(a02*a33-a03*a32)+a30*(a02*a23-a03*a22);a[6]=-(a00*(a12*a33-a13*a32)-a10*(a02*a33-a03*a32)+a30*(a02*a13-a03*a12));a[7]=a00*(a12*a23-a13*a22)-a10*(a02*a23-a03*a22)+a20*(a02*a13-a03*a12);a[8]=a10*(a21*a33-a23*a31)-a20*(a11*a33-a13*a31)+a30*(a11*a23-a13*a21);a[9]=-(a00*(a21*a33-a23*a31)-a20*(a01*a33-a03*a31)+a30*(a01*a23-a03*a21));a[10]=a00*(a11*a33-a13*a31)-a10*(a01*a33-a03*a31)+a30*(a01*a13-a03*a11);a[11]=-(a00*(a11*a23-a13*a21)-a10*(a01*a23-a03*a21)+a20*(a01*a13-a03*a11));a[12]=-(a10*(a21*a32-a22*a31)-a20*(a11*a32-a12*a31)+a30*(a11*a22-a12*a21));a[13]=a00*(a21*a32-a22*a31)-a20*(a01*a32-a02*a31)+a30*(a01*a22-a02*a21);a[14]=-(a00*(a11*a32-a12*a31)-a10*(a01*a32-a02*a31)+a30*(a01*a12-a02*a11));a[15]=a00*(a11*a22-a12*a21)-a10*(a01*a22-a02*a21)+a20*(a01*a12-a02*a11);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#determinant\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */determinant:function determinant(){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];var a30=a[12];var a31=a[13];var a32=a[14];var a33=a[15];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;// Calculate the determinant\nreturn b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */multiply:function multiply(src){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];var a30=a[12];var a31=a[13];var a32=a[14];var a33=a[15];var b=src.val;// Cache only the current line of the second matrix\nvar b0=b[0];var b1=b[1];var b2=b[2];var b3=b[3];a[0]=b0*a00+b1*a10+b2*a20+b3*a30;a[1]=b0*a01+b1*a11+b2*a21+b3*a31;a[2]=b0*a02+b1*a12+b2*a22+b3*a32;a[3]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[4];b1=b[5];b2=b[6];b3=b[7];a[4]=b0*a00+b1*a10+b2*a20+b3*a30;a[5]=b0*a01+b1*a11+b2*a21+b3*a31;a[6]=b0*a02+b1*a12+b2*a22+b3*a32;a[7]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[8];b1=b[9];b2=b[10];b3=b[11];a[8]=b0*a00+b1*a10+b2*a20+b3*a30;a[9]=b0*a01+b1*a11+b2*a21+b3*a31;a[10]=b0*a02+b1*a12+b2*a22+b3*a32;a[11]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[12];b1=b[13];b2=b[14];b3=b[15];a[12]=b0*a00+b1*a10+b2*a20+b3*a30;a[13]=b0*a01+b1*a11+b2*a21+b3*a31;a[14]=b0*a02+b1*a12+b2*a22+b3*a32;a[15]=b0*a03+b1*a13+b2*a23+b3*a33;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#multiplyLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */multiplyLocal:function multiplyLocal(src){var a=[];var m1=this.val;var m2=src.val;a[0]=m1[0]*m2[0]+m1[1]*m2[4]+m1[2]*m2[8]+m1[3]*m2[12];a[1]=m1[0]*m2[1]+m1[1]*m2[5]+m1[2]*m2[9]+m1[3]*m2[13];a[2]=m1[0]*m2[2]+m1[1]*m2[6]+m1[2]*m2[10]+m1[3]*m2[14];a[3]=m1[0]*m2[3]+m1[1]*m2[7]+m1[2]*m2[11]+m1[3]*m2[15];a[4]=m1[4]*m2[0]+m1[5]*m2[4]+m1[6]*m2[8]+m1[7]*m2[12];a[5]=m1[4]*m2[1]+m1[5]*m2[5]+m1[6]*m2[9]+m1[7]*m2[13];a[6]=m1[4]*m2[2]+m1[5]*m2[6]+m1[6]*m2[10]+m1[7]*m2[14];a[7]=m1[4]*m2[3]+m1[5]*m2[7]+m1[6]*m2[11]+m1[7]*m2[15];a[8]=m1[8]*m2[0]+m1[9]*m2[4]+m1[10]*m2[8]+m1[11]*m2[12];a[9]=m1[8]*m2[1]+m1[9]*m2[5]+m1[10]*m2[9]+m1[11]*m2[13];a[10]=m1[8]*m2[2]+m1[9]*m2[6]+m1[10]*m2[10]+m1[11]*m2[14];a[11]=m1[8]*m2[3]+m1[9]*m2[7]+m1[10]*m2[11]+m1[11]*m2[15];a[12]=m1[12]*m2[0]+m1[13]*m2[4]+m1[14]*m2[8]+m1[15]*m2[12];a[13]=m1[12]*m2[1]+m1[13]*m2[5]+m1[14]*m2[9]+m1[15]*m2[13];a[14]=m1[12]*m2[2]+m1[13]*m2[6]+m1[14]*m2[10]+m1[15]*m2[14];a[15]=m1[12]*m2[3]+m1[13]*m2[7]+m1[14]*m2[11]+m1[15]*m2[15];return this.fromArray(a);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */translate:function translate(v){var x=v.x;var y=v.y;var z=v.z;var a=this.val;a[12]=a[0]*x+a[4]*y+a[8]*z+a[12];a[13]=a[1]*x+a[5]*y+a[9]*z+a[13];a[14]=a[2]*x+a[6]*y+a[10]*z+a[14];a[15]=a[3]*x+a[7]*y+a[11]*z+a[15];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */scale:function scale(v){var x=v.x;var y=v.y;var z=v.z;var a=this.val;a[0]=a[0]*x;a[1]=a[1]*x;a[2]=a[2]*x;a[3]=a[3]*x;a[4]=a[4]*y;a[5]=a[5]*y;a[6]=a[6]*y;a[7]=a[7]*y;a[8]=a[8]*z;a[9]=a[9]*z;a[10]=a[10]*z;a[11]=a[11]*z;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#makeRotationAxis\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} axis - [description]\r\n     * @param {float} angle - The angle of rotation in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */makeRotationAxis:function makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp\nvar c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x;var y=axis.y;var z=axis.z;var tx=t*x;var ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;},//  aka rotationAxis\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} rad - [description]\r\n     * @param {Phaser.Math.Vector3} axis - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */rotate:function rotate(rad,axis){var a=this.val;var x=axis.x;var y=axis.y;var z=axis.z;var len=Math.sqrt(x*x+y*y+z*z);if(Math.abs(len)<EPSILON){return null;}len=1/len;x*=len;y*=len;z*=len;var s=Math.sin(rad);var c=Math.cos(rad);var t=1-c;var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];// Construct the elements of the rotation matrix\nvar b00=x*x*t+c;var b01=y*x*t+z*s;var b02=z*x*t-y*s;var b10=x*y*t-z*s;var b11=y*y*t+c;var b12=z*y*t+x*s;var b20=x*z*t+y*s;var b21=y*z*t-x*s;var b22=z*z*t+c;// Perform rotation-specific matrix multiplication\na[0]=a00*b00+a10*b01+a20*b02;a[1]=a01*b00+a11*b01+a21*b02;a[2]=a02*b00+a12*b01+a22*b02;a[3]=a03*b00+a13*b01+a23*b02;a[4]=a00*b10+a10*b11+a20*b12;a[5]=a01*b10+a11*b11+a21*b12;a[6]=a02*b10+a12*b11+a22*b12;a[7]=a03*b10+a13*b11+a23*b12;a[8]=a00*b20+a10*b21+a20*b22;a[9]=a01*b20+a11*b21+a21*b22;a[10]=a02*b20+a12*b21+a22*b22;a[11]=a03*b20+a13*b21+a23*b22;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} rad - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */rotateX:function rotateX(rad){var a=this.val;var s=Math.sin(rad);var c=Math.cos(rad);var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];// Perform axis-specific matrix multiplication\na[4]=a10*c+a20*s;a[5]=a11*c+a21*s;a[6]=a12*c+a22*s;a[7]=a13*c+a23*s;a[8]=a20*c-a10*s;a[9]=a21*c-a11*s;a[10]=a22*c-a12*s;a[11]=a23*c-a13*s;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} rad - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */rotateY:function rotateY(rad){var a=this.val;var s=Math.sin(rad);var c=Math.cos(rad);var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];// Perform axis-specific matrix multiplication\na[0]=a00*c-a20*s;a[1]=a01*c-a21*s;a[2]=a02*c-a22*s;a[3]=a03*c-a23*s;a[8]=a00*s+a20*c;a[9]=a01*s+a21*c;a[10]=a02*s+a22*c;a[11]=a03*s+a23*c;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} rad - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */rotateZ:function rotateZ(rad){var a=this.val;var s=Math.sin(rad);var c=Math.cos(rad);var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];// Perform axis-specific matrix multiplication\na[0]=a00*c+a10*s;a[1]=a01*c+a11*s;a[2]=a02*c+a12*s;a[3]=a03*c+a13*s;a[4]=a10*c-a00*s;a[5]=a11*c-a01*s;a[6]=a12*c-a02*s;a[7]=a13*c-a03*s;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromRotationTranslation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - [description]\r\n     * @param {Phaser.Math.Vector3} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */fromRotationTranslation:function fromRotationTranslation(q,v){// Quaternion math\nvar out=this.val;var x=q.x;var y=q.y;var z=q.z;var w=q.w;var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var xy=x*y2;var xz=x*z2;var yy=y*y2;var yz=y*z2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;out[0]=1-(yy+zz);out[1]=xy+wz;out[2]=xz-wy;out[3]=0;out[4]=xy-wz;out[5]=1-(xx+zz);out[6]=yz+wx;out[7]=0;out[8]=xz+wy;out[9]=yz-wx;out[10]=1-(xx+yy);out[11]=0;out[12]=v.x;out[13]=v.y;out[14]=v.z;out[15]=1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */fromQuat:function fromQuat(q){var out=this.val;var x=q.x;var y=q.y;var z=q.z;var w=q.w;var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var xy=x*y2;var xz=x*z2;var yy=y*y2;var yz=y*z2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;out[0]=1-(yy+zz);out[1]=xy+wz;out[2]=xz-wy;out[3]=0;out[4]=xy-wz;out[5]=1-(xx+zz);out[6]=yz+wx;out[7]=0;out[8]=xz+wy;out[9]=yz-wx;out[10]=1-(xx+yy);out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return this;},/**\r\n     * Generates a frustum matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#frustum\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} left - The left bound of the frustum.\r\n     * @param {number} right - The right bound of the frustum.\r\n     * @param {number} bottom - The bottom bound of the frustum.\r\n     * @param {number} top - The top bound of the frustum.\r\n     * @param {number} near - The near bound of the frustum.\r\n     * @param {number} far - The far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */frustum:function frustum(left,right,bottom,top,near,far){var out=this.val;var rl=1/(right-left);var tb=1/(top-bottom);var nf=1/(near-far);out[0]=near*2*rl;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=near*2*tb;out[6]=0;out[7]=0;out[8]=(right+left)*rl;out[9]=(top+bottom)*tb;out[10]=(far+near)*nf;out[11]=-1;out[12]=0;out[13]=0;out[14]=far*near*2*nf;out[15]=0;return this;},/**\r\n     * Generates a perspective projection matrix with the given bounds.\r\n     * perspective fov lh\r\n     *\r\n     * @method Phaser.Math.Matrix4#perspective\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} fovy - Vertical field of view in radians\r\n     * @param {number} aspect - Aspect ratio. Typically viewport width  /height.\r\n     * @param {number} near - Near bound of the frustum.\r\n     * @param {number} far - Far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */perspective:function perspective(fovy,aspect,near,far){var out=this.val;var f=1.0/Math.tan(fovy/2);var nf=1/(near-far);out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=(far+near)*nf;out[11]=-1;out[12]=0;out[13]=0;out[14]=2*far*near*nf;out[15]=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#perspectiveLH\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} near - Near bound of the frustum.\r\n     * @param {number} far - Far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */perspectiveLH:function perspectiveLH(width,height,near,far){var out=this.val;out[0]=2*near/width;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=2*near/height;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=-far/(near-far);out[11]=1;out[12]=0;out[13]=0;out[14]=near*far/(near-far);out[15]=0;return this;},/**\r\n     * Generates a orthogonal projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#ortho\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} left - The left bound of the frustum.\r\n     * @param {number} right - The right bound of the frustum.\r\n     * @param {number} bottom - The bottom bound of the frustum.\r\n     * @param {number} top - The top bound of the frustum.\r\n     * @param {number} near - The near bound of the frustum.\r\n     * @param {number} far - The far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */ortho:function ortho(left,right,bottom,top,near,far){var out=this.val;var lr=left-right;var bt=bottom-top;var nf=near-far;//  Avoid division by zero\nlr=lr===0?lr:1/lr;bt=bt===0?bt:1/bt;nf=nf===0?nf:1/nf;out[0]=-2*lr;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=-2*bt;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=2*nf;out[11]=0;out[12]=(left+right)*lr;out[13]=(top+bottom)*bt;out[14]=(far+near)*nf;out[15]=1;return this;},/**\r\n     * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#lookAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} eye - Position of the viewer\r\n     * @param {Phaser.Math.Vector3} center - Point the viewer is looking at\r\n     * @param {Phaser.Math.Vector3} up - vec3 pointing up.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */lookAt:function lookAt(eye,center,up){var out=this.val;var eyex=eye.x;var eyey=eye.y;var eyez=eye.z;var upx=up.x;var upy=up.y;var upz=up.z;var centerx=center.x;var centery=center.y;var centerz=center.z;if(Math.abs(eyex-centerx)<EPSILON&&Math.abs(eyey-centery)<EPSILON&&Math.abs(eyez-centerz)<EPSILON){return this.identity();}var z0=eyex-centerx;var z1=eyey-centery;var z2=eyez-centerz;var len=1/Math.sqrt(z0*z0+z1*z1+z2*z2);z0*=len;z1*=len;z2*=len;var x0=upy*z2-upz*z1;var x1=upz*z0-upx*z2;var x2=upx*z1-upy*z0;len=Math.sqrt(x0*x0+x1*x1+x2*x2);if(!len){x0=0;x1=0;x2=0;}else{len=1/len;x0*=len;x1*=len;x2*=len;}var y0=z1*x2-z2*x1;var y1=z2*x0-z0*x2;var y2=z0*x1-z1*x0;len=Math.sqrt(y0*y0+y1*y1+y2*y2);if(!len){y0=0;y1=0;y2=0;}else{len=1/len;y0*=len;y1*=len;y2*=len;}out[0]=x0;out[1]=y0;out[2]=z0;out[3]=0;out[4]=x1;out[5]=y1;out[6]=z1;out[7]=0;out[8]=x2;out[9]=y2;out[10]=z2;out[11]=0;out[12]=-(x0*eyex+x1*eyey+x2*eyez);out[13]=-(y0*eyex+y1*eyey+y2*eyez);out[14]=-(z0*eyex+z1*eyey+z2*eyez);out[15]=1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#yawPitchRoll\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} yaw - [description]\r\n     * @param {number} pitch - [description]\r\n     * @param {number} roll - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */yawPitchRoll:function yawPitchRoll(yaw,pitch,roll){this.zero();_tempMat1.zero();_tempMat2.zero();var m0=this.val;var m1=_tempMat1.val;var m2=_tempMat2.val;//  Rotate Z\nvar s=Math.sin(roll);var c=Math.cos(roll);m0[10]=1;m0[15]=1;m0[0]=c;m0[1]=s;m0[4]=-s;m0[5]=c;//  Rotate X\ns=Math.sin(pitch);c=Math.cos(pitch);m1[0]=1;m1[15]=1;m1[5]=c;m1[10]=c;m1[9]=-s;m1[6]=s;//  Rotate Y\ns=Math.sin(yaw);c=Math.cos(yaw);m2[5]=1;m2[15]=1;m2[0]=c;m2[2]=-s;m2[8]=s;m2[10]=c;this.multiplyLocal(_tempMat1);this.multiplyLocal(_tempMat2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#setWorldMatrix\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} rotation - [description]\r\n     * @param {Phaser.Math.Vector3} position - [description]\r\n     * @param {Phaser.Math.Vector3} scale - [description]\r\n     * @param {Phaser.Math.Matrix4} [viewMatrix] - [description]\r\n     * @param {Phaser.Math.Matrix4} [projectionMatrix] - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4 object.\r\n     */setWorldMatrix:function setWorldMatrix(rotation,position,scale,viewMatrix,projectionMatrix){this.yawPitchRoll(rotation.y,rotation.x,rotation.z);_tempMat1.scaling(scale.x,scale.y,scale.z);_tempMat2.xyz(position.x,position.y,position.z);this.multiplyLocal(_tempMat1);this.multiplyLocal(_tempMat2);if(viewMatrix!==undefined){this.multiplyLocal(viewMatrix);}if(projectionMatrix!==undefined){this.multiplyLocal(projectionMatrix);}return this;}});var _tempMat1=new Matrix4();var _tempMat2=new Matrix4();module.exports=Matrix4;/***/},/* 161 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Matrix4=__webpack_require__(160);var RandomXYZ=__webpack_require__(341);var RandomXYZW=__webpack_require__(340);var RotateVec3=__webpack_require__(339);var Set=__webpack_require__(65);var Sprite3D=__webpack_require__(105);var Vector2=__webpack_require__(6);var Vector3=__webpack_require__(59);var Vector4=__webpack_require__(159);//  Local cache vars\nvar tmpVec3=new Vector3();var tmpVec4=new Vector4();var dirvec=new Vector3();var rightvec=new Vector3();var billboardMatrix=new Matrix4();//  @author attribute https://github.com/mattdesl/cam3d/wiki\n/**\r\n * @typedef {object} RayDef\r\n *\r\n * @property {Phaser.Math.Vector3} origin - [description]\r\n * @property {Phaser.Math.Vector3} direction - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Camera\r\n * @memberOf Phaser.Cameras.Sprite3D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var Camera=new Class({initialize:function Camera(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */this.displayList=scene.sys.displayList;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#updateList\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @since 3.0.0\r\n         */this.updateList=scene.sys.updateList;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.name='';/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#direction\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.0.0\r\n         */this.direction=new Vector3(0,0,-1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#up\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.0.0\r\n         */this.up=new Vector3(0,1,0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#position\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.0.0\r\n         */this.position=new Vector3();//  The mapping from 3D size units to pixels.\n//  In the default case 1 3D unit = 128 pixels. So a sprite that is\n//  256 x 128 px in size will be 2 x 1 units.\n//  Change to whatever best fits your game assets.\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#pixelScale\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.pixelScale=128;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#projection\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.0.0\r\n         */this.projection=new Matrix4();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#view\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.0.0\r\n         */this.view=new Matrix4();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#combined\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.0.0\r\n         */this.combined=new Matrix4();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#invProjectionView\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.0.0\r\n         */this.invProjectionView=new Matrix4();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#near\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.near=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#far\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.far=100;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#ray\r\n         * @type {RayDef}\r\n         * @since 3.0.0\r\n         */this.ray={origin:new Vector3(),direction:new Vector3()};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#viewportWidth\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.viewportWidth=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#viewportHeight\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.viewportHeight=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#billboardMatrixDirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.billboardMatrixDirty=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#children\r\n         * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}\r\n         * @since 3.0.0\r\n         */this.children=new Set();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */setPosition:function setPosition(x,y,z){this.position.set(x,y,z);return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */setScene:function setScene(scene){this.scene=scene;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setPixelScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */setPixelScale:function setPixelScale(value){this.pixelScale=value;return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Sprite3D} sprite3D - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D} [description]\r\n     */add:function add(sprite3D){this.children.set(sprite3D);this.updateChildren();return sprite3D;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */remove:function remove(child){this.displayList.remove(child.gameObject);this.updateList.remove(child.gameObject);this.children.delete(child);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */clear:function clear(){var children=this.getChildren();for(var i=0;i<children.length;i++){this.remove(children[i]);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#getChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @return {array} [description]\r\n     */getChildren:function getChildren(){return this.children.entries;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     * @param {string} key - [description]\r\n     * @param {(string|number)} frame - [description]\r\n     * @param {boolean} [visible=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D} [description]\r\n     */create:function create(x,y,z,key,frame,visible){if(visible===undefined){visible=true;}var child=new Sprite3D(this.scene,x,y,z,key,frame);this.displayList.add(child.gameObject);this.updateList.add(child.gameObject);child.visible=visible;this.children.set(child);this.updateChildren();return child;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} quantity - [description]\r\n     * @param {string} key - [description]\r\n     * @param {(string|number)} frame - [description]\r\n     * @param {boolean} [visible=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D[]} [description]\r\n     */createMultiple:function createMultiple(quantity,key,frame,visible){if(visible===undefined){visible=true;}var output=[];for(var i=0;i<quantity;i++){var child=new Sprite3D(this.scene,0,0,0,key,frame);this.displayList.add(child.gameObject);this.updateList.add(child.gameObject);child.visible=visible;this.children.set(child);output.push(child);}return output;},//  Create a bunch of Sprite3D objects in a rectangle\n//  size and spacing are Vec3s (or if integers are converted to vec3s)\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#createRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|{x:number,y:number})} size - [description]\r\n     * @param {(number|{x:number,y:number,z:number})} spacing - [description]\r\n     * @param {string} key - [description]\r\n     * @param {(string|number)} [frame] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D[]} [description]\r\n     */createRect:function createRect(size,spacing,key,frame){if(typeof size==='number'){size={x:size,y:size,z:size};}if(typeof spacing==='number'){spacing={x:spacing,y:spacing,z:spacing};}var quantity=size.x*size.y*size.z;var sprites=this.createMultiple(quantity,key,frame);var i=0;for(var z=0.5-size.z/2;z<size.z/2;z++){for(var y=0.5-size.y/2;y<size.y/2;y++){for(var x=0.5-size.x/2;x<size.x/2;x++){var bx=x*spacing.x;var by=y*spacing.y;var bz=z*spacing.z;sprites[i].position.set(bx,by,bz);i++;}}}this.update();return sprites;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#randomSphere\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radius=1] - [description]\r\n     * @param {Phaser.GameObjects.Sprite3D[]} [sprites] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */randomSphere:function randomSphere(radius,sprites){if(sprites===undefined){sprites=this.getChildren();}for(var i=0;i<sprites.length;i++){RandomXYZ(sprites[i].position,radius);}return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#randomCube\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} [scale=1] - [description]\r\n     * @param {Phaser.GameObjects.Sprite3D[]} [sprites] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */randomCube:function randomCube(scale,sprites){if(sprites===undefined){sprites=this.getChildren();}for(var i=0;i<sprites.length;i++){RandomXYZW(sprites[i].position,scale);}return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#translateChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} vec3 - [description]\r\n     * @param {Phaser.GameObjects.Sprite3D[]} sprites - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */translateChildren:function translateChildren(vec3,sprites){if(sprites===undefined){sprites=this.getChildren();}for(var i=0;i<sprites.length;i++){sprites[i].position.add(vec3);}return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#transformChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat4 - [description]\r\n     * @param {Phaser.GameObjects.Sprite3D[]} sprites - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */transformChildren:function transformChildren(mat4,sprites){if(sprites===undefined){sprites=this.getChildren();}for(var i=0;i<sprites.length;i++){sprites[i].position.transformMat4(mat4);}return this.update();},/**\r\n     * Sets the width and height of the viewport. Does not update any matrices.\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setViewport\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */setViewport:function setViewport(width,height){this.viewportWidth=width;this.viewportHeight=height;return this.update();},/**\r\n     * Translates this camera by a specified Vector3 object\r\n     * or x, y, z parameters. Any undefined x y z values will\r\n     * default to zero, leaving that component unaffected.\r\n     * If you wish to set the camera position directly call setPosition instead.\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - [description]\r\n     * @param {number} [y] - [description]\r\n     * @param {number} [z] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */translate:function translate(x,y,z){if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.position.x+=x.x||0;this.position.y+=x.y||0;this.position.z+=x.z||0;}else{this.position.x+=x||0;this.position.y+=y||0;this.position.z+=z||0;}return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#lookAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - [description]\r\n     * @param {number} [y] - [description]\r\n     * @param {number} [z] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */lookAt:function lookAt(x,y,z){var dir=this.direction;var up=this.up;if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){dir.copy(x);}else{dir.set(x,y,z);}dir.subtract(this.position).normalize();//  Calculate right vector\ntmpVec3.copy(dir).cross(up).normalize();//  Calculate up vector\nup.copy(tmpVec3).cross(dir).normalize();return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} radians - [description]\r\n     * @param {Phaser.Math.Vector3} axis - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */rotate:function rotate(radians,axis){RotateVec3(this.direction,axis,radians);RotateVec3(this.up,axis,radians);return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#rotateAround\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} point - [description]\r\n     * @param {float} radians - [description]\r\n     * @param {Phaser.Math.Vector3} axis - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */rotateAround:function rotateAround(point,radians,axis){tmpVec3.copy(point).subtract(this.position);this.translate(tmpVec3);this.rotate(radians,axis);this.translate(tmpVec3.negate());return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#project\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} vec - [description]\r\n     * @param {Phaser.Math.Vector4} out - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} [description]\r\n     */project:function project(vec,out){if(out===undefined){out=new Vector4();}//  TODO: support viewport XY\nvar viewportWidth=this.viewportWidth;var viewportHeight=this.viewportHeight;var n=Camera.NEAR_RANGE;var f=Camera.FAR_RANGE;//  For useful Z and W values we should do the usual steps: clip space -> NDC -> window coords\n//  Implicit 1.0 for w component\ntmpVec4.set(vec.x,vec.y,vec.z,1.0);//  Transform into clip space\ntmpVec4.transformMat4(this.combined);//  Avoid divide by zero when 0x0x0 camera projects to a 0x0x0 vec3\nif(tmpVec4.w===0){tmpVec4.w=1;}//  Now into NDC\ntmpVec4.x=tmpVec4.x/tmpVec4.w;tmpVec4.y=tmpVec4.y/tmpVec4.w;tmpVec4.z=tmpVec4.z/tmpVec4.w;//  And finally into window coordinates\nout.x=viewportWidth/2*tmpVec4.x+(0+viewportWidth/2);out.y=viewportHeight/2*tmpVec4.y+(0+viewportHeight/2);out.z=(f-n)/2*tmpVec4.z+(f+n)/2;//  If the out vector has a fourth component, we also store (1/clip.w), same idea as gl_FragCoord.w\nif(out.w===0||out.w){out.w=1/tmpVec4.w;}return out;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#unproject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} vec - [description]\r\n     * @param {Phaser.Math.Vector3} out - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} [description]\r\n     */unproject:function unproject(vec,out){if(out===undefined){out=new Vector3();}var viewport=tmpVec4.set(0,0,this.viewportWidth,this.viewportHeight);return out.copy(vec).unproject(viewport,this.invProjectionView);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#getPickRay\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y] - [description]\r\n     *\r\n     * @return {RayDef} [description]\r\n     */getPickRay:function getPickRay(x,y){var origin=this.ray.origin.set(x,y,0);var direction=this.ray.direction.set(x,y,1);var viewport=tmpVec4.set(0,0,this.viewportWidth,this.viewportHeight);var mtx=this.invProjectionView;origin.unproject(viewport,mtx);direction.unproject(viewport,mtx);direction.subtract(origin).normalize();return this.ray;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#updateChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */updateChildren:function updateChildren(){var children=this.children.entries;for(var i=0;i<children.length;i++){children[i].project(this);}return this;},//  Overriden by subclasses\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */update:function update(){return this.updateChildren();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#updateBillboardMatrix\r\n     * @since 3.0.0\r\n     */updateBillboardMatrix:function updateBillboardMatrix(){var dir=dirvec.set(this.direction).negate();// Better view-aligned billboards might use this:\n// var dir = tmp.set(camera.position).subtract(p).normalize();\nvar right=rightvec.set(this.up).cross(dir).normalize();var up=tmpVec3.set(dir).cross(right).normalize();var out=billboardMatrix.val;out[0]=right.x;out[1]=right.y;out[2]=right.z;out[3]=0;out[4]=up.x;out[5]=up.y;out[6]=up.z;out[7]=0;out[8]=dir.x;out[9]=dir.y;out[10]=dir.z;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;this.billboardMatrixDirty=false;},/**\r\n     * This is a utility function for canvas 3D rendering,\r\n     * which determines the \"point size\" of a camera-facing\r\n     * sprite billboard given its 3D world position\r\n     * (origin at center of sprite) and its world width\r\n     * and height in x/y.\r\n     *\r\n     * We place into the output Vector2 the scaled width\r\n     * and height. If no `out` is specified, a new Vector2\r\n     * will be created for convenience (this should be avoided\r\n     * in tight loops).\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#getPointSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} vec - The position of the 3D Sprite.\r\n     * @param {Phaser.Math.Vector2} size - The x and y dimensions.\r\n     * @param {Phaser.Math.Vector2} out - The result, scaled x and y dimensions.\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getPointSize:function getPointSize(vec,size,out){if(out===undefined){out=new Vector2();}// TODO: optimize this with a simple distance calculation:\n// https://developer.valvesoftware.com/wiki/Field_of_View\nif(this.billboardMatrixDirty){this.updateBillboardMatrix();}var tmp=tmpVec3;var dx=size.x/this.pixelScale/2;var dy=size.y/this.pixelScale/2;tmp.set(-dx,-dy,0).transformMat4(billboardMatrix).add(vec);this.project(tmp,tmp);var tlx=tmp.x;var tly=tmp.y;tmp.set(dx,dy,0).transformMat4(billboardMatrix).add(vec);this.project(tmp,tmp);var brx=tmp.x;var bry=tmp.y;// var w = Math.abs(brx - tlx);\n// var h = Math.abs(bry - tly);\n//  Allow the projection to get negative ...\nvar w=brx-tlx;var h=bry-tly;return out.set(w,h);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.children.clear();this.scene=undefined;this.children=undefined;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */setX:function setX(value){this.position.x=value;return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */setY:function setY(value){this.position.y=value;return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */setZ:function setZ(value){this.position.z=value;return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Cameras.Sprite3D.Camera#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */x:{get:function get(){return this.position.x;},set:function set(value){this.position.x=value;this.update();}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Cameras.Sprite3D.Camera#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */y:{get:function get(){return this.position.y;},set:function set(value){this.position.y=value;this.update();}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Cameras.Sprite3D.Camera#z\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */z:{get:function get(){return this.position.z;},set:function set(value){this.position.z=value;this.update();}}});Camera.FAR_RANGE=1.0;Camera.NEAR_RANGE=0.0;module.exports=Camera;/***/},/* 162 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Given 3 separate color values this will return an integer representation of it.\r\n *\r\n * @function Phaser.Display.Color.GetColor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} red - The red color value. A number between 0 and 255.\r\n * @param {integer} green - The green color value. A number between 0 and 255.\r\n * @param {integer} blue - The blue color value. A number between 0 and 255.\r\n *\r\n * @return {number} The combined color value.\r\n */var GetColor=function GetColor(red,green,blue){return red<<16|green<<8|blue;};module.exports=GetColor;/***/},/* 163 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var HexStringToColor=__webpack_require__(347);var IntegerToColor=__webpack_require__(345);var ObjectToColor=__webpack_require__(343);var RGBStringToColor=__webpack_require__(342);/**\r\n * Converts the given source color value into an instance of a Color class.\r\n * The value can be either a string, prefixed with `rgb` or a hex string, a number or an Object.\r\n *\r\n * @function Phaser.Display.Color.ValueToColor\r\n * @since 3.0.0\r\n *\r\n * @param {(string|number|InputColorObject)} input - The source color value to convert.\r\n *\r\n * @return {Phaser.Display.Color} A Color object.\r\n */var ValueToColor=function ValueToColor(input){var t=typeof input==='undefined'?'undefined':_typeof(input);switch(t){case'string':if(input.substr(0,3).toLowerCase()==='rgb'){return RGBStringToColor(input);}else{return HexStringToColor(input);}case'number':return IntegerToColor(input);case'object':return ObjectToColor(input);}};module.exports=ValueToColor;/***/},/* 164 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var DegToRad=__webpack_require__(43);var Rectangle=__webpack_require__(10);var TransformMatrix=__webpack_require__(78);var ValueToColor=__webpack_require__(163);var Vector2=__webpack_require__(6);/**\r\n * @typedef {object} JSONCamera\r\n *\r\n * @property {string} name - The name of the camera\r\n * @property {number} x - The horizontal position of camera\r\n * @property {number} y - The vertical position of camera\r\n * @property {number} width - The width size of camera\r\n * @property {number} height - The height size of camera\r\n * @property {number} zoom - The zoom of camera\r\n * @property {number} rotation - The rotation of camera\r\n * @property {boolean} roundPixels - The round pixels st status of camera\r\n * @property {number} scrollX - The horizontal scroll of camera\r\n * @property {number} scrollY - The vertical scroll of camera\r\n * @property {string} backgroundColor - The background color of camera\r\n * @property {object} [bounds] - The bounds of camera\r\n * @property {number} [bounds.x] - The horizontal position of bounds of camera\r\n * @property {number} [bounds.y] - The vertical position of bounds of camera\r\n * @property {number} [bounds.width] - The width of the bounds of camera\r\n * @property {number} [bounds.height] - The height of the bounds of camera\r\n *//**\r\n * @callback Camera2DCallback\r\n *\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Camera\r\n * @memberOf Phaser.Cameras.Scene2D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} y - The y position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} width - The width of the Camera, in pixels.\r\n * @param {number} height - The height of the Camera, in pixels.\r\n */var Camera=new Class({initialize:function Camera(x,y,width,height){/**\r\n         * A reference to the Scene this camera belongs to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene;/**\r\n         * The name of the Camera. This is left empty for your own use.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.name='';/**\r\n         * The x position of the Camera, relative to the top-left of the game canvas.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * The y position of the Camera, relative to the top-left of the game canvas.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.y=y;/**\r\n         * The width of the Camera, in pixels.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=width;/**\r\n         * The height of the Camera, in pixels.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=height;/**\r\n         * Should this camera round its pixel values to integers?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#roundPixels\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.roundPixels=false;/**\r\n         * Is this Camera using a bounds to restrict scrolling movement?\r\n         * Set this property along with the bounds via `Camera.setBounds`.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#useBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.useBounds=false;/**\r\n         * The bounds the camera is restrained to during scrolling.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._bounds=new Rectangle();/**\r\n         * Does this Camera allow the Game Objects it renders to receive input events?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#inputEnabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.inputEnabled=true;/**\r\n         * The horizontal scroll position of this camera.\r\n         * Optionally restricted via the Camera bounds.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#scrollX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.scrollX=0;/**\r\n         * The vertical scroll position of this camera.\r\n         * Optionally restricted via the Camera bounds.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#scrollY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.scrollY=0;/**\r\n         * The Camera zoom value. Change this value to zoom in, or out of, a Scene.\r\n         * Set to 1 to return to the default zoom level.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#zoom\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.zoom=1;/**\r\n         * The rotation of the Camera. This influences the rendering of all Game Objects visible by this camera.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#rotation\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.rotation=0;/**\r\n         * A local transform matrix used for internal calculations.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#matrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.0.0\r\n         */this.matrix=new TransformMatrix(1,0,0,1,0,0);/**\r\n         * Does this Camera have a transparent background?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#transparent\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.transparent=true;/**\r\n         * TODO\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#clearBeforeRender\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.clearBeforeRender=true;/**\r\n         * The background color of this Camera. Only used if `transparent` is `false`.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#backgroundColor\r\n         * @type {Phaser.Display.Color}\r\n         * @since 3.0.0\r\n         */this.backgroundColor=ValueToColor('rgba(0,0,0,0)');/**\r\n         * Should the camera cull Game Objects before rendering?\r\n         * In some special cases it may be beneficial to disable this.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#disableCull\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.disableCull=false;/**\r\n         * A temporary array of culled objects.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#culledObjects\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.culledObjects=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_shakeDuration\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._shakeDuration=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_shakeIntensity\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._shakeIntensity=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_shakeOffsetX\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._shakeOffsetX=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_shakeOffsetY\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._shakeOffsetY=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_shakeCallback\r\n         * @type {?Camera2DCallback}\r\n         * @private\r\n         * @default null\r\n         * @since 3.3.0\r\n         */this._shakeCallback=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_fadeDuration\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._fadeDuration=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_fadeRed\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._fadeRed=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_fadeGreen\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._fadeGreen=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_fadeBlue\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._fadeBlue=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_fadeAlpha\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._fadeAlpha=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_fadeCallback\r\n         * @type {?Camera2DCallback}\r\n         * @private\r\n         * @default null\r\n         * @since 3.3.0\r\n         */this._fadeCallback=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_flashDuration\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._flashDuration=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_flashRed\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this._flashRed=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_flashGreen\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this._flashGreen=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_flashBlue\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this._flashBlue=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_flashAlpha\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._flashAlpha=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_flashCallback\r\n         * @type {?Camera2DCallback}\r\n         * @private\r\n         * @default null\r\n         * @since 3.3.0\r\n         */this._flashCallback=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_follow\r\n         * @type {?any}\r\n         * @private\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this._follow=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_id\r\n         * @type {integer}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._id=0;},scaleX:{get:function get(){return this.zoom;}},scaleY:{get:function get(){return this.zoom;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#centerToBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */centerToBounds:function centerToBounds(){this.scrollX=this._bounds.width*0.5-this.width*0.5;this.scrollY=this._bounds.height*0.5-this.height*0.5;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#centerToSize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */centerToSize:function centerToSize(){this.scrollX=this.width*0.5;this.scrollY=this.height*0.5;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#cull\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.GameObject[]} G - [renderableObjects,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} renderableObjects - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} [description]\r\n     */cull:function cull(renderableObjects){if(this.disableCull){return renderableObjects;}var cameraMatrix=this.matrix.matrix;var mva=cameraMatrix[0];var mvb=cameraMatrix[1];var mvc=cameraMatrix[2];var mvd=cameraMatrix[3];/* First Invert Matrix */var determinant=mva*mvd-mvb*mvc;if(!determinant){return renderableObjects;}var mve=cameraMatrix[4];var mvf=cameraMatrix[5];var scrollX=this.scrollX;var scrollY=this.scrollY;var cameraW=this.width;var cameraH=this.height;var culledObjects=this.culledObjects;var length=renderableObjects.length;determinant=1/determinant;culledObjects.length=0;for(var index=0;index<length;++index){var object=renderableObjects[index];if(!object.hasOwnProperty('width')||object.parentContainer){culledObjects.push(object);continue;}var objectW=object.width;var objectH=object.height;var objectX=object.x-scrollX*object.scrollFactorX-objectW*object.originX;var objectY=object.y-scrollY*object.scrollFactorY-objectH*object.originY;var tx=objectX*mva+objectY*mvc+mve;var ty=objectX*mvb+objectY*mvd+mvf;var tw=(objectX+objectW)*mva+(objectY+objectH)*mvc+mve;var th=(objectX+objectW)*mvb+(objectY+objectH)*mvd+mvf;var cullW=cameraW+objectW;var cullH=cameraH+objectH;if(tx>-objectW||ty>-objectH||tx<cullW||ty<cullH||tw>-objectW||th>-objectH||tw<cullW||th<cullH){culledObjects.push(object);}}return culledObjects;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#cullHitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.GameObject[]} G - [interactiveObjects,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} interactiveObjects - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} [description]\r\n     */cullHitTest:function cullHitTest(interactiveObjects){if(this.disableCull){return interactiveObjects;}var cameraMatrix=this.matrix.matrix;var mva=cameraMatrix[0];var mvb=cameraMatrix[1];var mvc=cameraMatrix[2];var mvd=cameraMatrix[3];/* First Invert Matrix */var determinant=mva*mvd-mvb*mvc;if(!determinant){return interactiveObjects;}var mve=cameraMatrix[4];var mvf=cameraMatrix[5];var scrollX=this.scrollX;var scrollY=this.scrollY;var cameraW=this.width;var cameraH=this.height;var length=interactiveObjects.length;determinant=1/determinant;var culledObjects=[];for(var index=0;index<length;++index){var object=interactiveObjects[index].gameObject;if(!object.hasOwnProperty('width')||object.parentContainer){culledObjects.push(interactiveObjects[index]);continue;}var objectW=object.width;var objectH=object.height;var objectX=object.x-scrollX*object.scrollFactorX-objectW*object.originX;var objectY=object.y-scrollY*object.scrollFactorY-objectH*object.originY;var tx=objectX*mva+objectY*mvc+mve;var ty=objectX*mvb+objectY*mvd+mvf;var tw=(objectX+objectW)*mva+(objectY+objectH)*mvc+mve;var th=(objectX+objectW)*mvb+(objectY+objectH)*mvd+mvf;var cullW=cameraW+objectW;var cullH=cameraH+objectH;if(tx>-objectW||ty>-objectH||tx<cullW||ty<cullH||tw>-objectW||th>-objectH||tw<cullW||th<cullH){culledObjects.push(interactiveObjects[index]);}}return culledObjects;},/**\r\n     * Fades the Camera in from the given color over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#fadeIn\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} duration - The duration of the effect in milliseconds.\r\n     * @param {function} [callback] - An optional callback to invoke when the fade completes. Will be sent one argument - a reference to this camera.\r\n     * @param {number} [red=0] - The value to fade the red channel from. A value between 0 and 1.\r\n     * @param {number} [green=0] - The value to fade the green channel from. A value between 0 and 1.\r\n     * @param {number} [blue=0] - The value to fade the blue channel from. A value between 0 and 1.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */fadeIn:function fadeIn(duration,callback,red,green,blue){if(red===undefined){red=0;}if(green===undefined){green=0;}if(blue===undefined){blue=0;}return this.flash(duration,red,green,blue,true,callback);},/**\r\n     * Fades the Camera out to the given color over the duration specified.\r\n     * This is an alias for Camera.fade that forces the fade to start, regardless of existing fades.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#fadeOut\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} duration - The duration of the effect in milliseconds.\r\n     * @param {function} [callback] - An optional callback to invoke when the fade completes. Will be sent one argument - a reference to this camera.\r\n     * @param {number} [red=0] - The value to fade the red channel from. A value between 0 and 1.\r\n     * @param {number} [green=0] - The value to fade the green channel from. A value between 0 and 1.\r\n     * @param {number} [blue=0] - The value to fade the blue channel from. A value between 0 and 1.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */fadeOut:function fadeOut(duration,callback,red,green,blue){if(red===undefined){red=0;}if(green===undefined){green=0;}if(blue===undefined){blue=0;}return this.fade(duration,red,green,blue,true,callback);},/**\r\n     * Fades the Camera to the given color over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#fade\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} duration - The duration of the effect in milliseconds.\r\n     * @param {number} [red=0] - The value to fade the red channel to. A value between 0 and 1.\r\n     * @param {number} [green=0] - The value to fade the green channel to. A value between 0 and 1.\r\n     * @param {number} [blue=0] - The value to fade the blue channel to. A value between 0 and 1.\r\n     * @param {boolean} [force=false] - Force the fade effect to start immediately, even if already running.\r\n     * @param {function} [callback] - An optional callback to invoke when the fade completes. Will be sent one argument - a reference to this camera.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */fade:function fade(duration,red,green,blue,force,callback){if(!duration){duration=Number.MIN_VALUE;}if(red===undefined){red=0;}if(green===undefined){green=0;}if(blue===undefined){blue=0;}if(force===undefined){force=false;}if(callback===undefined){callback=null;}if(!force&&this._fadeAlpha>0){return this;}this._fadeRed=red;this._fadeGreen=green;this._fadeBlue=blue;this._fadeCallback=callback;this._fadeDuration=duration;this._fadeAlpha=Number.MIN_VALUE;return this;},/**\r\n     * Flashes the Camera to the given color over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#flash\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} duration - The duration of the effect in milliseconds.\r\n     * @param {number} [red=1] - The value to flash the red channel to. A value between 0 and 1.\r\n     * @param {number} [green=1] - The value to flash the green channel to. A value between 0 and 1.\r\n     * @param {number} [blue=1] - The value to flash the blue channel to. A value between 0 and 1.\r\n     * @param {boolean} [force=false] - Force the flash effect to start immediately, even if already running.\r\n     * @param {function} [callback] - An optional callback to invoke when the flash completes. Will be sent one argument - a reference to this camera.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */flash:function flash(duration,red,green,blue,force,callback){if(!duration){duration=Number.MIN_VALUE;}if(red===undefined){red=1;}if(green===undefined){green=1;}if(blue===undefined){blue=1;}if(force===undefined){force=false;}if(callback===undefined){callback=null;}if(!force&&this._flashAlpha>0){return this;}this._flashRed=red;this._flashGreen=green;this._flashBlue=blue;this._flashCallback=callback;this._flashDuration=duration;this._flashAlpha=1;return this;},/**\r\n     * Shakes the Camera by the given intensity over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#shake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} duration - The duration of the effect in milliseconds.\r\n     * @param {number} [intensity=0.05] - The intensity of the shake.\r\n     * @param {boolean} [force=false] - Force the shake effect to start immediately, even if already running.\r\n     * @param {function} [callback] - An optional callback to invoke when the shake completes. Will be sent one argument - a reference to this camera.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */shake:function shake(duration,intensity,force,callback){if(!duration){duration=Number.MIN_VALUE;}if(intensity===undefined){intensity=0.05;}if(force===undefined){force=false;}if(callback===undefined){callback=null;}if(!force&&(this._shakeOffsetX!==0||this._shakeOffsetY!==0)){return this;}this._shakeDuration=duration;this._shakeIntensity=intensity;this._shakeOffsetX=0;this._shakeOffsetY=0;this._shakeCallback=callback;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#getWorldPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {(object|Phaser.Math.Vector2)} [output] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getWorldPoint:function getWorldPoint(x,y,output){if(output===undefined){output=new Vector2();}var cameraMatrix=this.matrix.matrix;var mva=cameraMatrix[0];var mvb=cameraMatrix[1];var mvc=cameraMatrix[2];var mvd=cameraMatrix[3];var mve=cameraMatrix[4];var mvf=cameraMatrix[5];/* First Invert Matrix */var determinant=mva*mvd-mvb*mvc;if(!determinant){output.x=x;output.y=y;return output;}determinant=1/determinant;var ima=mvd*determinant;var imb=-mvb*determinant;var imc=-mvc*determinant;var imd=mva*determinant;var ime=(mvc*mvf-mvd*mve)*determinant;var imf=(mvb*mve-mva*mvf)*determinant;var c=Math.cos(this.rotation);var s=Math.sin(this.rotation);var zoom=this.zoom;var scrollX=this.scrollX;var scrollY=this.scrollY;var sx=x+(scrollX*c-scrollY*s)*zoom;var sy=y+(scrollX*s+scrollY*c)*zoom;/* Apply transform to point */output.x=sx*ima+sy*imc+ime;output.y=sx*imb+sy*imd+imf;return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#ignore\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjectOrArray - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */ignore:function ignore(gameObjectOrArray){if(Array.isArray(gameObjectOrArray)){for(var index=0;index<gameObjectOrArray.length;++index){gameObjectOrArray[index].cameraFilter|=this._id;}}else{gameObjectOrArray.cameraFilter|=this._id;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#preRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} baseScale - [description]\r\n     * @param {number} resolution - [description]\r\n     *\r\n     */preRender:function preRender(baseScale,resolution){var width=this.width;var height=this.height;var zoom=this.zoom*baseScale;var matrix=this.matrix;var originX=width/2;var originY=height/2;var follow=this._follow;if(follow!==null){originX=follow.x;originY=follow.y;this.scrollX=(originX-width*0.5)/zoom;this.scrollY=(originY-height*0.5)/zoom;}if(this.useBounds){var bounds=this._bounds;var bw=Math.max(0,bounds.right-width);var bh=Math.max(0,bounds.bottom-height);if(this.scrollX<bounds.x){this.scrollX=bounds.x;}else if(this.scrollX>bw){this.scrollX=bw;}if(this.scrollY<bounds.y){this.scrollY=bounds.y;}else if(this.scrollY>bh){this.scrollY=bh;}}if(this.roundPixels){this.scrollX=Math.round(this.scrollX);this.scrollY=Math.round(this.scrollY);}matrix.loadIdentity();matrix.scale(resolution,resolution);matrix.translate(this.x+originX,this.y+originY);matrix.rotate(this.rotation);matrix.scale(zoom,zoom);matrix.translate(-originX,-originY);matrix.translate(this._shakeOffsetX,this._shakeOffsetY);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#removeBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */removeBounds:function removeBounds(){this.useBounds=false;this._bounds.setEmpty();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setAngle:function setAngle(value){if(value===undefined){value=0;}this.rotation=DegToRad(value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setBackgroundColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|InputColorObject)} [color='rgba(0,0,0,0)'] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setBackgroundColor:function setBackgroundColor(color){if(color===undefined){color='rgba(0,0,0,0)';}this.backgroundColor=ValueToColor(color);this.transparent=this.backgroundColor.alpha===0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setBounds:function setBounds(x,y,width,height){this._bounds.setTo(x,y,width,height);this.useBounds=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [value=''] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setName:function setName(value){if(value===undefined){value='';}this.name=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setPosition:function setPosition(x,y){if(y===undefined){y=x;}this.x=x;this.y=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setRotation:function setRotation(value){if(value===undefined){value=0;}this.rotation=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setRoundPixels\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setRoundPixels:function setRoundPixels(value){this.roundPixels=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setScene:function setScene(scene){this.scene=scene;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setScroll\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setScroll:function setScroll(x,y){if(y===undefined){y=x;}this.scrollX=x;this.scrollY=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} [height=width] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setSize:function setSize(width,height){if(height===undefined){height=width;}this.width=width;this.height=height;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setViewport\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setViewport:function setViewport(x,y,width,height){this.x=x;this.y=y;this.width=width;this.height=height;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setZoom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} [value=1] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */setZoom:function setZoom(value){if(value===undefined){value=1;}this.zoom=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#startFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|object)} target - [description]\r\n     * @param {boolean} [roundPx=false] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */startFollow:function startFollow(target,roundPx){if(roundPx===undefined){roundPx=false;}this._follow=target;this.roundPixels=roundPx;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#stopFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */stopFollow:function stopFollow(){this._follow=null;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONCamera} [description]\r\n     */toJSON:function toJSON(){var output={name:this.name,x:this.x,y:this.y,width:this.width,height:this.height,zoom:this.zoom,rotation:this.rotation,roundPixels:this.roundPixels,scrollX:this.scrollX,scrollY:this.scrollY,backgroundColor:this.backgroundColor.rgba};if(this.useBounds){output['bounds']={x:this._bounds.x,y:this._bounds.y,width:this._bounds.width,height:this._bounds.height};}return output;},/**\r\n     * Resets any active FX, such as a fade, flash or shake. Useful to call after a fade in order to\r\n     * remove the fade.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#resetFX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */resetFX:function resetFX(){this._flashAlpha=0;this._fadeAlpha=0;this._shakeOffsetX=0;this._shakeOffsetY=0;this._shakeDuration=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */update:function update(time,delta){if(this._flashAlpha>0){this._flashAlpha-=delta/this._flashDuration;if(this._flashAlpha<=0){this._flashAlpha=0;if(this._flashCallback){//  Do this in case the callback flashes again (otherwise we'd overwrite the new callback)\nvar flashCallback=this._flashCallback;this._flashCallback=null;flashCallback(this);}}}if(this._fadeAlpha>0&&this._fadeAlpha<1){this._fadeAlpha+=delta/this._fadeDuration;if(this._fadeAlpha>=1){this._fadeAlpha=1;if(this._fadeCallback){//  Do this in case the callback fades again (otherwise we'd overwrite the new callback)\nvar fadeCallback=this._fadeCallback;this._fadeCallback=null;fadeCallback(this);}}}if(this._shakeDuration>0){var intensity=this._shakeIntensity;this._shakeDuration-=delta;if(this._shakeDuration<=0){this._shakeOffsetX=0;this._shakeOffsetY=0;if(this._shakeCallback){//  Do this in case the callback shakes again (otherwise we'd overwrite the new callback)\nvar shakeCallback=this._shakeCallback;this._shakeCallback=null;shakeCallback(this);}}else{this._shakeOffsetX=(Math.random()*intensity*this.width*2-intensity*this.width)*this.zoom;this._shakeOffsetY=(Math.random()*intensity*this.height*2-intensity*this.height)*this.zoom;if(this.roundPixels){this._shakeOffsetX|=0;this._shakeOffsetY|=0;}}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this._bounds=undefined;this.matrix=undefined;this.culledObjects=[];this.scene=undefined;}});module.exports=Camera;/***/},/* 165 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Takes the given string and pads it out, to the length required, using the character\r\n * specified. For example if you need a string to be 6 characters long, you can call:\r\n *\r\n * `pad('bob', 6, '-', 2)`\r\n *\r\n * This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.\r\n *\r\n * You can also use it to pad numbers (they are always returned as strings):\r\n * \r\n * `pad(512, 6, '0', 1)`\r\n *\r\n * Would return: `000512` with the string padded to the left.\r\n *\r\n * If you don't specify a direction it'll pad to both sides:\r\n * \r\n * `pad('c64', 7, '*')`\r\n *\r\n * Would return: `**c64**`\r\n *\r\n * @function Phaser.Utils.String.Pad\r\n * @since 3.0.0\r\n *\r\n * @param {string} str - The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.\r\n * @param {integer} [len=0] - The number of characters to be added.\r\n * @param {string} [pad=\" \"] - The string to pad it out with (defaults to a space).\r\n * @param {integer} [dir=3] - The direction dir = 1 (left), 2 (right), 3 (both).\r\n * \r\n * @return {string} The padded string.\r\n */var Pad=function Pad(str,len,pad,dir){if(len===undefined){len=0;}if(pad===undefined){pad=' ';}if(dir===undefined){dir=3;}str=str.toString();var padlen=0;if(len+1>=str.length){switch(dir){case 1:str=new Array(len+1-str.length).join(pad)+str;break;case 3:var right=Math.ceil((padlen=len-str.length)/2);var left=padlen-right;str=new Array(left+1).join(pad)+str+new Array(right+1).join(pad);break;default:str=str+new Array(len+1-str.length).join(pad);break;}}return str;};module.exports=Pad;/***/},/* 166 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @callback EachMapCallback\r\n * @generic E - [entry]\r\n *\r\n * @param {string} key - [description]\r\n * @param {*} entry - [description]\r\n *\r\n * @return {?boolean} [description]\r\n *//**\r\n * @classdesc\r\n * The keys of a Map can be arbitrary values.\r\n * var map = new Map([\r\n *    [ 1, 'one' ],\r\n *    [ 2, 'two' ],\r\n *    [ 3, 'three' ]\r\n * ]);\r\n *\r\n * @class Map\r\n * @memberOf Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic K\r\n * @generic V\r\n * @genericUse {V[]} - [elements]\r\n *\r\n * @param {Array.<*>} elements - [description]\r\n */var Map=new Class({initialize:function Map(elements){/**\r\n         * [description]\r\n         *\r\n         * @genericUse {Object.<string, V>} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Map#entries\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */this.entries={};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Structs.Map#size\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.size=0;if(Array.isArray(elements)){for(var i=0;i<elements.length;i++){this.set(elements[i][0],elements[i][1]);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {V} - [value]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {*} value - [description]\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */set:function set(key,value){if(!this.has(key)){this.entries[key]=value;this.size++;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {V} - [$return]\r\n     *\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {*} [description]\r\n     */get:function get(key){if(this.has(key)){return this.entries[key];}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} [description]\r\n     */getArray:function getArray(){var output=[];var entries=this.entries;for(var key in entries){output.push(entries[key]);}return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#has\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     *\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */has:function has(key){return this.entries.hasOwnProperty(key);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */delete:function _delete(key){if(this.has(key)){delete this.entries[key];this.size--;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */clear:function clear(){Object.keys(this.entries).forEach(function(prop){delete this.entries[prop];},this);this.size=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#keys\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K[]} - [$return]\r\n     *\r\n     * @return {string[]} [description]\r\n     */keys:function keys(){return Object.keys(this.entries);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#values\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} [description]\r\n     */values:function values(){var output=[];var entries=this.entries;for(var key in entries){output.push(entries[key]);}return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#dump\r\n     * @since 3.0.0\r\n     */dump:function dump(){var entries=this.entries;// eslint-disable-next-line no-console\nconsole.group('Map');for(var key in entries){console.log(key,entries[key]);}// eslint-disable-next-line no-console\nconsole.groupEnd();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachMapCallback.<V>} - [callback]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {EachMapCallback} callback - [description]\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */each:function each(callback){var entries=this.entries;for(var key in entries){if(callback(key,entries[key])===false){break;}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.Map#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V} - [value]\r\n     *\r\n     * @param {*} value - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */contains:function contains(value){var entries=this.entries;for(var key in entries){if(entries[key]===value){return true;}}return false;},/**\r\n     * Merges all new keys from the given Map into this one\r\n     * If it encounters a key that already exists it will be skipped\r\n     * unless override = true.\r\n     *\r\n     * @method Phaser.Structs.Map#merge\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [map,$return]\r\n     *\r\n     * @param {Phaser.Structs.Map} map - [description]\r\n     * @param {boolean} [override=false] - [description]\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */merge:function merge(map,override){if(override===undefined){override=false;}var local=this.entries;var source=map.entries;for(var key in source){if(local.hasOwnProperty(key)&&override){local[key]=source[key];}else{this.set(key,source[key]);}}return this;}});module.exports=Map;/***/},/* 167 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.RotateAroundDistance\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The Point to be rotated.\r\n * @param {number} x - The horizontal coordinate to rotate around.\r\n * @param {number} y - The vertical coordinate to rotate around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n * @param {number} distance - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var RotateAroundDistance=function RotateAroundDistance(point,x,y,angle,distance){var t=angle+Math.atan2(point.y-y,point.x-x);point.x=x+distance*Math.cos(t);point.y=y+distance*Math.sin(t);return point;};module.exports=RotateAroundDistance;/***/},/* 168 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Random\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Point} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Random=function Random(triangle,out){if(out===undefined){out=new Point();}//  Basis vectors\nvar ux=triangle.x2-triangle.x1;var uy=triangle.y2-triangle.y1;var vx=triangle.x3-triangle.x1;var vy=triangle.y3-triangle.y1;//  Random point within the unit square\nvar r=Math.random();var s=Math.random();//  Point outside the triangle? Remap it.\nif(r+s>=1){r=1-r;s=1-s;}out.x=triangle.x1+(ux*r+vx*s);out.y=triangle.y1+(uy*r+vy*s);return out;};module.exports=Random;/***/},/* 169 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * Returns a uniformly distributed random point from anywhere within the given Ellipse.\r\n *\r\n * @function Phaser.Geom.Ellipse.Random\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get a random point from.\r\n * @param {(Phaser.Geom.Point|object)} [out] - A Point or point-like object to set the random `x` and `y` values in.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\r\n */var Random=function Random(ellipse,out){if(out===undefined){out=new Point();}var p=Math.random()*Math.PI*2;var s=Math.sqrt(Math.random());out.x=ellipse.x+s*Math.cos(p)*ellipse.width/2;out.y=ellipse.y+s*Math.sin(p)*ellipse.height/2;return out;};module.exports=Random;/***/},/* 170 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Random\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {Phaser.Geom.Point} out - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Random=function Random(rect,out){if(out===undefined){out=new Point();}out.x=rect.x+Math.random()*rect.width;out.y=rect.y+Math.random()*rect.height;return out;};module.exports=Random;/***/},/* 171 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Random\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var Random=function Random(line,out){if(out===undefined){out=new Point();}var t=Math.random();out.x=line.x1+t*(line.x2-line.x1);out.y=line.y1+t*(line.y2-line.y1);return out;};module.exports=Random;/***/},/* 172 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Length=__webpack_require__(79);var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {integer} quantity - [description]\r\n * @param {integer} [stepRate] - [description]\r\n * @param {(array|Phaser.Geom.Point[])} [out] - [description]\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} [description]\r\n */var GetPoints=function GetPoints(line,quantity,stepRate,out){if(out===undefined){out=[];}//  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\nif(!quantity){quantity=Length(line)/stepRate;}var x1=line.x1;var y1=line.y1;var x2=line.x2;var y2=line.y2;for(var i=0;i<quantity;i++){var position=i/quantity;var x=x1+(x2-x1)*position;var y=y1+(y2-y1)*position;out.push(new Point(x,y));}return out;};module.exports=GetPoints;/***/},/* 173 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Perimeter=__webpack_require__(109);var Point=__webpack_require__(4);/**\r\n * Position is a value between 0 and 1 where 0 = the top-left of the rectangle and 0.5 = the bottom right.\r\n *\r\n * @function Phaser.Geom.Rectangle.GetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectangle - [description]\r\n * @param {float} position - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var GetPoint=function GetPoint(rectangle,position,out){if(out===undefined){out=new Point();}if(position<=0||position>=1){out.x=rectangle.x;out.y=rectangle.y;return out;}var p=Perimeter(rectangle)*position;if(position>0.5){p-=rectangle.width+rectangle.height;if(p<=rectangle.width){//  Face 3\nout.x=rectangle.right-p;out.y=rectangle.bottom;}else{//  Face 4\nout.x=rectangle.x;out.y=rectangle.bottom-(p-rectangle.width);}}else if(p<=rectangle.width){//  Face 1\nout.x=rectangle.x+p;out.y=rectangle.y;}else{//  Face 2\nout.x=rectangle.right;out.y=rectangle.y+(p-rectangle.width);}return out;};module.exports=GetPoint;/***/},/* 174 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * Returns a uniformly distributed random point from anywhere within the given Circle.\r\n *\r\n * @function Phaser.Geom.Circle.Random\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get a random point from.\r\n * @param {(Phaser.Geom.Point|object)} [out] - A Point or point-like object to set the random `x` and `y` values in.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\r\n */var Random=function Random(circle,out){if(out===undefined){out=new Point();}var t=2*Math.PI*Math.random();var u=Math.random()+Math.random();var r=u>1?2-u:u;var x=r*Math.cos(t);var y=r*Math.sin(t);out.x=circle.x+x*circle.radius;out.y=circle.y+y*circle.radius;return out;};module.exports=Random;/***/},/* 175 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.\r\n *\r\n * @function Phaser.Geom.Circle.CircumferencePoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference point on.\r\n * @param {number} angle - The angle from the center of the Circle to the circumference to return the point from. Given in radians.\r\n * @param {(Phaser.Geom.Point|object)} [out] - A Point, or point-like object, to store the results in. If not given a Point will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object where the `x` and `y` properties are the point on the circumference.\r\n */var CircumferencePoint=function CircumferencePoint(circle,angle,out){if(out===undefined){out=new Point();}out.x=circle.x+circle.radius*Math.cos(angle);out.y=circle.y+circle.radius*Math.sin(angle);return out;};module.exports=CircumferencePoint;/***/},/* 176 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ALIGN_CONST={/**\r\n    * A constant representing a top-left alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.TOP_LEFT\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */TOP_LEFT:0,/**\r\n    * A constant representing a top-center alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.TOP_CENTER\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */TOP_CENTER:1,/**\r\n    * A constant representing a top-right alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.TOP_RIGHT\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */TOP_RIGHT:2,/**\r\n    * A constant representing a left-top alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.LEFT_TOP\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */LEFT_TOP:3,/**\r\n    * A constant representing a left-center alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.LEFT_CENTER\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */LEFT_CENTER:4,/**\r\n    * A constant representing a left-bottom alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.LEFT_BOTTOM\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */LEFT_BOTTOM:5,/**\r\n    * A constant representing a center alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.CENTER\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */CENTER:6,/**\r\n    * A constant representing a right-top alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.RIGHT_TOP\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */RIGHT_TOP:7,/**\r\n    * A constant representing a right-center alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.RIGHT_CENTER\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */RIGHT_CENTER:8,/**\r\n    * A constant representing a right-bottom alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.RIGHT_BOTTOM\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */RIGHT_BOTTOM:9,/**\r\n    * A constant representing a bottom-left alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.BOTTOM_LEFT\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */BOTTOM_LEFT:10,/**\r\n    * A constant representing a bottom-center alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.BOTTOM_CENTER\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */BOTTOM_CENTER:11,/**\r\n    * A constant representing a bottom-right alignment or position.\r\n    * @constant\r\n    * @name Phaser.Display.Align.BOTTOM_RIGHT\r\n    * @since 3.0.0\r\n    * @type {integer}\r\n    */BOTTOM_RIGHT:12};module.exports=ALIGN_CONST;/***/},/* 177 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\r\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\r\n* The stiffness of constraints can be modified to create springs or elastic.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Constraint\r\n*/var Constraint={};module.exports=Constraint;var Vertices=__webpack_require__(93);var Vector=__webpack_require__(83);var Sleeping=__webpack_require__(203);var Bounds=__webpack_require__(92);var Axes=__webpack_require__(470);var Common=__webpack_require__(37);(function(){Constraint._warming=0.4;Constraint._torqueDampen=1;Constraint._minLength=0.000001;/**\r\n     * Creates a new constraint.\r\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\r\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {} options\r\n     * @return {constraint} constraint\r\n     */Constraint.create=function(options){var constraint=options;// if bodies defined but no points, use body centre\nif(constraint.bodyA&&!constraint.pointA)constraint.pointA={x:0,y:0};if(constraint.bodyB&&!constraint.pointB)constraint.pointB={x:0,y:0};// calculate static length using initial world space points\nvar initialPointA=constraint.bodyA?Vector.add(constraint.bodyA.position,constraint.pointA):constraint.pointA,initialPointB=constraint.bodyB?Vector.add(constraint.bodyB.position,constraint.pointB):constraint.pointB,length=Vector.magnitude(Vector.sub(initialPointA,initialPointB));constraint.length=typeof constraint.length!=='undefined'?constraint.length:length;// option defaults\nconstraint.id=constraint.id||Common.nextId();constraint.label=constraint.label||'Constraint';constraint.type='constraint';constraint.stiffness=constraint.stiffness||(constraint.length>0?1:0.7);constraint.damping=constraint.damping||0;constraint.angularStiffness=constraint.angularStiffness||0;constraint.angleA=constraint.bodyA?constraint.bodyA.angle:constraint.angleA;constraint.angleB=constraint.bodyB?constraint.bodyB.angle:constraint.angleB;constraint.plugin={};// render\nvar render={visible:true,lineWidth:2,strokeStyle:'#ffffff',type:'line',anchors:true};if(constraint.length===0&&constraint.stiffness>0.1){render.type='pin';render.anchors=false;}else if(constraint.stiffness<0.9){render.type='spring';}constraint.render=Common.extend(render,constraint.render);return constraint;};/**\r\n     * Prepares for solving by constraint warming.\r\n     * @private\r\n     * @method preSolveAll\r\n     * @param {body[]} bodies\r\n     */Constraint.preSolveAll=function(bodies){for(var i=0;i<bodies.length;i+=1){var body=bodies[i],impulse=body.constraintImpulse;if(body.isStatic||impulse.x===0&&impulse.y===0&&impulse.angle===0){continue;}body.position.x+=impulse.x;body.position.y+=impulse.y;body.angle+=impulse.angle;}};/**\r\n     * Solves all constraints in a list of collisions.\r\n     * @private\r\n     * @method solveAll\r\n     * @param {constraint[]} constraints\r\n     * @param {number} timeScale\r\n     */Constraint.solveAll=function(constraints,timeScale){// Solve fixed constraints first.\nfor(var i=0;i<constraints.length;i+=1){var constraint=constraints[i],fixedA=!constraint.bodyA||constraint.bodyA&&constraint.bodyA.isStatic,fixedB=!constraint.bodyB||constraint.bodyB&&constraint.bodyB.isStatic;if(fixedA||fixedB){Constraint.solve(constraints[i],timeScale);}}// Solve free constraints last.\nfor(i=0;i<constraints.length;i+=1){constraint=constraints[i];fixedA=!constraint.bodyA||constraint.bodyA&&constraint.bodyA.isStatic;fixedB=!constraint.bodyB||constraint.bodyB&&constraint.bodyB.isStatic;if(!fixedA&&!fixedB){Constraint.solve(constraints[i],timeScale);}}};/**\r\n     * Solves a distance constraint with Gauss-Siedel method.\r\n     * @private\r\n     * @method solve\r\n     * @param {constraint} constraint\r\n     * @param {number} timeScale\r\n     */Constraint.solve=function(constraint,timeScale){var bodyA=constraint.bodyA,bodyB=constraint.bodyB,pointA=constraint.pointA,pointB=constraint.pointB;if(!bodyA&&!bodyB)return;// update reference angle\nif(bodyA&&!bodyA.isStatic){Vector.rotate(pointA,bodyA.angle-constraint.angleA,pointA);constraint.angleA=bodyA.angle;}// update reference angle\nif(bodyB&&!bodyB.isStatic){Vector.rotate(pointB,bodyB.angle-constraint.angleB,pointB);constraint.angleB=bodyB.angle;}var pointAWorld=pointA,pointBWorld=pointB;if(bodyA)pointAWorld=Vector.add(bodyA.position,pointA);if(bodyB)pointBWorld=Vector.add(bodyB.position,pointB);if(!pointAWorld||!pointBWorld)return;var delta=Vector.sub(pointAWorld,pointBWorld),currentLength=Vector.magnitude(delta);// prevent singularity\nif(currentLength<Constraint._minLength){currentLength=Constraint._minLength;}// solve distance constraint with Gauss-Siedel method\nvar difference=(currentLength-constraint.length)/currentLength,stiffness=constraint.stiffness<1?constraint.stiffness*timeScale:constraint.stiffness,force=Vector.mult(delta,difference*stiffness),massTotal=(bodyA?bodyA.inverseMass:0)+(bodyB?bodyB.inverseMass:0),inertiaTotal=(bodyA?bodyA.inverseInertia:0)+(bodyB?bodyB.inverseInertia:0),resistanceTotal=massTotal+inertiaTotal,torque,share,normal,normalVelocity,relativeVelocity;if(constraint.damping){var zero=Vector.create();normal=Vector.div(delta,currentLength);relativeVelocity=Vector.sub(bodyB&&Vector.sub(bodyB.position,bodyB.positionPrev)||zero,bodyA&&Vector.sub(bodyA.position,bodyA.positionPrev)||zero);normalVelocity=Vector.dot(normal,relativeVelocity);}if(bodyA&&!bodyA.isStatic){share=bodyA.inverseMass/massTotal;// keep track of applied impulses for post solving\nbodyA.constraintImpulse.x-=force.x*share;bodyA.constraintImpulse.y-=force.y*share;// apply forces\nbodyA.position.x-=force.x*share;bodyA.position.y-=force.y*share;// apply damping\nif(constraint.damping){bodyA.positionPrev.x-=constraint.damping*normal.x*normalVelocity*share;bodyA.positionPrev.y-=constraint.damping*normal.y*normalVelocity*share;}// apply torque\ntorque=Vector.cross(pointA,force)/resistanceTotal*Constraint._torqueDampen*bodyA.inverseInertia*(1-constraint.angularStiffness);bodyA.constraintImpulse.angle-=torque;bodyA.angle-=torque;}if(bodyB&&!bodyB.isStatic){share=bodyB.inverseMass/massTotal;// keep track of applied impulses for post solving\nbodyB.constraintImpulse.x+=force.x*share;bodyB.constraintImpulse.y+=force.y*share;// apply forces\nbodyB.position.x+=force.x*share;bodyB.position.y+=force.y*share;// apply damping\nif(constraint.damping){bodyB.positionPrev.x+=constraint.damping*normal.x*normalVelocity*share;bodyB.positionPrev.y+=constraint.damping*normal.y*normalVelocity*share;}// apply torque\ntorque=Vector.cross(pointB,force)/resistanceTotal*Constraint._torqueDampen*bodyB.inverseInertia*(1-constraint.angularStiffness);bodyB.constraintImpulse.angle+=torque;bodyB.angle+=torque;}};/**\r\n     * Performs body updates required after solving constraints.\r\n     * @private\r\n     * @method postSolveAll\r\n     * @param {body[]} bodies\r\n     */Constraint.postSolveAll=function(bodies){for(var i=0;i<bodies.length;i++){var body=bodies[i],impulse=body.constraintImpulse;if(body.isStatic||impulse.x===0&&impulse.y===0&&impulse.angle===0){continue;}Sleeping.set(body,false);// update geometry and reset\nfor(var j=0;j<body.parts.length;j++){var part=body.parts[j];Vertices.translate(part.vertices,impulse);if(j>0){part.position.x+=impulse.x;part.position.y+=impulse.y;}if(impulse.angle!==0){Vertices.rotate(part.vertices,impulse.angle,body.position);Axes.rotate(part.axes,impulse.angle);if(j>0){Vector.rotateAbout(part.position,impulse.angle,body.position,part.position);}}Bounds.update(part.bounds,part.vertices,body.velocity);}// dampen the cached impulse for warming next step\nimpulse.angle*=Constraint._warming;impulse.x*=Constraint._warming;impulse.y*=Constraint._warming;}};/*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    *//**\r\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\r\n     *\r\n     * @property id\r\n     * @type number\r\n     *//**\r\n     * A `String` denoting the type of object.\r\n     *\r\n     * @property type\r\n     * @type string\r\n     * @default \"constraint\"\r\n     * @readOnly\r\n     *//**\r\n     * An arbitrary `String` name to help the user identify and manage bodies.\r\n     *\r\n     * @property label\r\n     * @type string\r\n     * @default \"Constraint\"\r\n     *//**\r\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\r\n     *\r\n     * @property render\r\n     * @type object\r\n     *//**\r\n     * A flag that indicates if the constraint should be rendered.\r\n     *\r\n     * @property render.visible\r\n     * @type boolean\r\n     * @default true\r\n     *//**\r\n     * A `Number` that defines the line width to use when rendering the constraint outline.\r\n     * A value of `0` means no outline will be rendered.\r\n     *\r\n     * @property render.lineWidth\r\n     * @type number\r\n     * @default 2\r\n     *//**\r\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\r\n     * It is the same as when using a canvas, so it accepts CSS style property values.\r\n     *\r\n     * @property render.strokeStyle\r\n     * @type string\r\n     * @default a random colour\r\n     *//**\r\n     * A `String` that defines the constraint rendering type. \r\n     * The possible values are 'line', 'pin', 'spring'.\r\n     * An appropriate render type will be automatically chosen unless one is given in options.\r\n     *\r\n     * @property render.type\r\n     * @type string\r\n     * @default 'line'\r\n     *//**\r\n     * A `Boolean` that defines if the constraint's anchor points should be rendered.\r\n     *\r\n     * @property render.anchors\r\n     * @type boolean\r\n     * @default true\r\n     *//**\r\n     * The first possible `Body` that this constraint is attached to.\r\n     *\r\n     * @property bodyA\r\n     * @type body\r\n     * @default null\r\n     *//**\r\n     * The second possible `Body` that this constraint is attached to.\r\n     *\r\n     * @property bodyB\r\n     * @type body\r\n     * @default null\r\n     *//**\r\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\r\n     *\r\n     * @property pointA\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     *//**\r\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\r\n     *\r\n     * @property pointB\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     *//**\r\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\r\n     * A value of `1` means the constraint should be very stiff.\r\n     * A value of `0.2` means the constraint acts like a soft spring.\r\n     *\r\n     * @property stiffness\r\n     * @type number\r\n     * @default 1\r\n     *//**\r\n     * A `Number` that specifies the damping of the constraint, \r\n     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\r\n     * Damping will only be apparent when the constraint also has a very low `stiffness`.\r\n     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\r\n     * A value of `0` means the constraint will apply no damping.\r\n     *\r\n     * @property damping\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * A `Number` that specifies the target resting length of the constraint. \r\n     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\r\n     *\r\n     * @property length\r\n     * @type number\r\n     *//**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */})();/***/},/* 178 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Events` module contains methods to fire and listen to events on other objects.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Events\r\n*/var Events={};module.exports=Events;var Common=__webpack_require__(37);(function(){/**\r\n     * Subscribes a callback function to the given object's `eventName`.\r\n     * @method on\r\n     * @param {} object\r\n     * @param {string} eventNames\r\n     * @param {function} callback\r\n     */Events.on=function(object,eventNames,callback){var names=eventNames.split(' '),name;for(var i=0;i<names.length;i++){name=names[i];object.events=object.events||{};object.events[name]=object.events[name]||[];object.events[name].push(callback);}return callback;};/**\r\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\r\n     * @method off\r\n     * @param {} object\r\n     * @param {string} eventNames\r\n     * @param {function} callback\r\n     */Events.off=function(object,eventNames,callback){if(!eventNames){object.events={};return;}// handle Events.off(object, callback)\nif(typeof eventNames==='function'){callback=eventNames;eventNames=Common.keys(object.events).join(' ');}var names=eventNames.split(' ');for(var i=0;i<names.length;i++){var callbacks=object.events[names[i]],newCallbacks=[];if(callback&&callbacks){for(var j=0;j<callbacks.length;j++){if(callbacks[j]!==callback)newCallbacks.push(callbacks[j]);}}object.events[names[i]]=newCallbacks;}};/**\r\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\r\n     * @method trigger\r\n     * @param {} object\r\n     * @param {string} eventNames\r\n     * @param {} event\r\n     */Events.trigger=function(object,eventNames,event){var names,name,callbacks,eventClone;if(object.events){if(!event)event={};names=eventNames.split(' ');for(var i=0;i<names.length;i++){name=names[i];callbacks=object.events[name];if(callbacks){eventClone=Common.clone(event,false);eventClone.name=name;eventClone.source=object;for(var j=0;j<callbacks.length;j++){callbacks[j].apply(object,[eventClone]);}}}}};})();/***/},/* 179 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var ModelViewProjection=__webpack_require__(312);var ShaderSourceFS=__webpack_require__(839);var ShaderSourceVS=__webpack_require__(838);var Utils=__webpack_require__(38);var WebGLPipeline=__webpack_require__(111);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TextureTintPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberOf Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n */var TextureTintPipeline=new Class({Extends:WebGLPipeline,Mixins:[ModelViewProjection],initialize:function TextureTintPipeline(config){WebGLPipeline.call(this,{game:config.game,renderer:config.renderer,gl:config.renderer.gl,topology:config.topology?config.topology:config.renderer.gl.TRIANGLES,vertShader:config.vertShader?config.vertShader:ShaderSourceVS,fragShader:config.fragShader?config.fragShader:ShaderSourceFS,vertexCapacity:config.vertexCapacity?config.vertexCapacity:6*2000,vertexSize:config.vertexSize?config.vertexSize:Float32Array.BYTES_PER_ELEMENT*2+Float32Array.BYTES_PER_ELEMENT*2+Uint8Array.BYTES_PER_ELEMENT*4,attributes:[{name:'inPosition',size:2,type:config.renderer.gl.FLOAT,normalized:false,offset:0},{name:'inTexCoord',size:2,type:config.renderer.gl.FLOAT,normalized:false,offset:Float32Array.BYTES_PER_ELEMENT*2},{name:'inTint',size:4,type:config.renderer.gl.UNSIGNED_BYTE,normalized:true,offset:Float32Array.BYTES_PER_ELEMENT*4}]});/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.TextureTintPipeline#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.vertexViewF32=new Float32Array(this.vertexData);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.TextureTintPipeline#vertexViewU32\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */this.vertexViewU32=new Uint32Array(this.vertexData);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.TextureTintPipeline#maxQuads\r\n         * @type {integer}\r\n         * @default 2000\r\n         * @since 3.0.0\r\n         */this.maxQuads=2000;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.TextureTintPipeline#batches\r\n         * @type {array}\r\n         * @since 3.1.0\r\n         */this.batches=[];this.mvpInit();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#setTexture2D\r\n     * @since 3.1.0\r\n     *\r\n     * @param {WebGLTexture} texture - [description]\r\n     * @param {integer} textureUnit - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.TextureTintPipeline} [description]\r\n     */setTexture2D:function setTexture2D(texture,unit){if(!texture){return this;}var batches=this.batches;if(batches.length===0){this.pushBatch();}var batch=batches[batches.length-1];if(unit>0){if(batch.textures[unit-1]&&batch.textures[unit-1]!==texture){this.pushBatch();}batches[batches.length-1].textures[unit-1]=texture;}else{if(batch.texture!==null&&batch.texture!==texture){this.pushBatch();}batches[batches.length-1].texture=texture;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#pushBatch\r\n     * @since 3.1.0\r\n     */pushBatch:function pushBatch(){var batch={first:this.vertexCount,texture:null,textures:[]};this.batches.push(batch);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#flush\r\n     * @since 3.1.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.TextureTintPipeline} This Pipeline.\r\n     */flush:function flush(){if(this.flushLocked){return this;}this.flushLocked=true;var gl=this.gl;var renderer=this.renderer;var vertexCount=this.vertexCount;var topology=this.topology;var vertexSize=this.vertexSize;var batches=this.batches;var batchCount=batches.length;var batchVertexCount=0;var batch=null;var batchNext;var textureIndex;var nTexture;if(batchCount===0||vertexCount===0){this.flushLocked=false;return this;}gl.bufferSubData(gl.ARRAY_BUFFER,0,this.bytes.subarray(0,vertexCount*vertexSize));for(var index=0;index<batches.length-1;++index){batch=batches[index];batchNext=batches[index+1];if(batch.textures.length>0){for(textureIndex=0;textureIndex<batch.textures.length;++textureIndex){nTexture=batch.textures[textureIndex];if(nTexture){renderer.setTexture2D(nTexture,1+textureIndex);}}gl.activeTexture(gl.TEXTURE0);}batchVertexCount=batchNext.first-batch.first;if(batch.texture===null||batchVertexCount<=0){continue;}renderer.setTexture2D(batch.texture,0);gl.drawArrays(topology,batch.first,batchVertexCount);}// Left over data\nbatch=batches[batches.length-1];if(batch.textures.length>0){for(textureIndex=0;textureIndex<batch.textures.length;++textureIndex){nTexture=batch.textures[textureIndex];if(nTexture){renderer.setTexture2D(nTexture,1+textureIndex);}}gl.activeTexture(gl.TEXTURE0);}batchVertexCount=vertexCount-batch.first;if(batch.texture&&batchVertexCount>0){renderer.setTexture2D(batch.texture,0);gl.drawArrays(topology,batch.first,batchVertexCount);}this.vertexCount=0;batches.length=0;this.pushBatch();this.flushLocked=false;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#onBind\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.TextureTintPipeline} [description]\r\n     */onBind:function onBind(){WebGLPipeline.prototype.onBind.call(this);this.mvpUpdate();if(this.batches.length===0){this.pushBatch();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} resolution - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.TextureTintPipeline} [description]\r\n     */resize:function resize(width,height,resolution){WebGLPipeline.prototype.resize.call(this,width,height,resolution);this.projOrtho(0,this.width,this.height,0,-1000.0,1000.0);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#drawStaticTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.StaticTilemapLayer} tilemap - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */drawStaticTilemapLayer:function drawStaticTilemapLayer(tilemap){if(tilemap.vertexCount>0){var pipelineVertexBuffer=this.vertexBuffer;var gl=this.gl;var renderer=this.renderer;var frame=tilemap.tileset.image.get();if(renderer.currentPipeline&&renderer.currentPipeline.vertexCount>0){renderer.flush();}this.vertexBuffer=tilemap.vertexBuffer;renderer.setPipeline(this);renderer.setTexture2D(frame.source.glTexture,0);gl.drawArrays(this.topology,0,tilemap.vertexCount);this.vertexBuffer=pipelineVertexBuffer;}this.viewIdentity();this.modelIdentity();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#drawEmitterManager\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */drawEmitterManager:function drawEmitterManager(emitterManager,camera,parentTransformMatrix){var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}this.renderer.setPipeline(this);var roundPixels=this.renderer.config.roundPixels;var emitters=emitterManager.emitters.list;var emitterCount=emitters.length;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var renderer=this.renderer;var maxQuads=this.maxQuads;var cameraScrollX=camera.scrollX;var cameraScrollY=camera.scrollY;var cameraMatrix=camera.matrix.matrix;var cma=cameraMatrix[0];var cmb=cameraMatrix[1];var cmc=cameraMatrix[2];var cmd=cameraMatrix[3];var cme=cameraMatrix[4];var cmf=cameraMatrix[5];var sin=Math.sin;var cos=Math.cos;var vertexComponentCount=this.vertexComponentCount;var vertexCapacity=this.vertexCapacity;var texture=emitterManager.defaultFrame.source.glTexture;var pca,pcb,pcc,pcd,pce,pcf;if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];pca=cma*pma+cmb*pmc;pcb=cma*pmb+cmb*pmd;pcc=cmc*pma+cmd*pmc;pcd=cmc*pmb+cmd*pmd;pce=cme*pma+cmf*pmc+pme;pcf=cme*pmb+cmf*pmd+pmf;cma=pca;cmb=pcb;cmc=pcc;cmd=pcd;cme=pce;cmf=pcf;}this.setTexture2D(texture,0);for(var emitterIndex=0;emitterIndex<emitterCount;++emitterIndex){var emitter=emitters[emitterIndex];var particles=emitter.alive;var aliveLength=particles.length;var batchCount=Math.ceil(aliveLength/maxQuads);var particleOffset=0;var scrollX=cameraScrollX*emitter.scrollFactorX;var scrollY=cameraScrollY*emitter.scrollFactorY;if(!emitter.visible||aliveLength===0){continue;}renderer.setBlendMode(emitter.blendMode);if(this.vertexCount>=vertexCapacity){this.flush();this.setTexture2D(texture,0);}for(var batchIndex=0;batchIndex<batchCount;++batchIndex){var batchSize=Math.min(aliveLength,maxQuads);for(var index=0;index<batchSize;++index){var particle=particles[particleOffset+index];if(particle.alpha<=0){continue;}var frame=particle.frame;var uvs=frame.uvs;var x=-frame.halfWidth;var y=-frame.halfHeight;var color=particle.color;var xw=x+frame.width;var yh=y+frame.height;var sr=sin(particle.rotation);var cr=cos(particle.rotation);var sra=cr*particle.scaleX;var srb=-sr*particle.scaleX;var src=sr*particle.scaleY;var srd=cr*particle.scaleY;var sre=particle.x-scrollX*particle.scrollFactorX;var srf=particle.y-scrollY*particle.scrollFactorY;var mva=sra*cma+srb*cmc;var mvb=sra*cmb+srb*cmd;var mvc=src*cma+srd*cmc;var mvd=src*cmb+srd*cmd;var mve=sre*cma+srf*cmc+cme;var mvf=sre*cmb+srf*cmd+cmf;var tx0=x*mva+y*mvc+mve;var ty0=x*mvb+y*mvd+mvf;var tx1=x*mva+yh*mvc+mve;var ty1=x*mvb+yh*mvd+mvf;var tx2=xw*mva+yh*mvc+mve;var ty2=xw*mvb+yh*mvd+mvf;var tx3=xw*mva+y*mvc+mve;var ty3=xw*mvb+y*mvd+mvf;var vertexOffset=this.vertexCount*vertexComponentCount;if(roundPixels){tx0|=0;ty0|=0;tx1|=0;ty1|=0;tx2|=0;ty2|=0;tx3|=0;ty3|=0;}vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewF32[vertexOffset+2]=uvs.x0;vertexViewF32[vertexOffset+3]=uvs.y0;vertexViewU32[vertexOffset+4]=color;vertexViewF32[vertexOffset+5]=tx1;vertexViewF32[vertexOffset+6]=ty1;vertexViewF32[vertexOffset+7]=uvs.x1;vertexViewF32[vertexOffset+8]=uvs.y1;vertexViewU32[vertexOffset+9]=color;vertexViewF32[vertexOffset+10]=tx2;vertexViewF32[vertexOffset+11]=ty2;vertexViewF32[vertexOffset+12]=uvs.x2;vertexViewF32[vertexOffset+13]=uvs.y2;vertexViewU32[vertexOffset+14]=color;vertexViewF32[vertexOffset+15]=tx0;vertexViewF32[vertexOffset+16]=ty0;vertexViewF32[vertexOffset+17]=uvs.x0;vertexViewF32[vertexOffset+18]=uvs.y0;vertexViewU32[vertexOffset+19]=color;vertexViewF32[vertexOffset+20]=tx2;vertexViewF32[vertexOffset+21]=ty2;vertexViewF32[vertexOffset+22]=uvs.x2;vertexViewF32[vertexOffset+23]=uvs.y2;vertexViewU32[vertexOffset+24]=color;vertexViewF32[vertexOffset+25]=tx3;vertexViewF32[vertexOffset+26]=ty3;vertexViewF32[vertexOffset+27]=uvs.x3;vertexViewF32[vertexOffset+28]=uvs.y3;vertexViewU32[vertexOffset+29]=color;this.vertexCount+=6;}particleOffset+=batchSize;aliveLength-=batchSize;if(this.vertexCount>=vertexCapacity){this.flush();this.setTexture2D(texture,0);}}}this.setTexture2D(texture,0);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#drawBlitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Blitter} blitter - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */drawBlitter:function drawBlitter(blitter,camera,parentTransformMatrix){var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}this.renderer.setPipeline(this);var roundPixels=this.renderer.config.roundPixels;var getTint=Utils.getTintAppendFloatAlpha;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var list=blitter.getRenderList();var length=list.length;var cameraMatrix=camera.matrix.matrix;var a=cameraMatrix[0];var b=cameraMatrix[1];var c=cameraMatrix[2];var d=cameraMatrix[3];var e=cameraMatrix[4];var f=cameraMatrix[5];var cameraScrollX=camera.scrollX*blitter.scrollFactorX;var cameraScrollY=camera.scrollY*blitter.scrollFactorY;var batchCount=Math.ceil(length/this.maxQuads);var batchOffset=0;var blitterX=blitter.x-cameraScrollX;var blitterY=blitter.y-cameraScrollY;if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];var pca=a*pma+b*pmc;var pcb=a*pmb+b*pmd;var pcc=c*pma+d*pmc;var pcd=c*pmb+d*pmd;var pce=e*pma+f*pmc+pme;var pcf=e*pmb+f*pmd+pmf;a=pca;b=pcb;c=pcc;d=pcd;e=pce;f=pcf;}for(var batchIndex=0;batchIndex<batchCount;++batchIndex){var batchSize=Math.min(length,this.maxQuads);for(var index=0;index<batchSize;++index){var bob=list[batchOffset+index];var frame=bob.frame;var alpha=bob.alpha;var tint=getTint(0xffffff,alpha);var uvs=frame.uvs;var flipX=bob.flipX;var flipY=bob.flipY;var width=frame.width*(flipX?-1.0:1.0);var height=frame.height*(flipY?-1.0:1.0);var x=blitterX+bob.x+frame.x+frame.width*(flipX?1.0:0.0);var y=blitterY+bob.y+frame.y+frame.height*(flipY?1.0:0.0);var xw=x+width;var yh=y+height;var tx0=x*a+y*c+e;var ty0=x*b+y*d+f;var tx1=xw*a+yh*c+e;var ty1=xw*b+yh*d+f;// Bind Texture if texture wasn't bound.\n// This needs to be here because of multiple\n// texture atlas.\nthis.setTexture2D(frame.texture.source[frame.sourceIndex].glTexture,0);var vertexOffset=this.vertexCount*this.vertexComponentCount;if(roundPixels){tx0|=0;ty0|=0;tx1|=0;ty1|=0;}vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewF32[vertexOffset+2]=uvs.x0;vertexViewF32[vertexOffset+3]=uvs.y0;vertexViewU32[vertexOffset+4]=tint;vertexViewF32[vertexOffset+5]=tx0;vertexViewF32[vertexOffset+6]=ty1;vertexViewF32[vertexOffset+7]=uvs.x1;vertexViewF32[vertexOffset+8]=uvs.y1;vertexViewU32[vertexOffset+9]=tint;vertexViewF32[vertexOffset+10]=tx1;vertexViewF32[vertexOffset+11]=ty1;vertexViewF32[vertexOffset+12]=uvs.x2;vertexViewF32[vertexOffset+13]=uvs.y2;vertexViewU32[vertexOffset+14]=tint;vertexViewF32[vertexOffset+15]=tx0;vertexViewF32[vertexOffset+16]=ty0;vertexViewF32[vertexOffset+17]=uvs.x0;vertexViewF32[vertexOffset+18]=uvs.y0;vertexViewU32[vertexOffset+19]=tint;vertexViewF32[vertexOffset+20]=tx1;vertexViewF32[vertexOffset+21]=ty1;vertexViewF32[vertexOffset+22]=uvs.x2;vertexViewF32[vertexOffset+23]=uvs.y2;vertexViewU32[vertexOffset+24]=tint;vertexViewF32[vertexOffset+25]=tx1;vertexViewF32[vertexOffset+26]=ty0;vertexViewF32[vertexOffset+27]=uvs.x3;vertexViewF32[vertexOffset+28]=uvs.y3;vertexViewU32[vertexOffset+29]=tint;this.vertexCount+=6;if(this.vertexCount>=this.vertexCapacity){this.flush();}}batchOffset+=batchSize;length-=batchSize;if(this.vertexCount>=this.vertexCapacity){this.flush();}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Sprite} sprite - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchSprite:function batchSprite(sprite,camera,parentTransformMatrix){var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}this.renderer.setPipeline(this);if(this.vertexCount+6>this.vertexCapacity){this.flush();}var roundPixels=this.renderer.config.roundPixels;var getTint=Utils.getTintAppendFloatAlpha;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var cameraMatrix=camera.matrix.matrix;var frame=sprite.frame;var texture=frame.texture.source[frame.sourceIndex].glTexture;var forceFlipY=texture.isRenderTexture?true:false;var flipX=sprite.flipX;var flipY=sprite.flipY^forceFlipY;var uvs=frame.uvs;var width=frame.width*(flipX?-1.0:1.0);var height=frame.height*(flipY?-1.0:1.0);var x=-sprite.displayOriginX+frame.x+frame.width*(flipX?1.0:0.0);var y=-sprite.displayOriginY+frame.y+frame.height*(flipY?1.0:0.0);var xw=(roundPixels?x|0:x)+width;var yh=(roundPixels?y|0:y)+height;var translateX=sprite.x-camera.scrollX*sprite.scrollFactorX;var translateY=sprite.y-camera.scrollY*sprite.scrollFactorY;var scaleX=sprite.scaleX;var scaleY=sprite.scaleY;var rotation=-sprite.rotation;var alphaTL=sprite._alphaTL;var alphaTR=sprite._alphaTR;var alphaBL=sprite._alphaBL;var alphaBR=sprite._alphaBR;var tintTL=sprite._tintTL;var tintTR=sprite._tintTR;var tintBL=sprite._tintBL;var tintBR=sprite._tintBR;var sr=Math.sin(rotation);var cr=Math.cos(rotation);var sra=cr*scaleX;var srb=-sr*scaleX;var src=sr*scaleY;var srd=cr*scaleY;var sre=translateX;var srf=translateY;var cma=cameraMatrix[0];var cmb=cameraMatrix[1];var cmc=cameraMatrix[2];var cmd=cameraMatrix[3];var cme=cameraMatrix[4];var cmf=cameraMatrix[5];var mva,mvb,mvc,mvd,mve,mvf;if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];var pca=cma*pma+cmb*pmc;var pcb=cma*pmb+cmb*pmd;var pcc=cmc*pma+cmd*pmc;var pcd=cmc*pmb+cmd*pmd;var pce=cme*pma+cmf*pmc+pme;var pcf=cme*pmb+cmf*pmd+pmf;mva=sra*pca+srb*pcc;mvb=sra*pcb+srb*pcd;mvc=src*pca+srd*pcc;mvd=src*pcb+srd*pcd;mve=sre*pca+srf*pcc+pce;mvf=sre*pcb+srf*pcd+pcf;}else{mva=sra*cma+srb*cmc;mvb=sra*cmb+srb*cmd;mvc=src*cma+srd*cmc;mvd=src*cmb+srd*cmd;mve=sre*cma+srf*cmc+cme;mvf=sre*cmb+srf*cmd+cmf;}var tx0=x*mva+y*mvc+mve;var ty0=x*mvb+y*mvd+mvf;var tx1=x*mva+yh*mvc+mve;var ty1=x*mvb+yh*mvd+mvf;var tx2=xw*mva+yh*mvc+mve;var ty2=xw*mvb+yh*mvd+mvf;var tx3=xw*mva+y*mvc+mve;var ty3=xw*mvb+y*mvd+mvf;var vTintTL=getTint(tintTL,alphaTL);var vTintTR=getTint(tintTR,alphaTR);var vTintBL=getTint(tintBL,alphaBL);var vTintBR=getTint(tintBR,alphaBR);var vertexOffset=0;if(roundPixels){tx0|=0;ty0|=0;tx1|=0;ty1|=0;tx2|=0;ty2|=0;tx3|=0;ty3|=0;}this.setTexture2D(texture,0);vertexOffset=this.vertexCount*this.vertexComponentCount;vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewF32[vertexOffset+2]=uvs.x0;vertexViewF32[vertexOffset+3]=uvs.y0;vertexViewU32[vertexOffset+4]=vTintTL;vertexViewF32[vertexOffset+5]=tx1;vertexViewF32[vertexOffset+6]=ty1;vertexViewF32[vertexOffset+7]=uvs.x1;vertexViewF32[vertexOffset+8]=uvs.y1;vertexViewU32[vertexOffset+9]=vTintBL;vertexViewF32[vertexOffset+10]=tx2;vertexViewF32[vertexOffset+11]=ty2;vertexViewF32[vertexOffset+12]=uvs.x2;vertexViewF32[vertexOffset+13]=uvs.y2;vertexViewU32[vertexOffset+14]=vTintBR;vertexViewF32[vertexOffset+15]=tx0;vertexViewF32[vertexOffset+16]=ty0;vertexViewF32[vertexOffset+17]=uvs.x0;vertexViewF32[vertexOffset+18]=uvs.y0;vertexViewU32[vertexOffset+19]=vTintTL;vertexViewF32[vertexOffset+20]=tx2;vertexViewF32[vertexOffset+21]=ty2;vertexViewF32[vertexOffset+22]=uvs.x2;vertexViewF32[vertexOffset+23]=uvs.y2;vertexViewU32[vertexOffset+24]=vTintBR;vertexViewF32[vertexOffset+25]=tx3;vertexViewF32[vertexOffset+26]=ty3;vertexViewF32[vertexOffset+27]=uvs.x3;vertexViewF32[vertexOffset+28]=uvs.y3;vertexViewU32[vertexOffset+29]=vTintTR;this.vertexCount+=6;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchMesh\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Mesh} mesh - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchMesh:function batchMesh(mesh,camera,parentTransformMatrix){var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}var vertices=mesh.vertices;var length=vertices.length;var vertexCount=length/2|0;this.renderer.setPipeline(this);if(this.vertexCount+vertexCount>this.vertexCapacity){this.flush();}var roundPixels=this.renderer.config.roundPixels;var getTint=Utils.getTintAppendFloatAlpha;var uvs=mesh.uv;var colors=mesh.colors;var alphas=mesh.alphas;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var cameraMatrix=camera.matrix.matrix;var frame=mesh.frame;var texture=mesh.texture.source[frame.sourceIndex].glTexture;var translateX=mesh.x-camera.scrollX*mesh.scrollFactorX;var translateY=mesh.y-camera.scrollY*mesh.scrollFactorY;var scaleX=mesh.scaleX;var scaleY=mesh.scaleY;var rotation=-mesh.rotation;var sr=Math.sin(rotation);var cr=Math.cos(rotation);var sra=cr*scaleX;var srb=-sr*scaleX;var src=sr*scaleY;var srd=cr*scaleY;var sre=translateX;var srf=translateY;var cma=cameraMatrix[0];var cmb=cameraMatrix[1];var cmc=cameraMatrix[2];var cmd=cameraMatrix[3];var cme=cameraMatrix[4];var cmf=cameraMatrix[5];var vertexOffset=0;var mva,mvb,mvc,mvd,mve,mvf;if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];var pca=cma*pma+cmb*pmc;var pcb=cma*pmb+cmb*pmd;var pcc=cmc*pma+cmd*pmc;var pcd=cmc*pmb+cmd*pmd;var pce=cme*pma+cmf*pmc+pme;var pcf=cme*pmb+cmf*pmd+pmf;mva=sra*pca+srb*pcc;mvb=sra*pcb+srb*pcd;mvc=src*pca+srd*pcc;mvd=src*pcb+srd*pcd;mve=sre*pca+srf*pcc+pce;mvf=sre*pcb+srf*pcd+pcf;}else{mva=sra*cma+srb*cmc;mvb=sra*cmb+srb*cmd;mvc=src*cma+srd*cmc;mvd=src*cmb+srd*cmd;mve=sre*cma+srf*cmc+cme;mvf=sre*cmb+srf*cmd+cmf;}this.setTexture2D(texture,0);vertexOffset=this.vertexCount*this.vertexComponentCount;for(var index=0,index0=0;index<length;index+=2){var x=vertices[index+0];var y=vertices[index+1];var tx=x*mva+y*mvc+mve;var ty=x*mvb+y*mvd+mvf;if(roundPixels){tx|=0;ty|=0;}vertexViewF32[vertexOffset+0]=tx;vertexViewF32[vertexOffset+1]=ty;vertexViewF32[vertexOffset+2]=uvs[index+0];vertexViewF32[vertexOffset+3]=uvs[index+1];vertexViewU32[vertexOffset+4]=getTint(colors[index0],alphas[index0]);vertexOffset+=5;index0+=1;}this.vertexCount+=vertexCount;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchBitmapText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.BitmapText} bitmapText - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchBitmapText:function batchBitmapText(bitmapText,camera,parentTransformMatrix){var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}this.renderer.setPipeline(this);if(this.vertexCount+6>this.vertexCapacity){this.flush();}var roundPixels=this.renderer.config.roundPixels;var text=bitmapText.text;var textLength=text.length;var getTint=Utils.getTintAppendFloatAlpha;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var cameraMatrix=camera.matrix.matrix;var cameraWidth=camera.width+50;var cameraHeight=camera.height+50;var cameraX=-50;var cameraY=-50;var frame=bitmapText.frame;var textureSource=bitmapText.texture.source[frame.sourceIndex];var cameraScrollX=camera.scrollX*bitmapText.scrollFactorX;var cameraScrollY=camera.scrollY*bitmapText.scrollFactorY;var fontData=bitmapText.fontData;var lineHeight=fontData.lineHeight;var scale=bitmapText.fontSize/fontData.size;var chars=fontData.chars;var alpha=bitmapText.alpha;var vTintTL=getTint(bitmapText._tintTL,alpha);var vTintTR=getTint(bitmapText._tintTR,alpha);var vTintBL=getTint(bitmapText._tintBL,alpha);var vTintBR=getTint(bitmapText._tintBR,alpha);var srcX=bitmapText.x;var srcY=bitmapText.y;var textureX=frame.cutX;var textureY=frame.cutY;var textureWidth=textureSource.width;var textureHeight=textureSource.height;var texture=textureSource.glTexture;var xAdvance=0;var yAdvance=0;var indexCount=0;var charCode=0;var glyph=null;var glyphX=0;var glyphY=0;var glyphW=0;var glyphH=0;var x=0;var y=0;var xw=0;var yh=0;var tx0;var ty0;var tx1;var ty1;var tx2;var ty2;var tx3;var ty3;var umin=0;var umax=0;var vmin=0;var vmax=0;var lastGlyph=null;var lastCharCode=0;var translateX=srcX-cameraScrollX+frame.x;var translateY=srcY-cameraScrollY+frame.y;var rotation=-bitmapText.rotation;var scaleX=bitmapText.scaleX;var scaleY=bitmapText.scaleY;var letterSpacing=bitmapText.letterSpacing;var sr=Math.sin(rotation);var cr=Math.cos(rotation);var sra=cr*scaleX;var srb=-sr*scaleX;var src=sr*scaleY;var srd=cr*scaleY;var sre=translateX;var srf=translateY;var cma=cameraMatrix[0];var cmb=cameraMatrix[1];var cmc=cameraMatrix[2];var cmd=cameraMatrix[3];var cme=cameraMatrix[4];var cmf=cameraMatrix[5];var vertexOffset=0;var mva,mvb,mvc,mvd,mve,mvf;if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];var pca=cma*pma+cmb*pmc;var pcb=cma*pmb+cmb*pmd;var pcc=cmc*pma+cmd*pmc;var pcd=cmc*pmb+cmd*pmd;var pce=cme*pma+cmf*pmc+pme;var pcf=cme*pmb+cmf*pmd+pmf;mva=sra*pca+srb*pcc;mvb=sra*pcb+srb*pcd;mvc=src*pca+srd*pcc;mvd=src*pcb+srd*pcd;mve=sre*pca+srf*pcc+pce;mvf=sre*pcb+srf*pcd+pcf;}else{mva=sra*cma+srb*cmc;mvb=sra*cmb+srb*cmd;mvc=src*cma+srd*cmc;mvd=src*cmb+srd*cmd;mve=sre*cma+srf*cmc+cme;mvf=sre*cmb+srf*cmd+cmf;}this.setTexture2D(texture,0);for(var index=0;index<textLength;++index){charCode=text.charCodeAt(index);if(charCode===10){xAdvance=0;indexCount=0;yAdvance+=lineHeight;lastGlyph=null;continue;}glyph=chars[charCode];if(!glyph){continue;}glyphX=textureX+glyph.x;glyphY=textureY+glyph.y;glyphW=glyph.width;glyphH=glyph.height;x=(indexCount+glyph.xOffset+xAdvance)*scale;y=(glyph.yOffset+yAdvance)*scale;if(lastGlyph!==null){var kerningOffset=glyph.kerning[lastCharCode];x+=kerningOffset!==undefined?kerningOffset:0;}xAdvance+=glyph.xAdvance+letterSpacing;indexCount+=1;lastGlyph=glyph;lastCharCode=charCode;//  Nothing to render or a space? Then skip to the next glyph\nif(glyphW===0||glyphH===0||charCode===32){continue;}x-=bitmapText.displayOriginX;y-=bitmapText.displayOriginY;xw=x+glyphW*scale;yh=y+glyphH*scale;tx0=x*mva+y*mvc+mve;ty0=x*mvb+y*mvd+mvf;tx1=x*mva+yh*mvc+mve;ty1=x*mvb+yh*mvd+mvf;tx2=xw*mva+yh*mvc+mve;ty2=xw*mvb+yh*mvd+mvf;tx3=xw*mva+y*mvc+mve;ty3=xw*mvb+y*mvd+mvf;umin=glyphX/textureWidth;umax=(glyphX+glyphW)/textureWidth;vmin=glyphY/textureHeight;vmax=(glyphY+glyphH)/textureHeight;if((tx0<cameraX||tx0>cameraWidth||ty0<cameraY||ty0>cameraHeight)&&(tx1<cameraX||tx1>cameraWidth||ty1<cameraY||ty1>cameraHeight)&&(tx2<cameraX||tx2>cameraWidth||ty2<cameraY||ty2>cameraHeight)&&(tx3<cameraX||tx3>cameraWidth||ty3<cameraY||ty3>cameraHeight)){continue;}if(this.vertexCount+6>this.vertexCapacity){this.flush();}vertexOffset=this.vertexCount*this.vertexComponentCount;if(roundPixels){tx0|=0;ty0|=0;tx1|=0;ty1|=0;tx2|=0;ty2|=0;tx3|=0;ty3|=0;}vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewF32[vertexOffset+2]=umin;vertexViewF32[vertexOffset+3]=vmin;vertexViewU32[vertexOffset+4]=vTintTL;vertexViewF32[vertexOffset+5]=tx1;vertexViewF32[vertexOffset+6]=ty1;vertexViewF32[vertexOffset+7]=umin;vertexViewF32[vertexOffset+8]=vmax;vertexViewU32[vertexOffset+9]=vTintBL;vertexViewF32[vertexOffset+10]=tx2;vertexViewF32[vertexOffset+11]=ty2;vertexViewF32[vertexOffset+12]=umax;vertexViewF32[vertexOffset+13]=vmax;vertexViewU32[vertexOffset+14]=vTintBR;vertexViewF32[vertexOffset+15]=tx0;vertexViewF32[vertexOffset+16]=ty0;vertexViewF32[vertexOffset+17]=umin;vertexViewF32[vertexOffset+18]=vmin;vertexViewU32[vertexOffset+19]=vTintTL;vertexViewF32[vertexOffset+20]=tx2;vertexViewF32[vertexOffset+21]=ty2;vertexViewF32[vertexOffset+22]=umax;vertexViewF32[vertexOffset+23]=vmax;vertexViewU32[vertexOffset+24]=vTintBR;vertexViewF32[vertexOffset+25]=tx3;vertexViewF32[vertexOffset+26]=ty3;vertexViewF32[vertexOffset+27]=umax;vertexViewF32[vertexOffset+28]=vmin;vertexViewU32[vertexOffset+29]=vTintTR;this.vertexCount+=6;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchDynamicBitmapText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.DynamicBitmapText} bitmapText - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchDynamicBitmapText:function batchDynamicBitmapText(bitmapText,camera,parentTransformMatrix){var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}this.renderer.setPipeline(this);if(this.vertexCount+6>this.vertexCapacity){this.flush();}var roundPixels=this.renderer.config.roundPixels;var displayCallback=bitmapText.displayCallback;var text=bitmapText.text;var textLength=text.length;var getTint=Utils.getTintAppendFloatAlpha;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var renderer=this.renderer;var cameraMatrix=camera.matrix.matrix;var frame=bitmapText.frame;var textureSource=bitmapText.texture.source[frame.sourceIndex];var cameraScrollX=camera.scrollX*bitmapText.scrollFactorX;var cameraScrollY=camera.scrollY*bitmapText.scrollFactorY;var scrollX=bitmapText.scrollX;var scrollY=bitmapText.scrollY;var fontData=bitmapText.fontData;var lineHeight=fontData.lineHeight;var scale=bitmapText.fontSize/fontData.size;var chars=fontData.chars;var alpha=bitmapText.alpha;var vTintTL=getTint(bitmapText._tintTL,alpha);var vTintTR=getTint(bitmapText._tintTR,alpha);var vTintBL=getTint(bitmapText._tintBL,alpha);var vTintBR=getTint(bitmapText._tintBR,alpha);var srcX=bitmapText.x;var srcY=bitmapText.y;var textureX=frame.cutX;var textureY=frame.cutY;var textureWidth=textureSource.width;var textureHeight=textureSource.height;var texture=textureSource.glTexture;var xAdvance=0;var yAdvance=0;var indexCount=0;var charCode=0;var glyph=null;var glyphX=0;var glyphY=0;var glyphW=0;var glyphH=0;var x=0;var y=0;var xw=0;var tx0;var ty0;var tx1;var ty1;var tx2;var ty2;var tx3;var ty3;var yh=0;var umin=0;var umax=0;var vmin=0;var vmax=0;var lastGlyph=null;var lastCharCode=0;var translateX=srcX+frame.x;var translateY=srcY+frame.y;var rotation=-bitmapText.rotation;var scaleX=bitmapText.scaleX;var scaleY=bitmapText.scaleY;var letterSpacing=bitmapText.letterSpacing;var sr=Math.sin(rotation);var cr=Math.cos(rotation);var sra=cr*scaleX;var srb=-sr*scaleX;var src=sr*scaleY;var srd=cr*scaleY;var sre=translateX;var srf=translateY;var cma=cameraMatrix[0];var cmb=cameraMatrix[1];var cmc=cameraMatrix[2];var cmd=cameraMatrix[3];var cme=cameraMatrix[4];var cmf=cameraMatrix[5];var crop=bitmapText.cropWidth>0||bitmapText.cropHeight>0;var uta,utb,utc,utd,ute,utf;var vertexOffset=0;var mva,mvb,mvc,mvd,mve,mvf;if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];var pca=cma*pma+cmb*pmc;var pcb=cma*pmb+cmb*pmd;var pcc=cmc*pma+cmd*pmc;var pcd=cmc*pmb+cmd*pmd;var pce=cme*pma+cmf*pmc+pme;var pcf=cme*pmb+cmf*pmd+pmf;mva=sra*pca+srb*pcc;mvb=sra*pcb+srb*pcd;mvc=src*pca+srd*pcc;mvd=src*pcb+srd*pcd;mve=sre*pca+srf*pcc+pce;mvf=sre*pcb+srf*pcd+pcf;}else{mva=sra*cma+srb*cmc;mvb=sra*cmb+srb*cmd;mvc=src*cma+srd*cmc;mvd=src*cmb+srd*cmd;mve=sre*cma+srf*cmc+cme;mvf=sre*cmb+srf*cmd+cmf;}this.setTexture2D(texture,0);if(crop){renderer.pushScissor(bitmapText.x,bitmapText.y,bitmapText.cropWidth*bitmapText.scaleX,bitmapText.cropHeight*bitmapText.scaleY);}for(var index=0;index<textLength;++index){scale=bitmapText.fontSize/bitmapText.fontData.size;rotation=0;charCode=text.charCodeAt(index);if(charCode===10){xAdvance=0;indexCount=0;yAdvance+=lineHeight;lastGlyph=null;continue;}glyph=chars[charCode];if(!glyph){continue;}glyphX=textureX+glyph.x;glyphY=textureY+glyph.y;glyphW=glyph.width;glyphH=glyph.height;x=indexCount+glyph.xOffset+xAdvance-scrollX;y=glyph.yOffset+yAdvance-scrollY;if(lastGlyph!==null){var kerningOffset=glyph.kerning[lastCharCode];x+=kerningOffset!==undefined?kerningOffset:0;}xAdvance+=glyph.xAdvance+letterSpacing;indexCount+=1;lastGlyph=glyph;lastCharCode=charCode;//  Nothing to render or a space? Then skip to the next glyph\nif(glyphW===0||glyphH===0||charCode===32){continue;}if(displayCallback){var output=displayCallback({color:0,tint:{topLeft:vTintTL,topRight:vTintTR,bottomLeft:vTintBL,bottomRight:vTintBR},index:index,charCode:charCode,x:x,y:y,scale:scale,rotation:0,data:glyph.data});x=output.x;y=output.y;scale=output.scale;rotation=output.rotation;if(output.color){vTintTL=output.color;vTintTR=output.color;vTintBL=output.color;vTintBR=output.color;}else{vTintTL=output.tint.topLeft;vTintTR=output.tint.topRight;vTintBL=output.tint.bottomLeft;vTintBR=output.tint.bottomRight;}vTintTL=getTint(vTintTL,alpha);vTintTR=getTint(vTintTR,alpha);vTintBL=getTint(vTintBL,alpha);vTintBR=getTint(vTintBR,alpha);}x-=bitmapText.displayOriginX;y-=bitmapText.displayOriginY;x*=scale;y*=scale;x-=cameraScrollX;y-=cameraScrollY;sr=Math.sin(-rotation);cr=Math.cos(-rotation);uta=cr*scale;utb=-sr*scale;utc=sr*scale;utd=cr*scale;ute=x;utf=y;sra=uta*mva+utb*mvc;srb=uta*mvb+utb*mvd;src=utc*mva+utd*mvc;srd=utc*mvb+utd*mvd;sre=ute*mva+utf*mvc+mve;srf=ute*mvb+utf*mvd+mvf;xw=glyphW;yh=glyphH;tx0=sre;ty0=srf;tx1=yh*src+sre;ty1=yh*srd+srf;tx2=xw*sra+yh*src+sre;ty2=xw*srb+yh*srd+srf;tx3=xw*sra+sre;ty3=xw*srb+srf;umin=glyphX/textureWidth;umax=(glyphX+glyphW)/textureWidth;vmin=glyphY/textureHeight;vmax=(glyphY+glyphH)/textureHeight;if(this.vertexCount+6>this.vertexCapacity){this.flush();}vertexOffset=this.vertexCount*this.vertexComponentCount;if(roundPixels){tx0|=0;ty0|=0;tx1|=0;ty1|=0;tx2|=0;ty2|=0;tx3|=0;ty3|=0;}vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewF32[vertexOffset+2]=umin;vertexViewF32[vertexOffset+3]=vmin;vertexViewU32[vertexOffset+4]=vTintTL;vertexViewF32[vertexOffset+5]=tx1;vertexViewF32[vertexOffset+6]=ty1;vertexViewF32[vertexOffset+7]=umin;vertexViewF32[vertexOffset+8]=vmax;vertexViewU32[vertexOffset+9]=vTintBL;vertexViewF32[vertexOffset+10]=tx2;vertexViewF32[vertexOffset+11]=ty2;vertexViewF32[vertexOffset+12]=umax;vertexViewF32[vertexOffset+13]=vmax;vertexViewU32[vertexOffset+14]=vTintBR;vertexViewF32[vertexOffset+15]=tx0;vertexViewF32[vertexOffset+16]=ty0;vertexViewF32[vertexOffset+17]=umin;vertexViewF32[vertexOffset+18]=vmin;vertexViewU32[vertexOffset+19]=vTintTL;vertexViewF32[vertexOffset+20]=tx2;vertexViewF32[vertexOffset+21]=ty2;vertexViewF32[vertexOffset+22]=umax;vertexViewF32[vertexOffset+23]=vmax;vertexViewU32[vertexOffset+24]=vTintBR;vertexViewF32[vertexOffset+25]=tx3;vertexViewF32[vertexOffset+26]=ty3;vertexViewF32[vertexOffset+27]=umax;vertexViewF32[vertexOffset+28]=vmin;vertexViewU32[vertexOffset+29]=vTintTR;this.vertexCount+=6;}if(crop){renderer.popScissor();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Text} text - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchText:function batchText(text,camera,parentTransformMatrix){var getTint=Utils.getTintAppendFloatAlpha;this.batchTexture(text,text.canvasTexture,text.canvasTexture.width,text.canvasTexture.height,text.x,text.y,text.canvasTexture.width,text.canvasTexture.height,text.scaleX,text.scaleY,text.rotation,text.flipX,text.flipY,text.scrollFactorX,text.scrollFactorY,text.displayOriginX,text.displayOriginY,0,0,text.canvasTexture.width,text.canvasTexture.height,getTint(text._tintTL,text._alphaTL),getTint(text._tintTR,text._alphaTR),getTint(text._tintBL,text._alphaBL),getTint(text._tintBR,text._alphaBR),0,0,camera,parentTransformMatrix);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchDynamicTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.DynamicTilemapLayer} tilemapLayer - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchDynamicTilemapLayer:function batchDynamicTilemapLayer(tilemapLayer,camera,parentTransformMatrix){var renderTiles=tilemapLayer.culledTiles;var length=renderTiles.length;var texture=tilemapLayer.tileset.image.get().source.glTexture;var tileset=tilemapLayer.tileset;var scrollFactorX=tilemapLayer.scrollFactorX;var scrollFactorY=tilemapLayer.scrollFactorY;var alpha=tilemapLayer.alpha;var x=tilemapLayer.x;var y=tilemapLayer.y;var sx=tilemapLayer.scaleX;var sy=tilemapLayer.scaleY;var getTint=Utils.getTintAppendFloatAlpha;for(var index=0;index<length;++index){var tile=renderTiles[index];var tileTexCoords=tileset.getTileTextureCoordinates(tile.index);if(tileTexCoords===null){continue;}var frameWidth=tile.width;var frameHeight=tile.height;var frameX=tileTexCoords.x;var frameY=tileTexCoords.y;var tint=getTint(tile.tint,alpha*tile.alpha);this.batchTexture(tilemapLayer,texture,texture.width,texture.height,tile.width/2+x+tile.pixelX*sx,tile.height/2+y+tile.pixelY*sy,tile.width*sx,tile.height*sy,1,1,tile.rotation,tile.flipX,tile.flipY,scrollFactorX,scrollFactorY,tile.width/2,tile.height/2,frameX,frameY,frameWidth,frameHeight,tint,tint,tint,tint,0,0,camera,parentTransformMatrix);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchTileSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.TileSprite} tileSprite - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchTileSprite:function batchTileSprite(tileSprite,camera,parentTransformMatrix){var getTint=Utils.getTintAppendFloatAlpha;this.batchTexture(tileSprite,tileSprite.tileTexture,tileSprite.frame.width,tileSprite.frame.height,tileSprite.x,tileSprite.y,tileSprite.width,tileSprite.height,tileSprite.scaleX,tileSprite.scaleY,tileSprite.rotation,tileSprite.flipX,tileSprite.flipY,tileSprite.scrollFactorX,tileSprite.scrollFactorY,tileSprite.originX*tileSprite.width,tileSprite.originY*tileSprite.height,0,0,tileSprite.width,tileSprite.height,getTint(tileSprite._tintTL,tileSprite._alphaTL),getTint(tileSprite._tintTR,tileSprite._alphaTR),getTint(tileSprite._tintBL,tileSprite._alphaBL),getTint(tileSprite._tintBR,tileSprite._alphaBR),tileSprite.tilePositionX%tileSprite.frame.width/tileSprite.frame.width,tileSprite.tilePositionY%tileSprite.frame.height/tileSprite.frame.height,camera,parentTransformMatrix);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     * @param {WebGLTexture} texture - [description]\r\n     * @param {integer} textureWidth - [description]\r\n     * @param {integer} textureHeight - [description]\r\n     * @param {float} srcX - [description]\r\n     * @param {float} srcY - [description]\r\n     * @param {float} srcWidth - [description]\r\n     * @param {float} srcHeight - [description]\r\n     * @param {float} scaleX - [description]\r\n     * @param {float} scaleY - [description]\r\n     * @param {float} rotation - [description]\r\n     * @param {boolean} flipX - [description]\r\n     * @param {boolean} flipY - [description]\r\n     * @param {float} scrollFactorX - [description]\r\n     * @param {float} scrollFactorY - [description]\r\n     * @param {float} displayOriginX - [description]\r\n     * @param {float} displayOriginY - [description]\r\n     * @param {float} frameX - [description]\r\n     * @param {float} frameY - [description]\r\n     * @param {float} frameWidth - [description]\r\n     * @param {float} frameHeight - [description]\r\n     * @param {integer} tintTL - [description]\r\n     * @param {integer} tintTR - [description]\r\n     * @param {integer} tintBL - [description]\r\n     * @param {integer} tintBR - [description]\r\n     * @param {float} uOffset - [description]\r\n     * @param {float} vOffset - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchTexture:function batchTexture(gameObject,texture,textureWidth,textureHeight,srcX,srcY,srcWidth,srcHeight,scaleX,scaleY,rotation,flipX,flipY,scrollFactorX,scrollFactorY,displayOriginX,displayOriginY,frameX,frameY,frameWidth,frameHeight,tintTL,tintTR,tintBL,tintBR,uOffset,vOffset,camera,parentTransformMatrix){var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}this.renderer.setPipeline(this);if(this.vertexCount+6>this.vertexCapacity){this.flush();}flipY=flipY^(texture.isRenderTexture?1:0);rotation=-rotation;var roundPixels=this.renderer.config.roundPixels;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var cameraMatrix=camera.matrix.matrix;var width=srcWidth*(flipX?-1.0:1.0);var height=srcHeight*(flipY?-1.0:1.0);var x=-displayOriginX+srcWidth*(flipX?1.0:0.0);var y=-displayOriginY+srcHeight*(flipY?1.0:0.0);var xw=x+width;var yh=y+height;var translateX=srcX-camera.scrollX*scrollFactorX;var translateY=srcY-camera.scrollY*scrollFactorY;var sr=Math.sin(rotation);var cr=Math.cos(rotation);var sra=cr*scaleX;var srb=-sr*scaleX;var src=sr*scaleY;var srd=cr*scaleY;var sre=translateX;var srf=translateY;var cma=cameraMatrix[0];var cmb=cameraMatrix[1];var cmc=cameraMatrix[2];var cmd=cameraMatrix[3];var cme=cameraMatrix[4];var cmf=cameraMatrix[5];var mva,mvb,mvc,mvd,mve,mvf;if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];var pca=cma*pma+cmb*pmc;var pcb=cma*pmb+cmb*pmd;var pcc=cmc*pma+cmd*pmc;var pcd=cmc*pmb+cmd*pmd;var pce=cme*pma+cmf*pmc+pme;var pcf=cme*pmb+cmf*pmd+pmf;mva=sra*pca+srb*pcc;mvb=sra*pcb+srb*pcd;mvc=src*pca+srd*pcc;mvd=src*pcb+srd*pcd;mve=sre*pca+srf*pcc+pce;mvf=sre*pcb+srf*pcd+pcf;}else{mva=sra*cma+srb*cmc;mvb=sra*cmb+srb*cmd;mvc=src*cma+srd*cmc;mvd=src*cmb+srd*cmd;mve=sre*cma+srf*cmc+cme;mvf=sre*cmb+srf*cmd+cmf;}var tx0=x*mva+y*mvc+mve;var ty0=x*mvb+y*mvd+mvf;var tx1=x*mva+yh*mvc+mve;var ty1=x*mvb+yh*mvd+mvf;var tx2=xw*mva+yh*mvc+mve;var ty2=xw*mvb+yh*mvd+mvf;var tx3=xw*mva+y*mvc+mve;var ty3=xw*mvb+y*mvd+mvf;var vertexOffset=0;var u0=frameX/textureWidth+uOffset;var v0=frameY/textureHeight+vOffset;var u1=(frameX+frameWidth)/textureWidth+uOffset;var v1=(frameY+frameHeight)/textureHeight+vOffset;this.setTexture2D(texture,0);vertexOffset=this.vertexCount*this.vertexComponentCount;if(roundPixels){tx0|=0;ty0|=0;tx1|=0;ty1|=0;tx2|=0;ty2|=0;tx3|=0;ty3|=0;}vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewF32[vertexOffset+2]=u0;vertexViewF32[vertexOffset+3]=v0;vertexViewU32[vertexOffset+4]=tintTL;vertexViewF32[vertexOffset+5]=tx1;vertexViewF32[vertexOffset+6]=ty1;vertexViewF32[vertexOffset+7]=u0;vertexViewF32[vertexOffset+8]=v1;vertexViewU32[vertexOffset+9]=tintTR;vertexViewF32[vertexOffset+10]=tx2;vertexViewF32[vertexOffset+11]=ty2;vertexViewF32[vertexOffset+12]=u1;vertexViewF32[vertexOffset+13]=v1;vertexViewU32[vertexOffset+14]=tintBL;vertexViewF32[vertexOffset+15]=tx0;vertexViewF32[vertexOffset+16]=ty0;vertexViewF32[vertexOffset+17]=u0;vertexViewF32[vertexOffset+18]=v0;vertexViewU32[vertexOffset+19]=tintTL;vertexViewF32[vertexOffset+20]=tx2;vertexViewF32[vertexOffset+21]=ty2;vertexViewF32[vertexOffset+22]=u1;vertexViewF32[vertexOffset+23]=v1;vertexViewU32[vertexOffset+24]=tintBL;vertexViewF32[vertexOffset+25]=tx3;vertexViewF32[vertexOffset+26]=ty3;vertexViewF32[vertexOffset+27]=u1;vertexViewF32[vertexOffset+28]=v0;vertexViewU32[vertexOffset+29]=tintBR;this.vertexCount+=6;},/**\r\n     * Immediately draws a texture with no batching.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#drawTexture\r\n     * @since 3.2.0\r\n     *\r\n     * @param {WebGLTexture} texture [description]\r\n     * @param {number} srcX - [description]\r\n     * @param {number} srcY - [description]\r\n     * @param {number} tint - [description]\r\n     * @param {number} alpha - [description]\r\n     * @param {number} frameX - [description]\r\n     * @param {number} frameY - [description]\r\n     * @param {number} frameWidth - [description]\r\n     * @param {number} frameHeight - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} transformMatrix - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.TextureTintPipeline} This Pipeline.\r\n     */drawTexture:function drawTexture(texture,srcX,srcY,tint,alpha,frameX,frameY,frameWidth,frameHeight,transformMatrix,parentTransformMatrix){var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}this.renderer.setPipeline(this);if(this.vertexCount+6>this.vertexCapacity){this.flush();}var roundPixels=this.renderer.config.roundPixels;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var width=frameWidth;var height=frameHeight;var x=srcX;var y=srcY;var xw=x+width;var yh=y+height;var mva=transformMatrix[0];var mvb=transformMatrix[1];var mvc=transformMatrix[2];var mvd=transformMatrix[3];var mve=transformMatrix[4];var mvf=transformMatrix[5];if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];var pca=mva*pma+mvb*pmc;var pcb=mva*pmb+mvb*pmd;var pcc=mvc*pma+mvd*pmc;var pcd=mvc*pmb+mvd*pmd;var pce=mve*pma+mvf*pmc+pme;var pcf=mve*pmb+mvf*pmd+pmf;mva=pca;mvb=pcb;mvc=pcc;mvd=pcd;mve=pce;mvf=pcf;}var tx0=x*mva+y*mvc+mve;var ty0=x*mvb+y*mvd+mvf;var tx1=x*mva+yh*mvc+mve;var ty1=x*mvb+yh*mvd+mvf;var tx2=xw*mva+yh*mvc+mve;var ty2=xw*mvb+yh*mvd+mvf;var tx3=xw*mva+y*mvc+mve;var ty3=xw*mvb+y*mvd+mvf;var vertexOffset=0;var textureWidth=texture.width;var textureHeight=texture.height;var u0=frameX/textureWidth;var v0=frameY/textureHeight;var u1=(frameX+frameWidth)/textureWidth;var v1=(frameY+frameHeight)/textureHeight;tint=Utils.getTintAppendFloatAlpha(tint,alpha);this.setTexture2D(texture,0);vertexOffset=this.vertexCount*this.vertexComponentCount;if(roundPixels){tx0|=0;ty0|=0;tx1|=0;ty1|=0;tx2|=0;ty2|=0;tx3|=0;ty3|=0;}vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewF32[vertexOffset+2]=u0;vertexViewF32[vertexOffset+3]=v0;vertexViewU32[vertexOffset+4]=tint;vertexViewF32[vertexOffset+5]=tx1;vertexViewF32[vertexOffset+6]=ty1;vertexViewF32[vertexOffset+7]=u0;vertexViewF32[vertexOffset+8]=v1;vertexViewU32[vertexOffset+9]=tint;vertexViewF32[vertexOffset+10]=tx2;vertexViewF32[vertexOffset+11]=ty2;vertexViewF32[vertexOffset+12]=u1;vertexViewF32[vertexOffset+13]=v1;vertexViewU32[vertexOffset+14]=tint;vertexViewF32[vertexOffset+15]=tx0;vertexViewF32[vertexOffset+16]=ty0;vertexViewF32[vertexOffset+17]=u0;vertexViewF32[vertexOffset+18]=v0;vertexViewU32[vertexOffset+19]=tint;vertexViewF32[vertexOffset+20]=tx2;vertexViewF32[vertexOffset+21]=ty2;vertexViewF32[vertexOffset+22]=u1;vertexViewF32[vertexOffset+23]=v1;vertexViewU32[vertexOffset+24]=tint;vertexViewF32[vertexOffset+25]=tx3;vertexViewF32[vertexOffset+26]=ty3;vertexViewF32[vertexOffset+27]=u1;vertexViewF32[vertexOffset+28]=v0;vertexViewU32[vertexOffset+29]=tint;this.vertexCount+=6;// Force an immediate draw\nthis.flush();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.TextureTintPipeline#batchGraphics\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */batchGraphics:function batchGraphics(){// Stub\n}});module.exports=TextureTintPipeline;/***/},/* 180 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var ShaderSourceFS=__webpack_require__(840);var TextureTintPipeline=__webpack_require__(179);var LIGHT_COUNT=10;/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ForwardDiffuseLightPipeline\r\n * @extends Phaser.Renderer.WebGL.TextureTintPipeline\r\n * @memberOf Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n */var ForwardDiffuseLightPipeline=new Class({Extends:TextureTintPipeline,initialize:function ForwardDiffuseLightPipeline(config){config.fragShader=ShaderSourceFS.replace('%LIGHT_COUNT%',LIGHT_COUNT.toString());TextureTintPipeline.call(this,config);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#onBind\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline} [description]\r\n     */onBind:function onBind(){TextureTintPipeline.prototype.onBind.call(this);var renderer=this.renderer;var program=this.program;this.mvpUpdate();renderer.setInt1(program,'uNormSampler',1);renderer.setFloat2(program,'uResolution',this.width,this.height);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#onRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline} [description]\r\n     */onRender:function onRender(scene,camera){var lightManager=scene.sys.lights;if(!lightManager){return this;}lightManager.culledLights.length=0;if(lightManager.lights.length<=0||!lightManager.active){return this;// If not visible lights just passthrough\n}var renderer=this.renderer;var program=this.program;var lights=lightManager.cull(camera);var lightCount=Math.min(lights.length,LIGHT_COUNT);var cameraMatrix=camera.matrix;var point={x:0,y:0};var height=renderer.height;var index;for(index=0;index<LIGHT_COUNT;++index){renderer.setFloat1(program,'uLights['+index+'].radius',0);// reset lights\n}if(lightCount<=0){return this;}renderer.setFloat4(program,'uCamera',camera.x,camera.y,camera.rotation,camera.zoom);renderer.setFloat3(program,'uAmbientLightColor',lightManager.ambientColor.r,lightManager.ambientColor.g,lightManager.ambientColor.b);for(index=0;index<lightCount;++index){var light=lights[index];var lightName='uLights['+index+'].';cameraMatrix.transformPoint(light.x,light.y,point);renderer.setFloat2(program,lightName+'position',point.x-camera.scrollX*light.scrollFactorX*camera.zoom,height-(point.y-camera.scrollY*light.scrollFactorY*camera.zoom));renderer.setFloat3(program,lightName+'color',light.r,light.g,light.b);renderer.setFloat1(program,lightName+'intensity',light.intensity);renderer.setFloat1(program,lightName+'radius',light.radius);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#drawStaticTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.StaticTilemapLayer} tilemap - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */drawStaticTilemapLayer:function drawStaticTilemapLayer(tilemap,camera){var normalTexture=tilemap.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.drawStaticTilemapLayer.call(this,tilemap,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. StaticTilemapLayer rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.drawStaticTilemapLayer(tilemap,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#drawEmitterManager\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */drawEmitterManager:function drawEmitterManager(emitterManager,camera){var normalTexture=emitterManager.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.drawEmitterManager.call(this,emitterManager,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. EmitterManager rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.drawEmitterManager(emitterManager,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#drawBlitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Blitter} blitter - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */drawBlitter:function drawBlitter(blitter,camera){var normalTexture=blitter.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.drawBlitter.call(this,blitter,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. Blitter rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.drawBlitter(blitter,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#batchSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Sprite} sprite - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */batchSprite:function batchSprite(sprite,camera){var normalTexture=sprite.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.batchSprite.call(this,sprite,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. Sprite rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.batchSprite(sprite,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#batchMesh\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Mesh} mesh - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */batchMesh:function batchMesh(mesh,camera){var normalTexture=mesh.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.batchMesh.call(this,mesh,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. Mesh rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.batchMesh(mesh,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#batchBitmapText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.BitmapText} bitmapText - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */batchBitmapText:function batchBitmapText(bitmapText,camera){var normalTexture=bitmapText.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.batchBitmapText.call(this,bitmapText,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. BitmapText rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.batchBitmapText(bitmapText,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#batchDynamicBitmapText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.DynamicBitmapText} bitmapText - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */batchDynamicBitmapText:function batchDynamicBitmapText(bitmapText,camera){var normalTexture=bitmapText.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.batchDynamicBitmapText.call(this,bitmapText,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. DynamicBitmapText rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.batchDynamicBitmapText(bitmapText,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#batchText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Text} text - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */batchText:function batchText(text,camera){var normalTexture=text.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.batchText.call(this,text,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. Text rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.batchText(text,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#batchDynamicTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.DynamicTilemapLayer} tilemapLayer - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */batchDynamicTilemapLayer:function batchDynamicTilemapLayer(tilemapLayer,camera){var normalTexture=tilemapLayer.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.batchDynamicTilemapLayer.call(this,tilemapLayer,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. DynamicTilemapLayer rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.batchDynamicTilemapLayer(tilemapLayer,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.ForwardDiffuseLightPipeline#batchTileSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.TileSprite} tileSprite - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     */batchTileSprite:function batchTileSprite(tileSprite,camera){var normalTexture=tileSprite.texture.dataSource[0];if(normalTexture){this.renderer.setPipeline(this);this.setTexture2D(normalTexture.glTexture,1);TextureTintPipeline.prototype.batchTileSprite.call(this,tileSprite,camera);}else{console.warn('Normal map texture missing for using Light2D pipeline. TileSprite rendered with default pipeline.');this.renderer.pipelines.TextureTintPipeline.batchTileSprite(tileSprite,camera);}}});ForwardDiffuseLightPipeline.LIGHT_COUNT=LIGHT_COUNT;module.exports=ForwardDiffuseLightPipeline;/***/},/* 181 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Wrap=__webpack_require__(44);/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Angle.WrapDegrees\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - [description]\r\n *\r\n * @return {number} [description]\r\n */var WrapDegrees=function WrapDegrees(angle){return Wrap(angle,-180,180);};module.exports=WrapDegrees;/***/},/* 182 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MathWrap=__webpack_require__(44);/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Angle.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - [description]\r\n *\r\n * @return {number} [description]\r\n */var Wrap=function Wrap(angle){return MathWrap(angle,-Math.PI,Math.PI);};module.exports=Wrap;/***/},/* 183 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var EventEmitter=__webpack_require__(14);var TweenBuilder=__webpack_require__(85);var TWEEN_CONST=__webpack_require__(69);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Timeline\r\n * @memberOf Phaser.Tweens\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tweens.TweenManager} manager - [description]\r\n */var Timeline=new Class({Extends:EventEmitter,initialize:function Timeline(manager){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.Timeline#manager\r\n         * @type {Phaser.Tweens.TweenManager}\r\n         * @since 3.0.0\r\n         */this.manager=manager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.Timeline#isTimeline\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.isTimeline=true;/**\r\n         * An array of Tween objects, each containing a unique property and target being tweened.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#data\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.data=[];/**\r\n         * data array doesn't usually change, so we can cache the length\r\n         *\r\n         * @name Phaser.Tweens.Timeline#totalData\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.totalData=0;/**\r\n         * If true then duration, delay, etc values are all frame totals.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#useFrames\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.useFrames=false;/**\r\n         * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n         * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.timeScale=1;/**\r\n         * Loop this tween? Can be -1 for an infinite loop, or an integer.\r\n         * When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#loop\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.loop=0;/**\r\n         * Time in ms/frames before the tween loops.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#loopDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.loopDelay=0;/**\r\n         * How many loops are left to run?\r\n         *\r\n         * @name Phaser.Tweens.Timeline#loopCounter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.loopCounter=0;/**\r\n         * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = true (as it never completes)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#completeDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.completeDelay=0;/**\r\n         * Countdown timer (used by loopDelay and completeDelay)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#countdown\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.countdown=0;/**\r\n         * The current state of the tween\r\n         *\r\n         * @name Phaser.Tweens.Timeline#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.state=TWEEN_CONST.PENDING_ADD;/**\r\n         * The state of the tween when it was paused (used by Resume)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#_pausedState\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._pausedState=TWEEN_CONST.PENDING_ADD;/**\r\n         * Does the Tween start off paused? (if so it needs to be started with Tween.play)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.paused=false;/**\r\n         * Elapsed time in ms/frames of this run through the Tween.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#elapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.elapsed=0;/**\r\n         * Total elapsed time in ms/frames of the entire Tween, including looping.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#totalElapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.totalElapsed=0;/**\r\n         * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.duration=0;/**\r\n         * Value between 0 and 1. The amount through the Tween, excluding loops.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.progress=0;/**\r\n         * Time in ms/frames for all Tweens to complete (including looping)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#totalDuration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.totalDuration=0;/**\r\n         * Value between 0 and 1. The amount through the entire Tween, including looping.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#totalProgress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.totalProgress=0;this.callbacks={onComplete:null,onLoop:null,onStart:null,onUpdate:null,onYoyo:null};this.callbackScope;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#setTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */setTimeScale:function setTimeScale(value){this.timeScale=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#getTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getTimeScale:function getTimeScale(){return this.timeScale;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#isPlaying\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isPlaying:function isPlaying(){return this.state===TWEEN_CONST.ACTIVE;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */add:function add(config){return this.queue(TweenBuilder(this,config));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#queue\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */queue:function queue(tween){if(!this.isPlaying()){tween.parent=this;tween.parentIsTimeline=true;this.data.push(tween);this.totalData=this.data.length;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#hasOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hasOffset:function hasOffset(tween){return tween.offset!==null;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#isOffsetAbsolute\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */isOffsetAbsolute:function isOffsetAbsolute(value){return typeof value==='number';},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#isOffsetRelative\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */isOffsetRelative:function isOffsetRelative(value){var t=typeof value==='undefined'?'undefined':_typeof(value);if(t==='string'){var op=value[0];if(op==='-'||op==='+'){return true;}}return false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#getRelativeOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - [description]\r\n     * @param {number} base - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */getRelativeOffset:function getRelativeOffset(value,base){var op=value[0];var num=parseFloat(value.substr(2));var result=base;switch(op){case'+':result+=num;break;case'-':result-=num;break;}//  Cannot ever be < 0\nreturn Math.max(0,result);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#calcDuration\r\n     * @since 3.0.0\r\n     */calcDuration:function calcDuration(){var prevEnd=0;var totalDuration=0;var offsetDuration=0;for(var i=0;i<this.totalData;i++){var tween=this.data[i];tween.init();if(this.hasOffset(tween)){if(this.isOffsetAbsolute(tween.offset)){//  An actual number, so it defines the start point from the beginning of the timeline\ntween.calculatedOffset=tween.offset;if(tween.offset===0){offsetDuration=0;}}else if(this.isOffsetRelative(tween.offset)){//  A relative offset (i.e. '-=1000', so starts at 'offset' ms relative to the PREVIOUS Tweens ending time)\ntween.calculatedOffset=this.getRelativeOffset(tween.offset,prevEnd);}}else{//  Sequential\ntween.calculatedOffset=offsetDuration;}prevEnd=tween.totalDuration+tween.calculatedOffset;totalDuration+=tween.totalDuration;offsetDuration+=tween.totalDuration;}//  Excludes loop values\nthis.duration=totalDuration;this.loopCounter=this.loop===-1?999999999999:this.loop;if(this.loopCounter>0){this.totalDuration=this.duration+this.completeDelay+(this.duration+this.loopDelay)*this.loopCounter;}else{this.totalDuration=this.duration+this.completeDelay;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#init\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */init:function init(){this.calcDuration();this.progress=0;this.totalProgress=0;if(this.paused){this.state=TWEEN_CONST.PAUSED;return false;}else{return true;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#resetTweens\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} resetFromLoop - [description]\r\n     */resetTweens:function resetTweens(resetFromLoop){for(var i=0;i<this.totalData;i++){var tween=this.data[i];tween.play(resetFromLoop);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#setCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} type - [description]\r\n     * @param {function} callback - [description]\r\n     * @param {array} [params] - [description]\r\n     * @param {object} [scope] - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */setCallback:function setCallback(type,callback,params,scope){if(Timeline.TYPES.indexOf(type)!==-1){this.callbacks[type]={func:callback,scope:scope,params:params};}return this;},/**\r\n     * Delegates #makeActive to the Tween manager.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#makeActive\r\n     * @since 3.3.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - The tween object to make active.\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} The Timeline's Tween Manager object.\r\n     */makeActive:function makeActive(tween){return this.manager.makeActive(tween);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#play\r\n     * @since 3.0.0\r\n     */play:function play(){if(this.state===TWEEN_CONST.ACTIVE){return;}if(this.paused){this.paused=false;this.manager.makeActive(this);return;}else{this.resetTweens(false);this.state=TWEEN_CONST.ACTIVE;}var onStart=this.callbacks.onStart;if(onStart){onStart.func.apply(onStart.scope,onStart.params);}this.emit('start',this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#nextState\r\n     * @since 3.0.0\r\n     */nextState:function nextState(){if(this.loopCounter>0){//  Reset the elapsed time\n//  TODO: Probably ought to be set to the remainder from elapsed - duration\n//  as the tweens nearly always over-run by a few ms due to rAf\nthis.elapsed=0;this.progress=0;this.loopCounter--;var onLoop=this.callbacks.onLoop;if(onLoop){onLoop.func.apply(onLoop.scope,onLoop.params);}this.emit('loop',this,this.loopCounter);this.resetTweens(true);if(this.loopDelay>0){this.countdown=this.loopDelay;this.state=TWEEN_CONST.LOOP_DELAY;}else{this.state=TWEEN_CONST.ACTIVE;}}else if(this.completeDelay>0){this.countdown=this.completeDelay;this.state=TWEEN_CONST.COMPLETE_DELAY;}else{var onComplete=this.callbacks.onComplete;if(onComplete){onComplete.func.apply(onComplete.scope,onComplete.params);}this.emit('complete',this);this.state=TWEEN_CONST.PENDING_REMOVE;}},/**\r\n     * Returns 'true' if this Timeline has finished and should be removed from the Tween Manager.\r\n     * Otherwise, returns false.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestamp - [description]\r\n     * @param {number} delta - [description]\r\n     *\r\n     * @return {boolean} Returns `true` if this Timeline has finished and should be removed from the Tween Manager.\r\n     */update:function update(timestamp,delta){if(this.state===TWEEN_CONST.PAUSED){return;}var rawDelta=delta;if(this.useFrames){delta=1*this.manager.timeScale;}delta*=this.timeScale;this.elapsed+=delta;this.progress=Math.min(this.elapsed/this.duration,1);this.totalElapsed+=delta;this.totalProgress=Math.min(this.totalElapsed/this.totalDuration,1);switch(this.state){case TWEEN_CONST.ACTIVE:var stillRunning=this.totalData;for(var i=0;i<this.totalData;i++){var tween=this.data[i];if(tween.update(timestamp,rawDelta)){stillRunning--;}}var onUpdate=this.callbacks.onUpdate;if(onUpdate){onUpdate.func.apply(onUpdate.scope,onUpdate.params);}this.emit('update',this);//  Anything still running? If not, we're done\nif(stillRunning===0){this.nextState();}break;case TWEEN_CONST.LOOP_DELAY:this.countdown-=delta;if(this.countdown<=0){this.state=TWEEN_CONST.ACTIVE;}break;case TWEEN_CONST.COMPLETE_DELAY:this.countdown-=delta;if(this.countdown<=0){var onComplete=this.callbacks.onComplete;if(onComplete){onComplete.func.apply(onComplete.scope,onComplete.params);}this.emit('complete',this);this.state=TWEEN_CONST.PENDING_REMOVE;}break;}return this.state===TWEEN_CONST.PENDING_REMOVE;},/**\r\n     * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#stop\r\n     * @since 3.0.0\r\n     */stop:function stop(){this.state=TWEEN_CONST.PENDING_REMOVE;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */pause:function pause(){if(this.state===TWEEN_CONST.PAUSED){return;}this.paused=true;this._pausedState=this.state;this.state=TWEEN_CONST.PAUSED;this.emit('pause',this);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */resume:function resume(){if(this.state===TWEEN_CONST.PAUSED){this.paused=false;this.state=this._pausedState;}this.emit('resume',this);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#hasTarget\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} target - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hasTarget:function hasTarget(target){for(var i=0;i<this.data.length;i++){if(this.data[i].hasTarget(target)){return true;}}return false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){for(var i=0;i<this.data.length;i++){this.data[i].stop();}}});Timeline.TYPES=['onStart','onUpdate','onLoop','onComplete','onYoyo'];module.exports=Timeline;/***/},/* 184 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clone=__webpack_require__(57);var Defaults=__webpack_require__(114);var GetAdvancedValue=__webpack_require__(8);var GetBoolean=__webpack_require__(70);var GetEaseFunction=__webpack_require__(72);var GetNewValue=__webpack_require__(86);var GetTargets=__webpack_require__(116);var GetTweens=__webpack_require__(186);var GetValue=__webpack_require__(5);var Timeline=__webpack_require__(183);var TweenBuilder=__webpack_require__(85);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.TimelineBuilder\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tweens.TweenManager} manager - [description]\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.Tweens.Timeline} [description]\r\n */var TimelineBuilder=function TimelineBuilder(manager,config){var timeline=new Timeline(manager);var tweens=GetTweens(config);if(tweens.length===0){timeline.paused=true;return timeline;}var defaults=Clone(Defaults);defaults.targets=GetTargets(config);//  totalDuration: If specified each tween in the Timeline is given an equal portion of the totalDuration\nvar totalDuration=GetAdvancedValue(config,'totalDuration',0);if(totalDuration>0){defaults.duration=Math.floor(totalDuration/tweens.length);}else{defaults.duration=GetNewValue(config,'duration',defaults.duration);}defaults.delay=GetNewValue(config,'delay',defaults.delay);defaults.easeParams=GetValue(config,'easeParams',defaults.easeParams);defaults.ease=GetEaseFunction(GetValue(config,'ease',defaults.ease),defaults.easeParams);defaults.hold=GetNewValue(config,'hold',defaults.hold);defaults.repeat=GetNewValue(config,'repeat',defaults.repeat);defaults.repeatDelay=GetNewValue(config,'repeatDelay',defaults.repeatDelay);defaults.yoyo=GetBoolean(config,'yoyo',defaults.yoyo);defaults.flipX=GetBoolean(config,'flipX',defaults.flipX);defaults.flipY=GetBoolean(config,'flipY',defaults.flipY);//  Create the Tweens\nfor(var i=0;i<tweens.length;i++){timeline.queue(TweenBuilder(timeline,tweens[i],defaults));}timeline.completeDelay=GetAdvancedValue(config,'completeDelay',0);timeline.loop=Math.round(GetAdvancedValue(config,'loop',0));timeline.loopDelay=Math.round(GetAdvancedValue(config,'loopDelay',0));timeline.paused=GetBoolean(config,'paused',false);timeline.useFrames=GetBoolean(config,'useFrames',false);//  Callbacks\nvar scope=GetValue(config,'callbackScope',timeline);var timelineArray=[timeline];var onStart=GetValue(config,'onStart',false);//  The Start of the Timeline\nif(onStart){var onStartScope=GetValue(config,'onStartScope',scope);var onStartParams=GetValue(config,'onStartParams',[]);timeline.setCallback('onStart',onStart,timelineArray.concat(onStartParams),onStartScope);}var onUpdate=GetValue(config,'onUpdate',false);//  Every time the Timeline updates (regardless which Tweens are running)\nif(onUpdate){var onUpdateScope=GetValue(config,'onUpdateScope',scope);var onUpdateParams=GetValue(config,'onUpdateParams',[]);timeline.setCallback('onUpdate',onUpdate,timelineArray.concat(onUpdateParams),onUpdateScope);}var onLoop=GetValue(config,'onLoop',false);//  Called when the whole Timeline loops\nif(onLoop){var onLoopScope=GetValue(config,'onLoopScope',scope);var onLoopParams=GetValue(config,'onLoopParams',[]);timeline.setCallback('onLoop',onLoop,timelineArray.concat(onLoopParams),onLoopScope);}var onYoyo=GetValue(config,'onYoyo',false);//  Called when a Timeline yoyos\nif(onYoyo){var onYoyoScope=GetValue(config,'onYoyoScope',scope);var onYoyoParams=GetValue(config,'onYoyoParams',[]);timeline.setCallback('onYoyo',onYoyo,timelineArray.concat(null,onYoyoParams),onYoyoScope);}var onComplete=GetValue(config,'onComplete',false);//  Called when the Timeline completes, after the completeDelay, etc.\nif(onComplete){var onCompleteScope=GetValue(config,'onCompleteScope',scope);var onCompleteParams=GetValue(config,'onCompleteParams',[]);timeline.setCallback('onComplete',onComplete,timelineArray.concat(onCompleteParams),onCompleteScope);}return timeline;};module.exports=TimelineBuilder;/***/},/* 185 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Defaults=__webpack_require__(114);var GetAdvancedValue=__webpack_require__(8);var GetBoolean=__webpack_require__(70);var GetEaseFunction=__webpack_require__(72);var GetNewValue=__webpack_require__(86);var GetValue=__webpack_require__(5);var GetValueOp=__webpack_require__(115);var Tween=__webpack_require__(113);var TweenData=__webpack_require__(112);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.NumberTweenBuilder\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)} parent - [description]\r\n * @param {object} config - [description]\r\n * @param {Phaser.Tweens.TweenConfigDefaults} defaults - [description]\r\n *\r\n * @return {Phaser.Tweens.Tween} [description]\r\n */var NumberTweenBuilder=function NumberTweenBuilder(parent,config,defaults){if(defaults===undefined){defaults=Defaults;}//  var tween = this.tweens.addCounter({\n//      from: 100,\n//      to: 200,\n//      ... (normal tween properties)\n//  })\n//\n//  Then use it in your game via:\n//\n//  tween.getValue()\nvar from=GetValue(config,'from',0);var to=GetValue(config,'to',1);var targets=[{value:from}];var delay=GetNewValue(config,'delay',defaults.delay);var duration=GetNewValue(config,'duration',defaults.duration);var easeParams=GetValue(config,'easeParams',defaults.easeParams);var ease=GetEaseFunction(GetValue(config,'ease',defaults.ease),easeParams);var hold=GetNewValue(config,'hold',defaults.hold);var repeat=GetNewValue(config,'repeat',defaults.repeat);var repeatDelay=GetNewValue(config,'repeatDelay',defaults.repeatDelay);var yoyo=GetBoolean(config,'yoyo',defaults.yoyo);var data=[];var ops=GetValueOp('value',to);var tweenData=TweenData(targets[0],'value',ops.getEnd,ops.getStart,ease,delay,duration,yoyo,hold,repeat,repeatDelay,false,false);tweenData.start=from;tweenData.current=from;tweenData.to=to;data.push(tweenData);var tween=new Tween(parent,data,targets);tween.offset=GetAdvancedValue(config,'offset',null);tween.completeDelay=GetAdvancedValue(config,'completeDelay',0);tween.loop=Math.round(GetAdvancedValue(config,'loop',0));tween.loopDelay=Math.round(GetAdvancedValue(config,'loopDelay',0));tween.paused=GetBoolean(config,'paused',false);tween.useFrames=GetBoolean(config,'useFrames',false);//  Set the Callbacks\nvar scope=GetValue(config,'callbackScope',tween);//  Callback parameters: 0 = a reference to the Tween itself, 1 = the target/s of the Tween, ... your own params\nvar tweenArray=[tween,null];var callbacks=Tween.TYPES;for(var i=0;i<callbacks.length;i++){var type=callbacks[i];var callback=GetValue(config,type,false);if(callback){var callbackScope=GetValue(config,type+'Scope',scope);var callbackParams=GetValue(config,type+'Params',[]);//  The null is reset to be the Tween target\ntween.setCallback(type,callback,tweenArray.concat(callbackParams),callbackScope);}}return tween;};module.exports=NumberTweenBuilder;/***/},/* 186 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetValue=__webpack_require__(5);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.GetTweens\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {array} [description]\r\n */var GetTweens=function GetTweens(config){var tweens=GetValue(config,'tweens',null);if(tweens===null){return[];}else if(typeof tweens==='function'){tweens=tweens.call();}if(!Array.isArray(tweens)){tweens=[tweens];}return tweens;};module.exports=GetTweens;/***/},/* 187 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RESERVED=__webpack_require__(404);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tweens.Builders.GetProps\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {array} [description]\r\n */var GetProps=function GetProps(config){var key;var keys=[];//  First see if we have a props object\nif(config.hasOwnProperty('props')){for(key in config.props){//  Skip any property that starts with an underscore\nif(key.substr(0,1)!=='_'){keys.push({key:key,value:config.props[key]});}}}else{for(key in config){//  Skip any property that is in the ReservedProps list or that starts with an underscore\nif(RESERVED.indexOf(key)===-1&&key.substr(0,1)!=='_'){keys.push({key:key,value:config[key]});}}}return keys;};module.exports=GetProps;/***/},/* 188 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetFastValue=__webpack_require__(2);/**\r\n * @typedef {object} TimerEventConfig\r\n *\r\n * @property {number} [delay=0] - [description]\r\n * @property {number} [repeat=0] - [description]\r\n * @property {boolean} [loop=false] - [description]\r\n * @property {function} [callback] - [description]\r\n * @property {*} [callbackScope] - [description]\r\n * @property {Array.<*>} [args] - [description]\r\n * @property {number} [timeScale=1] - [description]\r\n * @property {number} [startAt=1] - [description]\r\n * @property {boolean} [paused=false] - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TimerEvent\r\n * @memberOf Phaser.Time\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {TimerEventConfig} config - [description]\r\n */var TimerEvent=new Class({initialize:function TimerEvent(config){/**\r\n         * The delay in ms at which this TimerEvent fires.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#delay\r\n         * @type {number}\r\n         * @default 0\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.delay=0;/**\r\n         * The total number of times this TimerEvent will repeat before finishing.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#repeat\r\n         * @type {number}\r\n         * @default 0\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.repeat=0;/**\r\n         * If repeating this contains the current repeat count.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#repeatCount\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.repeatCount=0;/**\r\n         * True if this TimerEvent loops, otherwise false.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#loop\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.loop=false;/**\r\n         * The callback that will be called when the TimerEvent occurs.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#callback\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */this.callback;/**\r\n         * The scope in which the callback will be called.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#callbackScope\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.callbackScope;/**\r\n         * Additional arguments to be passed to the callback.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#args\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.args;/**\r\n         * Scale the time causing this TimerEvent to update.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.timeScale=1;/**\r\n         * Start this many MS into the elapsed (useful if you want a long duration with repeat, but for the first loop to fire quickly)\r\n         *\r\n         * @name Phaser.Time.TimerEvent#startAt\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.startAt=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.TimerEvent#elapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.elapsed=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.TimerEvent#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.paused=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.TimerEvent#hasDispatched\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.hasDispatched=false;this.reset(config);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.TimerEvent#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TimerEventConfig} config - [description]\r\n     *\r\n     * @return {Phaser.Time.TimerEvent} This TimerEvent object.\r\n     */reset:function reset(config){this.delay=GetFastValue(config,'delay',0);//  Can also be set to -1 for an infinite loop (same as setting loop: true)\nthis.repeat=GetFastValue(config,'repeat',0);this.loop=GetFastValue(config,'loop',false);this.callback=GetFastValue(config,'callback',undefined);this.callbackScope=GetFastValue(config,'callbackScope',this.callback);this.args=GetFastValue(config,'args',[]);this.timeScale=GetFastValue(config,'timeScale',1);this.startAt=GetFastValue(config,'startAt',0);this.paused=GetFastValue(config,'paused',false);this.elapsed=this.startAt;this.hasDispatched=false;this.repeatCount=this.repeat===-1||this.loop?999999999999:this.repeat;return this;},/**\r\n     * Gets the progress of the current iteration, not factoring in repeats.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getProgress\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getProgress:function getProgress(){return this.elapsed/this.delay;},/**\r\n     * Gets the progress of the timer overall, factoring in repeats.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getOverallProgress\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getOverallProgress:function getOverallProgress(){if(this.repeat>0){var totalDuration=this.delay+this.delay*this.repeat;var totalElapsed=this.elapsed+this.delay*(this.repeat-this.repeatCount);return totalElapsed/totalDuration;}else{return this.getProgress();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getRepeatCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getRepeatCount:function getRepeatCount(){return this.repeatCount;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getElapsed\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getElapsed:function getElapsed(){return this.elapsed;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getElapsedSeconds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getElapsedSeconds:function getElapsedSeconds(){return this.elapsed*0.001;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.TimerEvent#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} dispatchCallback - [description]\r\n     */remove:function remove(dispatchCallback){if(dispatchCallback===undefined){dispatchCallback=false;}this.elapsed=this.delay;this.hasDispatched=!dispatchCallback;this.repeatCount=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.TimerEvent#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.callback=undefined;this.callbackScope=undefined;this.args=[];}});module.exports=TimerEvent;/***/},/* 189 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var CONST=__webpack_require__(22);var GameObject=__webpack_require__(1);var StaticTilemapLayerRender=__webpack_require__(413);var TilemapComponents=__webpack_require__(91);var Utils=__webpack_require__(38);/**\r\n * @classdesc\r\n * A StaticTilemapLayer is a game object that renders LayerData from a Tilemap. A\r\n * StaticTilemapLayer can only render tiles from a single tileset.\r\n *\r\n * A StaticTilemapLayer is optimized for speed over flexibility. You cannot apply per-tile\r\n * effects like tint or alpha. You cannot change the tiles in a StaticTilemapLayer. Use this\r\n * over a DynamicTilemapLayer when you don't need either of those features.\r\n *\r\n * @class StaticTilemapLayer\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {Phaser.Tilemaps.Tilemap} tilemap - The Tilemap this layer is a part of.\r\n * @param {integer} layerIndex - The index of the LayerData associated with this layer.\r\n * @param {Phaser.Tilemaps.Tileset} tileset - The tileset used to render the tiles in this layer.\r\n * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n */var StaticTilemapLayer=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.ComputedSize,Components.Depth,Components.Flip,Components.GetBounds,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.Transform,Components.Visible,Components.ScrollFactor,StaticTilemapLayerRender],initialize:function StaticTilemapLayer(scene,tilemap,layerIndex,tileset,x,y){GameObject.call(this,scene,'StaticTilemapLayer');/**\r\n         * Used internally by physics system to perform fast type checks.\r\n         *\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#isTilemap\r\n         * @type {boolean}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isTilemap=true;/**\r\n         * The Tilemap that this layer is a part of.\r\n         *\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#tilemap\r\n         * @type {Phaser.Tilemaps.Tilemap}\r\n         * @since 3.0.0\r\n         */this.tilemap=tilemap;/**\r\n         * The index of the LayerData associated with this layer.\r\n         *\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#layerIndex\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.layerIndex=layerIndex;/**\r\n         * The LayerData associated with this layer. LayerData can only be associated with one\r\n         * tilemap layer.\r\n         *\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.0.0\r\n         */this.layer=tilemap.layers[layerIndex];this.layer.tilemapLayer=this;// Link the LayerData with this static tilemap layer\n/**\r\n         * The Tileset associated with this layer. A tilemap layer can only render from one Tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#tileset\r\n         * @type {Phaser.Tilemaps.Tileset}\r\n         * @since 3.0.0\r\n         */this.tileset=tileset;/**\r\n         * Used internally with the canvas render. This holds the tiles that are visible within the\r\n         * camera.\r\n         *\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#culledTiles\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.culledTiles=[];/**\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#vertexBuffer\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.vertexBuffer=null;/**\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.renderer=scene.sys.game.renderer;/**\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#bufferData\r\n         * @type {ArrayBuffer}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.bufferData=null;/**\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.vertexViewF32=null;/**\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#vertexViewU32\r\n         * @type {Uint32Array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.vertexViewU32=null;/**\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#dirty\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.dirty=true;/**\r\n         * @name Phaser.Tilemaps.StaticTilemapLayer#vertexCount\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.vertexCount=0;this.setAlpha(this.layer.alpha);this.setPosition(x,y);this.setOrigin();this.setSize(this.layer.tileWidth*this.layer.width,this.layer.tileHeight*this.layer.height);this.initPipeline('TextureTintPipeline');if(scene.sys.game.config.renderType===CONST.WEBGL){scene.sys.game.renderer.onContextRestored(function(){this.dirty=true;this.vertexBuffer=null;},this);}},/**\r\n     * Upload the tile data to a VBO.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#upload\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to render to.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */upload:function upload(camera){var tileset=this.tileset;var mapWidth=this.layer.width;var mapHeight=this.layer.height;var width=tileset.image.source[0].width;var height=tileset.image.source[0].height;var mapData=this.layer.data;var renderer=this.renderer;var tile;var row;var col;var texCoords;if(renderer.gl){var pipeline=renderer.pipelines.TextureTintPipeline;if(this.dirty){var gl=renderer.gl;var vertexBuffer=this.vertexBuffer;var bufferData=this.bufferData;var voffset=0;var vertexCount=0;var bufferSize=mapWidth*mapHeight*pipeline.vertexSize*6;if(bufferData===null){bufferData=new ArrayBuffer(bufferSize);this.bufferData=bufferData;this.vertexViewF32=new Float32Array(bufferData);this.vertexViewU32=new Uint32Array(bufferData);}var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;for(row=0;row<mapHeight;++row){for(col=0;col<mapWidth;++col){tile=mapData[row][col];if(tile===null||tile.index===-1){continue;}var tx=tile.pixelX;var ty=tile.pixelY;var txw=tx+tile.width;var tyh=ty+tile.height;texCoords=tileset.getTileTextureCoordinates(tile.index);if(texCoords===null){continue;}var u0=texCoords.x/width;var v0=texCoords.y/height;var u1=(texCoords.x+tile.width)/width;var v1=(texCoords.y+tile.height)/height;var tx0=tx;var ty0=ty;var tx1=tx;var ty1=tyh;var tx2=txw;var ty2=tyh;var tx3=txw;var ty3=ty;var tint=Utils.getTintAppendFloatAlpha(0xffffff,this.alpha*tile.alpha);vertexViewF32[voffset+0]=tx0;vertexViewF32[voffset+1]=ty0;vertexViewF32[voffset+2]=u0;vertexViewF32[voffset+3]=v0;vertexViewU32[voffset+4]=tint;vertexViewF32[voffset+5]=tx1;vertexViewF32[voffset+6]=ty1;vertexViewF32[voffset+7]=u0;vertexViewF32[voffset+8]=v1;vertexViewU32[voffset+9]=tint;vertexViewF32[voffset+10]=tx2;vertexViewF32[voffset+11]=ty2;vertexViewF32[voffset+12]=u1;vertexViewF32[voffset+13]=v1;vertexViewU32[voffset+14]=tint;vertexViewF32[voffset+15]=tx0;vertexViewF32[voffset+16]=ty0;vertexViewF32[voffset+17]=u0;vertexViewF32[voffset+18]=v0;vertexViewU32[voffset+19]=tint;vertexViewF32[voffset+20]=tx2;vertexViewF32[voffset+21]=ty2;vertexViewF32[voffset+22]=u1;vertexViewF32[voffset+23]=v1;vertexViewU32[voffset+24]=tint;vertexViewF32[voffset+25]=tx3;vertexViewF32[voffset+26]=ty3;vertexViewF32[voffset+27]=u1;vertexViewF32[voffset+28]=v0;vertexViewU32[voffset+29]=tint;voffset+=30;vertexCount+=6;}}this.vertexCount=vertexCount;this.dirty=false;if(vertexBuffer===null){vertexBuffer=renderer.createVertexBuffer(bufferData,gl.STATIC_DRAW);this.vertexBuffer=vertexBuffer;}else{renderer.setVertexBuffer(vertexBuffer);gl.bufferSubData(gl.ARRAY_BUFFER,0,bufferData);}}pipeline.modelIdentity();pipeline.modelTranslate(this.x-camera.scrollX*this.scrollFactorX,this.y-camera.scrollY*this.scrollFactorY,0.0);pipeline.modelScale(this.scaleX,this.scaleY,1.0);pipeline.viewLoad2D(camera.matrix.matrix);}return this;},/**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#calculateFacesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - The x coordinate.\r\n     * @param {integer} tileY - The y coordinate.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */calculateFacesAt:function calculateFacesAt(tileX,tileY){TilemapComponents.CalculateFacesAt(tileX,tileY,this.layer);return this;},/**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#calculateFacesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */calculateFacesWithin:function calculateFacesWithin(tileX,tileY,width,height){TilemapComponents.CalculateFacesWithin(tileX,tileY,width,height,this.layer);return this;},/**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#createFromTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {object} spriteConfig - The config object to pass into the Sprite creator (i.e.\r\n     * scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n     */createFromTiles:function createFromTiles(indexes,replacements,spriteConfig,scene,camera){return TilemapComponents.CreateFromTiles(indexes,replacements,spriteConfig,scene,camera,this.layer);},/**\r\n     * Returns the tiles in the given layer that are within the cameras viewport.\r\n     * This is used internally.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#cull\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */cull:function cull(camera){return TilemapComponents.CullTiles(this.layer,camera,this.culledTiles);},/**\r\n     * Destroys this StaticTilemapLayer and removes its link to the associated LayerData.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){// Uninstall this layer only if it is still installed on the LayerData object\nif(this.layer.tilemapLayer===this){this.layer.tilemapLayer=undefined;}this.tilemap=undefined;this.layer=undefined;this.tileset=undefined;GameObject.prototype.destroy.call(this);},/**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#findByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The tile index value to search for.\r\n     * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the\r\n     * bottom-right. Otherwise it scans from the top-left.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */findByIndex:function findByIndex(findIndex,skip,reverse){return TilemapComponents.FindByIndex(findIndex,skip,reverse,this.layer);},/**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#findTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile}\r\n     */findTile:function findTile(callback,context,tileX,tileY,width,height,filteringOptions){return TilemapComponents.FindTile(callback,context,tileX,tileY,width,height,filteringOptions,this.layer);},/**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#filterTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */filterTiles:function filterTiles(callback,context,tileX,tileY,width,height,filteringOptions){return TilemapComponents.FilterTiles(callback,context,tileX,tileY,width,height,filteringOptions,this.layer);},/**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#forEachTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */forEachTile:function forEachTile(callback,context,tileX,tileY,width,height,filteringOptions){TilemapComponents.ForEachTile(callback,context,tileX,tileY,width,height,filteringOptions,this.layer);return this;},/**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#getTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile\r\n     * object with an index of -1.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n     */getTileAt:function getTileAt(tileX,tileY,nonNull){return TilemapComponents.GetTileAt(tileX,tileY,nonNull,this.layer);},/**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#getTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile\r\n     * object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates\r\n     * were invalid.\r\n     */getTileAtWorldXY:function getTileAtWorldXY(worldX,worldY,nonNull,camera){return TilemapComponents.GetTileAtWorldXY(worldX,worldY,nonNull,camera,this.layer);},/**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#getTilesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */getTilesWithin:function getTilesWithin(tileX,tileY,width,height,filteringOptions){return TilemapComponents.GetTilesWithin(tileX,tileY,width,height,filteringOptions,this.layer);},/**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#getTilesWithinWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */getTilesWithinWorldXY:function getTilesWithinWorldXY(worldX,worldY,width,height,filteringOptions,camera){return TilemapComponents.GetTilesWithinWorldXY(worldX,worldY,width,height,filteringOptions,camera,this.layer);},/**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#getTilesWithinShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */getTilesWithinShape:function getTilesWithinShape(shape,filteringOptions,camera){return TilemapComponents.GetTilesWithinShape(shape,filteringOptions,camera,this.layer);},/**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#hasTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     *\r\n     * @return {boolean}\r\n     */hasTileAt:function hasTileAt(tileX,tileY){return TilemapComponents.HasTileAt(tileX,tileY,this.layer);},/**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#hasTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {boolean}\r\n     */hasTileAtWorldXY:function hasTileAtWorldXY(worldX,worldY,camera){return TilemapComponents.HasTileAtWorldXY(worldX,worldY,camera,this.layer);},/**\r\n     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#renderDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {object} styleConfig - An object specifying the colors to use for the debug drawing.\r\n     * @param {?Color} [styleConfig.tileColor=blue] - Color to use for drawing a filled rectangle at\r\n     * non-colliding tile locations. If set to null, non-colliding tiles will not be drawn.\r\n     * @param {?Color} [styleConfig.collidingTileColor=orange] - Color to use for drawing a filled\r\n     * rectangle at colliding tile locations. If set to null, colliding tiles will not be drawn.\r\n     * @param {?Color} [styleConfig.faceColor=grey] - Color to use for drawing a line at interesting\r\n     * tile faces. If set to null, interesting tile faces will not be drawn.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */renderDebug:function renderDebug(graphics,styleConfig){TilemapComponents.RenderDebug(graphics,styleConfig,this.layer);return this;},/**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */setCollision:function setCollision(indexes,collides,recalculateFaces){TilemapComponents.SetCollision(indexes,collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollisionBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} start - The first index of the tile to be set for collision.\r\n     * @param {integer} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */setCollisionBetween:function setCollisionBetween(start,stop,collides,recalculateFaces){TilemapComponents.SetCollisionBetween(start,stop,collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollisionByProperty\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should\r\n     * be checked.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */setCollisionByProperty:function setCollisionByProperty(properties,collides,recalculateFaces){TilemapComponents.SetCollisionByProperty(properties,collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollisionByExclusion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */setCollisionByExclusion:function setCollisionByExclusion(indexes,collides,recalculateFaces){TilemapComponents.SetCollisionByExclusion(indexes,collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see setTileLocationCallback.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#setTileIndexCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes to have a\r\n     * collision callback set for.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */setTileIndexCallback:function setTileIndexCallback(indexes,callback,callbackContext){TilemapComponents.SetTileIndexCallback(indexes,callback,callbackContext,this.layer);return this;},/**\r\n     * Sets collision on the tiles within a layer by checking each tiles collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tiles collision group, the tile's colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#setCollisionFromCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */setCollisionFromCollisionGroup:function setCollisionFromCollisionGroup(collides,recalculateFaces){TilemapComponents.SetCollisionFromCollisionGroup(collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#setTileLocationCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     *\r\n     * @return {Phaser.Tilemaps.StaticTilemapLayer} This Tilemap Layer object.\r\n     */setTileLocationCallback:function setTileLocationCallback(tileX,tileY,width,height,callback,callbackContext){TilemapComponents.SetTileLocationCallback(tileX,tileY,width,height,callback,callbackContext,this.layer);return this;},/**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#tileToWorldX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {number}\r\n     */tileToWorldX:function tileToWorldX(tileX,camera){return TilemapComponents.TileToWorldX(tileX,camera,this.layer);},/**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#tileToWorldY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileY - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {number}\r\n     */tileToWorldY:function tileToWorldY(tileY,camera){return TilemapComponents.TileToWorldY(tileY,camera,this.layer);},/**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#tileToWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {Phaser.Math.Vector2} [point] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2}\r\n     */tileToWorldXY:function tileToWorldXY(tileX,tileY,point,camera){return TilemapComponents.TileToWorldXY(tileX,tileY,point,camera,this.layer);},/**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#worldToTileX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {number}\r\n     */worldToTileX:function worldToTileX(worldX,snapToFloor,camera){return TilemapComponents.WorldToTileX(worldX,snapToFloor,camera,this.layer);},/**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldY - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {number}\r\n     */worldToTileY:function worldToTileY(worldY,snapToFloor,camera){return TilemapComponents.WorldToTileY(worldY,snapToFloor,camera,this.layer);},/**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.StaticTilemapLayer#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Math.Vector2} [point] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2}\r\n     */worldToTileXY:function worldToTileXY(worldX,worldY,snapToFloor,point,camera){return TilemapComponents.WorldToTileXY(worldX,worldY,snapToFloor,point,camera,this.layer);}});module.exports=StaticTilemapLayer;/***/},/* 190 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(12);var DynamicTilemapLayerRender=__webpack_require__(416);var GameObject=__webpack_require__(1);var TilemapComponents=__webpack_require__(91);/**\r\n * @classdesc\r\n * A DynamicTilemapLayer is a game object that renders LayerData from a Tilemap. A\r\n * DynamicTilemapLayer can only render tiles from a single tileset.\r\n *\r\n * A DynamicTilemapLayer trades some speed for being able to apply powerful effects. Unlike a\r\n * StaticTilemapLayer, you can apply per-tile effects like tint or alpha, and you can change the\r\n * tiles in a DynamicTilemapLayer. Use this over a StaticTilemapLayer when you need those\r\n * features.\r\n *\r\n * @class DynamicTilemapLayer\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {Phaser.Tilemaps.Tilemap} tilemap - The Tilemap this layer is a part of.\r\n * @param {integer} layerIndex - The index of the LayerData associated with this layer.\r\n * @param {Phaser.Tilemaps.Tileset} tileset - The tileset used to render the tiles in this layer.\r\n * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n */var DynamicTilemapLayer=new Class({Extends:GameObject,Mixins:[Components.Alpha,Components.BlendMode,Components.ComputedSize,Components.Depth,Components.Flip,Components.GetBounds,Components.Origin,Components.Pipeline,Components.ScaleMode,Components.Transform,Components.Visible,Components.ScrollFactor,DynamicTilemapLayerRender],initialize:function DynamicTilemapLayer(scene,tilemap,layerIndex,tileset,x,y){GameObject.call(this,scene,'DynamicTilemapLayer');/**\r\n         * Used internally by physics system to perform fast type checks.\r\n         *\r\n         * @name Phaser.Tilemaps.DynamicTilemapLayer#isTilemap\r\n         * @type {boolean}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isTilemap=true;/**\r\n         * The Tilemap that this layer is a part of.\r\n         *\r\n         * @name Phaser.Tilemaps.DynamicTilemapLayer#tilemap\r\n         * @type {Phaser.Tilemaps.Tilemap}\r\n         * @since 3.0.0\r\n         */this.tilemap=tilemap;/**\r\n         * The index of the LayerData associated with this layer.\r\n         *\r\n         * @name Phaser.Tilemaps.DynamicTilemapLayer#layerIndex\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.layerIndex=layerIndex;/**\r\n         * The LayerData associated with this layer. LayerData can only be associated with one\r\n         * tilemap layer.\r\n         *\r\n         * @name Phaser.Tilemaps.DynamicTilemapLayer#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.0.0\r\n         */this.layer=tilemap.layers[layerIndex];this.layer.tilemapLayer=this;// Link the LayerData with this static tilemap layer\n/**\r\n         * The Tileset associated with this layer. A tilemap layer can only render from one Tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.DynamicTilemapLayer#tileset\r\n         * @type {Phaser.Tilemaps.Tileset}\r\n         * @since 3.0.0\r\n         */this.tileset=tileset;/**\r\n         * Used internally with the canvas render. This holds the tiles that are visible within the\r\n         * camera.\r\n         *\r\n         * @name Phaser.Tilemaps.DynamicTilemapLayer#culledTiles\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.culledTiles=[];this.setAlpha(this.layer.alpha);this.setPosition(x,y);this.setOrigin();this.setSize(this.layer.tileWidth*this.layer.width,this.layer.tileHeight*this.layer.height);this.initPipeline('TextureTintPipeline');},/**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#calculateFacesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - The x coordinate.\r\n     * @param {integer} tileY - The y coordinate.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */calculateFacesAt:function calculateFacesAt(tileX,tileY){TilemapComponents.CalculateFacesAt(tileX,tileY,this.layer);return this;},/**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#calculateFacesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */calculateFacesWithin:function calculateFacesWithin(tileX,tileY,width,height){TilemapComponents.CalculateFacesWithin(tileX,tileY,width,height,this.layer);return this;},/**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#createFromTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {object} spriteConfig - The config object to pass into the Sprite creator (i.e.\r\n     * scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n     */createFromTiles:function createFromTiles(indexes,replacements,spriteConfig,scene,camera){return TilemapComponents.CreateFromTiles(indexes,replacements,spriteConfig,scene,camera,this.layer);},/**\r\n     * Returns the tiles in the given layer that are within the cameras viewport.\r\n     * This is used internally.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#cull\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */cull:function cull(camera){return TilemapComponents.CullTiles(this.layer,camera,this.culledTiles);},/**\r\n     * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n     * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n     * information in the destination region.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} srcTileX - [description]\r\n     * @param {integer} srcTileY - [description]\r\n     * @param {integer} width - [description]\r\n     * @param {integer} height - [description]\r\n     * @param {integer} destTileX - [description]\r\n     * @param {integer} destTileY - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */copy:function copy(srcTileX,srcTileY,width,height,destTileX,destTileY,recalculateFaces){TilemapComponents.Copy(srcTileX,srcTileY,width,height,destTileX,destTileY,recalculateFaces,this.layer);return this;},/**\r\n     * Destroys this DynamicTilemapLayer and removes its link to the associated LayerData.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){// Uninstall this layer only if it is still installed on the LayerData object\nif(this.layer.tilemapLayer===this){this.layer.tilemapLayer=undefined;}this.tilemap=undefined;this.layer=undefined;this.tileset=undefined;this.culledTiles.length=0;GameObject.prototype.destroy.call(this);},/**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#fill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - [description]\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */fill:function fill(index,tileX,tileY,width,height,recalculateFaces){TilemapComponents.Fill(index,tileX,tileY,width,height,recalculateFaces,this.layer);return this;},/**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#filterTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */filterTiles:function filterTiles(callback,context,tileX,tileY,width,height,filteringOptions){return TilemapComponents.FilterTiles(callback,context,tileX,tileY,width,height,filteringOptions,this.layer);},/**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#findByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The tile index value to search for.\r\n     * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the\r\n     * bottom-right. Otherwise it scans from the top-left.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */findByIndex:function findByIndex(findIndex,skip,reverse){return TilemapComponents.FindByIndex(findIndex,skip,reverse,this.layer);},/**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#findTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile}\r\n     */findTile:function findTile(callback,context,tileX,tileY,width,height,filteringOptions){return TilemapComponents.FindTile(callback,context,tileX,tileY,width,height,filteringOptions,this.layer);},/**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#forEachTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */forEachTile:function forEachTile(callback,context,tileX,tileY,width,height,filteringOptions){TilemapComponents.ForEachTile(callback,context,tileX,tileY,width,height,filteringOptions,this.layer);return this;},/**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile\r\n     * object with an index of -1.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n     */getTileAt:function getTileAt(tileX,tileY,nonNull){return TilemapComponents.GetTileAt(tileX,tileY,nonNull,this.layer);},/**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile\r\n     * object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates\r\n     * were invalid.\r\n     */getTileAtWorldXY:function getTileAtWorldXY(worldX,worldY,nonNull,camera){return TilemapComponents.GetTileAtWorldXY(worldX,worldY,nonNull,camera,this.layer);},/**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTilesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */getTilesWithin:function getTilesWithin(tileX,tileY,width,height,filteringOptions){return TilemapComponents.GetTilesWithin(tileX,tileY,width,height,filteringOptions,this.layer);},/**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTilesWithinShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */getTilesWithinShape:function getTilesWithinShape(shape,filteringOptions,camera){return TilemapComponents.GetTilesWithinShape(shape,filteringOptions,camera,this.layer);},/**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#getTilesWithinWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */getTilesWithinWorldXY:function getTilesWithinWorldXY(worldX,worldY,width,height,filteringOptions,camera){return TilemapComponents.GetTilesWithinWorldXY(worldX,worldY,width,height,filteringOptions,camera,this.layer);},/**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#hasTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     *\r\n     * @return {boolean}\r\n     */hasTileAt:function hasTileAt(tileX,tileY){return TilemapComponents.HasTileAt(tileX,tileY,this.layer);},/**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#hasTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {boolean}\r\n     */hasTileAtWorldXY:function hasTileAtWorldXY(worldX,worldY,camera){return TilemapComponents.HasTileAtWorldXY(worldX,worldY,camera,this.layer);},/**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#putTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */putTileAt:function putTileAt(tile,tileX,tileY,recalculateFaces){return TilemapComponents.PutTileAt(tile,tileX,tileY,recalculateFaces,this.layer);},/**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#putTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {integer} worldX - [description]\r\n     * @param {integer} worldY - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */putTileAtWorldXY:function putTileAtWorldXY(tile,worldX,worldY,recalculateFaces,camera){return TilemapComponents.PutTileAtWorldXY(tile,worldX,worldY,recalculateFaces,camera,this.layer);},/**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#putTilesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer[]|integer[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles\r\n     * or tile indexes to place.\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */putTilesAt:function putTilesAt(tilesArray,tileX,tileY,recalculateFaces){TilemapComponents.PutTilesAt(tilesArray,tileX,tileY,recalculateFaces,this.layer);return this;},/**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#randomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */randomize:function randomize(tileX,tileY,width,height,indexes){TilemapComponents.Randomize(tileX,tileY,width,height,indexes,this.layer);return this;},/**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layer's\r\n     * collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#removeTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified\r\n     * location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */removeTileAt:function removeTileAt(tileX,tileY,replaceWithNull,recalculateFaces){return TilemapComponents.RemoveTileAt(tileX,tileY,replaceWithNull,recalculateFaces,this.layer);},/**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layer's\r\n     * collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#removeTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified\r\n     * location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */removeTileAtWorldXY:function removeTileAtWorldXY(worldX,worldY,replaceWithNull,recalculateFaces,camera){return TilemapComponents.RemoveTileAtWorldXY(worldX,worldY,replaceWithNull,recalculateFaces,camera,this.layer);},/**\r\n     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#renderDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {object} styleConfig - An object specifying the colors to use for the debug drawing.\r\n     * @param {?Color} [styleConfig.tileColor=blue] - Color to use for drawing a filled rectangle at\r\n     * non-colliding tile locations. If set to null, non-colliding tiles will not be drawn.\r\n     * @param {?Color} [styleConfig.collidingTileColor=orange] - Color to use for drawing a filled\r\n     * rectangle at colliding tile locations. If set to null, colliding tiles will not be drawn.\r\n     * @param {?Color} [styleConfig.faceColor=grey] - Color to use for drawing a line at interesting\r\n     * tile faces. If set to null, interesting tile faces will not be drawn.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */renderDebug:function renderDebug(graphics,styleConfig){TilemapComponents.RenderDebug(graphics,styleConfig,this.layer);return this;},/**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#replaceByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} findIndex - [description]\r\n     * @param {integer} newIndex - [description]\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */replaceByIndex:function replaceByIndex(findIndex,newIndex,tileX,tileY,width,height){TilemapComponents.ReplaceByIndex(findIndex,newIndex,tileX,tileY,width,height,this.layer);return this;},/**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */setCollision:function setCollision(indexes,collides,recalculateFaces){TilemapComponents.SetCollision(indexes,collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollisionBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} start - The first index of the tile to be set for collision.\r\n     * @param {integer} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */setCollisionBetween:function setCollisionBetween(start,stop,collides,recalculateFaces){TilemapComponents.SetCollisionBetween(start,stop,collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollisionByProperty\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should\r\n     * be checked.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */setCollisionByProperty:function setCollisionByProperty(properties,collides,recalculateFaces){TilemapComponents.SetCollisionByProperty(properties,collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollisionByExclusion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */setCollisionByExclusion:function setCollisionByExclusion(indexes,collides,recalculateFaces){TilemapComponents.SetCollisionByExclusion(indexes,collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets collision on the tiles within a layer by checking each tiles collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tiles collision group, the tile's colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#setCollisionFromCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */setCollisionFromCollisionGroup:function setCollisionFromCollisionGroup(collides,recalculateFaces){TilemapComponents.SetCollisionFromCollisionGroup(collides,recalculateFaces,this.layer);return this;},/**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see setTileLocationCallback.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#setTileIndexCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes to have a\r\n     * collision callback set for.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */setTileIndexCallback:function setTileIndexCallback(indexes,callback,callbackContext){TilemapComponents.SetTileIndexCallback(indexes,callback,callbackContext,this.layer);return this;},/**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#setTileLocationCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */setTileLocationCallback:function setTileLocationCallback(tileX,tileY,width,height,callback,callbackContext){TilemapComponents.SetTileLocationCallback(tileX,tileY,width,height,callback,callbackContext,this.layer);return this;},/**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#shuffle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */shuffle:function shuffle(tileX,tileY,width,height){TilemapComponents.Shuffle(tileX,tileY,width,height,this.layer);return this;},/**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#swapByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileA - First tile index.\r\n     * @param {integer} tileB - Second tile index.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */swapByIndex:function swapByIndex(indexA,indexB,tileX,tileY,width,height){TilemapComponents.SwapByIndex(indexA,indexB,tileX,tileY,width,height,this.layer);return this;},/**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#tileToWorldX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {number}\r\n     */tileToWorldX:function tileToWorldX(tileX,camera){return TilemapComponents.TileToWorldX(tileX,camera,this.layer);},/**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#tileToWorldY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileY - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {number}\r\n     */tileToWorldY:function tileToWorldY(tileY,camera){return TilemapComponents.TileToWorldY(tileY,camera,this.layer);},/**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#tileToWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {Phaser.Math.Vector2} [point] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2}\r\n     */tileToWorldXY:function tileToWorldXY(tileX,tileY,point,camera){return TilemapComponents.TileToWorldXY(tileX,tileY,point,camera,this.layer);},/**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will recieve a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#weightedRandomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object[]} [weightedIndexes] - An array of objects to randomly draw from during\r\n     * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n     * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     *\r\n     * @return {Phaser.Tilemaps.DynamicTilemapLayer} This Tilemap Layer object.\r\n     */weightedRandomize:function weightedRandomize(tileX,tileY,width,height,weightedIndexes){TilemapComponents.WeightedRandomize(tileX,tileY,width,height,weightedIndexes,this.layer);return this;},/**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#worldToTileX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {number}\r\n     */worldToTileX:function worldToTileX(worldX,snapToFloor,camera){return TilemapComponents.WorldToTileX(worldX,snapToFloor,camera,this.layer);},/**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldY - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {number}\r\n     */worldToTileY:function worldToTileY(worldY,snapToFloor,camera){return TilemapComponents.WorldToTileY(worldY,snapToFloor,camera,this.layer);},/**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.DynamicTilemapLayer#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Math.Vector2} [point] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2}\r\n     */worldToTileXY:function worldToTileXY(worldX,worldY,snapToFloor,point,camera){return TilemapComponents.WorldToTileXY(worldX,worldY,snapToFloor,point,camera,this.layer);}});module.exports=DynamicTilemapLayer;/***/},/* 191 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var DegToRad=__webpack_require__(43);var DynamicTilemapLayer=__webpack_require__(190);var Extend=__webpack_require__(18);var Formats=__webpack_require__(24);var LayerData=__webpack_require__(67);var Rotate=__webpack_require__(220);var StaticTilemapLayer=__webpack_require__(189);var Tile=__webpack_require__(45);var TilemapComponents=__webpack_require__(91);var Tileset=__webpack_require__(87);/**\r\n * @callback TilemapFilterCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - [description]\r\n * @param {number} index - [description]\r\n * @param {Phaser.GameObjects.GameObject[]} array - [description]\r\n *\r\n * @return {Phaser.GameObjects.GameObject} [description]\r\n *//**\r\n * @callback TilemapFindCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - [description]\r\n * @param {number} index - [description]\r\n * @param {Phaser.GameObjects.GameObject[]} array - [description]\r\n *\r\n * @return {boolean} [description]\r\n *//**\r\n * @classdesc\r\n * A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\r\n * about the map and allows you to add tilesets and tilemap layers to it. A map can have one or\r\n * more tilemap layers (StaticTilemapLayer or DynamicTilemapLayer), which are the display\r\n * objects that actually render tiles.\r\n *\r\n * The Tilemap data be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\r\n * software package specifically for creating tile maps, and is available from:\r\n * http://www.mapeditor.org\r\n *\r\n * A Tilemap has handy methods for getting & manipulating the tiles within a layer. You can only\r\n * use the methods that change tiles (e.g. removeTileAt) on a DynamicTilemapLayer.\r\n *\r\n * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a\r\n * StaticTilemapLayer or DynamicTilemapLayer may have its own unique tile size that overrides\r\n * it.\r\n *\r\n * @class Tilemap\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {Phaser.Tilemaps.MapData} mapData - A MapData instance containing Tilemap data.\r\n */var Tilemap=new Class({initialize:function Tilemap(scene,mapData){/**\r\n         * @name Phaser.Tilemaps.Tilemap#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * The base width of a tile in pixels. Note that individual layers may have a different tile\r\n         * width.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.tileWidth=mapData.tileWidth;/**\r\n         * The base height of a tile in pixels. Note that individual layers may have a different\r\n         * tile height.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.tileHeight=mapData.tileHeight;/**\r\n         * The width of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=mapData.width;/**\r\n         * The height of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=mapData.height;/**\r\n         * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#orientation\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.orientation=mapData.orientation;/**\r\n         * The format of the map data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#format\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.format=mapData.format;/**\r\n         * The version of the map data (as specified in Tiled, usually 1).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#version\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.version=mapData.version;/**\r\n         * Map specific properties as specified in Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.properties=mapData.properties;/**\r\n         * The width of the map in pixels based on width * tileWidth.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.widthInPixels=mapData.widthInPixels;/**\r\n         * The height of the map in pixels based on height * tileHeight.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.heightInPixels=mapData.heightInPixels;/**\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#imageCollections\r\n         * @type {Phaser.Tilemaps.ImageCollection[]}\r\n         * @since 3.0.0\r\n         */this.imageCollections=mapData.imageCollections;/**\r\n         * An array of Tiled Image Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.images=mapData.images;/**\r\n         * An array of Tilemap layer data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#layers\r\n         * @type {Phaser.Tilemaps.LayerData[]}\r\n         * @since 3.0.0\r\n         */this.layers=mapData.layers;/**\r\n         * An array of Tilesets used in the map.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tilesets\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.0.0\r\n         */this.tilesets=mapData.tilesets;/**\r\n         * An array of ObjectLayer instances parsed from Tiled object layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#objects\r\n         * @type {Phaser.Tilemaps.ObjectLayer[]}\r\n         * @since 3.0.0\r\n         */this.objects=mapData.objects;/**\r\n         * The index of the currently selected LayerData object.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#currentLayerIndex\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.currentLayerIndex=0;},/**\r\n     * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.\r\n     * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled\r\n     * editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#addTilesetImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} tilesetName - The name of the tileset as specified in the map data.\r\n     * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If\r\n     * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.\r\n     * @param {integer} [tileWidth] - The width of the tile (in pixels) in the Tileset Image. If not\r\n     * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled\r\n     * JSON file.\r\n     * @param {integer} [tileHeight] - The height of the tiles (in pixels) in the Tileset Image. If\r\n     * not given it will default to the map's tileHeight value, or the tileHeight specified in the\r\n     * Tiled JSON file.\r\n     * @param {integer} [tileMargin] - The margin around the tiles in the sheet (in pixels). If not\r\n     * specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {integer} [tileSpacing] - The spacing between each the tile in the sheet (in pixels).\r\n     * If not specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {integer} [gid=0] - If adding multiple tilesets to a blank map, specify the starting\r\n     * GID this set will use here.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} Returns the Tileset object that was created or updated, or null if it\r\n     * failed.\r\n     */addTilesetImage:function addTilesetImage(tilesetName,key,tileWidth,tileHeight,tileMargin,tileSpacing,gid){if(tilesetName===undefined){return null;}if(key===undefined||key===null){key=tilesetName;}if(!this.scene.sys.textures.exists(key)){console.warn('Invalid image key given for tileset: \"'+key+'\"');return null;}var texture=this.scene.sys.textures.get(key);var index=this.getTilesetIndex(tilesetName);if(index===null&&this.format===Formats.TILED_JSON){console.warn('No data found in the JSON tilemap from Tiled matching the tileset name: \"'+tilesetName+'\"');return null;}if(this.tilesets[index]){this.tilesets[index].setTileSize(tileWidth,tileHeight);this.tilesets[index].setSpacing(tileMargin,tileSpacing);this.tilesets[index].setImage(texture);return this.tilesets[index];}if(tileWidth===undefined){tileWidth=this.tileWidth;}if(tileHeight===undefined){tileHeight=this.tileHeight;}if(tileMargin===undefined){tileMargin=0;}if(tileSpacing===undefined){tileSpacing=0;}if(gid===undefined){gid=0;}var tileset=new Tileset(tilesetName,gid,tileWidth,tileHeight,tileMargin,tileSpacing);tileset.setImage(texture);this.tilesets.push(tileset);return tileset;},/**\r\n     * Turns the StaticTilemapLayer associated with the given layer into a DynamicTilemapLayer. If\r\n     * no layer specified, the map's current layer is used. This is useful if you want to manipulate\r\n     * a map at the start of a scene, but then make it non-manipulable and optimize it for speed.\r\n     * Note: the DynamicTilemapLayer passed in is destroyed, so make sure to store the value\r\n     * returned from this method if you want to manipulate the new StaticTilemapLayer.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#convertLayerToStatic\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer)} [layer] - The name of the layer from Tiled, the\r\n     * index of the layer in the map, or a DynamicTilemapLayer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.StaticTilemapLayer} Returns the new layer that was created, or null if it\r\n     * failed.\r\n     */convertLayerToStatic:function convertLayerToStatic(layer){layer=this.getLayer(layer);if(layer===null){return null;}var dynamicLayer=layer.tilemapLayer;if(!dynamicLayer||!(dynamicLayer instanceof DynamicTilemapLayer)){return null;}var staticLayer=new StaticTilemapLayer(dynamicLayer.scene,dynamicLayer.tilemap,dynamicLayer.layerIndex,dynamicLayer.tileset,dynamicLayer.x,dynamicLayer.y);this.scene.sys.displayList.add(staticLayer);dynamicLayer.destroy();return staticLayer;},/**\r\n     * See component documentation. If no layer specified, the map's current layer is used. This\r\n     * cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */copy:function copy(srcTileX,srcTileY,width,height,destTileX,destTileY,recalculateFaces,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'copy')){return this;}if(layer!==null){TilemapComponents.Copy(srcTileX,srcTileY,width,height,destTileX,destTileY,recalculateFaces,layer);}return this;},/**\r\n     * Creates a new and empty DynamicTilemapLayer. The currently selected layer in the map is set\r\n     * to this new layer.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createBlankDynamicLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of this layer. Must be unique within the map.\r\n     * @param {Phaser.Tilemaps.Tileset} tileset - The tileset the new layer will use.\r\n     * @param {integer} width - The width of the layer in tiles. If not specified, it will default\r\n     * to the map's width.\r\n     * @param {integer} height - The height of the layer in tiles. If not specified, it will default\r\n     * to the map's height.\r\n     * @param {integer} tileWidth - The width of the tiles the layer uses for calculations. If not\r\n     * specified, it will default to the map's tileWidth.\r\n     * @param {integer} tileHeight - The height of the tiles the layer uses for calculations. If not\r\n     * specified, it will default to the map's tileHeight.\r\n     * @return {?Phaser.Tilemaps.DynamicTilemapLayer} Returns the new layer was created, or null if it failed.\r\n     */createBlankDynamicLayer:function createBlankDynamicLayer(name,tileset,x,y,width,height,tileWidth,tileHeight){if(tileWidth===undefined){tileWidth=tileset.tileWidth;}if(tileHeight===undefined){tileHeight=tileset.tileHeight;}if(width===undefined){width=this.width;}if(height===undefined){height=this.height;}if(x===undefined){x=0;}if(y===undefined){y=0;}var index=this.getLayerIndex(name);if(index!==null){console.warn('Cannot create blank layer: layer with matching name already exists '+name);return null;}var layerData=new LayerData({name:name,tileWidth:tileWidth,tileHeight:tileHeight,width:width,height:height});var row;for(var tileY=0;tileY<height;tileY++){row=[];for(var tileX=0;tileX<width;tileX++){row.push(new Tile(layerData,-1,tileX,tileY,tileWidth,tileHeight,this.tileWidth,this.tileHeight));}layerData.data.push(row);}this.layers.push(layerData);this.currentLayerIndex=this.layers.length-1;var dynamicLayer=new DynamicTilemapLayer(this.scene,this,this.currentLayerIndex,tileset,x,y);this.scene.sys.displayList.add(dynamicLayer);return dynamicLayer;},/**\r\n     * Creates a new DynamicTilemapLayer that renders the LayerData associated with the given\r\n     * `layerID`. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n     * look at the layers[].name value. Either way it must match.\r\n     *\r\n     * Unlike a static layer, a dynamic layer can be modified. See DynamicTilemapLayer for more\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createDynamicLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|string)} layerID - The layer array index value, or if a string is given, the\r\n     * layer name from Tiled.\r\n     * @param {Phaser.Tilemaps.Tileset} tileset - The tileset the new layer will use.\r\n     * @param {number} x - The x position to place the layer in the world. If not specified, it will\r\n     * default to the layer offset from Tiled or 0.\r\n     * @param {number} y - The y position to place the layer in the world. If not specified, it will\r\n     * default to the layer offset from Tiled or 0.\r\n     *\r\n     * @return {?Phaser.Tilemaps.DynamicTilemapLayer} Returns the new layer was created, or null if it failed.\r\n     */createDynamicLayer:function createDynamicLayer(layerID,tileset,x,y){var index=this.getLayerIndex(layerID);if(index===null){console.warn('Cannot create tilemap layer, invalid layer ID given: '+layerID);return null;}var layerData=this.layers[index];// Check for an associated static or dynamic tilemap layer\nif(layerData.tilemapLayer){console.warn('Cannot create dynamic tilemap layer since a static or dynamic tilemap layer exists for layer ID:'+layerID);return null;}this.currentLayerIndex=index;// Make sure that all the LayerData & the tiles have the correct tile size. They usually\n// are, but wouldn't match if you try to load a 2x or 4x res tileset when the map was made\n// with a 1x res tileset.\nif(layerData.tileWidth!==tileset.tileWidth||layerData.tileHeight!==tileset.tileHeight){this.setLayerTileSize(tileset.tileWidth,tileset.tileHeight,index);}// Default the x/y position to match Tiled layer offset, if it exists.\nif(x===undefined&&this.layers[index].x){x=this.layers[index].x;}if(y===undefined&&this.layers[index].y){y=this.layers[index].y;}var layer=new DynamicTilemapLayer(this.scene,this,index,tileset,x,y);this.scene.sys.displayList.add(layer);return layer;},/**\r\n     * Creates a Sprite for every object matching the given gid in the map data. All properties from\r\n     * the map data objectgroup are copied into the `spriteConfig`, so you can use this as an easy\r\n     * way to configure Sprite properties from within the map editor. For example giving an object a\r\n     * property of alpha: 0.5 in the map editor will duplicate that when the Sprite is created.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the object layer (from Tiled) to create Sprites from.\r\n     * @param {(integer|string)} id - Either the id (object), gid (tile object) or name (object or\r\n     * tile object) from Tiled. Ids are unique in Tiled, but a gid is shared by all tile objects\r\n     * with the same graphic. The same name can be used on multiple objects.\r\n     * @param {object} spriteConfig - The config object to pass into the Sprite creator (i.e.\r\n     * scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene=the scene the map is within] - The Scene to create the Sprites within.\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n     */createFromObjects:function createFromObjects(name,id,spriteConfig,scene){if(spriteConfig===undefined){spriteConfig={};}if(scene===undefined){scene=this.scene;}var objectLayer=this.getObjectLayer(name);if(!objectLayer){console.warn('Cannot create from object. Invalid objectgroup name given: '+name);return;}var objects=objectLayer.objects;var sprites=[];for(var i=0;i<objects.length;i++){var found=false;var obj=objects[i];if(obj.gid!==undefined&&typeof id==='number'&&obj.gid===id||obj.id!==undefined&&typeof id==='number'&&obj.id===id||obj.name!==undefined&&typeof id==='string'&&obj.name===id){found=true;}if(found){var config=Extend({},spriteConfig,obj.properties);config.x=obj.x;config.y=obj.y;var sprite=this.scene.make.sprite(config);sprite.name=obj.name;if(obj.width){sprite.displayWidth=obj.width;}if(obj.height){sprite.displayHeight=obj.height;}// Origin is (0, 1) in Tiled, so find the offset that matches the Sprite's origin.\nvar offset={x:sprite.originX*sprite.displayWidth,y:(sprite.originY-1)*sprite.displayHeight};// If the object is rotated, then the origin offset also needs to be rotated.\nif(obj.rotation){var angle=DegToRad(obj.rotation);Rotate(offset,angle);sprite.rotation=angle;}sprite.x+=offset.x;sprite.y+=offset.y;if(obj.flippedHorizontal!==undefined||obj.flippedVertical!==undefined){sprite.setFlip(obj.flippedHorizontal,obj.flippedVertical);}if(!obj.visible){sprite.visible=false;}sprites.push(sprite);}}return sprites;},/**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {object} spriteConfig - The config object to pass into the Sprite creator (i.e.\r\n     * scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.GameObjects.Sprite[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */createFromTiles:function createFromTiles(indexes,replacements,spriteConfig,scene,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.CreateFromTiles(indexes,replacements,spriteConfig,scene,camera,layer);},/**\r\n     * Creates a new StaticTilemapLayer that renders the LayerData associated with the given\r\n     * `layerID`. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n     * look at the layers[].name value. Either way it must match.\r\n     *\r\n     * It's important to remember that a static layer cannot be modified. See StaticTilemapLayer for\r\n     * more information.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createStaticLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|string)} layerID - The layer array index value, or if a string is given, the\r\n     * layer name from Tiled.\r\n     * @param {Phaser.Tilemaps.Tileset} tileset - The tileset the new layer will use.\r\n     * @param {number} x - The x position to place the layer in the world. If not specified, it will\r\n     * default to the layer offset from Tiled or 0.\r\n     * @param {number} y - The y position to place the layer in the world. If not specified, it will\r\n     * default to the layer offset from Tiled or 0.\r\n     *\r\n     * @return {?Phaser.Tilemaps.StaticTilemapLayer} Returns the new layer was created, or null if it failed.\r\n     */createStaticLayer:function createStaticLayer(layerID,tileset,x,y){var index=this.getLayerIndex(layerID);if(index===null){console.warn('Cannot create tilemap layer, invalid layer ID given: '+layerID);return null;}var layerData=this.layers[index];// Check for an associated static or dynamic tilemap layer\nif(layerData.tilemapLayer){console.warn('Cannot create static tilemap layer since a static or dynamic tilemap layer exists for layer ID:'+layerID);return null;}this.currentLayerIndex=index;// Make sure that all the LayerData & the tiles have the correct tile size. They usually\n// are, but wouldn't match if you try to load a 2x or 4x res tileset when the map was made\n// with a 1x res tileset.\nif(layerData.tileWidth!==tileset.tileWidth||layerData.tileHeight!==tileset.tileHeight){this.setLayerTileSize(tileset.tileWidth,tileset.tileHeight,index);}// Default the x/y position to match Tiled layer offset, if it exists.\nif(x===undefined&&this.layers[index].x){x=this.layers[index].x;}if(y===undefined&&this.layers[index].y){y=this.layers[index].y;}var layer=new StaticTilemapLayer(this.scene,this,index,tileset,x,y);this.scene.sys.displayList.add(layer);return layer;},/**\r\n     * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any\r\n     * StaticTilemapLayers or DynamicTilemapLayers that have been linked to LayerData.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.removeAllLayers();this.tilesets.length=0;this.objects.length=0;this.scene=undefined;},/**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#fill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - [description]\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */fill:function fill(index,tileX,tileY,width,height,recalculateFaces,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'fill')){return this;}if(layer!==null){TilemapComponents.Fill(index,tileX,tileY,width,height,recalculateFaces,layer);}return this;},/**\r\n     * For each object in the given object layer, run the given filter callback function. Any\r\n     * objects that pass the filter test (i.e. where the callback returns true) will returned as a\r\n     * new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} [objectLayer] - The name of an object layer (from Tiled) or an\r\n     * ObjectLayer instance.\r\n     * @param {TilemapFilterCallback} callback - The callback. Each object in the given area will be passed to\r\n     * this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject[]} An array of object that match the search, or null if the objectLayer\r\n     * given was invalid.\r\n     */filterObjects:function filterObjects(objectLayer,callback,context){if(typeof objectLayer==='string'){var name=objectLayer;objectLayer=this.getObjectLayer(objectLayer);if(!objectLayer){console.warn('No object layer found with the name: '+name);return null;}}return objectLayer.objects.filter(callback,context);},/**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */filterTiles:function filterTiles(callback,context,tileX,tileY,width,height,filteringOptions,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.FilterTiles(callback,context,tileX,tileY,width,height,filteringOptions,layer);},/**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The tile index value to search for.\r\n     * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the\r\n     * bottom-right. Otherwise it scans from the top-left.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */findByIndex:function findByIndex(findIndex,skip,reverse,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.FindByIndex(findIndex,skip,reverse,layer);},/**\r\n     * Find the first object in the given object layer that satisfies the provided testing function.\r\n     * I.e. finds the first object for which `callback` returns true. Similar to\r\n     * Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} [objectLayer] - The name of an object layer (from Tiled) or an\r\n     * ObjectLayer instance.\r\n     * @param {TilemapFindCallback} callback - The callback. Each object in the given area will be passed to\r\n     * this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} An object that matches the search, or null if no object found\r\n     */findObject:function findObject(objectLayer,callback,context){if(typeof objectLayer==='string'){var name=objectLayer;objectLayer=this.getObjectLayer(objectLayer);if(!objectLayer){console.warn('No object layer found with the name: '+name);return null;}}return objectLayer.objects.find(callback,context)||null;},/**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */findTile:function findTile(callback,context,tileX,tileY,width,height,filteringOptions,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.FindTile(callback,context,tileX,tileY,width,height,filteringOptions,layer);},/**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#forEachTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n     * on at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */forEachTile:function forEachTile(callback,context,tileX,tileY,width,height,filteringOptions,layer){layer=this.getLayer(layer);if(layer!==null){TilemapComponents.ForEachTile(callback,context,tileX,tileY,width,height,filteringOptions,layer);}return this;},/**\r\n     * Gets the image layer index based on its name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the image to get.\r\n     *\r\n     * @return {integer} The index of the image in this tilemap, or null if not found.\r\n     */getImageIndex:function getImageIndex(name){return this.getIndex(this.images,name);},/**\r\n     * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name\r\n     * property matches the given `name`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} location - The Tilemap array to search.\r\n     * @param {string} name - The name of the array element to get.\r\n     *\r\n     * @return {number} The index of the element in the array, or null if not found.\r\n     */getIndex:function getIndex(location,name){for(var i=0;i<location.length;i++){if(location[i].name===name){return i;}}return null;},/**\r\n     * Gets the LayerData from this.layers that is associated with `layer`, or null if an invalid\r\n     * `layer` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n     * StaticTilemapLayer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.LayerData} The corresponding LayerData within this.layers.\r\n     */getLayer:function getLayer(layer){var index=this.getLayerIndex(layer);return index!==null?this.layers[index]:null;},/**\r\n     * Gets the ObjectLayer from this.objects that has the given `name`, or null if no ObjectLayer\r\n     * is found with that name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [name] - The name of the object layer from Tiled.\r\n     *\r\n     * @return {?Phaser.Tilemaps.ObjectLayer} The corresponding ObjectLayer within this.objects or null.\r\n     */getObjectLayer:function getObjectLayer(name){var index=this.getIndex(this.objects,name);return index!==null?this.objects[index]:null;},/**\r\n     * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid\r\n     * `layer` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n     * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {integer} The LayerData index within this.layers.\r\n     */getLayerIndex:function getLayerIndex(layer){if(layer===undefined){return this.currentLayerIndex;}else if(typeof layer==='string'){return this.getLayerIndexByName(layer);}else if(typeof layer==='number'&&layer<this.layers.length){return layer;}else if(layer instanceof StaticTilemapLayer||layer instanceof DynamicTilemapLayer){return layer.layerIndex;}else{return null;}},/**\r\n     * Gets the index of the LayerData within this.layers that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndexByName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the layer to get.\r\n     *\r\n     * @return {integer} The LayerData index within this.layers.\r\n     */getLayerIndexByName:function getLayerIndexByName(name){return this.getIndex(this.layers,name);},/**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile\r\n     * object with an index of -1.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */getTileAt:function getTileAt(tileX,tileY,nonNull,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.GetTileAt(tileX,tileY,nonNull,layer);},/**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile\r\n     * object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */getTileAtWorldXY:function getTileAtWorldXY(worldX,worldY,nonNull,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.GetTileAtWorldXY(worldX,worldY,nonNull,camera,layer);},/**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */getTilesWithin:function getTilesWithin(tileX,tileY,width,height,filteringOptions,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.GetTilesWithin(tileX,tileY,width,height,filteringOptions,layer);},/**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */getTilesWithinShape:function getTilesWithinShape(shape,filteringOptions,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.GetTilesWithinShape(shape,filteringOptions,camera,layer);},/**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n     * -1 for an index.\r\n     * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n     * at least one side.\r\n     * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n     * have at least one interesting face.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */getTilesWithinWorldXY:function getTilesWithinWorldXY(worldX,worldY,width,height,filteringOptions,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.GetTilesWithinWorldXY(worldX,worldY,width,height,filteringOptions,camera,layer);},/**\r\n     * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesetIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {integer} The Tileset index within this.tilesets.\r\n     */getTilesetIndex:function getTilesetIndex(name){return this.getIndex(this.tilesets,name);},/**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */hasTileAt:function hasTileAt(tileX,tileY,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.HasTileAt(tileX,tileY,layer);},/**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */hasTileAtWorldXY:function hasTileAtWorldXY(worldX,worldY,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.HasTileAtWorldXY(worldX,worldY,camera,layer);},/**\r\n     * The LayerData object that is currently selected in the map. You can set this property using\r\n     * any type supported by setLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#layer\r\n     * @type {Phaser.Tilemaps.LayerData}\r\n     * @since 3.0.0\r\n     */layer:{get:function get(){return this.layers[this.currentLayerIndex];},set:function set(layer){this.setLayer(layer);}},/**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */putTileAt:function putTileAt(tile,tileX,tileY,recalculateFaces,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'putTileAt')){return null;}if(layer===null){return null;}return TilemapComponents.PutTileAt(tile,tileX,tileY,recalculateFaces,layer);},/**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer specified, the maps current layer is used. This\r\n     * cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {integer} worldX - [description]\r\n     * @param {integer} worldY - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */putTileAtWorldXY:function putTileAtWorldXY(tile,worldX,worldY,recalculateFaces,camera,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'putTileAtWorldXY')){return null;}if(layer===null){return null;}return TilemapComponents.PutTileAtWorldXY(tile,worldX,worldY,recalculateFaces,camera,layer);},/**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTilesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer[]|integer[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles\r\n     * or tile indexes to place.\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */putTilesAt:function putTilesAt(tilesArray,tileX,tileY,recalculateFaces,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'putTilesAt')){return this;}if(layer!==null){TilemapComponents.PutTilesAt(tilesArray,tileX,tileY,recalculateFaces,layer);}return this;},/**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will recieve a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#randomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */randomize:function randomize(tileX,tileY,width,height,indexes,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'randomize')){return this;}if(layer!==null){TilemapComponents.Randomize(tileX,tileY,width,height,indexes,layer);}return this;},/**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */calculateFacesAt:function calculateFacesAt(tileX,tileY,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.CalculateFacesAt(tileX,tileY,layer);return this;},/**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */calculateFacesWithin:function calculateFacesWithin(tileX,tileY,width,height,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.CalculateFacesWithin(tileX,tileY,width,height,layer);return this;},/**\r\n     * Removes all layers from this Tilemap and destroys any associated StaticTilemapLayers or\r\n     * DynamicTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeAllLayers\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n     */removeAllLayers:function removeAllLayers(){// Destroy any StaticTilemapLayers or DynamicTilemapLayers that are stored in LayerData\nfor(var i=0;i<this.layers.length;i++){if(this.layers[i].tilemapLayer){this.layers[i].tilemapLayer.destroy();}}this.layers.length=0;this.currentLayerIndex=0;return this;},/**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layer's\r\n     * collision information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified\r\n     * location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */removeTileAt:function removeTileAt(tileX,tileY,replaceWithNull,recalculateFaces,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'removeTileAt')){return null;}if(layer===null){return null;}return TilemapComponents.RemoveTileAt(tileX,tileY,replaceWithNull,recalculateFaces,layer);},/**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layer's\r\n     * collision information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified\r\n     * location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */removeTileAtWorldXY:function removeTileAtWorldXY(worldX,worldY,replaceWithNull,recalculateFaces,camera,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'removeTileAtWorldXY')){return null;}if(layer===null){return null;}return TilemapComponents.RemoveTileAtWorldXY(worldX,worldY,replaceWithNull,recalculateFaces,camera,layer);},/**\r\n     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {object} styleConfig - An object specifying the colors to use for the debug drawing.\r\n     * @param {?Color} [styleConfig.tileColor=blue] - Color to use for drawing a filled rectangle at\r\n     * non-colliding tile locations. If set to null, non-colliding tiles will not be drawn.\r\n     * @param {?Color} [styleConfig.collidingTileColor=orange] - Color to use for drawing a filled\r\n     * rectangle at colliding tile locations. If set to null, colliding tiles will not be drawn.\r\n     * @param {?Color} [styleConfig.faceColor=grey] - Color to use for drawing a line at interesting\r\n     * tile faces. If set to null, interesting tile faces will not be drawn.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */renderDebug:function renderDebug(graphics,styleConfig,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.RenderDebug(graphics,styleConfig,layer);return this;},/**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#replaceByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} findIndex - [description]\r\n     * @param {integer} newIndex - [description]\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */replaceByIndex:function replaceByIndex(findIndex,newIndex,tileX,tileY,width,height,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'replaceByIndex')){return this;}if(layer!==null){TilemapComponents.ReplaceByIndex(findIndex,newIndex,tileX,tileY,width,height,layer);}return this;},/**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */setCollision:function setCollision(indexes,collides,recalculateFaces,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.SetCollision(indexes,collides,recalculateFaces,layer);return this;},/**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} start - The first index of the tile to be set for collision.\r\n     * @param {integer} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */setCollisionBetween:function setCollisionBetween(start,stop,collides,recalculateFaces,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.SetCollisionBetween(start,stop,collides,recalculateFaces,layer);return this;},/**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByProperty\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should\r\n     * be checked.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */setCollisionByProperty:function setCollisionByProperty(properties,collides,recalculateFaces,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.SetCollisionByProperty(properties,collides,recalculateFaces,layer);return this;},/**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false).\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByExclusion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */setCollisionByExclusion:function setCollisionByExclusion(indexes,collides,recalculateFaces,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.SetCollisionByExclusion(indexes,collides,recalculateFaces,layer);return this;},/**\r\n     * Sets collision on the tiles within a layer by checking each tile's collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tile's collision group, the tile's colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionFromCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n     * collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n     * update.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */setCollisionFromCollisionGroup:function setCollisionFromCollisionGroup(collides,recalculateFaces,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.SetCollisionFromCollisionGroup(collides,recalculateFaces,layer);return this;},/**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see setTileLocationCallback.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileIndexCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes to have a\r\n     * collision callback set for.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */setTileIndexCallback:function setTileIndexCallback(indexes,callback,callbackContext,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.SetTileIndexCallback(indexes,callback,callbackContext,layer);return this;},/**\r\n     * Sets a collision callback for the given rectangular area (in tile coordindates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileLocationCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */setTileLocationCallback:function setTileLocationCallback(tileX,tileY,width,height,callback,callbackContext,layer){layer=this.getLayer(layer);if(layer===null){return this;}TilemapComponents.SetTileLocationCallback(tileX,tileY,width,height,callback,callbackContext,layer);return this;},/**\r\n     * Sets the current layer to the LayerData associated with `layer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n     * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n     */setLayer:function setLayer(layer){var index=this.getLayerIndex(layer);if(index!==null){this.currentLayerIndex=index;}return this;},/**\r\n     * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and\r\n     * tileHeight for all layers. This also updates the base size on all tiles across all layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setBaseTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileWidth - The width of the tiles the map uses for calculations.\r\n     * @param {integer} tileHeight - The height of the tiles the map uses for calculations.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n     */setBaseTileSize:function setBaseTileSize(tileWidth,tileHeight){this.tileWidth=tileWidth;this.tileHeight=tileHeight;this.widthInPixels=this.width*tileWidth;this.heightInPixels=this.height*tileHeight;// Update the base tile size on all layers & tiles\nfor(var i=0;i<this.layers.length;i++){this.layers[i].baseWidth=tileWidth;this.layers[i].baseHeight=tileHeight;var mapData=this.layers[i].data;var mapWidth=this.layers[i].width;var mapHeight=this.layers[i].height;for(var row=0;row<mapHeight;++row){for(var col=0;col<mapWidth;++col){var tile=mapData[row][col];if(tile!==null){tile.setSize(undefined,undefined,tileWidth,tileHeight);}}}}return this;},/**\r\n     * Sets the tile size for a specific `layer`. Note: this does not necessarily match the map's\r\n     * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any\r\n     * tiles the layer has.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayerTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileWidth - The width of the tiles (in pixels) in the layer.\r\n     * @param {integer} tileHeight - The height of the tiles (in pixels) in the layer.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n     * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n     */setLayerTileSize:function setLayerTileSize(tileWidth,tileHeight,layer){layer=this.getLayer(layer);if(layer===null){return this;}layer.tileWidth=tileWidth;layer.tileHeight=tileHeight;var mapData=layer.data;var mapWidth=layer.width;var mapHeight=layer.height;for(var row=0;row<mapHeight;++row){for(var col=0;col<mapWidth;++col){var tile=mapData[row][col];if(tile!==null){tile.setSize(tileWidth,tileHeight);}}}return this;},/**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#shuffle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */shuffle:function shuffle(tileX,tileY,width,height,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'shuffle')){return this;}if(layer!==null){TilemapComponents.Shuffle(tileX,tileY,width,height,layer);}return this;},/**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#swapByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileA - First tile index.\r\n     * @param {integer} tileB - Second tile index.\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */swapByIndex:function swapByIndex(indexA,indexB,tileX,tileY,width,height,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'swapByIndex')){return this;}if(layer!==null){TilemapComponents.SwapByIndex(indexA,indexB,tileX,tileY,width,height,layer);}return this;},/**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */tileToWorldX:function tileToWorldX(tileX,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.TileToWorldX(tileX,camera,layer);},/**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileY - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */tileToWorldY:function tileToWorldY(tileX,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.TileToWorldY(tileX,camera,layer);},/**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - [description]\r\n     * @param {integer} tileY - [description]\r\n     * @param {Phaser.Math.Vector2} [point] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a point, or null if the layer given was invalid.\r\n     */tileToWorldXY:function tileToWorldXY(tileX,tileY,point,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.TileToWorldXY(tileX,tileY,point,camera,layer);},/**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer specified, the map's current layer is used. This\r\n     * cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#weightedRandomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - [description]\r\n     * @param {integer} [tileY=0] - [description]\r\n     * @param {integer} [width=max width based on tileX] - [description]\r\n     * @param {integer} [height=max height based on tileY] - [description]\r\n     * @param {object[]} [weightedIndexes] - An array of objects to randomly draw from during\r\n     * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n     * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */weightedRandomize:function weightedRandomize(tileX,tileY,width,height,weightedIndexes,layer){layer=this.getLayer(layer);if(this._isStaticCall(layer,'weightedRandomize')){return this;}if(layer!==null){TilemapComponents.WeightedRandomize(tileX,tileY,width,height,weightedIndexes,layer);}return this;},/**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */worldToTileX:function worldToTileX(worldX,snapToFloor,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.WorldToTileX(worldX,snapToFloor,camera,layer);},/**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldY - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */worldToTileY:function worldToTileY(worldY,snapToFloor,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.WorldToTileY(worldY,snapToFloor,camera,layer);},/**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - [description]\r\n     * @param {number} worldY - [description]\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n     * nearest integer.\r\n     * @param {Phaser.Math.Vector2} [point] - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n     * @param {Phaser.Tilemaps.LayerData} layer - [description]\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a point, or null if the layer given was invalid.\r\n     */worldToTileXY:function worldToTileXY(worldX,worldY,snapToFloor,point,camera,layer){layer=this.getLayer(layer);if(layer===null){return null;}return TilemapComponents.WorldToTileXY(worldX,worldY,snapToFloor,point,camera,layer);},/**\r\n     * Used internally to check if a layer is static and prints out a warning.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#_isStaticCall\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean}\r\n     */_isStaticCall:function _isStaticCall(layer,functionName){if(layer.tilemapLayer instanceof StaticTilemapLayer){console.warn(functionName+': You cannot change the tiles in a static tilemap layer');return true;}else{return false;}}});module.exports=Tilemap;/***/},/* 192 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Formats=__webpack_require__(24);var MapData=__webpack_require__(66);var ParseTileLayers=__webpack_require__(418);var ParseTilesets=__webpack_require__(417);/**\r\n * Parses a Weltmeister JSON object into a new MapData object.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseWeltmeister\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {object} json - The Weltmeister JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {?object} [description]\r\n */var ParseWeltmeister=function ParseWeltmeister(name,json,insertNull){if(json.layer.length===0){console.warn('No layers found in the Weltmeister map: '+name);return null;}var width=0;var height=0;for(var i=0;i<json.layer.length;i++){if(json.layer[i].width>width){width=json.layer[i].width;}if(json.layer[i].height>height){height=json.layer[i].height;}}var mapData=new MapData({width:width,height:height,name:name,tileWidth:json.layer[0].tilesize,tileHeight:json.layer[0].tilesize,format:Formats.WELTMEISTER});mapData.layers=ParseTileLayers(json,insertNull);mapData.tilesets=ParseTilesets(json);return mapData;};module.exports=ParseWeltmeister;/***/},/* 193 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * A class for representing a Tiled object layer in a map. This mirrors the structure of a Tiled\r\n * object layer, except:\r\n *  - \"x\" & \"y\" properties are ignored since these cannot be changed in Tiled.\r\n *  - \"offsetx\" & \"offsety\" are applied to the individual object coordinates directly, so they\r\n *    are ignored as well.\r\n *  - \"draworder\" is ignored.\r\n *\r\n * @class ObjectLayer\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} [config] - [description]\r\n */var ObjectLayer=new Class({initialize:function ObjectLayer(config){if(config===undefined){config={};}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.name=GetFastValue(config,'name','object layer');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#opacity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.opacity=GetFastValue(config,'opacity',1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.properties=GetFastValue(config,'properties',{});/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#propertyTypes\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.propertyTypes=GetFastValue(config,'propertytypes',{});/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.type=GetFastValue(config,'type','objectgroup');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#visible\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.visible=GetFastValue(config,'visible',true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#objects\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @since 3.0.0\r\n         */this.objects=GetFastValue(config,'objects',[]);}});module.exports=ObjectLayer;/***/},/* 194 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Pick=__webpack_require__(422);var ParseGID=__webpack_require__(196);var copyPoints=function copyPoints(p){return{x:p.x,y:p.y};};var commonObjectProps=['id','name','type','rotation','properties','visible','x','y','width','height'];/**\r\n * [description]\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseObject\r\n * @since 3.0.0\r\n *\r\n * @param {object} tiledObject - [description]\r\n * @param {number} [offsetX=0] - [description]\r\n * @param {number} [offsetY=0] - [description]\r\n *\r\n * @return {object} [description]\r\n */var ParseObject=function ParseObject(tiledObject,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}var parsedObject=Pick(tiledObject,commonObjectProps);parsedObject.x+=offsetX;parsedObject.y+=offsetY;if(tiledObject.gid){//  Object tiles\nvar gidInfo=ParseGID(tiledObject.gid);parsedObject.gid=gidInfo.gid;parsedObject.flippedHorizontal=gidInfo.flippedHorizontal;parsedObject.flippedVertical=gidInfo.flippedVertical;parsedObject.flippedAntiDiagonal=gidInfo.flippedAntiDiagonal;}else if(tiledObject.polyline){parsedObject.polyline=tiledObject.polyline.map(copyPoints);}else if(tiledObject.polygon){parsedObject.polygon=tiledObject.polygon.map(copyPoints);}else if(tiledObject.ellipse){parsedObject.ellipse=tiledObject.ellipse;parsedObject.width=tiledObject.width;parsedObject.height=tiledObject.height;}else if(tiledObject.text){parsedObject.width=tiledObject.width;parsedObject.height=tiledObject.height;parsedObject.text=tiledObject.text;}else{// Otherwise, assume it is a rectangle\nparsedObject.rectangle=true;parsedObject.width=tiledObject.width;parsedObject.height=tiledObject.height;}return parsedObject;};module.exports=ParseObject;/***/},/* 195 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * An Image Collection is a special Tile Set containing multiple images, with no slicing into each image.\r\n *\r\n * Image Collections are normally created automatically when Tiled data is loaded.\r\n *\r\n * @class ImageCollection\r\n * @memberOf Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n * \r\n * @param {string} name - The name of the image collection in the map data.\r\n * @param {integer} firstgid - The first image index this image collection contains.\r\n * @param {integer} [width=32] - Width of widest image (in pixels).\r\n * @param {integer} [height=32] - Height of tallest image (in pixels).\r\n * @param {integer} [margin=0] - The margin around all images in the collection (in pixels).\r\n * @param {integer} [spacing=0] - The spacing between each image in the collection (in pixels).\r\n * @param {object} [properties={}] - Custom Image Collection properties.\r\n */var ImageCollection=new Class({initialize:function ImageCollection(name,firstgid,width,height,margin,spacing,properties){if(width===undefined||width<=0){width=32;}if(height===undefined||height<=0){height=32;}if(margin===undefined){margin=0;}if(spacing===undefined){spacing=0;}/**\r\n         * The name of the Image Collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n        */this.name=name;/**\r\n         * The Tiled firstgid value.\r\n         * This is the starting index of the first image index this Image Collection contains.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#firstgid\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.firstgid=firstgid|0;/**\r\n         * The width of the widest image (in pixels).\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageWidth\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.imageWidth=width|0;/**\r\n         * The height of the tallest image (in pixels).\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageHeight\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.imageHeight=height|0;/**\r\n         * The margin around the images in the collection (in pixels).\r\n         * Use `setSpacing` to change.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageMarge\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.imageMargin=margin|0;/**\r\n         * The spacing between each image in the collection (in pixels).\r\n         * Use `setSpacing` to change.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageSpacing\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.imageSpacing=spacing|0;/**\r\n         * Image Collection-specific properties that are typically defined in the Tiled editor.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.properties=properties||{};/**\r\n         * The cached images that are a part of this collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#images\r\n         * @type {array}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.images=[];/**\r\n         * The total number of images in the image collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#total\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.total=0;},/**\r\n     * Returns true if and only if this image collection contains the given image index.\r\n     *\r\n     * @method Phaser.Tilemaps.ImageCollection#containsImageIndex\r\n     * @since 3.0.0\r\n     * \r\n     * @param {integer} imageIndex - The image index to search for.\r\n     * \r\n     * @return {boolean} True if this Image Collection contains the given index.\r\n     */containsImageIndex:function containsImageIndex(imageIndex){return imageIndex>=this.firstgid&&imageIndex<this.firstgid+this.total;},/**\r\n     * Add an image to this Image Collection.\r\n     *\r\n     * @method Phaser.Tilemaps.ImageCollection#addImage\r\n     * @since 3.0.0\r\n     * \r\n     * @param {integer} gid - The gid of the image in the Image Collection.\r\n     * @param {string} image - The the key of the image in the Image Collection and in the cache.\r\n     *\r\n     * @return {Phaser.Tilemaps.ImageCollection} This ImageCollection object.\r\n     */addImage:function addImage(gid,image){this.images.push({gid:gid,image:image});this.total++;return this;}});module.exports=ImageCollection;/***/},/* 196 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FLIPPED_HORIZONTAL=0x80000000;var FLIPPED_VERTICAL=0x40000000;var FLIPPED_ANTI_DIAGONAL=0x20000000;// Top-right is swapped with bottom-left corners\n/**\r\n * See Tiled documentation on tile flipping:\r\n * http://docs.mapeditor.org/en/latest/reference/tmx-map-format/\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseGID\r\n * @since 3.0.0\r\n *\r\n * @param {number} gid - [description]\r\n *\r\n * @return {object} [description]\r\n */var ParseGID=function ParseGID(gid){var flippedHorizontal=Boolean(gid&FLIPPED_HORIZONTAL);var flippedVertical=Boolean(gid&FLIPPED_VERTICAL);var flippedAntiDiagonal=Boolean(gid&FLIPPED_ANTI_DIAGONAL);gid=gid&~(FLIPPED_HORIZONTAL|FLIPPED_VERTICAL|FLIPPED_ANTI_DIAGONAL);// Parse the flip flags into something Phaser can use\nvar rotation=0;var flipped=false;if(flippedHorizontal&&flippedVertical&&flippedAntiDiagonal){rotation=Math.PI/2;flipped=true;}else if(flippedHorizontal&&flippedVertical&&!flippedAntiDiagonal){rotation=Math.PI;flipped=false;}else if(flippedHorizontal&&!flippedVertical&&flippedAntiDiagonal){rotation=Math.PI/2;flipped=false;}else if(flippedHorizontal&&!flippedVertical&&!flippedAntiDiagonal){rotation=0;flipped=true;}else if(!flippedHorizontal&&flippedVertical&&flippedAntiDiagonal){rotation=3*Math.PI/2;flipped=false;}else if(!flippedHorizontal&&flippedVertical&&!flippedAntiDiagonal){rotation=Math.PI;flipped=true;}else if(!flippedHorizontal&&!flippedVertical&&flippedAntiDiagonal){rotation=3*Math.PI/2;flipped=true;}else if(!flippedHorizontal&&!flippedVertical&&!flippedAntiDiagonal){rotation=0;flipped=false;}return{gid:gid,flippedHorizontal:flippedHorizontal,flippedVertical:flippedVertical,flippedAntiDiagonal:flippedAntiDiagonal,rotation:rotation,flipped:flipped};};module.exports=ParseGID;/***/},/* 197 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Formats=__webpack_require__(24);var MapData=__webpack_require__(66);var ParseTileLayers=__webpack_require__(426);var ParseImageLayers=__webpack_require__(424);var ParseTilesets=__webpack_require__(423);var ParseObjectLayers=__webpack_require__(421);var BuildTilesetIndex=__webpack_require__(420);var AssignTileProperties=__webpack_require__(419);/**\r\n * Parses a Tiled JSON object into a new MapData object.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {?Phaser.Tilemaps.MapData} [description]\r\n */var ParseJSONTiled=function ParseJSONTiled(name,json,insertNull){if(json.orientation!=='orthogonal'){console.warn('Only orthogonal map types are supported in this version of Phaser');return null;}//  Map data will consist of: layers, objects, images, tilesets, sizes\nvar mapData=new MapData({width:json.width,height:json.height,name:name,tileWidth:json.tilewidth,tileHeight:json.tileheight,orientation:json.orientation,format:Formats.TILED_JSON,version:json.version,properties:json.properties});mapData.layers=ParseTileLayers(json,insertNull);mapData.images=ParseImageLayers(json);var sets=ParseTilesets(json);mapData.tilesets=sets.tilesets;mapData.imageCollections=sets.imageCollections;mapData.objects=ParseObjectLayers(json);mapData.tiles=BuildTilesetIndex(mapData);AssignTileProperties(mapData);return mapData;};module.exports=ParseJSONTiled;/***/},/* 198 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Formats=__webpack_require__(24);var Parse2DArray=__webpack_require__(118);/**\r\n * Parses a CSV string of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.ParseCSV\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {string} data - CSV string of tile indexes.\r\n * @param {integer} tileWidth - The width of a tile in pixels.\r\n * @param {integer} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} [description]\r\n */var ParseCSV=function ParseCSV(name,data,tileWidth,tileHeight,insertNull){var array2D=data.trim().split('\\n').map(function(row){return row.split(',');});var map=Parse2DArray(name,array2D,tileWidth,tileHeight,insertNull);map.format=Formats.CSV;return map;};module.exports=ParseCSV;/***/},/* 199 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Formats=__webpack_require__(24);var Parse2DArray=__webpack_require__(118);var ParseCSV=__webpack_require__(198);var ParseJSONTiled=__webpack_require__(197);var ParseWeltmeister=__webpack_require__(192);/**\r\n * Parses raw data of a given Tilemap format into a new MapData object. If no recognized data format\r\n * is found, returns `null`. When loading from CSV or a 2D array, you should specify the tileWidth &\r\n * tileHeight. When parsing from a map from Tiled, the tileWidth & tileHeight will be pulled from\r\n * the map data.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {integer} mapFormat - See ../Formats.js.\r\n * @param {(integer[][]|string|object)} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {integer} tileWidth - The width of a tile in pixels. Required for 2D array and CSV, but\r\n * ignored for Tiled JSON.\r\n * @param {integer} tileHeight - The height of a tile in pixels. Required for 2D array and CSV, but\r\n * ignored for Tiled JSON.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} [description]\r\n */var Parse=function Parse(name,mapFormat,data,tileWidth,tileHeight,insertNull){var newMap;switch(mapFormat){case Formats.ARRAY_2D:newMap=Parse2DArray(name,data,tileWidth,tileHeight,insertNull);break;case Formats.CSV:newMap=ParseCSV(name,data,tileWidth,tileHeight,insertNull);break;case Formats.TILED_JSON:newMap=ParseJSONTiled(name,data,insertNull);break;case Formats.WELTMEISTER:newMap=ParseWeltmeister(name,data,insertNull);break;default:console.warn('Unrecognized tilemap data format: '+mapFormat);newMap=null;}return newMap;};module.exports=Parse;/***/},/* 200 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Tile=__webpack_require__(45);var IsInLayerBounds=__webpack_require__(68);var CalculateFacesAt=__webpack_require__(121);/**\r\n * Removes the tile at the given tile coordinates in the specified layer and updates the layer's\r\n * collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.RemoveTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {integer} tileX - [description]\r\n * @param {integer} tileY - [description]\r\n * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified\r\n * location with null instead of a Tile with an index of -1.\r\n * @param {boolean} [recalculateFaces=true] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was removed.\r\n */var RemoveTileAt=function RemoveTileAt(tileX,tileY,replaceWithNull,recalculateFaces,layer){if(replaceWithNull===undefined){replaceWithNull=false;}if(recalculateFaces===undefined){recalculateFaces=true;}if(!IsInLayerBounds(tileX,tileY,layer)){return null;}var tile=layer.data[tileY][tileX];if(tile===null){return null;}else{layer.data[tileY][tileX]=replaceWithNull?null:new Tile(layer,-1,tileX,tileY,tile.width,tile.height);}// Recalculate faces only if the removed tile was a colliding tile\nif(recalculateFaces&&tile&&tile.collides){CalculateFacesAt(tileX,tileY,layer);}return tile;};module.exports=RemoveTileAt;/***/},/* 201 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var IsInLayerBounds=__webpack_require__(68);/**\r\n * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n * false if there is no tile or if the tile at that location has an index of -1.\r\n *\r\n * @function Phaser.Tilemaps.Components.HasTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - [description]\r\n * @param {integer} tileY - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {boolean}\r\n */var HasTileAt=function HasTileAt(tileX,tileY,layer){if(IsInLayerBounds(tileX,tileY,layer)){var tile=layer.data[tileY][tileX];return tile!==null&&tile.index>-1;}else{return false;}};module.exports=HasTileAt;/***/},/* 202 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);/**\r\n * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n * not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.ReplaceByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {integer} findIndex - [description]\r\n * @param {integer} newIndex - [description]\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var ReplaceByIndex=function ReplaceByIndex(findIndex,newIndex,tileX,tileY,width,height,layer){var tiles=GetTilesWithin(tileX,tileY,width,height,null,layer);for(var i=0;i<tiles.length;i++){if(tiles[i]&&tiles[i].index===findIndex){tiles[i].index=newIndex;}}};module.exports=ReplaceByIndex;/***/},/* 203 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\r\n*\r\n* @class Sleeping\r\n*/var Sleeping={};module.exports=Sleeping;var Events=__webpack_require__(178);(function(){Sleeping._motionWakeThreshold=0.18;Sleeping._motionSleepThreshold=0.08;Sleeping._minBias=0.9;/**\r\n     * Puts bodies to sleep or wakes them up depending on their motion.\r\n     * @method update\r\n     * @param {body[]} bodies\r\n     * @param {number} timeScale\r\n     */Sleeping.update=function(bodies,timeScale){var timeFactor=timeScale*timeScale*timeScale;// update bodies sleeping status\nfor(var i=0;i<bodies.length;i++){var body=bodies[i],motion=body.speed*body.speed+body.angularSpeed*body.angularSpeed;// wake up bodies if they have a force applied\nif(body.force.x!==0||body.force.y!==0){Sleeping.set(body,false);continue;}var minMotion=Math.min(body.motion,motion),maxMotion=Math.max(body.motion,motion);// biased average motion estimation between frames\nbody.motion=Sleeping._minBias*minMotion+(1-Sleeping._minBias)*maxMotion;if(body.sleepThreshold>0&&body.motion<Sleeping._motionSleepThreshold*timeFactor){body.sleepCounter+=1;if(body.sleepCounter>=body.sleepThreshold)Sleeping.set(body,true);}else if(body.sleepCounter>0){body.sleepCounter-=1;}}};/**\r\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\r\n     * @method afterCollisions\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */Sleeping.afterCollisions=function(pairs,timeScale){var timeFactor=timeScale*timeScale*timeScale;// wake up bodies involved in collisions\nfor(var i=0;i<pairs.length;i++){var pair=pairs[i];// don't wake inactive pairs\nif(!pair.isActive)continue;var collision=pair.collision,bodyA=collision.bodyA.parent,bodyB=collision.bodyB.parent;// don't wake if at least one body is static\nif(bodyA.isSleeping&&bodyB.isSleeping||bodyA.isStatic||bodyB.isStatic)continue;if(bodyA.isSleeping||bodyB.isSleeping){var sleepingBody=bodyA.isSleeping&&!bodyA.isStatic?bodyA:bodyB,movingBody=sleepingBody===bodyA?bodyB:bodyA;if(!sleepingBody.isStatic&&movingBody.motion>Sleeping._motionWakeThreshold*timeFactor){Sleeping.set(sleepingBody,false);}}}};/**\r\n     * Set a body as sleeping or awake.\r\n     * @method set\r\n     * @param {body} body\r\n     * @param {boolean} isSleeping\r\n     */Sleeping.set=function(body,isSleeping){var wasSleeping=body.isSleeping;if(isSleeping){body.isSleeping=true;body.sleepCounter=body.sleepThreshold;body.positionImpulse.x=0;body.positionImpulse.y=0;body.positionPrev.x=body.position.x;body.positionPrev.y=body.position.y;body.anglePrev=body.angle;body.speed=0;body.angularSpeed=0;body.motion=0;if(!wasSleeping){Events.trigger(body,'sleepStart');}}else{body.isSleeping=false;body.sleepCounter=0;if(wasSleeping){Events.trigger(body,'sleepEnd');}}};})();/***/},/* 204 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Collision Types - Determine if and how entities collide with each other.\r\n *\r\n * In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the \"weak\" entity moves,\r\n * while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE\r\n * collisions, both entities are moved. LITE or PASSIVE entities don't collide\r\n * with other LITE or PASSIVE entities at all. The behavior for FIXED vs.\r\n * FIXED collisions is undefined.\r\n *\r\n * @name Phaser.Physics.Impact.TYPE\r\n * @enum {integer}\r\n * @memberOf Phaser.Physics.Impact\r\n * @readOnly\r\n * @since 3.0.0\r\n */module.exports={/**\r\n     * Collides with nothing.\r\n     *\r\n     * @name Phaser.Physics.Impact.TYPE.NONE\r\n     */NONE:0,/**\r\n     * Type A. Collides with Type B.\r\n     *\r\n     * @name Phaser.Physics.Impact.TYPE.A\r\n     */A:1,/**\r\n     * Type B. Collides with Type A.\r\n     *\r\n     * @name Phaser.Physics.Impact.TYPE.B\r\n     */B:2,/**\r\n     * Collides with both types A and B.\r\n     *\r\n     * @name Phaser.Physics.Impact.TYPE.BOTH\r\n     */BOTH:3};/***/},/* 205 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Collision Types - Determine if and how entities collide with each other.\r\n *\r\n * In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the \"weak\" entity moves,\r\n * while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE\r\n * collisions, both entities are moved. LITE or PASSIVE entities don't collide\r\n * with other LITE or PASSIVE entities at all. The behavior for FIXED vs.\r\n * FIXED collisions is undefined.\r\n *\r\n * @name Phaser.Physics.Impact.COLLIDES\r\n * @enum {integer}\r\n * @memberOf Phaser.Physics.Impact\r\n * @readOnly\r\n * @since 3.0.0\r\n */module.exports={/**\r\n     * Never collides.\r\n     *\r\n     * @name Phaser.Physics.Impact.COLLIDES.NEVER\r\n     */NEVER:0,/**\r\n     * Lite collision.\r\n     *\r\n     * @name Phaser.Physics.Impact.COLLIDES.LITE\r\n     */LITE:1,/**\r\n     * Passive collision.\r\n     *\r\n     * @name Phaser.Physics.Impact.COLLIDES.PASSIVE\r\n     */PASSIVE:2,/**\r\n     * Active collision.\r\n     *\r\n     * @name Phaser.Physics.Impact.COLLIDES.ACTIVE\r\n     */ACTIVE:4,/**\r\n     * Fixed collision.\r\n     *\r\n     * @name Phaser.Physics.Impact.COLLIDES.FIXED\r\n     */FIXED:8};/***/},/* 206 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CircleContains=__webpack_require__(28);var Class=__webpack_require__(0);var CONST=__webpack_require__(47);var RectangleContains=__webpack_require__(27);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class StaticBody\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - [description]\r\n * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n */var StaticBody=new Class({initialize:function StaticBody(world,gameObject){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */this.gameObject=gameObject;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#debugShowBody\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.debugShowBody=world.defaults.debugShowStaticBody;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#debugBodyColor\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.debugBodyColor=world.defaults.staticBodyDebugColor;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#enable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.enable=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#isCircle\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isCircle=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#radius\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.radius=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#offset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.offset=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.position=new Vector2(gameObject.x-gameObject.displayOriginX,gameObject.y-gameObject.displayOriginY);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=gameObject.displayWidth;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=gameObject.displayHeight;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#halfWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.halfWidth=Math.abs(this.width/2);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#halfHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.halfHeight=Math.abs(this.height/2);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#center\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.center=new Vector2(gameObject.x+this.halfWidth,gameObject.y+this.halfHeight);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#velocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.velocity=Vector2.ZERO;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#allowGravity\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.allowGravity=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.gravity=Vector2.ZERO;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#bounce\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.bounce=Vector2.ZERO;//  If true this Body will dispatch events\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.onWorldBounds=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onCollide\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.onCollide=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onOverlap\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.onOverlap=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#mass\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.mass=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#immovable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.immovable=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#customSeparateX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.customSeparateX=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#customSeparateY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.customSeparateY=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.overlapX=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.overlapY=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapR\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.overlapR=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#embedded\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.embedded=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#collideWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.collideWorldBounds=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#checkCollision\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */this.checkCollision={none:false,up:true,down:true,left:true,right:true};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#touching\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */this.touching={none:true,up:false,down:false,left:false,right:false};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#wasTouching\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */this.wasTouching={none:true,up:false,down:false,left:false,right:false};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#blocked\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */this.blocked={none:true,up:false,down:false,left:false,right:false};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#physicsType\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.physicsType=CONST.STATIC_BODY;},/**\r\n     * Changes the Game Object this Body is bound to.\r\n     * First it removes its reference from the old Game Object, then sets the new one.\r\n     * You can optionally update the position and dimensions of this Body to reflect that of the new Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setGameObject\r\n     * @since 3.1.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The new Game Object that will own this Body.\r\n     * @param {boolean} [update=true] - Reposition and resize this Body to match the new Game Object?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */setGameObject:function setGameObject(gameObject,update){if(gameObject&&gameObject!==this.gameObject){//  Remove this body from the old game object\nthis.gameObject.body=null;gameObject.body=this;//  Update our reference\nthis.gameObject=gameObject;}if(update){this.updateFromGameObject();}return this;},/**\r\n     * Updates this Static Body so that its position and dimensions are updated\r\n     * based on the current Game Object it is bound to.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#updateFromGameObject\r\n     * @since 3.1.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */updateFromGameObject:function updateFromGameObject(){this.world.staticTree.remove(this);var gameObject=this.gameObject;gameObject.getTopLeft(this.position);this.width=gameObject.displayWidth;this.height=gameObject.displayHeight;this.halfWidth=Math.abs(this.width/2);this.halfHeight=Math.abs(this.height/2);this.center.set(this.position.x+this.halfWidth,this.position.y+this.halfHeight);this.world.staticTree.insert(this);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setOffset\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */setOffset:function setOffset(x,y){if(y===undefined){y=x;}this.world.staticTree.remove(this);this.position.x-=this.offset.x;this.position.y-=this.offset.y;this.offset.set(x,y);this.position.x+=this.offset.x;this.position.y+=this.offset.y;this.updateCenter();this.world.staticTree.insert(this);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} [offsetX] - [description]\r\n     * @param {number} [offsetY] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */setSize:function setSize(width,height,offsetX,offsetY){if(offsetX===undefined){offsetX=this.offset.x;}if(offsetY===undefined){offsetY=this.offset.y;}this.world.staticTree.remove(this);this.width=width;this.height=height;this.halfWidth=Math.floor(width/2);this.halfHeight=Math.floor(height/2);this.offset.set(offsetX,offsetY);this.updateCenter();this.isCircle=false;this.radius=0;this.world.staticTree.insert(this);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - [description]\r\n     * @param {number} [offsetX] - [description]\r\n     * @param {number} [offsetY] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */setCircle:function setCircle(radius,offsetX,offsetY){if(offsetX===undefined){offsetX=this.offset.x;}if(offsetY===undefined){offsetY=this.offset.y;}if(radius>0){this.world.staticTree.remove(this);this.isCircle=true;this.radius=radius;this.width=radius*2;this.height=radius*2;this.halfWidth=Math.floor(this.width/2);this.halfHeight=Math.floor(this.height/2);this.offset.set(offsetX,offsetY);this.updateCenter();this.world.staticTree.insert(this);}else{this.isCircle=false;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#updateCenter\r\n     * @since 3.0.0\r\n     */updateCenter:function updateCenter(){this.center.set(this.position.x+this.halfWidth,this.position.y+this.halfHeight);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     */reset:function reset(x,y){var gameObject=this.gameObject;if(x===undefined){x=gameObject.x;}if(y===undefined){y=gameObject.y;}this.world.staticTree.remove(this);gameObject.getTopLeft(this.position);this.updateCenter();this.world.staticTree.insert(this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */stop:function stop(){return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeBodyBounds} obj - [description]\r\n     *\r\n     * @return {ArcadeBodyBounds} [description]\r\n     */getBounds:function getBounds(obj){obj.x=this.x;obj.y=this.y;obj.right=this.right;obj.bottom=this.bottom;return obj;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hitTest:function hitTest(x,y){return this.isCircle?CircleContains(this,x,y):RectangleContains(this,x,y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaAbsX:function deltaAbsX(){return 0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaAbsY:function deltaAbsY(){return 0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaX:function deltaX(){return 0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaY:function deltaY(){return 0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaZ\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaZ:function deltaZ(){return 0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.enable=false;this.world.pendingDestroy.set(this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#drawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphic - [description]\r\n     */drawDebug:function drawDebug(graphic){var pos=this.position;if(this.debugShowBody){graphic.lineStyle(1,this.debugBodyColor,1);graphic.strokeRect(pos.x,pos.y,this.width,this.height);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#willDrawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */willDrawDebug:function willDrawDebug(){return this.debugShowBody;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */setMass:function setMass(value){if(value<=0){//  Causes havoc otherwise\nvalue=0.1;}this.mass=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */x:{get:function get(){return this.position.x;},set:function set(value){this.world.staticTree.remove(this);this.position.x=value;this.world.staticTree.insert(this);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */y:{get:function get(){return this.position.y;},set:function set(value){this.world.staticTree.remove(this);this.position.y=value;this.world.staticTree.insert(this);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#left\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */left:{get:function get(){return this.position.x;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#right\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */right:{get:function get(){return this.position.x+this.width;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#top\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */top:{get:function get(){return this.position.y;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#bottom\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */bottom:{get:function get(){return this.position.y+this.height;}}});module.exports=StaticBody;/***/},/* 207 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.TileIntersectsBody\r\n * @since 3.0.0\r\n *\r\n * @param {{ left: number, right: number, top: number, bottom: number }} tileWorldRect - [description]\r\n * @param {Phaser.Physics.Arcade.Body} body - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var TileIntersectsBody=function TileIntersectsBody(tileWorldRect,body){// Currently, all bodies are treated as rectangles when colliding with a Tile. Eventually, this\n// should support circle bodies when those are less buggy in v3.\nreturn!(body.right<=tileWorldRect.left||body.bottom<=tileWorldRect.top||body.position.x>=tileWorldRect.right||body.position.y>=tileWorldRect.bottom);};module.exports=TileIntersectsBody;/***/},/* 208 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var quickselect=__webpack_require__(281);/**\r\n * @classdesc\r\n * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.\r\n * It's based on an optimized R-tree data structure with bulk insertion support.\r\n *\r\n * Spatial index is a special data structure for points and rectangles that allows you to perform queries like\r\n * \"all items within this bounding box\" very efficiently (e.g. hundreds of times faster than looping over all items).\r\n *\r\n * @class RTree\r\n * @memberOf Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n */function rbush(maxEntries,format){if(!(this instanceof rbush))return new rbush(maxEntries,format);// max entries in a node is 9 by default; min node fill is 40% for best performance\nthis._maxEntries=Math.max(4,maxEntries||9);this._minEntries=Math.max(2,Math.ceil(this._maxEntries*0.4));if(format){this._initFormat(format);}this.clear();}rbush.prototype={all:function all(){return this._all(this.data,[]);},search:function search(bbox){var node=this.data,result=[],toBBox=this.toBBox;if(!intersects(bbox,node))return result;var nodesToSearch=[],i,len,child,childBBox;while(node){for(i=0,len=node.children.length;i<len;i++){child=node.children[i];childBBox=node.leaf?toBBox(child):child;if(intersects(bbox,childBBox)){if(node.leaf)result.push(child);else if(contains(bbox,childBBox))this._all(child,result);else nodesToSearch.push(child);}}node=nodesToSearch.pop();}return result;},collides:function collides(bbox){var node=this.data,toBBox=this.toBBox;if(!intersects(bbox,node))return false;var nodesToSearch=[],i,len,child,childBBox;while(node){for(i=0,len=node.children.length;i<len;i++){child=node.children[i];childBBox=node.leaf?toBBox(child):child;if(intersects(bbox,childBBox)){if(node.leaf||contains(bbox,childBBox))return true;nodesToSearch.push(child);}}node=nodesToSearch.pop();}return false;},load:function load(data){if(!(data&&data.length))return this;if(data.length<this._minEntries){for(var i=0,len=data.length;i<len;i++){this.insert(data[i]);}return this;}// recursively build the tree with the given data from scratch using OMT algorithm\nvar node=this._build(data.slice(),0,data.length-1,0);if(!this.data.children.length){// save as is if tree is empty\nthis.data=node;}else if(this.data.height===node.height){// split root if trees have the same height\nthis._splitRoot(this.data,node);}else{if(this.data.height<node.height){// swap trees if inserted one is bigger\nvar tmpNode=this.data;this.data=node;node=tmpNode;}// insert the small tree into the large tree at appropriate level\nthis._insert(node,this.data.height-node.height-1,true);}return this;},insert:function insert(item){if(item)this._insert(item,this.data.height-1);return this;},clear:function clear(){this.data=createNode([]);return this;},remove:function remove(item,equalsFn){if(!item)return this;var node=this.data,bbox=this.toBBox(item),path=[],indexes=[],i,parent,index,goingUp;// depth-first iterative tree traversal\nwhile(node||path.length){if(!node){// go up\nnode=path.pop();parent=path[path.length-1];i=indexes.pop();goingUp=true;}if(node.leaf){// check current node\nindex=findItem(item,node.children,equalsFn);if(index!==-1){// item found, remove the item and condense tree upwards\nnode.children.splice(index,1);path.push(node);this._condense(path);return this;}}if(!goingUp&&!node.leaf&&contains(node,bbox)){// go down\npath.push(node);indexes.push(i);i=0;parent=node;node=node.children[0];}else if(parent){// go right\ni++;node=parent.children[i];goingUp=false;}else node=null;// nothing found\n}return this;},toBBox:function toBBox(item){return item;},compareMinX:compareNodeMinX,compareMinY:compareNodeMinY,toJSON:function toJSON(){return this.data;},fromJSON:function fromJSON(data){this.data=data;return this;},_all:function _all(node,result){var nodesToSearch=[];while(node){if(node.leaf)result.push.apply(result,node.children);else nodesToSearch.push.apply(nodesToSearch,node.children);node=nodesToSearch.pop();}return result;},_build:function _build(items,left,right,height){var N=right-left+1,M=this._maxEntries,node;if(N<=M){// reached leaf level; return leaf\nnode=createNode(items.slice(left,right+1));calcBBox(node,this.toBBox);return node;}if(!height){// target height of the bulk-loaded tree\nheight=Math.ceil(Math.log(N)/Math.log(M));// target number of root entries to maximize storage utilization\nM=Math.ceil(N/Math.pow(M,height-1));}node=createNode([]);node.leaf=false;node.height=height;// split the items into M mostly square tiles\nvar N2=Math.ceil(N/M),N1=N2*Math.ceil(Math.sqrt(M)),i,j,right2,right3;multiSelect(items,left,right,N1,this.compareMinX);for(i=left;i<=right;i+=N1){right2=Math.min(i+N1-1,right);multiSelect(items,i,right2,N2,this.compareMinY);for(j=i;j<=right2;j+=N2){right3=Math.min(j+N2-1,right2);// pack each entry recursively\nnode.children.push(this._build(items,j,right3,height-1));}}calcBBox(node,this.toBBox);return node;},_chooseSubtree:function _chooseSubtree(bbox,node,level,path){var i,len,child,targetNode,area,enlargement,minArea,minEnlargement;while(true){path.push(node);if(node.leaf||path.length-1===level)break;minArea=minEnlargement=Infinity;for(i=0,len=node.children.length;i<len;i++){child=node.children[i];area=bboxArea(child);enlargement=enlargedArea(bbox,child)-area;// choose entry with the least area enlargement\nif(enlargement<minEnlargement){minEnlargement=enlargement;minArea=area<minArea?area:minArea;targetNode=child;}else if(enlargement===minEnlargement){// otherwise choose one with the smallest area\nif(area<minArea){minArea=area;targetNode=child;}}}node=targetNode||node.children[0];}return node;},_insert:function _insert(item,level,isNode){var toBBox=this.toBBox,bbox=isNode?item:toBBox(item),insertPath=[];// find the best node for accommodating the item, saving all nodes along the path too\nvar node=this._chooseSubtree(bbox,this.data,level,insertPath);// put the item into the node\nnode.children.push(item);extend(node,bbox);// split on node overflow; propagate upwards if necessary\nwhile(level>=0){if(insertPath[level].children.length>this._maxEntries){this._split(insertPath,level);level--;}else break;}// adjust bboxes along the insertion path\nthis._adjustParentBBoxes(bbox,insertPath,level);},// split overflowed node into two\n_split:function _split(insertPath,level){var node=insertPath[level],M=node.children.length,m=this._minEntries;this._chooseSplitAxis(node,m,M);var splitIndex=this._chooseSplitIndex(node,m,M);var newNode=createNode(node.children.splice(splitIndex,node.children.length-splitIndex));newNode.height=node.height;newNode.leaf=node.leaf;calcBBox(node,this.toBBox);calcBBox(newNode,this.toBBox);if(level)insertPath[level-1].children.push(newNode);else this._splitRoot(node,newNode);},_splitRoot:function _splitRoot(node,newNode){// split root node\nthis.data=createNode([node,newNode]);this.data.height=node.height+1;this.data.leaf=false;calcBBox(this.data,this.toBBox);},_chooseSplitIndex:function _chooseSplitIndex(node,m,M){var i,bbox1,bbox2,overlap,area,minOverlap,minArea,index;minOverlap=minArea=Infinity;for(i=m;i<=M-m;i++){bbox1=distBBox(node,0,i,this.toBBox);bbox2=distBBox(node,i,M,this.toBBox);overlap=intersectionArea(bbox1,bbox2);area=bboxArea(bbox1)+bboxArea(bbox2);// choose distribution with minimum overlap\nif(overlap<minOverlap){minOverlap=overlap;index=i;minArea=area<minArea?area:minArea;}else if(overlap===minOverlap){// otherwise choose distribution with minimum area\nif(area<minArea){minArea=area;index=i;}}}return index;},// sorts node children by the best axis for split\n_chooseSplitAxis:function _chooseSplitAxis(node,m,M){var compareMinX=node.leaf?this.compareMinX:compareNodeMinX,compareMinY=node.leaf?this.compareMinY:compareNodeMinY,xMargin=this._allDistMargin(node,m,M,compareMinX),yMargin=this._allDistMargin(node,m,M,compareMinY);// if total distributions margin value is minimal for x, sort by minX,\n// otherwise it's already sorted by minY\nif(xMargin<yMargin)node.children.sort(compareMinX);},// total margin of all possible split distributions where each node is at least m full\n_allDistMargin:function _allDistMargin(node,m,M,compare){node.children.sort(compare);var toBBox=this.toBBox,leftBBox=distBBox(node,0,m,toBBox),rightBBox=distBBox(node,M-m,M,toBBox),margin=bboxMargin(leftBBox)+bboxMargin(rightBBox),i,child;for(i=m;i<M-m;i++){child=node.children[i];extend(leftBBox,node.leaf?toBBox(child):child);margin+=bboxMargin(leftBBox);}for(i=M-m-1;i>=m;i--){child=node.children[i];extend(rightBBox,node.leaf?toBBox(child):child);margin+=bboxMargin(rightBBox);}return margin;},_adjustParentBBoxes:function _adjustParentBBoxes(bbox,path,level){// adjust bboxes along the given tree path\nfor(var i=level;i>=0;i--){extend(path[i],bbox);}},_condense:function _condense(path){// go through the path, removing empty nodes and updating bboxes\nfor(var i=path.length-1,siblings;i>=0;i--){if(path[i].children.length===0){if(i>0){siblings=path[i-1].children;siblings.splice(siblings.indexOf(path[i]),1);}else this.clear();}else calcBBox(path[i],this.toBBox);}},_initFormat:function _initFormat(format){// format: [minX, minY, maxX, maxY accessors]\n// accessors will be dotted names\n// Because we have historically used eval-based function constructor\n// the format accerrsors need to have their leading dots stripped to\n// obtain the actual accessor\nformat=format.map(function(f){return f.substring(1);});// Do not use string-generated Functions for CSP policies\n// Instead a combination of anonymous functions and grabbing properties\n// by string is used.\n// cf. https://github.com/photonstorm/phaser/issues/3441\n// and https://github.com/photonstorm/phaser/issues/3535\nvar mkCompareFn=function mkCompareFn(attr){return function(a,b){return a[attr]-b[attr];};};this.compareMinX=mkCompareFn(format[0]);this.compareMinY=mkCompareFn(format[1]);this.toBBox=function(a){return{minX:a[format[0]],minY:a[format[1]],maxX:a[format[2]],maxY:a[format[3]]};};}};function findItem(item,items,equalsFn){if(!equalsFn)return items.indexOf(item);for(var i=0;i<items.length;i++){if(equalsFn(item,items[i]))return i;}return-1;}// calculate node's bbox from bboxes of its children\nfunction calcBBox(node,toBBox){distBBox(node,0,node.children.length,toBBox,node);}// min bounding rectangle of node children from k to p-1\nfunction distBBox(node,k,p,toBBox,destNode){if(!destNode)destNode=createNode(null);destNode.minX=Infinity;destNode.minY=Infinity;destNode.maxX=-Infinity;destNode.maxY=-Infinity;for(var i=k,child;i<p;i++){child=node.children[i];extend(destNode,node.leaf?toBBox(child):child);}return destNode;}function extend(a,b){a.minX=Math.min(a.minX,b.minX);a.minY=Math.min(a.minY,b.minY);a.maxX=Math.max(a.maxX,b.maxX);a.maxY=Math.max(a.maxY,b.maxY);return a;}function compareNodeMinX(a,b){return a.minX-b.minX;}function compareNodeMinY(a,b){return a.minY-b.minY;}function bboxArea(a){return(a.maxX-a.minX)*(a.maxY-a.minY);}function bboxMargin(a){return a.maxX-a.minX+(a.maxY-a.minY);}function enlargedArea(a,b){return(Math.max(b.maxX,a.maxX)-Math.min(b.minX,a.minX))*(Math.max(b.maxY,a.maxY)-Math.min(b.minY,a.minY));}function intersectionArea(a,b){var minX=Math.max(a.minX,b.minX),minY=Math.max(a.minY,b.minY),maxX=Math.min(a.maxX,b.maxX),maxY=Math.min(a.maxY,b.maxY);return Math.max(0,maxX-minX)*Math.max(0,maxY-minY);}function contains(a,b){return a.minX<=b.minX&&a.minY<=b.minY&&b.maxX<=a.maxX&&b.maxY<=a.maxY;}function intersects(a,b){return b.minX<=a.maxX&&b.minY<=a.maxY&&b.maxX>=a.minX&&b.maxY>=a.minY;}function createNode(children){return{children:children,height:1,leaf:true,minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity};}// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\nfunction multiSelect(arr,left,right,n,compare){var stack=[left,right],mid;while(stack.length){right=stack.pop();left=stack.pop();if(right-left<=n)continue;mid=left+Math.ceil((right-left)/n/2)*n;quickselect(arr,mid,left,right,compare);stack.push(left,mid,mid,right);}}module.exports=rbush;/***/},/* 209 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ProcessQueue\r\n * @memberOf Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n */var ProcessQueue=new Class({initialize:function ProcessQueue(){/**\r\n         * [description]\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.ProcessQueue#_pending\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._pending=[];/**\r\n         * [description]\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.ProcessQueue#_active\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._active=[];/**\r\n         * [description]\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.ProcessQueue#_destroy\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._destroy=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Structs.ProcessQueue#_toProcess\r\n         * @type {integer}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._toProcess=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.ProcessQueue#add\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [item]\r\n     * @genericUse {Phaser.Structs.ProcessQueue.<T>} - [$return]\r\n     *\r\n     * @param {*} item - [description]\r\n     *\r\n     * @return {Phaser.Structs.ProcessQueue} This Process Queue object.\r\n     */add:function add(item){this._pending.push(item);this._toProcess++;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.ProcessQueue#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [item]\r\n     * @genericUse {Phaser.Structs.ProcessQueue.<T>} - [$return]\r\n     *\r\n     * @param {*} item - [description]\r\n     *\r\n     * @return {Phaser.Structs.ProcessQueue} This Process Queue object.\r\n     */remove:function remove(item){this._destroy.push(item);this._toProcess++;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.ProcessQueue#update\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} [description]\r\n     */update:function update(){if(this._toProcess===0){//  Quick bail\nreturn this._active;}var list=this._destroy;var active=this._active;var i;var item;//  Clear the 'destroy' list\nfor(i=0;i<list.length;i++){item=list[i];//  Remove from the 'active' array\nvar idx=active.indexOf(item);if(idx!==-1){active.splice(idx,1);}}list.length=0;//  Process the pending addition list\n//  This stops callbacks and out of sync events from populating the active array mid-way during an update\nlist=this._pending;for(i=0;i<list.length;i++){item=list[i];this._active.push(item);}list.length=0;this._toProcess=0;//  The owner of this queue can now safely do whatever it needs to with the active list\nreturn this._active;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.ProcessQueue#getActive\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} [description]\r\n     */getActive:function getActive(){return this._active;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Structs.ProcessQueue#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this._pending=[];this._active=[];this._destroy=[];}});module.exports=ProcessQueue;/***/},/* 210 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Arcade.GetOverlapY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - [description]\r\n * @param {Phaser.Physics.Arcade.Body} body2 - [description]\r\n * @param {boolean} overlapOnly - [description]\r\n * @param {number} bias - [description]\r\n *\r\n * @return {number} [description]\r\n */var GetOverlapY=function GetOverlapY(body1,body2,overlapOnly,bias){var overlap=0;var maxOverlap=body1.deltaAbsY()+body2.deltaAbsY()+bias;if(body1.deltaY()===0&&body2.deltaY()===0){//  They overlap but neither of them are moving\nbody1.embedded=true;body2.embedded=true;}else if(body1.deltaY()>body2.deltaY()){//  Body1 is moving down and/or Body2 is moving up\noverlap=body1.bottom-body2.y;if(overlap>maxOverlap&&!overlapOnly||body1.checkCollision.down===false||body2.checkCollision.up===false){overlap=0;}else{body1.touching.none=false;body1.touching.down=true;body2.touching.none=false;body2.touching.up=true;}}else if(body1.deltaY()<body2.deltaY()){//  Body1 is moving up and/or Body2 is moving down\noverlap=body1.y-body2.bottom;if(-overlap>maxOverlap&&!overlapOnly||body1.checkCollision.up===false||body2.checkCollision.down===false){overlap=0;}else{body1.touching.none=false;body1.touching.up=true;body2.touching.none=false;body2.touching.down=true;}}//  Resets the overlapY to zero if there is no overlap, or to the actual pixel value if there is\nbody1.overlapY=overlap;body2.overlapY=overlap;return overlap;};module.exports=GetOverlapY;/***/},/* 211 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Arcade.GetOverlapX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - [description]\r\n * @param {Phaser.Physics.Arcade.Body} body2 - [description]\r\n * @param {boolean} overlapOnly - [description]\r\n * @param {number} bias - [description]\r\n *\r\n * @return {number} [description]\r\n */var GetOverlapX=function GetOverlapX(body1,body2,overlapOnly,bias){var overlap=0;var maxOverlap=body1.deltaAbsX()+body2.deltaAbsX()+bias;if(body1.deltaX()===0&&body2.deltaX()===0){//  They overlap but neither of them are moving\nbody1.embedded=true;body2.embedded=true;}else if(body1.deltaX()>body2.deltaX()){//  Body1 is moving right and / or Body2 is moving left\noverlap=body1.right-body2.x;if(overlap>maxOverlap&&!overlapOnly||body1.checkCollision.right===false||body2.checkCollision.left===false){overlap=0;}else{body1.touching.none=false;body1.touching.right=true;body2.touching.none=false;body2.touching.left=true;}}else if(body1.deltaX()<body2.deltaX()){//  Body1 is moving left and/or Body2 is moving right\noverlap=body1.x-body2.width-body2.x;if(-overlap>maxOverlap&&!overlapOnly||body1.checkCollision.left===false||body2.checkCollision.right===false){overlap=0;}else{body1.touching.none=false;body1.touching.left=true;body2.touching.none=false;body2.touching.right=true;}}//  Resets the overlapX to zero if there is no overlap, or to the actual pixel value if there is\nbody1.overlapX=overlap;body2.overlapX=overlap;return overlap;};module.exports=GetOverlapX;/***/},/* 212 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Collider\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - [description]\r\n * @param {boolean} overlapOnly - [description]\r\n * @param {Phaser.Physics.Arcade.Body} object1 - The first object to check for collision.\r\n * @param {Phaser.Physics.Arcade.Body} object2 - The second object to check for collision.\r\n * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n * @param {object} callbackContext - The scope in which to call the callbacks.\r\n */var Collider=new Class({initialize:function Collider(world,overlapOnly,object1,object2,collideCallback,processCallback,callbackContext){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#name\r\n         * @type {string}\r\n         * @since 3.1.0\r\n         */this.name='';/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.active=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#overlapOnly\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.overlapOnly=overlapOnly;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#object1\r\n         * @type {Phaser.Physics.Arcade.Body}\r\n         * @since 3.0.0\r\n         */this.object1=object1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#object2\r\n         * @type {Phaser.Physics.Arcade.Body}\r\n         * @since 3.0.0\r\n         */this.object2=object2;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#collideCallback\r\n         * @type {ArcadePhysicsCallback}\r\n         * @since 3.0.0\r\n         */this.collideCallback=collideCallback;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#processCallback\r\n         * @type {ArcadePhysicsCallback}\r\n         * @since 3.0.0\r\n         */this.processCallback=processCallback;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#callbackContext\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.callbackContext=callbackContext;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Collider#setName\r\n     * @since 3.1.0\r\n     *\r\n     * @param {string} name - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} [description]\r\n     */setName:function setName(name){this.name=name;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Collider#update\r\n     * @since 3.0.0\r\n     */update:function update(){this.world.collideObjects(this.object1,this.object2,this.collideCallback,this.processCallback,this.callbackContext,this.overlapOnly);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Collider#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.world.removeCollider(this);this.active=false;this.world=null;this.object1=null;this.object2=null;this.collideCallback=null;this.processCallback=null;this.callbackContext=null;}});module.exports=Collider;/***/},/* 213 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CircleContains=__webpack_require__(28);var Class=__webpack_require__(0);var CONST=__webpack_require__(47);var RadToDeg=__webpack_require__(156);var Rectangle=__webpack_require__(10);var RectangleContains=__webpack_require__(27);var TransformMatrix=__webpack_require__(78);var Vector2=__webpack_require__(6);/**\r\n * @typedef {object} ArcadeBodyBounds\r\n *\r\n * @property {number} x - [description]\r\n * @property {number} y - [description]\r\n * @property {number} right - [description]\r\n * @property {number} bottom - [description]\r\n *//**\r\n * @typedef {object} ArcadeBodyCollision\r\n *\r\n * @property {boolean} none - [description]\r\n * @property {boolean} up - [description]\r\n * @property {boolean} down - [description]\r\n * @property {boolean} left - [description]\r\n * @property {boolean} right - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Body\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - [description]\r\n * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n */var Body=new Class({initialize:function Body(world,gameObject){var width=gameObject.width?gameObject.width:64;var height=gameObject.height?gameObject.height:64;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */this.gameObject=gameObject;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#transform\r\n         * @type {object}\r\n         * @since 3.4.0\r\n         */this.transform={x:gameObject.x,y:gameObject.y,rotation:gameObject.angle,scaleX:gameObject.scaleX,scaleY:gameObject.scaleY,displayOriginX:gameObject.displayOriginX,displayOriginY:gameObject.displayOriginY};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugShowBody\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.debugShowBody=world.defaults.debugShowBody;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugShowVelocity\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.debugShowVelocity=world.defaults.debugShowVelocity;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugBodyColor\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.debugBodyColor=world.defaults.bodyDebugColor;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#enable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.enable=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#isCircle\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isCircle=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#radius\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.radius=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#offset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.offset=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.position=new Vector2(gameObject.x,gameObject.y);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#prev\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.prev=new Vector2(gameObject.x,gameObject.y);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowRotation\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.allowRotation=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.rotation=gameObject.angle;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#preRotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.preRotation=gameObject.angle;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=width;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=height;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#sourceWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.sourceWidth=width;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#sourceHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.sourceHeight=height;if(gameObject.frame){this.sourceWidth=gameObject.frame.realWidth;this.sourceHeight=gameObject.frame.realHeight;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#halfWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.halfWidth=Math.abs(width/2);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#halfHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.halfHeight=Math.abs(height/2);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#center\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.center=new Vector2(gameObject.x+this.halfWidth,gameObject.y+this.halfHeight);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#velocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.velocity=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#newVelocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.newVelocity=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#deltaMax\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.deltaMax=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#acceleration\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.acceleration=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowDrag\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.allowDrag=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#drag\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.drag=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowGravity\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.allowGravity=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.gravity=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#bounce\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.bounce=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#worldBounce\r\n         * @type {?Phaser.Math.Vector2}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.worldBounce=null;//  If true this Body will dispatch events\n/**\r\n         * Emit a `worldbounds` event when this body collides with the world bounds (and `collideWorldBounds` is also true).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.onWorldBounds=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onCollide\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.onCollide=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onOverlap\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.onOverlap=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxVelocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.maxVelocity=new Vector2(10000,10000);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#friction\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.friction=new Vector2(1,0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularVelocity\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.angularVelocity=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularAcceleration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.angularAcceleration=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularDrag\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.angularDrag=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxAngular\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */this.maxAngular=1000;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#mass\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.mass=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angle\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.angle=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#speed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.speed=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#facing\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.facing=CONST.FACING_NONE;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#immovable\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.immovable=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#moves\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.moves=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customSeparateX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.customSeparateX=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customSeparateY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.customSeparateY=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.overlapX=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.overlapY=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapR\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.overlapR=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#embedded\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.embedded=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#collideWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.collideWorldBounds=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#checkCollision\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */this.checkCollision={none:false,up:true,down:true,left:true,right:true};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#touching\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */this.touching={none:true,up:false,down:false,left:false,right:false};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#wasTouching\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */this.wasTouching={none:true,up:false,down:false,left:false,right:false};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#blocked\r\n         * @type {ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */this.blocked={none:true,up:false,down:false,left:false,right:false};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.dirty=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#syncBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.syncBounds=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#isMoving\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isMoving=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#stopVelocityOnCollide\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.stopVelocityOnCollide=true;//  read-only\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#physicsType\r\n         * @type {integer}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.physicsType=CONST.DYNAMIC_BODY;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_reset\r\n         * @type {boolean}\r\n         * @private\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this._reset=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_sx\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._sx=gameObject.scaleX;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_sy\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._sy=gameObject.scaleY;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_dx\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._dx=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_dy\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._dy=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._bounds=new Rectangle();this._tempMatrix=new TransformMatrix();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateBounds\r\n     * @since 3.0.0\r\n     */updateBounds:function updateBounds(){var sprite=this.gameObject;//  Container?\nvar transform=this.transform;if(sprite.parentContainer){var matrix=sprite.getWorldTransformMatrix(this._tempMatrix);transform.x=matrix.tx;transform.y=matrix.ty;transform.rotation=RadToDeg(matrix.rotation);transform.scaleX=matrix.scaleX;transform.scaleY=matrix.scaleY;}else{transform.x=sprite.x;transform.y=sprite.y;transform.rotation=sprite.angle;transform.scaleX=sprite.scaleX;transform.scaleY=sprite.scaleY;}if(this.syncBounds){var b=sprite.getBounds(this._bounds);if(b.width!==this.width||b.height!==this.height){this.width=b.width;this.height=b.height;this._reset=true;}}else{var asx=Math.abs(transform.scaleX);var asy=Math.abs(transform.scaleY);if(asx!==this._sx||asy!==this._sy){this.width=this.sourceWidth*asx;this.height=this.sourceHeight*asy;this._sx=asx;this._sy=asy;this._reset=true;}}if(this._reset){this.halfWidth=Math.floor(this.width/2);this.halfHeight=Math.floor(this.height/2);this.updateCenter();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateCenter\r\n     * @since 3.0.0\r\n     */updateCenter:function updateCenter(){this.center.set(this.position.x+this.halfWidth,this.position.y+this.halfHeight);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - [description]\r\n     */update:function update(delta){this.dirty=true;//  Store and reset collision flags\nthis.wasTouching.none=this.touching.none;this.wasTouching.up=this.touching.up;this.wasTouching.down=this.touching.down;this.wasTouching.left=this.touching.left;this.wasTouching.right=this.touching.right;this.touching.none=true;this.touching.up=false;this.touching.down=false;this.touching.left=false;this.touching.right=false;this.blocked.none=true;this.blocked.up=false;this.blocked.down=false;this.blocked.left=false;this.blocked.right=false;this.overlapR=0;this.overlapX=0;this.overlapY=0;this.embedded=false;//  Updates the transform values\nthis.updateBounds();var sprite=this.transform;this.position.x=sprite.x+sprite.scaleX*(this.offset.x-sprite.displayOriginX);this.position.y=sprite.y+sprite.scaleY*(this.offset.y-sprite.displayOriginY);this.updateCenter();this.rotation=sprite.rotation;this.preRotation=this.rotation;if(this._reset){this.prev.x=this.position.x;this.prev.y=this.position.y;}if(this.moves){this.world.updateMotion(this);this.newVelocity.set(this.velocity.x*delta,this.velocity.y*delta);this.position.x+=this.newVelocity.x;this.position.y+=this.newVelocity.y;this.updateCenter();if(this.position.x!==this.prev.x||this.position.y!==this.prev.y){this.angle=Math.atan2(this.velocity.y,this.velocity.x);}this.speed=Math.sqrt(this.velocity.x*this.velocity.x+this.velocity.y*this.velocity.y);//  Now the State update will throw collision checks at the Body\n//  And finally we'll integrate the new position back to the Sprite in postUpdate\nif(this.collideWorldBounds&&this.checkWorldBounds()&&this.onWorldBounds){this.world.emit('worldbounds',this,this.blocked.up,this.blocked.down,this.blocked.left,this.blocked.right);}}this._dx=this.deltaX();this._dy=this.deltaY();this._reset=false;},/**\r\n     * Feeds the body results back into the parent gameobject.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#postUpdate\r\n     * @since 3.0.0\r\n     */postUpdate:function postUpdate(){//  Only allow postUpdate to be called once per frame\nif(!this.enable||!this.dirty){return;}this.dirty=false;this._dx=this.deltaX();this._dy=this.deltaY();if(this._dx<0){this.facing=CONST.FACING_LEFT;}else if(this._dx>0){this.facing=CONST.FACING_RIGHT;}if(this._dy<0){this.facing=CONST.FACING_UP;}else if(this._dy>0){this.facing=CONST.FACING_DOWN;}if(this.moves){if(this.deltaMax.x!==0&&this._dx!==0){if(this._dx<0&&this._dx<-this.deltaMax.x){this._dx=-this.deltaMax.x;}else if(this._dx>0&&this._dx>this.deltaMax.x){this._dx=this.deltaMax.x;}}if(this.deltaMax.y!==0&&this._dy!==0){if(this._dy<0&&this._dy<-this.deltaMax.y){this._dy=-this.deltaMax.y;}else if(this._dy>0&&this._dy>this.deltaMax.y){this._dy=this.deltaMax.y;}}// this.transform.x += this._dx;\n// this.transform.y += this._dy;\nthis.gameObject.x+=this._dx;this.gameObject.y+=this._dy;this._reset=true;}this.updateCenter();if(this.allowRotation){this.gameObject.angle+=this.deltaZ();}this.prev.x=this.position.x;this.prev.y=this.position.y;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#checkWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */checkWorldBounds:function checkWorldBounds(){var pos=this.position;var bounds=this.world.bounds;var check=this.world.checkCollision;var bx=this.worldBounce?-this.worldBounce.x:-this.bounce.x;var by=this.worldBounce?-this.worldBounce.y:-this.bounce.y;if(pos.x<bounds.x&&check.left){pos.x=bounds.x;this.velocity.x*=bx;this.blocked.left=true;this.blocked.none=false;}else if(this.right>bounds.right&&check.right){pos.x=bounds.right-this.width;this.velocity.x*=bx;this.blocked.right=true;this.blocked.none=false;}if(pos.y<bounds.y&&check.up){pos.y=bounds.y;this.velocity.y*=by;this.blocked.up=true;this.blocked.none=false;}else if(this.bottom>bounds.bottom&&check.down){pos.y=bounds.bottom-this.height;this.velocity.y*=by;this.blocked.down=true;this.blocked.none=false;}return!this.blocked.none;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setOffset:function setOffset(x,y){if(y===undefined){y=x;}this.offset.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {boolean} [center=true] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setSize:function setSize(width,height,center){if(center===undefined){center=true;}var gameObject=this.gameObject;this.sourceWidth=width;this.sourceHeight=height;this.width=this.sourceWidth*this._sx;this.height=this.sourceHeight*this._sy;this.halfWidth=Math.floor(this.width/2);this.halfHeight=Math.floor(this.height/2);this.updateCenter();if(center&&gameObject.getCenter){var ox=gameObject.displayWidth/2;var oy=gameObject.displayHeight/2;this.offset.set(ox-this.halfWidth,oy-this.halfHeight);}this.isCircle=false;this.radius=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - [description]\r\n     * @param {number} [offsetX] - [description]\r\n     * @param {number} [offsetY] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setCircle:function setCircle(radius,offsetX,offsetY){if(offsetX===undefined){offsetX=this.offset.x;}if(offsetY===undefined){offsetY=this.offset.y;}if(radius>0){this.isCircle=true;this.radius=radius;this.sourceWidth=radius*2;this.sourceHeight=radius*2;this.width=this.sourceWidth*this._sx;this.height=this.sourceHeight*this._sy;this.halfWidth=Math.floor(this.width/2);this.halfHeight=Math.floor(this.height/2);this.offset.set(offsetX,offsetY);this.updateCenter();}else{this.isCircle=false;}return this;},/**\r\n     * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\r\n     * If the body had any velocity or acceleration it is lost as a result of calling this.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position to place the Game Object and Body.\r\n     * @param {number} y - The vertical position to place the Game Object and Body.\r\n     */reset:function reset(x,y){this.stop();var gameObject=this.gameObject;gameObject.setPosition(x,y);gameObject.getTopLeft(this.position);this.prev.copy(this.position);this.rotation=gameObject.angle;this.preRotation=gameObject.angle;this.updateBounds();this.updateCenter();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */stop:function stop(){this.velocity.set(0);this.acceleration.set(0);this.speed=0;this.angularVelocity=0;this.angularAcceleration=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArcadeBodyBounds} obj - [description]\r\n     *\r\n     * @return {ArcadeBodyBounds} [description]\r\n     */getBounds:function getBounds(obj){obj.x=this.x;obj.y=this.y;obj.right=this.right;obj.bottom=this.bottom;return obj;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hitTest:function hitTest(x,y){return this.isCircle?CircleContains(this,x,y):RectangleContains(this,x,y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onFloor\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */onFloor:function onFloor(){return this.blocked.down;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onCeiling\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */onCeiling:function onCeiling(){return this.blocked.up;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onWall\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */onWall:function onWall(){return this.blocked.left||this.blocked.right;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaAbsX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaAbsX:function deltaAbsX(){return this.deltaX()>0?this.deltaX():-this.deltaX();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaAbsY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaAbsY:function deltaAbsY(){return this.deltaY()>0?this.deltaY():-this.deltaY();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaX:function deltaX(){return this.position.x-this.prev.x;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaY:function deltaY(){return this.position.y-this.prev.y;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaZ\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */deltaZ:function deltaZ(){return this.rotation-this.preRotation;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.enable=false;this.world.pendingDestroy.set(this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#drawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphic - [description]\r\n     */drawDebug:function drawDebug(graphic){var pos=this.position;var x=pos.x+this.halfWidth;var y=pos.y+this.halfHeight;if(this.debugShowBody){graphic.lineStyle(1,this.debugBodyColor);if(this.isCircle){graphic.strokeCircle(x,y,this.width/2);}else{graphic.strokeRect(pos.x,pos.y,this.width,this.height);}}if(this.debugShowVelocity){graphic.lineStyle(1,this.world.defaults.velocityDebugColor,1);graphic.lineBetween(x,y,x+this.velocity.x/2,y+this.velocity.y/2);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#willDrawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */willDrawDebug:function willDrawDebug(){return this.debugShowBody||this.debugShowVelocity;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setCollideWorldBounds:function setCollideWorldBounds(value){this.collideWorldBounds=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setVelocity:function setVelocity(x,y){this.velocity.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setVelocityX:function setVelocityX(value){this.velocity.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setVelocityY:function setVelocityY(value){this.velocity.y=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setBounce:function setBounce(x,y){this.bounce.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounceX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setBounceX:function setBounceX(value){this.bounce.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounceY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setBounceY:function setBounceY(value){this.bounce.y=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setAcceleration:function setAcceleration(x,y){this.acceleration.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAccelerationX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setAccelerationX:function setAccelerationX(value){this.acceleration.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAccelerationY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setAccelerationY:function setAccelerationY(value){this.acceleration.y=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setDrag:function setDrag(x,y){this.drag.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDragX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setDragX:function setDragX(value){this.drag.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDragY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setDragY:function setDragY(value){this.drag.y=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setGravity:function setGravity(x,y){this.gravity.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setGravityX:function setGravityX(value){this.gravity.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setGravityY:function setGravityY(value){this.gravity.y=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setFriction:function setFriction(x,y){this.friction.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFrictionX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setFrictionX:function setFrictionX(value){this.friction.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFrictionY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setFrictionY:function setFrictionY(value){this.friction.y=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setAngularVelocity:function setAngularVelocity(value){this.angularVelocity=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setAngularAcceleration:function setAngularAcceleration(value){this.angularAcceleration=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setAngularDrag:function setAngularDrag(value){this.angularDrag=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setMass:function setMass(value){this.mass=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setImmovable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */setImmovable:function setImmovable(value){this.immovable=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */x:{get:function get(){return this.position.x;},set:function set(value){this.position.x=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */y:{get:function get(){return this.position.y;},set:function set(value){this.position.y=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#left\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */left:{get:function get(){return this.position.x;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#right\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */right:{get:function get(){return this.position.x+this.width;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#top\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */top:{get:function get(){return this.position.y;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#bottom\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */bottom:{get:function get(){return this.position.y+this.height;}}});module.exports=Body;/***/},/* 214 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Body=__webpack_require__(213);var Clamp=__webpack_require__(50);var Class=__webpack_require__(0);var Collider=__webpack_require__(212);var CONST=__webpack_require__(47);var DistanceBetween=__webpack_require__(49);var EventEmitter=__webpack_require__(14);var GetOverlapX=__webpack_require__(211);var GetOverlapY=__webpack_require__(210);var GetValue=__webpack_require__(5);var ProcessQueue=__webpack_require__(209);var ProcessTileCallbacks=__webpack_require__(479);var Rectangle=__webpack_require__(10);var RTree=__webpack_require__(208);var SeparateTile=__webpack_require__(478);var SeparateX=__webpack_require__(473);var SeparateY=__webpack_require__(472);var Set=__webpack_require__(65);var StaticBody=__webpack_require__(206);var TileIntersectsBody=__webpack_require__(207);var Vector2=__webpack_require__(6);var Wrap=__webpack_require__(44);/**\r\n * @typedef {object} ArcadeWorldConfig\r\n *\r\n * @property {object} [gravity] - [description]\r\n * @property {number} [gravity.x=0] - [description]\r\n * @property {number} [gravity.y=0] - [description]\r\n * @property {number} [x=0] - [description]\r\n * @property {number} [y=0] - [description]\r\n * @property {number} [width=0] - [description]\r\n * @property {number} [height=0] - [description]\r\n * @property {object} [checkCollision] - [description]\r\n * @property {boolean} [checkCollision.up=true] - [description]\r\n * @property {boolean} [checkCollision.down=true] - [description]\r\n * @property {boolean} [checkCollision.left=true] - [description]\r\n * @property {boolean} [checkCollision.right=true] - [description]\r\n * @property {number} [overlapBias=4] - [description]\r\n * @property {number} [tileBias=16] - [description]\r\n * @property {boolean} [forceX=false] - [description]\r\n * @property {boolean} [isPaused=false] - [description]\r\n * @property {boolean} [debug=false] - [description]\r\n * @property {boolean} [debugShowBody=true] - [description]\r\n * @property {boolean} [debugShowStaticBody=true] - [description]\r\n * @property {boolean} [debugShowVelocity=true] - [description]\r\n * @property {number} [debugBodyColor=0xff00ff] - [description]\r\n * @property {number} [debugStaticBodyColor=0x0000ff] - [description]\r\n * @property {number} [debugVelocityColor=0x00ff00] - [description]\r\n * @property {number} [maxEntries=16] - [description]\r\n *//**\r\n * @typedef {object} CheckCollisionObject\r\n *\r\n * @property {boolean} up - [description]\r\n * @property {boolean} down - [description]\r\n * @property {boolean} left - [description]\r\n * @property {boolean} right - [description]\r\n *//**\r\n * @typedef {object} ArcadeWorldDefaults\r\n *\r\n * @property {boolean} debugShowBody - [description]\r\n * @property {boolean} debugShowStaticBody - [description]\r\n * @property {boolean} debugShowVelocity - [description]\r\n * @property {number} bodyDebugColor - [description]\r\n * @property {number} staticBodyDebugColor - [description]\r\n * @property {number} velocityDebugColor - [description]\r\n *//**\r\n * @typedef {object} ArcadeWorldTreeMinMax\r\n *\r\n * @property {number} minX - [description]\r\n * @property {number} minY - [description]\r\n * @property {number} maxX - [description]\r\n * @property {number} maxY - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {ArcadeWorldConfig} config - [description]\r\n */var World=new Class({Extends:EventEmitter,initialize:function World(scene,config){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * Dynamic Bodies\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#bodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>}\r\n         * @since 3.0.0\r\n         */this.bodies=new Set();/**\r\n         * Static Bodies\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#staticBodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.StaticBody>}\r\n         * @since 3.0.0\r\n         */this.staticBodies=new Set();/**\r\n         * Static Bodies\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#pendingDestroy\r\n         * @type {Phaser.Structs.Set.<(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)>}\r\n         * @since 3.1.0\r\n         */this.pendingDestroy=new Set();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#colliders\r\n         * @type {Phaser.Structs.ProcessQueue.<Phaser.Physics.Arcade.Collider>}\r\n         * @since 3.0.0\r\n         */this.colliders=new ProcessQueue();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.gravity=new Vector2(GetValue(config,'gravity.x',0),GetValue(config,'gravity.y',0));/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.0.0\r\n         */this.bounds=new Rectangle(GetValue(config,'x',0),GetValue(config,'y',0),GetValue(config,'width',scene.sys.game.config.width),GetValue(config,'height',scene.sys.game.config.height));/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#checkCollision\r\n         * @type {CheckCollisionObject}\r\n         * @since 3.0.0\r\n         */this.checkCollision={up:GetValue(config,'checkCollision.up',true),down:GetValue(config,'checkCollision.down',true),left:GetValue(config,'checkCollision.left',true),right:GetValue(config,'checkCollision.right',true)};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#OVERLAP_BIAS\r\n         * @type {number}\r\n         * @default 4\r\n         * @since 3.0.0\r\n         */this.OVERLAP_BIAS=GetValue(config,'overlapBias',4);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#TILE_BIAS\r\n         * @type {number}\r\n         * @default 16\r\n         * @since 3.0.0\r\n         */this.TILE_BIAS=GetValue(config,'tileBias',16);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#forceX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.forceX=GetValue(config,'forceX',false);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#isPaused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isPaused=GetValue(config,'isPaused',false);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_total\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._total=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#drawDebug\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.drawDebug=GetValue(config,'debug',false);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */this.debugGraphic;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#defaults\r\n         * @type {ArcadeWorldDefaults}\r\n         * @since 3.0.0\r\n         */this.defaults={debugShowBody:GetValue(config,'debugShowBody',true),debugShowStaticBody:GetValue(config,'debugShowStaticBody',true),debugShowVelocity:GetValue(config,'debugShowVelocity',true),bodyDebugColor:GetValue(config,'debugBodyColor',0xff00ff),staticBodyDebugColor:GetValue(config,'debugStaticBodyColor',0x0000ff),velocityDebugColor:GetValue(config,'debugVelocityColor',0x00ff00)};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#maxEntries\r\n         * @type {integer}\r\n         * @default 16\r\n         * @since 3.0.0\r\n         */this.maxEntries=GetValue(config,'maxEntries',16);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#tree\r\n         * @type {Phaser.Structs.RTree}\r\n         * @since 3.0.0\r\n         */this.tree=new RTree(this.maxEntries,['.left','.top','.right','.bottom']);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#staticTree\r\n         * @type {Phaser.Structs.RTree}\r\n         * @since 3.0.0\r\n         */this.staticTree=new RTree(this.maxEntries,['.left','.top','.right','.bottom']);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#treeMinMax\r\n         * @type {ArcadeWorldTreeMinMax}\r\n         * @since 3.0.0\r\n         */this.treeMinMax={minX:0,minY:0,maxX:0,maxY:0};if(this.drawDebug){this.createDebugGraphic();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} object - [description]\r\n     * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n     */enable:function enable(object,bodyType){if(bodyType===undefined){bodyType=CONST.DYNAMIC_BODY;}var i=1;if(Array.isArray(object)){i=object.length;while(i--){if(object[i].hasOwnProperty('children')){//  If it's a Group then we do it on the children regardless\nthis.enable(object[i].children.entries,bodyType);}else{this.enableBody(object[i],bodyType);}}}else if(object.hasOwnProperty('children')){//  If it's a Group then we do it on the children regardless\nthis.enable(object.children.entries,bodyType);}else{this.enableBody(object,bodyType);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#enableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object - [description]\r\n     * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */enableBody:function enableBody(object,bodyType){if(object.body===null){if(bodyType===CONST.DYNAMIC_BODY){object.body=new Body(this,object);this.bodies.set(object.body);}else if(bodyType===CONST.STATIC_BODY){object.body=new StaticBody(this,object);this.staticBodies.set(object.body);this.staticTree.insert(object.body);}}return object;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} object - [description]\r\n     */remove:function remove(object){this.disableBody(object);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} object - [description]\r\n     */disable:function disable(object){var i=1;if(Array.isArray(object)){i=object.length;while(i--){if(object[i].hasOwnProperty('children')){//  If it's a Group then we do it on the children regardless\nthis.disable(object[i].children.entries);}else{this.disableGameObjectBody(object[i]);}}}else if(object.hasOwnProperty('children')){//  If it's a Group then we do it on the children regardless\nthis.disable(object.children.entries);}else{this.disableGameObjectBody(object);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disableGameObjectBody\r\n     * @since 3.1.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */disableGameObjectBody:function disableGameObjectBody(object){if(object.body){if(object.body.physicsType===CONST.DYNAMIC_BODY){this.bodies.delete(object.body);}else if(object.body.physicsType===CONST.STATIC_BODY){this.staticBodies.delete(object.body);this.staticTree.remove(object.body);}object.body.enable=false;}return object;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - [description]\r\n     */disableBody:function disableBody(body){if(body.physicsType===CONST.DYNAMIC_BODY){this.tree.remove(body);this.bodies.delete(body);}else if(body.physicsType===CONST.STATIC_BODY){this.staticBodies.delete(body);this.staticTree.remove(body);}body.enable=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} [description]\r\n     */createDebugGraphic:function createDebugGraphic(){var graphic=this.scene.sys.add.graphics({x:0,y:0});graphic.setDepth(Number.MAX_VALUE);this.debugGraphic=graphic;this.drawDebug=true;return graphic;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {boolean} [checkLeft] - [description]\r\n     * @param {boolean} [checkRight] - [description]\r\n     * @param {boolean} [checkUp] - [description]\r\n     * @param {boolean} [checkDown] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */setBounds:function setBounds(x,y,width,height,checkLeft,checkRight,checkUp,checkDown){this.bounds.setTo(x,y,width,height);if(checkLeft!==undefined){this.setBoundsCollision(checkLeft,checkRight,checkUp,checkDown);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setBoundsCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [left=true] - [description]\r\n     * @param {boolean} [right=true] - [description]\r\n     * @param {boolean} [up=true] - [description]\r\n     * @param {boolean} [down=true] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */setBoundsCollision:function setBoundsCollision(left,right,up,down){if(left===undefined){left=true;}if(right===undefined){right=true;}if(up===undefined){up=true;}if(down===undefined){down=true;}this.checkCollision.left=left;this.checkCollision.right=right;this.checkCollision.up=up;this.checkCollision.down=down;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */pause:function pause(){this.isPaused=true;this.emit('pause');return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */resume:function resume(){this.isPaused=false;this.emit('resume');return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#addCollider\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} object1 - The first object to check for collision.\r\n     * @param {Phaser.Physics.Arcade.Body} object2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */addCollider:function addCollider(object1,object2,collideCallback,processCallback,callbackContext){if(collideCallback===undefined){collideCallback=null;}if(processCallback===undefined){processCallback=null;}if(callbackContext===undefined){callbackContext=collideCallback;}var collider=new Collider(this,false,object1,object2,collideCallback,processCallback,callbackContext);this.colliders.add(collider);return collider;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#addOverlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} object1 - The first object to check for overlap.\r\n     * @param {Phaser.Physics.Arcade.Body} object2 - The second object to check for overlap.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects overlap. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */addOverlap:function addOverlap(object1,object2,collideCallback,processCallback,callbackContext){if(collideCallback===undefined){collideCallback=null;}if(processCallback===undefined){processCallback=null;}if(callbackContext===undefined){callbackContext=collideCallback;}var collider=new Collider(this,true,object1,object2,collideCallback,processCallback,callbackContext);this.colliders.add(collider);return collider;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#removeCollider\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Collider} collider - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */removeCollider:function removeCollider(collider){this.colliders.remove(collider);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(time,delta){if(this.isPaused||this.bodies.size===0){return;}// this.delta = Math.min(delta / 1000, this.maxStep) * this.timeScale;\ndelta/=1000;this.delta=delta;//  Update all active bodies\nvar i;var body;var bodies=this.bodies.entries;var len=bodies.length;for(i=0;i<len;i++){body=bodies[i];if(body.enable){body.update(delta);}}//  Populate our dynamic collision tree\nthis.tree.clear();this.tree.load(bodies);//  Process any colliders\nvar colliders=this.colliders.update();for(i=0;i<colliders.length;i++){var collider=colliders[i];if(collider.active){collider.update();}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#postUpdate\r\n     * @since 3.0.0\r\n     */postUpdate:function postUpdate(){var i;var body;var dynamic=this.bodies;var staticBodies=this.staticBodies;var pending=this.pendingDestroy;var bodies=dynamic.entries;var len=bodies.length;for(i=0;i<len;i++){body=bodies[i];if(body.enable){body.postUpdate();}}if(this.drawDebug){var graphics=this.debugGraphic;graphics.clear();for(i=0;i<len;i++){body=bodies[i];if(body.willDrawDebug()){body.drawDebug(graphics);}}bodies=staticBodies.entries;len=bodies.length;for(i=0;i<len;i++){body=bodies[i];if(body.willDrawDebug()){body.drawDebug(graphics);}}}if(pending.size>0){var dynamicTree=this.tree;var staticTree=this.staticTree;bodies=pending.entries;len=bodies.length;for(i=0;i<len;i++){body=bodies[i];if(body.physicsType===CONST.DYNAMIC_BODY){dynamicTree.remove(body);dynamic.delete(body);}else if(body.physicsType===CONST.STATIC_BODY){staticTree.remove(body);staticBodies.delete(body);}body.world=undefined;body.gameObject=undefined;}pending.clear();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#updateMotion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - [description]\r\n     */updateMotion:function updateMotion(body){if(body.allowRotation){var velocityDelta=this.computeVelocity(0,body,body.angularVelocity,body.angularAcceleration,body.angularDrag,body.maxAngular)-body.angularVelocity;body.angularVelocity+=velocityDelta;body.rotation+=body.angularVelocity*this.delta;}body.velocity.x=this.computeVelocity(1,body,body.velocity.x,body.acceleration.x,body.drag.x,body.maxVelocity.x);body.velocity.y=this.computeVelocity(2,body,body.velocity.y,body.acceleration.y,body.drag.y,body.maxVelocity.y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#computeVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} axis - [description]\r\n     * @param {Phaser.Physics.Arcade.Body} body - [description]\r\n     * @param {number} velocity - [description]\r\n     * @param {number} acceleration - [description]\r\n     * @param {number} drag - [description]\r\n     * @param {number} max - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */computeVelocity:function computeVelocity(axis,body,velocity,acceleration,drag,max){if(max===undefined){max=10000;}if(axis===1&&body.allowGravity){velocity+=(this.gravity.x+body.gravity.x)*this.delta;}else if(axis===2&&body.allowGravity){velocity+=(this.gravity.y+body.gravity.y)*this.delta;}if(acceleration){velocity+=acceleration*this.delta;}else if(drag&&body.allowDrag){drag*=this.delta;if(velocity-drag>0){velocity-=drag;}else if(velocity+drag<0){velocity+=drag;}else{velocity=0;}}if(velocity>max){velocity=max;}else if(velocity<-max){velocity=-max;}return velocity;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#separate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - [description]\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - [description]\r\n     * @param {ArcadePhysicsCallback} [processCallback] - [description]\r\n     * @param {*} [callbackContext] - [description]\r\n     * @param {boolean} [overlapOnly] - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */separate:function separate(body1,body2,processCallback,callbackContext,overlapOnly){if(!body1.enable||!body2.enable||body1.checkCollision.none||body2.checkCollision.none||!this.intersects(body1,body2)){return false;}//  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\nif(processCallback&&processCallback.call(callbackContext,body1.gameObject,body2.gameObject)===false){return false;}//  Circle vs. Circle quick bail out\nif(body1.isCircle&&body2.isCircle){return this.separateCircle(body1,body2,overlapOnly);}// We define the behavior of bodies in a collision circle and rectangle\n// If a collision occurs in the corner points of the rectangle, the body behave like circles\n//  Either body1 or body2 is a circle\nif(body1.isCircle!==body2.isCircle){var bodyRect=body1.isCircle?body2:body1;var bodyCircle=body1.isCircle?body1:body2;var rect={x:bodyRect.x,y:bodyRect.y,right:bodyRect.right,bottom:bodyRect.bottom};var circle=bodyCircle.center;if(circle.y<rect.y||circle.y>rect.bottom){if(circle.x<rect.x||circle.x>rect.right){return this.separateCircle(body1,body2,overlapOnly);}}}var resultX=false;var resultY=false;//  Do we separate on x or y first?\nif(this.forceX||Math.abs(this.gravity.y+body1.gravity.y)<Math.abs(this.gravity.x+body1.gravity.x)){resultX=SeparateX(body1,body2,overlapOnly,this.OVERLAP_BIAS);//  Are they still intersecting? Let's do the other axis then\nif(this.intersects(body1,body2)){resultY=SeparateY(body1,body2,overlapOnly,this.OVERLAP_BIAS);}}else{resultY=SeparateY(body1,body2,overlapOnly,this.OVERLAP_BIAS);//  Are they still intersecting? Let's do the other axis then\nif(this.intersects(body1,body2)){resultX=SeparateX(body1,body2,overlapOnly,this.OVERLAP_BIAS);}}var result=resultX||resultY;if(result){if(overlapOnly&&(body1.onOverlap||body2.onOverlap)){this.emit('overlap',body1.gameObject,body2.gameObject,body1,body2);}else if(body1.onCollide||body2.onCollide){this.emit('collide',body1.gameObject,body2.gameObject,body1,body2);}}return result;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#separateCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - [description]\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - [description]\r\n     * @param {boolean} overlapOnly - [description]\r\n     * @param {number} bias - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */separateCircle:function separateCircle(body1,body2,overlapOnly,bias){//  Set the bounding box overlap values into the bodies themselves (hence we don't use the return values here)\nGetOverlapX(body1,body2,false,bias);GetOverlapY(body1,body2,false,bias);var dx=body2.center.x-body1.center.x;var dy=body2.center.y-body1.center.y;var angleCollision=Math.atan2(dy,dx);var overlap=0;if(body1.isCircle!==body2.isCircle){var rect={x:body2.isCircle?body1.position.x:body2.position.x,y:body2.isCircle?body1.position.y:body2.position.y,right:body2.isCircle?body1.right:body2.right,bottom:body2.isCircle?body1.bottom:body2.bottom};var circle={x:body1.isCircle?body1.center.x:body2.center.x,y:body1.isCircle?body1.center.y:body2.center.y,radius:body1.isCircle?body1.halfWidth:body2.halfWidth};if(circle.y<rect.y){if(circle.x<rect.x){overlap=DistanceBetween(circle.x,circle.y,rect.x,rect.y)-circle.radius;}else if(circle.x>rect.right){overlap=DistanceBetween(circle.x,circle.y,rect.right,rect.y)-circle.radius;}}else if(circle.y>rect.bottom){if(circle.x<rect.x){overlap=DistanceBetween(circle.x,circle.y,rect.x,rect.bottom)-circle.radius;}else if(circle.x>rect.right){overlap=DistanceBetween(circle.x,circle.y,rect.right,rect.bottom)-circle.radius;}}overlap*=-1;}else{overlap=body1.halfWidth+body2.halfWidth-DistanceBetween(body1.center.x,body1.center.y,body2.center.x,body2.center.y);}//  Can't separate two immovable bodies, or a body with its own custom separation logic\nif(overlapOnly||overlap===0||body1.immovable&&body2.immovable||body1.customSeparateX||body2.customSeparateX){if(overlap!==0&&(body1.onOverlap||body2.onOverlap)){this.emit('overlap',body1.gameObject,body2.gameObject,body1,body2);}//  return true if there was some overlap, otherwise false\nreturn overlap!==0;}// Transform the velocity vector to the coordinate system oriented along the direction of impact.\n// This is done to eliminate the vertical component of the velocity\nvar b1vx=body1.velocity.x;var b1vy=body1.velocity.y;var b1mass=body1.mass;var b2vx=body2.velocity.x;var b2vy=body2.velocity.y;var b2mass=body2.mass;var v1={x:b1vx*Math.cos(angleCollision)+b1vy*Math.sin(angleCollision),y:b1vx*Math.sin(angleCollision)-b1vy*Math.cos(angleCollision)};var v2={x:b2vx*Math.cos(angleCollision)+b2vy*Math.sin(angleCollision),y:b2vx*Math.sin(angleCollision)-b2vy*Math.cos(angleCollision)};// We expect the new velocity after impact\nvar tempVel1=((b1mass-b2mass)*v1.x+2*b2mass*v2.x)/(b1mass+b2mass);var tempVel2=(2*b1mass*v1.x+(b2mass-b1mass)*v2.x)/(b1mass+b2mass);// We convert the vector to the original coordinate system and multiplied by factor of rebound\nif(!body1.immovable){body1.velocity.x=(tempVel1*Math.cos(angleCollision)-v1.y*Math.sin(angleCollision))*body1.bounce.x;body1.velocity.y=(v1.y*Math.cos(angleCollision)+tempVel1*Math.sin(angleCollision))*body1.bounce.y;//  Reset local var\nb1vx=body1.velocity.x;b1vy=body1.velocity.y;}if(!body2.immovable){body2.velocity.x=(tempVel2*Math.cos(angleCollision)-v2.y*Math.sin(angleCollision))*body2.bounce.x;body2.velocity.y=(v2.y*Math.cos(angleCollision)+tempVel2*Math.sin(angleCollision))*body2.bounce.y;//  Reset local var\nb2vx=body2.velocity.x;b2vy=body2.velocity.y;}// When the collision angle is almost perpendicular to the total initial velocity vector\n// (collision on a tangent) vector direction can be determined incorrectly.\n// This code fixes the problem\nif(Math.abs(angleCollision)<Math.PI/2){if(b1vx>0&&!body1.immovable&&b2vx>b1vx){body1.velocity.x*=-1;}else if(b2vx<0&&!body2.immovable&&b1vx<b2vx){body2.velocity.x*=-1;}else if(b1vy>0&&!body1.immovable&&b2vy>b1vy){body1.velocity.y*=-1;}else if(b2vy<0&&!body2.immovable&&b1vy<b2vy){body2.velocity.y*=-1;}}else if(Math.abs(angleCollision)>Math.PI/2){if(b1vx<0&&!body1.immovable&&b2vx<b1vx){body1.velocity.x*=-1;}else if(b2vx>0&&!body2.immovable&&b1vx>b2vx){body2.velocity.x*=-1;}else if(b1vy<0&&!body1.immovable&&b2vy<b1vy){body1.velocity.y*=-1;}else if(b2vy>0&&!body2.immovable&&b1vx>b2vy){body2.velocity.y*=-1;}}if(!body1.immovable){body1.x+=body1.velocity.x*this.delta-overlap*Math.cos(angleCollision);body1.y+=body1.velocity.y*this.delta-overlap*Math.sin(angleCollision);}if(!body2.immovable){body2.x+=body2.velocity.x*this.delta+overlap*Math.cos(angleCollision);body2.y+=body2.velocity.y*this.delta+overlap*Math.sin(angleCollision);}if(body1.onCollide||body2.onCollide){this.emit('collide',body1.gameObject,body2.gameObject,body1,body2);}return true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - [description]\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */intersects:function intersects(body1,body2){if(body1===body2){return false;}if(body1.isCircle){if(body2.isCircle){//  Circle vs. Circle\nreturn DistanceBetween(body1.center.x,body1.center.y,body2.center.x,body2.center.y)<=body1.halfWidth+body2.halfWidth;}else{//  Circle vs. Rect\nreturn this.circleBodyIntersects(body1,body2);}}else if(body2.isCircle){//  Rect vs. Circle\nreturn this.circleBodyIntersects(body2,body1);}else{//  Rect vs. Rect\nif(body1.right<=body2.position.x){return false;}if(body1.bottom<=body2.position.y){return false;}if(body1.position.x>=body2.right){return false;}if(body1.position.y>=body2.bottom){return false;}return true;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#circleBodyIntersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} circle - [description]\r\n     * @param {Phaser.Physics.Arcade.Body} body - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */circleBodyIntersects:function circleBodyIntersects(circle,body){var x=Clamp(circle.center.x,body.left,body.right);var y=Clamp(circle.center.y,body.top,body.bottom);var dx=(circle.center.x-x)*(circle.center.x-x);var dy=(circle.center.y-y)*(circle.center.y-y);return dx+dy<=circle.halfWidth*circle.halfWidth;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object1 - [description]\r\n     * @param {Phaser.GameObjects.GameObject} object2 - [description]\r\n     * @param {ArcadePhysicsCallback} [overlapCallback] - [description]\r\n     * @param {ArcadePhysicsCallback} [processCallback] - [description]\r\n     * @param {*} [callbackContext] - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */overlap:function overlap(object1,object2,overlapCallback,processCallback,callbackContext){if(overlapCallback===undefined){overlapCallback=null;}if(processCallback===undefined){processCallback=null;}if(callbackContext===undefined){callbackContext=overlapCallback;}return this.collideObjects(object1,object2,overlapCallback,processCallback,callbackContext,true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object1 - [description]\r\n     * @param {Phaser.GameObjects.GameObject} object2 - [description]\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - [description]\r\n     * @param {ArcadePhysicsCallback} [processCallback] - [description]\r\n     * @param {*} [callbackContext] - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */collide:function collide(object1,object2,collideCallback,processCallback,callbackContext){if(collideCallback===undefined){collideCallback=null;}if(processCallback===undefined){processCallback=null;}if(callbackContext===undefined){callbackContext=collideCallback;}return this.collideObjects(object1,object2,collideCallback,processCallback,callbackContext,false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object1 - [description]\r\n     * @param {Phaser.GameObjects.GameObject} object2 - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */collideObjects:function collideObjects(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly){var i;object1=object1.isParent&&typeof object1.physicsType==='undefined'?object1.children.entries:object1;object2=object2.isParent&&typeof object2.physicsType==='undefined'?object2.children.entries:object2;var object1isArray=Array.isArray(object1);var object2isArray=Array.isArray(object2);this._total=0;if(!object1isArray&&!object2isArray){//  Neither of them are arrays - do this first as it's the most common use-case\nthis.collideHandler(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly);}else if(!object1isArray&&object2isArray){//  Object 2 is an Array\nfor(i=0;i<object2.length;i++){this.collideHandler(object1,object2[i],collideCallback,processCallback,callbackContext,overlapOnly);}}else if(object1isArray&&!object2isArray){//  Object 1 is an Array\nfor(i=0;i<object1.length;i++){this.collideHandler(object1[i],object2,collideCallback,processCallback,callbackContext,overlapOnly);}}else{//  They're both arrays\nfor(i=0;i<object1.length;i++){for(var j=0;j<object2.length;j++){this.collideHandler(object1[i],object2[j],collideCallback,processCallback,callbackContext,overlapOnly);}}}return this._total>0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideHandler\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object1 - [description]\r\n     * @param {Phaser.GameObjects.GameObject} object2 - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */collideHandler:function collideHandler(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly){//  Collide Group with Self\n//  Only collide valid objects\nif(object2===undefined&&object1.isParent){return this.collideGroupVsGroup(object1,object1,collideCallback,processCallback,callbackContext,overlapOnly);}//  If neither of the objects are set then bail out\nif(!object1||!object2){return false;}//  A Body\nif(object1.body){if(object2.body){return this.collideSpriteVsSprite(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly);}else if(object2.isParent){return this.collideSpriteVsGroup(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly);}else if(object2.isTilemap){return this.collideSpriteVsTilemapLayer(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly);}}//  GROUPS\nelse if(object1.isParent){if(object2.body){return this.collideSpriteVsGroup(object2,object1,collideCallback,processCallback,callbackContext,overlapOnly);}else if(object2.isParent){return this.collideGroupVsGroup(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly);}else if(object2.isTilemap){return this.collideGroupVsTilemapLayer(object1,object2,collideCallback,processCallback,callbackContext,overlapOnly);}}//  TILEMAP LAYERS\nelse if(object1.isTilemap){if(object2.body){return this.collideSpriteVsTilemapLayer(object2,object1,collideCallback,processCallback,callbackContext,overlapOnly);}else if(object2.isParent){return this.collideGroupVsTilemapLayer(object2,object1,collideCallback,processCallback,callbackContext,overlapOnly);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite1 - [description]\r\n     * @param {Phaser.GameObjects.GameObject} sprite2 - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */collideSpriteVsSprite:function collideSpriteVsSprite(sprite1,sprite2,collideCallback,processCallback,callbackContext,overlapOnly){if(!sprite1.body||!sprite2.body){return false;}if(this.separate(sprite1.body,sprite2.body,processCallback,callbackContext,overlapOnly)){if(collideCallback){collideCallback.call(callbackContext,sprite1,sprite2);}this._total++;}return true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - [description]\r\n     * @param {Phaser.GameObjects.Group} group - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */collideSpriteVsGroup:function collideSpriteVsGroup(sprite,group,collideCallback,processCallback,callbackContext,overlapOnly){var bodyA=sprite.body;if(group.length===0||!bodyA){return;}//  Does sprite collide with anything?\nvar minMax=this.treeMinMax;minMax.minX=bodyA.left;minMax.minY=bodyA.top;minMax.maxX=bodyA.right;minMax.maxY=bodyA.bottom;var results=group.physicsType===CONST.DYNAMIC_BODY?this.tree.search(minMax):this.staticTree.search(minMax);if(results.length===0){return;}var children=group.getChildren();for(var i=0;i<children.length;i++){var bodyB=children[i].body;if(!bodyB||bodyA===bodyB||results.indexOf(bodyB)===-1){continue;}if(this.separate(bodyA,bodyB,processCallback,callbackContext,overlapOnly)){if(collideCallback){collideCallback.call(callbackContext,bodyA.gameObject,bodyB.gameObject);}this._total++;}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideGroupVsTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Group} group - [description]\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */collideGroupVsTilemapLayer:function collideGroupVsTilemapLayer(group,tilemapLayer,collideCallback,processCallback,callbackContext,overlapOnly){var children=group.getChildren();if(children.length===0){return false;}var didCollide=false;for(var i=0;i<children.length;i++){if(children[i].body){if(this.collideSpriteVsTilemapLayer(children[i],tilemapLayer,collideCallback,processCallback,callbackContext,overlapOnly)){didCollide=true;}}}return didCollide;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - [description]\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */collideSpriteVsTilemapLayer:function collideSpriteVsTilemapLayer(sprite,tilemapLayer,collideCallback,processCallback,callbackContext,overlapOnly){var body=sprite.body;if(!body.enable){return false;}var x=body.position.x;var y=body.position.y;var w=body.width;var h=body.height;// TODO: this logic should be encapsulated within the Tilemap API at some point.\n// If the maps base tile size differs from the layer's tile size, we need to adjust the\n// selection area by the difference between the two.\nvar layerData=tilemapLayer.layer;if(layerData.tileWidth>layerData.baseTileWidth){// The x origin of a tile is the left side, so x and width need to be adjusted.\nvar xDiff=(layerData.tileWidth-layerData.baseTileWidth)*tilemapLayer.scaleX;x-=xDiff;w+=xDiff;}if(layerData.tileHeight>layerData.baseTileHeight){// The y origin of a tile is the bottom side, so just the height needs to be adjusted.\nvar yDiff=(layerData.tileHeight-layerData.baseTileHeight)*tilemapLayer.scaleY;h+=yDiff;}var mapData=tilemapLayer.getTilesWithinWorldXY(x,y,w,h);if(mapData.length===0){return false;}var tile;var tileWorldRect={left:0,right:0,top:0,bottom:0};for(var i=0;i<mapData.length;i++){tile=mapData[i];tileWorldRect.left=tilemapLayer.tileToWorldX(tile.x);tileWorldRect.top=tilemapLayer.tileToWorldY(tile.y);// If the map's base tile size differs from the layer's tile size, only the top of the rect\n// needs to be adjusted since it's origin is (0, 1).\nif(tile.baseHeight!==tile.height){tileWorldRect.top-=(tile.height-tile.baseHeight)*tilemapLayer.scaleY;}tileWorldRect.right=tileWorldRect.left+tile.width*tilemapLayer.scaleX;tileWorldRect.bottom=tileWorldRect.top+tile.height*tilemapLayer.scaleY;if(TileIntersectsBody(tileWorldRect,body)&&(!processCallback||processCallback.call(callbackContext,sprite,tile))&&ProcessTileCallbacks(tile,sprite)&&(overlapOnly||SeparateTile(i,body,tile,tileWorldRect,tilemapLayer,this.TILE_BIAS))){this._total++;if(collideCallback){collideCallback.call(callbackContext,sprite,tile);}if(overlapOnly&&body.onOverlap){sprite.emit('overlap',body.gameObject,tile,body,null);}else if(body.onCollide){sprite.emit('collide',body.gameObject,tile,body,null);}}}},/**\r\n     * TODO!\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideGroupVsGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Group} group1 - [description]\r\n     * @param {Phaser.GameObjects.Group} group2 - [description]\r\n     * @param {ArcadePhysicsCallback} collideCallback - [description]\r\n     * @param {ArcadePhysicsCallback} processCallback - [description]\r\n     * @param {*} callbackContext - [description]\r\n     * @param {boolean} overlapOnly - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */collideGroupVsGroup:function collideGroupVsGroup(group1,group2,collideCallback,processCallback,callbackContext,overlapOnly){if(group1.length===0||group2.length===0){return;}var children=group1.getChildren();for(var i=0;i<children.length;i++){this.collideSpriteVsGroup(children[i],group2,collideCallback,processCallback,callbackContext,overlapOnly);}},/**\r\n    * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.\r\n    *\r\n    * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).\r\n    *\r\n    * @method Phaser.Physics.Arcade.World#wrap\r\n    * @since 3.3.0\r\n    *\r\n    * @param {*} object - A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.\r\n    * @param {number} [padding=0] - An amount added to each boundary edge during the operation.\r\n    */wrap:function wrap(object,padding){if(object.body){this.wrapObject(object,padding);}else if(object.getChildren){this.wrapArray(object.getChildren(),padding);}else if(Array.isArray(object)){this.wrapArray(object,padding);}else{this.wrapObject(object,padding);}},/**\r\n    * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n    *\r\n    * @method Phaser.Physics.Arcade.World#wrapArray\r\n    * @since 3.3.0\r\n    *\r\n    * @param {Array.<*>} arr\r\n    * @param {number} [padding=0] - An amount added to the boundary.\r\n    */wrapArray:function wrapArray(arr,padding){if(arr.length===0){return;}for(var i=0,len=arr.length;i<len;i++){this.wrapObject(arr[i],padding);}},/**\r\n    * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n    *\r\n    * @method Phaser.Physics.Arcade.World#wrapObject\r\n    * @since 3.3.0\r\n    *\r\n    * @param {*} object - A Game Object, a Physics Body, or any object with `x` and `y` coordinates\r\n    * @param {number} [padding=0] - An amount added to the boundary.\r\n    */wrapObject:function wrapObject(object,padding){if(padding===undefined){padding=0;}object.x=Wrap(object.x,this.bounds.left-padding,this.bounds.right+padding);object.y=Wrap(object.y,this.bounds.top-padding,this.bounds.bottom+padding);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.removeAllListeners();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.tree.clear();this.staticTree.clear();this.bodies.clear();this.staticBodies.clear();this.colliders.destroy();this.removeAllListeners();}});module.exports=World;/***/},/* 215 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Physics.Arcade.StaticGroup\nvar ArcadeSprite=__webpack_require__(94);var Class=__webpack_require__(0);var CONST=__webpack_require__(47);var Group=__webpack_require__(74);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class StaticGroup\r\n * @extends Phaser.GameObjects.Group\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - [description]\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {array} children - [description]\r\n * @param {GroupConfig} config - [description]\r\n */var StaticPhysicsGroup=new Class({Extends:Group,initialize:function StaticPhysicsGroup(world,scene,children,config){if(config===undefined&&!Array.isArray(children)&&(typeof children==='undefined'?'undefined':_typeof(children))==='object'){config=children;children=null;}else if(config===undefined){config={};}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticGroup#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */this.world=world;config.createCallback=this.createCallback;config.removeCallback=this.removeCallback;config.createMultipleCallback=this.createMultipleCallback;config.classType=ArcadeSprite;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticGroup#physicsType\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.physicsType=CONST.STATIC_BODY;Group.call(this,scene,children,config);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticGroup#createCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     */createCallback:function createCallback(child){if(!child.body){this.world.enableBody(child,CONST.STATIC_BODY);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticGroup#removeCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     */removeCallback:function removeCallback(child){if(child.body){this.world.disableBody(child);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticGroup#createMultipleCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} entries - [description]\r\n     */createMultipleCallback:function createMultipleCallback(){this.refresh();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticGroup#refresh\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticGroup} [description]\r\n     */refresh:function refresh(){var children=this.children.entries;for(var i=0;i<children.length;i++){children[i].body.reset();}return this;}});module.exports=StaticPhysicsGroup;/***/},/* 216 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ArcadeSprite=__webpack_require__(94);var Class=__webpack_require__(0);var CONST=__webpack_require__(47);var GetFastValue=__webpack_require__(2);var Group=__webpack_require__(74);/**\r\n * @typedef {object} PhysicsGroupConfig\r\n * @extends GroupConfig\r\n *\r\n * @property {[type]} [collideWorldBounds=false] - [description]\r\n * @property {number} [accelerationX=0] - [description]\r\n * @property {number} [accelerationY=0] - [description]\r\n * @property {number} [bounceX=0] - [description]\r\n * @property {number} [bounceY=0] - [description]\r\n * @property {number} [dragX=0] - [description]\r\n * @property {number} [dragY=0] - [description]\r\n * @property {number} [gravityX=0] - [description]\r\n * @property {number} [gravityY=0] - [description]\r\n * @property {number} [frictionX=0] - [description]\r\n * @property {number} [frictionY=0] - [description]\r\n * @property {number} [velocityX=0] - [description]\r\n * @property {number} [velocityY=0] - [description]\r\n * @property {number} [angularVelocity=0] - [description]\r\n * @property {number} [angularAcceleration=0] - [description]\r\n * @property {number} [angularDrag=0] - [description]\r\n * @property {number} [mass=0] - [description]\r\n * @property {boolean} [immovable=false] - [description]\r\n *//**\r\n * @typedef {object} PhysicsGroupDefaults\r\n *\r\n * @property {[type]} setCollideWorldBounds - [description]\r\n * @property {number} setAccelerationX - [description]\r\n * @property {number} setAccelerationY - [description]\r\n * @property {number} setBounceX - [description]\r\n * @property {number} setBounceY - [description]\r\n * @property {number} setDragX - [description]\r\n * @property {number} setDragY - [description]\r\n * @property {number} setGravityX - [description]\r\n * @property {number} setGravityY - [description]\r\n * @property {number} setFrictionX - [description]\r\n * @property {number} setFrictionY - [description]\r\n * @property {number} setVelocityX - [description]\r\n * @property {number} setVelocityY - [description]\r\n * @property {number} setAngularVelocity - [description]\r\n * @property {number} setAngularAcceleration - [description]\r\n * @property {number} setAngularDrag - [description]\r\n * @property {number} setMass - [description]\r\n * @property {boolean} setImmovable - [description]\r\n *//**\r\n * @classdesc\r\n * An Arcade Physics Group object.\r\n *\r\n * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.\r\n *\r\n * @class Group\r\n * @extends Phaser.GameObjects.Group\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - [description]\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {array} children - [description]\r\n * @param {PhysicsGroupConfig} [config] - [description]\r\n */var PhysicsGroup=new Class({Extends:Group,initialize:function PhysicsGroup(world,scene,children,config){if(config===undefined&&!Array.isArray(children)&&(typeof children==='undefined'?'undefined':_typeof(children))==='object'){config=children;children=null;}else if(config===undefined){config={};}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Group#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */this.world=world;config.createCallback=this.createCallback;config.removeCallback=this.removeCallback;config.classType=GetFastValue(config,'classType',ArcadeSprite);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Group#physicsType\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.physicsType=CONST.DYNAMIC_BODY;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.Group#defaults\r\n         * @type {PhysicsGroupDefaults}\r\n         * @since 3.0.0\r\n         */this.defaults={setCollideWorldBounds:GetFastValue(config,'collideWorldBounds',false),setAccelerationX:GetFastValue(config,'accelerationX',0),setAccelerationY:GetFastValue(config,'accelerationY',0),setBounceX:GetFastValue(config,'bounceX',0),setBounceY:GetFastValue(config,'bounceY',0),setDragX:GetFastValue(config,'dragX',0),setDragY:GetFastValue(config,'dragY',0),setGravityX:GetFastValue(config,'gravityX',0),setGravityY:GetFastValue(config,'gravityY',0),setFrictionX:GetFastValue(config,'frictionX',0),setFrictionY:GetFastValue(config,'frictionY',0),setVelocityX:GetFastValue(config,'velocityX',0),setVelocityY:GetFastValue(config,'velocityY',0),setAngularVelocity:GetFastValue(config,'angularVelocity',0),setAngularAcceleration:GetFastValue(config,'angularAcceleration',0),setAngularDrag:GetFastValue(config,'angularDrag',0),setMass:GetFastValue(config,'mass',1),setImmovable:GetFastValue(config,'immovable',false)};Group.call(this,scene,children,config);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#createCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     */createCallback:function createCallback(child){if(!child.body){this.world.enableBody(child,CONST.DYNAMIC_BODY);}var body=child.body;for(var key in this.defaults){body[key](this.defaults[key]);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#removeCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     */removeCallback:function removeCallback(child){if(child.body){this.world.disableBody(child);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} step - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.\r\n     */setVelocity:function setVelocity(x,y,step){if(step===undefined){step=0;}var items=this.getChildren();for(var i=0;i<items.length;i++){items[i].body.velocity.set(x+i*step,y+i*step);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     * @param {number} step - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.\r\n     */setVelocityX:function setVelocityX(value,step){if(step===undefined){step=0;}var items=this.getChildren();for(var i=0;i<items.length;i++){items[i].body.velocity.x=value+i*step;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     * @param {number} step - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.\r\n     */setVelocityY:function setVelocityY(value,step){if(step===undefined){step=0;}var items=this.getChildren();for(var i=0;i<items.length;i++){items[i].body.velocity.y=value+i*step;}return this;}});module.exports=PhysicsGroup;/***/},/* 217 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Physics.Arcade.Body.Components\r\n */module.exports={Acceleration:__webpack_require__(491),Angular:__webpack_require__(490),Bounce:__webpack_require__(489),Debug:__webpack_require__(488),Drag:__webpack_require__(487),Enable:__webpack_require__(486),Friction:__webpack_require__(485),Gravity:__webpack_require__(484),Immovable:__webpack_require__(483),Mass:__webpack_require__(482),Size:__webpack_require__(481),Velocity:__webpack_require__(480)};/***/},/* 218 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(217);var Image=__webpack_require__(73);/**\r\n * @classdesc\r\n * An Arcade Physics Image Game Object.\r\n *\r\n * An Image is a light-weight Game Object useful for the display of static images in your game,\r\n * such as logos, backgrounds, scenery or other non-animated elements. Images can have input\r\n * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an\r\n * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.\r\n *\r\n * @class Image\r\n * @extends Phaser.GameObjects.Image\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Arcade.Components.Acceleration\r\n * @extends Phaser.Physics.Arcade.Components.Angular\r\n * @extends Phaser.Physics.Arcade.Components.Bounce\r\n * @extends Phaser.Physics.Arcade.Components.Debug\r\n * @extends Phaser.Physics.Arcade.Components.Drag\r\n * @extends Phaser.Physics.Arcade.Components.Enable\r\n * @extends Phaser.Physics.Arcade.Components.Friction\r\n * @extends Phaser.Physics.Arcade.Components.Gravity\r\n * @extends Phaser.Physics.Arcade.Components.Immovable\r\n * @extends Phaser.Physics.Arcade.Components.Mass\r\n * @extends Phaser.Physics.Arcade.Components.Size\r\n * @extends Phaser.Physics.Arcade.Components.Velocity\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var ArcadeImage=new Class({Extends:Image,Mixins:[Components.Acceleration,Components.Angular,Components.Bounce,Components.Debug,Components.Drag,Components.Enable,Components.Friction,Components.Gravity,Components.Immovable,Components.Mass,Components.Size,Components.Velocity],initialize:function ArcadeImage(scene,x,y,texture,frame){Image.call(this,scene,x,y,texture,frame);}});module.exports=ArcadeImage;/***/},/* 219 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ArcadeImage=__webpack_require__(218);var ArcadeSprite=__webpack_require__(94);var Class=__webpack_require__(0);var CONST=__webpack_require__(47);var PhysicsGroup=__webpack_require__(216);var StaticPhysicsGroup=__webpack_require__(215);/**\r\n * @classdesc\r\n * The Arcade Physics Factory allows you to easily create Arcade Physics enabled Game Objects.\r\n * Objects that are created by this Factory are automatically added to the physics world.\r\n *\r\n * @class Factory\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics World instance.\r\n */var Factory=new Class({initialize:function Factory(world){/**\r\n         * A reference to the Arcade Physics World.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Factory#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * A reference to the Scene this Arcade Physics instance belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Factory#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=world.scene;/**\r\n         * A reference to the Scene.Systems this Arcade Physics instance belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Factory#sys\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.sys=world.scene.sys;},/**\r\n     * Create a new Arcade Physics Collider object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#collider\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} object1 - The first object to check for collision.\r\n     * @param {Phaser.Physics.Arcade.Body} object2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {*} callbackContext - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */collider:function collider(object1,object2,collideCallback,processCallback,callbackContext){return this.world.addCollider(object1,object2,collideCallback,processCallback,callbackContext);},/**\r\n     * Create a new Arcade Physics Collider Overlap object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} object1 - The first object to check for overlap.\r\n     * @param {Phaser.Physics.Arcade.Body} object2 - The second object to check for overlap.\r\n     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {*} callbackContext - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */overlap:function overlap(object1,object2,collideCallback,processCallback,callbackContext){return this.world.addOverlap(object1,object2,collideCallback,processCallback,callbackContext);},/**\r\n     * Adds an Arcade Physics Body to the given Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#existing\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     * @param {boolean} [isStatic=false] - Set to true to create a Static body, otherwise it will create a Dynamic body.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object.\r\n     */existing:function existing(gameObject,isStatic){var type=isStatic?CONST.STATIC_BODY:CONST.DYNAMIC_BODY;this.world.enableBody(gameObject,type);return gameObject;},/**\r\n     * Creates a new Arcade Image object with a Static body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#staticImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Image} The Image object that was created.\r\n     */staticImage:function staticImage(x,y,key,frame){var image=new ArcadeImage(this.scene,x,y,key,frame);this.sys.displayList.add(image);this.world.enableBody(image,CONST.STATIC_BODY);return image;},/**\r\n     * Creates a new Arcade Image object with a Dynamic body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#image\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Image} The Image object that was created.\r\n     */image:function image(x,y,key,frame){var image=new ArcadeImage(this.scene,x,y,key,frame);this.sys.displayList.add(image);this.world.enableBody(image,CONST.DYNAMIC_BODY);return image;},/**\r\n     * Creates a new Arcade Sprite object with a Static body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#staticSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Sprite} The Sprite object that was created.\r\n     */staticSprite:function staticSprite(x,y,key,frame){var sprite=new ArcadeSprite(this.scene,x,y,key,frame);this.sys.displayList.add(sprite);this.sys.updateList.add(sprite);this.world.enableBody(sprite,CONST.STATIC_BODY);return sprite;},/**\r\n     * Creates a new Arcade Sprite object with a Dynamic body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#sprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Sprite} The Sprite object that was created.\r\n     */sprite:function sprite(x,y,key,frame){var sprite=new ArcadeSprite(this.scene,x,y,key,frame);this.sys.displayList.add(sprite);this.sys.updateList.add(sprite);this.world.enableBody(sprite,CONST.DYNAMIC_BODY);return sprite;},/**\r\n     * Creates a Static Physics Group object.\r\n     * All Game Objects created by this Group will automatically be static Arcade Physics objects.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#staticGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} [children] - [description]\r\n     * @param {GroupConfig} [config] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticGroup} The Static Group object that was created.\r\n     */staticGroup:function staticGroup(children,config){return this.sys.updateList.add(new StaticPhysicsGroup(this.world,this.world.scene,children,config));},/**\r\n     * Creates a Physics Group object.\r\n     * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#group\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} [children] - [description]\r\n     * @param {PhysicsGroupConfig} [config] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Group} The Group object that was created.\r\n     */group:function group(children,config){return this.sys.updateList.add(new PhysicsGroup(this.world,this.world.scene,children,config));}});module.exports=Factory;/***/},/* 220 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Rotate\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - [description]\r\n * @param {number} angle - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Rotate=function Rotate(point,angle){var x=point.x;var y=point.y;point.x=x*Math.cos(angle)-y*Math.sin(angle);point.y=x*Math.sin(angle)+y*Math.cos(angle);return point;};module.exports=Rotate;/***/},/* 221 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Factorial\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n *\r\n * @return {number} [description]\r\n */var Factorial=function Factorial(value){if(value===0){return 1;}var res=value;while(--value){res*=value;}return res;};module.exports=Factorial;/***/},/* 222 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Factorial=__webpack_require__(221);/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Bernstein\r\n * @since 3.0.0\r\n *\r\n * @param {number} n - [description]\r\n * @param {number} i - [description]\r\n *\r\n * @return {number} [description]\r\n */var Bernstein=function Bernstein(n,i){return Factorial(n)/Factorial(i)/Factorial(n-i);};module.exports=Bernstein;/***/},/* 223 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Angle.Normalize\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - [description]\r\n *\r\n * @return {number} [description]\r\n */var Normalize=function Normalize(angle){angle=angle%(2*Math.PI);if(angle>=0){return angle;}else{return angle+2*Math.PI;}};module.exports=Normalize;/***/},/* 224 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TextFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var TextFile=new Class({Extends:File,initialize:function TextFile(key,url,path,xhrSettings){var fileConfig={type:'text',extension:'txt',responseType:'text',key:key,url:url,path:path,xhrSettings:xhrSettings};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=this.xhrLoader.responseText;this.onComplete();callback(this);}});/**\r\n * Adds a Text file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Text File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#text\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('text',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new TextFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new TextFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=TextFile;/***/},/* 225 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);var ParseXML=__webpack_require__(318);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class XMLFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var XMLFile=new Class({Extends:File,initialize:function XMLFile(key,url,path,xhrSettings){var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'xml',extension:GetFastValue(key,'extension','xml'),responseType:'text',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings)};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=ParseXML(this.xhrLoader.responseText);if(this.data===null){throw new Error('XMLFile: Invalid XML');}this.onComplete();callback(this);}});/**\r\n * Adds an XML file to the current load queue.\r\n *\r\n * Note: This method will only be available if the XML File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#xml\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('xml',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new XMLFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new XMLFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=XMLFile;/***/},/* 226 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var File=__webpack_require__(19);var GetFastValue=__webpack_require__(2);var GetURL=__webpack_require__(125);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class HTML5AudioFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} config - [description]\r\n * @param {boolean} locked - [description]\r\n */var HTML5AudioFile=new Class({Extends:File,initialize:function HTML5AudioFile(key,url,path,config,locked){this.locked=locked;this.loaded=false;var fileConfig={type:'audio',extension:GetFastValue(url,'type',''),key:key,url:GetFastValue(url,'uri',url),path:path,config:config};File.call(this,fileConfig);},onLoad:function onLoad(){if(this.loaded){return;}this.loaded=true;this.loader.nextFile(this,true);},onError:function onError(){for(var i=0;i<this.data.length;i++){var audio=this.data[i];audio.oncanplaythrough=null;audio.onerror=null;}this.loader.nextFile(this,false);},onProgress:function onProgress(event){var audio=event.target;audio.oncanplaythrough=null;audio.onerror=null;this.filesLoaded++;this.percentComplete=Math.min(this.filesLoaded/this.filesTotal,1);this.loader.emit('fileprogress',this,this.percentComplete);if(this.filesLoaded===this.filesTotal){this.onLoad();}},//  Called by the Loader, starts the actual file downloading\nload:function load(loader){this.loader=loader;this.data=[];var instances=this.config&&this.config.instances||1;this.filesTotal=instances;this.filesLoaded=0;this.percentComplete=0;for(var i=0;i<instances;i++){var audio=new Audio();audio.dataset.name=this.key+('0'+i).slice(-2);// Useful for debugging\naudio.dataset.used='false';if(!this.locked){audio.preload='auto';audio.oncanplaythrough=this.onProgress.bind(this);audio.onerror=this.onError.bind(this);}this.data.push(audio);}for(i=0;i<this.data.length;i++){audio=this.data[i];audio.src=GetURL(this,loader.baseURL);if(!this.locked){audio.load();}}if(this.locked){setTimeout(this.onLoad.bind(this));}}});module.exports=HTML5AudioFile;/***/},/* 227 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(22);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);var HTML5AudioFile=__webpack_require__(226);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class AudioFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n * @param {AudioContext} audioContext - [description]\r\n */var AudioFile=new Class({Extends:File,initialize:function AudioFile(key,url,path,xhrSettings,audioContext){/**\r\n         * [description]\r\n         *\r\n         * @property {AudioContext} context\r\n         * @since 3.0.0\r\n         */this.context=audioContext;var fileConfig={type:'audio',extension:GetFastValue(url,'type',''),responseType:'arraybuffer',key:key,url:GetFastValue(url,'uri',url),path:path,xhrSettings:xhrSettings};File.call(this,fileConfig);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioFile#onProcess\r\n     * @since 3.0.0\r\n     *\r\n     * @param {FileProcessCallback} callback - [description]\r\n     */onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;var _this=this;// interesting read https://github.com/WebAudio/web-audio-api/issues/1305\nthis.context.decodeAudioData(this.xhrLoader.response,function(audioBuffer){_this.data=audioBuffer;_this.onComplete();callback(_this);},function(e){// eslint-disable-next-line no-console\nconsole.error('Error with decoding audio data for \\''+this.key+'\\':',e.message);_this.state=CONST.FILE_ERRORED;callback(_this);});this.context=null;}});AudioFile.create=function(loader,key,urls,config,xhrSettings){var game=loader.systems.game;var audioConfig=game.config.audio;var deviceAudio=game.device.audio;if(audioConfig&&audioConfig.noAudio||!deviceAudio.webAudio&&!deviceAudio.audioData){// console.info('Skipping loading audio \\'' + key + '\\' since sounds are disabled.');\nreturn null;}var url=AudioFile.findAudioURL(game,urls);if(!url){// console.warn('No supported url provided for audio \\'' + key + '\\'!');\nreturn null;}if(deviceAudio.webAudio&&!(audioConfig&&audioConfig.disableWebAudio)){return new AudioFile(key,url,loader.path,xhrSettings,game.sound.context);}else{return new HTML5AudioFile(key,url,loader.path,config,game.sound.locked);}};/**\r\n * Adds an Audio file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Audio File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#audio\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {(string|string[])} urls - [description]\r\n * @param {object} config - [description]\r\n * @param {object} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('audio',function(key,urls,config,xhrSettings){var audioFile=AudioFile.create(this,key,urls,config,xhrSettings);if(audioFile){this.addFile(audioFile);}return this;});// this.load.audio('sound', 'assets/audio/booom.ogg', config, xhrSettings);\n//\n// this.load.audio('sound',\n//     [\n//         'assets/audio/booom.ogg',\n//         'assets/audio/booom.m4a',\n//         'assets/audio/booom.mp3'\n//     ],\n//     config, xhrSettings);\n//\n// this.load.audio('sound',\n//     {\n//         uri: 'assets/audio/boooooom',\n//         type: 'ogg'\n//     },\n//     config, xhrSettings);\n//\n// this.load.audio('sound',\n//     [\n//         {\n//             uri: 'assets/audio/booooooo',\n//             type: 'ogg'\n//         },\n//         {\n//             uri: 'assets/audio/boooooom',\n//             type: 'mp3'\n//         }\n//     ],\n//     config, xhrSettings);\n//\n// this.load.audio('sound',\n//     [\n//         {\n//             uri: 'assets/audio/booooooo',\n//             type: 'ogg'\n//         },\n//         'assets/audio/booom.m4a',\n//         {\n//             uri: 'assets/audio/boooooom',\n//             type: 'mp3'\n//         }\n//     ],\n//     config, xhrSettings);\nAudioFile.findAudioURL=function(game,urls){if(urls.constructor!==Array){urls=[urls];}for(var i=0;i<urls.length;i++){var url=GetFastValue(urls[i],'uri',urls[i]);if(url.indexOf('blob:')===0||url.indexOf('data:')===0){return url;}var audioType=url.match(/\\.([a-zA-Z0-9]+)($|\\?)/);audioType=GetFastValue(urls[i],'type',audioType?audioType[1]:'').toLowerCase();if(game.device.audio[audioType]){return{uri:url,type:audioType};}}return null;};module.exports=AudioFile;/***/},/* 228 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MergeXHRSettings=__webpack_require__(124);/**\r\n * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings\r\n * and starts the download of it. It uses the Files own XHRSettings and merges them\r\n * with the global XHRSettings object to set the xhr values before download.\r\n *\r\n * @function Phaser.Loader.XHRLoader\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File to download.\r\n * @param {XHRSettingsObject} globalXHRSettings - The global XHRSettings object.\r\n *\r\n * @return {XMLHttpRequest} The XHR object.\r\n */var XHRLoader=function XHRLoader(file,globalXHRSettings){var config=MergeXHRSettings(globalXHRSettings,file.xhrSettings);var xhr=new XMLHttpRequest();xhr.open('GET',file.src,config.async,config.user,config.password);xhr.responseType=file.xhrSettings.responseType;xhr.timeout=config.timeout;if(config.header&&config.headerValue){xhr.setRequestHeader(config.header,config.headerValue);}if(config.overrideMimeType){xhr.overrideMimeType(config.overrideMimeType);}// After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)\nxhr.onload=file.onLoad.bind(file);xhr.onerror=file.onError.bind(file);xhr.onprogress=file.onProgress.bind(file);//  This is the only standard method, the ones above are browser additions (maybe not universal?)\n// xhr.onreadystatechange\nxhr.send();return xhr;};module.exports=XHRLoader;/***/},/* 229 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @callback HitAreaCallback\r\n *\r\n * @param {*} hitArea - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n *\r\n * @return {boolean} [description]\r\n *//**\r\n * @typedef {object} Phaser.Input.InteractiveObject\r\n *\r\n * @property {Phaser.GameObjects.GameObject} gameObject - [description]\r\n * @property {boolean} enabled - [description]\r\n * @property {boolean} draggable - [description]\r\n * @property {boolean} dropZone - [description]\r\n * @property {?Phaser.GameObjects.GameObject} target - [description]\r\n * @property {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n * @property {*} hitArea - [description]\r\n * @property {HitAreaCallback} hitAreaCallback - [description]\r\n * @property {number} localX - [description]\r\n * @property {number} localY - [description]\r\n * @property {(0|1|2)} dragState - [description]\r\n * @property {number} dragStartX - [description]\r\n * @property {number} dragStartY - [description]\r\n * @property {number} dragX - [description]\r\n * @property {number} dragY - [description]\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Input.CreateInteractiveObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n * @param {*} hitArea - [description]\r\n * @param {HitAreaCallback} hitAreaCallback - [description]\r\n *\r\n * @return {Phaser.Input.InteractiveObject} [description]\r\n */var CreateInteractiveObject=function CreateInteractiveObject(gameObject,hitArea,hitAreaCallback){return{gameObject:gameObject,enabled:true,draggable:false,dropZone:false,target:null,camera:null,hitArea:hitArea,hitAreaCallback:hitAreaCallback,localX:0,localY:0,//  0 = Not being dragged\n//  1 = Being checked for dragging\n//  2 = Being dragged\ndragState:0,dragStartX:0,dragStartY:0,dragX:0,dragY:0};};module.exports=CreateInteractiveObject;/***/},/* 230 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);// The three angle bisectors of a triangle meet in one point called the incenter.\n// It is the center of the incircle, the circle inscribed in the triangle.\nfunction getLength(x1,y1,x2,y2){var x=x1-x2;var y=y1-y2;var magnitude=x*x+y*y;return Math.sqrt(magnitude);}/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.InCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Point} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var InCenter=function InCenter(triangle,out){if(out===undefined){out=new Point();}var x1=triangle.x1;var y1=triangle.y1;var x2=triangle.x2;var y2=triangle.y2;var x3=triangle.x3;var y3=triangle.y3;var d1=getLength(x3,y3,x2,y2);var d2=getLength(x1,y1,x3,y3);var d3=getLength(x2,y2,x1,y1);var p=d1+d2+d3;out.x=(x1*d1+x2*d2+x3*d3)/p;out.y=(y1*d1+y2*d2+y3*d3)/p;return out;};module.exports=InCenter;/***/},/* 231 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var Offset=function Offset(triangle,x,y){triangle.x1+=x;triangle.y1+=y;triangle.x2+=x;triangle.y2+=y;triangle.x3+=x;triangle.y3+=y;return triangle;};module.exports=Offset;/***/},/* 232 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);//  The three medians (the lines drawn from the vertices to the bisectors of the opposite sides)\n//  meet in the centroid or center of mass (center of gravity).\n//  The centroid divides each median in a ratio of 2:1\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Centroid\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var Centroid=function Centroid(triangle,out){if(out===undefined){out=new Point();}out.x=(triangle.x1+triangle.x2+triangle.x3)/3;out.y=(triangle.y1+triangle.y2+triangle.y3)/3;return out;};module.exports=Centroid;/***/},/* 233 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Length=__webpack_require__(79);var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {integer} quantity - [description]\r\n * @param {number} stepRate - [description]\r\n * @param {(array|Phaser.Geom.Point[])} [out] - [description]\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} [description]\r\n */var GetPoints=function GetPoints(triangle,quantity,stepRate,out){if(out===undefined){out=[];}var line1=triangle.getLineA();var line2=triangle.getLineB();var line3=triangle.getLineC();var length1=Length(line1);var length2=Length(line2);var length3=Length(line3);var perimeter=length1+length2+length3;//  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\nif(!quantity){quantity=perimeter/stepRate;}for(var i=0;i<quantity;i++){var p=perimeter*(i/quantity);var localPosition=0;var point=new Point();//  Which line is it on?\nif(p<length1){//  Line 1\nlocalPosition=p/length1;point.x=line1.x1+(line1.x2-line1.x1)*localPosition;point.y=line1.y1+(line1.y2-line1.y1)*localPosition;}else if(p>length1+length2){//  Line 3\np-=length1+length2;localPosition=p/length3;point.x=line3.x1+(line3.x2-line3.x1)*localPosition;point.y=line3.y1+(line3.y2-line3.y1)*localPosition;}else{//  Line 2\np-=length1;localPosition=p/length2;point.x=line2.x1+(line2.x2-line2.x1)*localPosition;point.y=line2.y1+(line2.y2-line2.y1)*localPosition;}out.push(point);}return out;};module.exports=GetPoints;/***/},/* 234 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);var Length=__webpack_require__(79);//  Position is a value between 0 and 1\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.GetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {float} position - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var GetPoint=function GetPoint(triangle,position,out){if(out===undefined){out=new Point();}var line1=triangle.getLineA();var line2=triangle.getLineB();var line3=triangle.getLineC();if(position<=0||position>=1){out.x=line1.x1;out.y=line1.y1;return out;}var length1=Length(line1);var length2=Length(line2);var length3=Length(line3);var perimeter=length1+length2+length3;var p=perimeter*position;var localPosition=0;//  Which line is it on?\nif(p<length1){//  Line 1\nlocalPosition=p/length1;out.x=line1.x1+(line1.x2-line1.x1)*localPosition;out.y=line1.y1+(line1.y2-line1.y1)*localPosition;}else if(p>length1+length2){//  Line 3\np-=length1+length2;localPosition=p/length3;out.x=line3.x1+(line3.x2-line3.x1)*localPosition;out.y=line3.y1+(line3.y2-line3.y1)*localPosition;}else{//  Line 2\np-=length1;localPosition=p/length2;out.x=line2.x1+(line2.x2-line2.x1)*localPosition;out.y=line2.y1+(line2.y2-line2.y1)*localPosition;}return out;};module.exports=GetPoint;/***/},/* 235 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */// Centers this Rectangle so that the center coordinates match the given x and y values.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.CenterOn\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var CenterOn=function CenterOn(rect,x,y){rect.x=x-rect.width/2;rect.y=y-rect.height/2;return rect;};module.exports=CenterOn;/***/},/* 236 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);Rectangle.Area=__webpack_require__(606);Rectangle.Ceil=__webpack_require__(605);Rectangle.CeilAll=__webpack_require__(604);Rectangle.CenterOn=__webpack_require__(235);Rectangle.Clone=__webpack_require__(603);Rectangle.Contains=__webpack_require__(27);Rectangle.ContainsPoint=__webpack_require__(602);Rectangle.ContainsRect=__webpack_require__(601);Rectangle.CopyFrom=__webpack_require__(600);Rectangle.Decompose=__webpack_require__(242);Rectangle.Equals=__webpack_require__(599);Rectangle.FitInside=__webpack_require__(598);Rectangle.FitOutside=__webpack_require__(597);Rectangle.Floor=__webpack_require__(596);Rectangle.FloorAll=__webpack_require__(595);Rectangle.FromPoints=__webpack_require__(157);Rectangle.GetAspectRatio=__webpack_require__(127);Rectangle.GetCenter=__webpack_require__(594);Rectangle.GetPoint=__webpack_require__(173);Rectangle.GetPoints=__webpack_require__(365);Rectangle.GetSize=__webpack_require__(593);Rectangle.Inflate=__webpack_require__(592);Rectangle.MarchingAnts=__webpack_require__(361);Rectangle.MergePoints=__webpack_require__(591);Rectangle.MergeRect=__webpack_require__(590);Rectangle.MergeXY=__webpack_require__(589);Rectangle.Offset=__webpack_require__(588);Rectangle.OffsetPoint=__webpack_require__(587);Rectangle.Overlaps=__webpack_require__(586);Rectangle.Perimeter=__webpack_require__(109);Rectangle.PerimeterPoint=__webpack_require__(585);Rectangle.Random=__webpack_require__(170);Rectangle.Scale=__webpack_require__(584);Rectangle.Union=__webpack_require__(277);module.exports=Rectangle;/***/},/* 237 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Contains=__webpack_require__(128);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Polygon\r\n * @memberOf Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point[]} [points] - [description]\r\n */var Polygon=new Class({initialize:function Polygon(points){/**\r\n         * The area of this Polygon.\r\n         *\r\n         * @name Phaser.Geom.Polygon#area\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.area=0;/**\r\n         * An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]\r\n         *\r\n         * @name Phaser.Geom.Polygon#points\r\n         * @type {Phaser.Geom.Point[]}\r\n         * @since 3.0.0\r\n         */this.points=[];if(points){this.setTo(points);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Geom.Polygon#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */contains:function contains(x,y){return Contains(this,x,y);},/**\r\n     * Sets this Polygon to the given points.\r\n     *\r\n     * The points can be set from a variety of formats:\r\n     *\r\n     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`\r\n     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`\r\n     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\r\n     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\r\n     *\r\n     * `setTo` may also be called without any arguments to remove all points.\r\n     *\r\n     * @method Phaser.Geom.Polygon#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} points - [description]\r\n     *\r\n     * @return {Phaser.Geom.Polygon} This Polygon object.\r\n     */setTo:function setTo(points){this.area=0;this.points=[];if(!Array.isArray(points)){return this;}var entry;var y0=Number.MAX_VALUE;var p;//  The points argument is an array, so iterate through it\nfor(var i=0;i<points.length;i++){p={x:0,y:0};if(typeof points[i]==='number'){p.x=points[i];p.y=points[i+1];i++;}else if(Array.isArray(entry)){//  An array of arrays?\np.x=points[i][0];p.y=points[i][1];}else{p.x=points[i].x;p.y=points[i].y;}this.points.push(p);//  Lowest boundary\nif(p.y<y0){y0=p.y;}}this.calculateArea(y0);return this;},/**\r\n     * Calculates the area of the Polygon. This is available in the property Polygon.area\r\n     *\r\n     * @method Phaser.Geom.Polygon#calculateArea\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */calculateArea:function calculateArea(){if(this.points.length<3){this.area=0;return this.area;}var sum=0;var p1;var p2;for(var i=0;i<this.points.length-1;i++){p1=this.points[i];p2=this.points[i+1];sum+=(p2.x-p1.x)*(p1.y+p2.y);}p1=this.points[0];p2=this.points[this.points.length-1];sum+=(p1.x-p2.x)*(p2.y+p1.y);this.area=-sum*0.5;return this.area;}});module.exports=Polygon;/***/},/* 238 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.GetMagnitudeSq\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {number} [description]\r\n */var GetMagnitudeSq=function GetMagnitudeSq(point){return point.x*point.x+point.y*point.y;};module.exports=GetMagnitudeSq;/***/},/* 239 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.GetMagnitude\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {number} [description]\r\n */var GetMagnitude=function GetMagnitude(point){return Math.sqrt(point.x*point.x+point.y*point.y);};module.exports=GetMagnitude;/***/},/* 240 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MATH_CONST=__webpack_require__(16);var Wrap=__webpack_require__(44);var Angle=__webpack_require__(55);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.NormalAngle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var NormalAngle=function NormalAngle(line){var angle=Angle(line)-MATH_CONST.TAU;return Wrap(angle,-Math.PI,Math.PI);};module.exports=NormalAngle;/***/},/* 241 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Decompose\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {array} [out] - [description]\r\n *\r\n * @return {array} [description]\r\n */var Decompose=function Decompose(triangle,out){if(out===undefined){out=[];}out.push({x:triangle.x1,y:triangle.y1});out.push({x:triangle.x2,y:triangle.y2});out.push({x:triangle.x3,y:triangle.y3});return out;};module.exports=Decompose;/***/},/* 242 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Decompose\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {array} [out] - [description]\r\n *\r\n * @return {array} [description]\r\n */var Decompose=function Decompose(rect,out){if(out===undefined){out=[];}out.push({x:rect.x,y:rect.y});out.push({x:rect.right,y:rect.y});out.push({x:rect.right,y:rect.bottom});out.push({x:rect.x,y:rect.bottom});return out;};module.exports=Decompose;/***/},/* 243 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.PointToLine\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var PointToLine=function PointToLine(point,line){return(point.x-line.x1)*(line.y2-line.y1)===(line.x2-line.x1)*(point.y-line.y1);};module.exports=PointToLine;/***/},/* 244 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Based on code by Matt DesLauriers\n//  https://github.com/mattdesl/line-circle-collision/blob/master/LICENSE.md\nvar Contains=__webpack_require__(28);var Point=__webpack_require__(4);var tmp=new Point();/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.LineToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {Phaser.Geom.Circle} circle - [description]\r\n * @param {Phaser.Geom.Point} [nearest] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var LineToCircle=function LineToCircle(line,circle,nearest){if(nearest===undefined){nearest=tmp;}if(Contains(circle,line.x1,line.y1)){nearest.x=line.x1;nearest.y=line.y1;return true;}if(Contains(circle,line.x2,line.y2)){nearest.x=line.x2;nearest.y=line.y2;return true;}var dx=line.x2-line.x1;var dy=line.y2-line.y1;var lcx=circle.x-line.x1;var lcy=circle.y-line.y1;//  project lc onto d, resulting in vector p\nvar dLen2=dx*dx+dy*dy;var px=dx;var py=dy;if(dLen2>0){var dp=(lcx*dx+lcy*dy)/dLen2;px*=dp;py*=dp;}nearest.x=line.x1+px;nearest.y=line.y1+py;//  len2 of p\nvar pLen2=px*px+py*py;return pLen2<=dLen2&&px*dx+py*dy>=0&&Contains(circle,nearest.x,nearest.y);};module.exports=LineToCircle;/***/},/* 245 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.RectangleToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - [description]\r\n * @param {Phaser.Geom.Rectangle} rectB - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var RectangleToRectangle=function RectangleToRectangle(rectA,rectB){if(rectA.width<=0||rectA.height<=0||rectB.width<=0||rectB.height<=0){return false;}return!(rectA.right<rectB.x||rectA.bottom<rectB.y||rectA.x>rectB.right||rectA.y>rectB.bottom);};module.exports=RectangleToRectangle;/***/},/* 246 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Geom.Intersects\r\n */module.exports={CircleToCircle:__webpack_require__(653),CircleToRectangle:__webpack_require__(652),GetRectangleIntersection:__webpack_require__(651),LineToCircle:__webpack_require__(244),LineToLine:__webpack_require__(96),LineToRectangle:__webpack_require__(650),PointToLine:__webpack_require__(243),PointToLineSegment:__webpack_require__(649),RectangleToRectangle:__webpack_require__(245),RectangleToTriangle:__webpack_require__(648),RectangleToValues:__webpack_require__(647),TriangleToCircle:__webpack_require__(646),TriangleToLine:__webpack_require__(645),TriangleToTriangle:__webpack_require__(644)};/***/},/* 247 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Geom\r\n */module.exports={Circle:__webpack_require__(663),Ellipse:__webpack_require__(276),Intersects:__webpack_require__(246),Line:__webpack_require__(643),Point:__webpack_require__(625),Polygon:__webpack_require__(611),Rectangle:__webpack_require__(236),Triangle:__webpack_require__(583)};/***/},/* 248 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Light=__webpack_require__(249);var LightPipeline=__webpack_require__(180);var Utils=__webpack_require__(38);/**\r\n * @callback LightForEach\r\n *\r\n * @param {Phaser.GameObjects.Light} light - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class LightsManager\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n */var LightsManager=new Class({initialize:function LightsManager(){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#lightPool\r\n         * @type {Phaser.GameObjects.Light[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.lightPool=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#lights\r\n         * @type {Phaser.GameObjects.Light[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.lights=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#culledLights\r\n         * @type {Phaser.GameObjects.Light[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.culledLights=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#ambientColor\r\n         * @type {{ r: float, g: float, b: float }}\r\n         * @since 3.0.0\r\n         */this.ambientColor={r:0.1,g:0.1,b:0.1};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#active\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.active=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.\r\n     */enable:function enable(){this.active=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.\r\n     */disable:function disable(){this.active=false;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#cull\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Light[]} [description]\r\n     */cull:function cull(camera){var lights=this.lights;var culledLights=this.culledLights;var length=lights.length;var cameraCenterX=camera.x+camera.width/2.0;var cameraCenterY=camera.y+camera.height/2.0;var cameraRadius=(camera.width+camera.height)/2.0;var point={x:0,y:0};var cameraMatrix=camera.matrix;var viewportHeight=this.systems.game.config.height;culledLights.length=0;for(var index=0;index<length&&culledLights.length<LightPipeline.LIGHT_COUNT;++index){var light=lights[index];cameraMatrix.transformPoint(light.x,light.y,point);// We'll just use bounding spheres to test\n// if lights should be rendered\nvar dx=cameraCenterX-(point.x-camera.scrollX*light.scrollFactorX*camera.zoom);var dy=cameraCenterY-(viewportHeight-(point.y-camera.scrollY*light.scrollFactorY*camera.zoom));var distance=Math.sqrt(dx*dx+dy*dy);if(distance<light.radius+cameraRadius){culledLights.push(lights[index]);}}return culledLights;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#forEachLight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {LightForEach} callback - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.\r\n     */forEachLight:function forEachLight(callback){if(!callback){return;}var lights=this.lights;var length=lights.length;for(var index=0;index<length;++index){callback(lights[index]);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#setAmbientColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rgb - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.\r\n     */setAmbientColor:function setAmbientColor(rgb){var color=Utils.getFloatsFromUintRGB(rgb);this.ambientColor.r=color[0];this.ambientColor.g=color[1];this.ambientColor.b=color[2];return this;},/**\r\n     * Returns the maximum number of Lights allowed to appear at once.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#getMaxVisibleLights\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */getMaxVisibleLights:function getMaxVisibleLights(){return 10;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#getLightCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */getLightCount:function getLightCount(){return this.lights.length;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#addLight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} radius - [description]\r\n     * @param {number} rgb - [description]\r\n     * @param {number} intensity - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Light} [description]\r\n     */addLight:function addLight(x,y,radius,rgb,intensity){var color=null;var light=null;x=x===undefined?0.0:x;y=y===undefined?0.0:y;rgb=rgb===undefined?0xffffff:rgb;radius=radius===undefined?100.0:radius;intensity=intensity===undefined?1.0:intensity;color=Utils.getFloatsFromUintRGB(rgb);light=null;if(this.lightPool.length>0){light=this.lightPool.pop();light.set(x,y,radius,color[0],color[1],color[2],intensity);}else{light=new Light(x,y,radius,color[0],color[1],color[2],intensity);}this.lights.push(light);return light;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#removeLight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Light} light - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.LightsManager} This Lights Manager object.\r\n     */removeLight:function removeLight(light){var index=this.lights.indexOf(light);if(index>=0){this.lightPool.push(light);this.lights.splice(index,1);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){while(this.lights.length>0){this.lightPool.push(this.lights.pop());}this.ambientColor={r:0.1,g:0.1,b:0.1};this.culledLights.length=0;this.lights.length=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.shutdown();}});module.exports=LightsManager;/***/},/* 249 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Utils=__webpack_require__(38);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Light\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of the light.\r\n * @param {number} y - The vertical position of the light.\r\n * @param {number} radius - The radius of the light.\r\n * @param {number} r - The red color. A value between 0 and 1.\r\n * @param {number} g - The green color. A value between 0 and 1.\r\n * @param {number} b - The blue color. A value between 0 and 1.\r\n * @param {number} intensity - The intensity of the light.\r\n */var Light=new Class({initialize:function Light(x,y,radius,r,g,b,intensity){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.y=y;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#radius\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.radius=radius;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#r\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.r=r;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#g\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.g=g;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#b\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.b=b;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#intensity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.intensity=intensity;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#scrollFactorX\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.scrollFactorX=1.0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Light#scrollFactorY\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.scrollFactorY=1.0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Light#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of the light.\r\n     * @param {number} y - The vertical position of the light.\r\n     * @param {number} radius - The radius of the light.\r\n     * @param {number} r - The red color. A value between 0 and 1.\r\n     * @param {number} g - The green color. A value between 0 and 1.\r\n     * @param {number} b - The blue color. A value between 0 and 1.\r\n     * @param {number} intensity - The intensity of the light.\r\n     *\r\n     * @return {Phaser.GameObjects.Light} This Light object.\r\n     */set:function set(x,y,radius,r,g,b,intensity){this.x=x;this.y=y;this.radius=radius;this.r=r;this.g=g;this.b=b;this.intensity=intensity;this.scrollFactorX=1;this.scrollFactorY=1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Light#setScrollFactor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scroll factor of the light.\r\n     * @param {number} y - The vertical scroll factor of the light.\r\n     *\r\n     * @return {Phaser.GameObjects.Light} This Light object.\r\n     */setScrollFactor:function setScrollFactor(x,y){if(x===undefined){x=1;}if(y===undefined){y=x;}this.scrollFactorX=x;this.scrollFactorY=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Light#setColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rgb - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Light} This Light object.\r\n     */setColor:function setColor(rgb){var color=Utils.getFloatsFromUintRGB(rgb);this.r=color[0];this.g=color[1];this.b=color[2];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Light#setIntensity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} intensity - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Light} This Light object.\r\n     */setIntensity:function setIntensity(intensity){this.intensity=intensity;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Light#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of the light.\r\n     * @param {number} y - The vertical position of the light.\r\n     *\r\n     * @return {Phaser.GameObjects.Light} This Light object.\r\n     */setPosition:function setPosition(x,y){this.x=x;this.y=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Light#setRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Light} This Light object.\r\n     */setRadius:function setRadius(radius){this.radius=radius;return this;}});module.exports=Light;/***/},/* 250 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the nearest power of 2 to the given `value`.\r\n *\r\n * @function Phaser.Math.Pow2.GetPowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n *\r\n * @return {integer} [description]\r\n */var GetPowerOfTwo=function GetPowerOfTwo(value){//  Math.log(2)\nvar index=Math.log(value)/0.6931471805599453;return 1<<Math.ceil(index);};module.exports=GetPowerOfTwo;/***/},/* 251 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var DegToRad=__webpack_require__(43);var GetBoolean=__webpack_require__(70);var GetValue=__webpack_require__(5);var Sprite=__webpack_require__(41);var TWEEN_CONST=__webpack_require__(69);var Vector2=__webpack_require__(6);/**\r\n * @typedef {object} PathConfig\r\n *\r\n * @property {number} duration - [description]\r\n * @property {number} from - [description]\r\n * @property {number} to - [description]\r\n * @property {boolean} [positionOnPath=false] - [description]\r\n * @property {boolean} [rotateToPath=false] - [description]\r\n * @property {number} [rotationOffset=0] - [description]\r\n * @property {boolean} [verticalAdjust=false] - [description]\r\n *//**\r\n * @classdesc\r\n * A PathFollower Game Object.\r\n *\r\n * A PathFollower is a Sprite Game Object with some extra helpers to allow it to follow a Path automatically.\r\n *\r\n * Anything you can do with a standard Sprite can be done with this PathFollower, such as animate it, tint it,\r\n * scale it and so on.\r\n *\r\n * PathFollowers are bound to a single Path at any one time and can traverse the length of the Path, from start\r\n * to finish, forwards or backwards, or from any given point on the Path to its end. They can optionally rotate\r\n * to face the direction of the path, be offset from the path coordinates or rotate independently of the Path.\r\n *\r\n * @class PathFollower\r\n * @extends Phaser.GameObjects.Sprite\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {Phaser.Curves.Path} path - The Path this PathFollower is following. It can only follow one Path at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var PathFollower=new Class({Extends:Sprite,initialize:function PathFollower(scene,path,x,y,texture,frame){Sprite.call(this,scene,x,y,texture,frame);/**\r\n         * The Path this PathFollower is following. It can only follow one Path at a time.\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#path\r\n         * @type {Phaser.Curves.Path}\r\n         * @since 3.0.0\r\n         */this.path=path;/**\r\n         * Should the PathFollower automatically rotate to point in the direction of the Path?\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#rotateToPath\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.rotateToPath=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#pathRotationVerticalAdjust\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.pathRotationVerticalAdjust=false;/**\r\n         * If the PathFollower is rotating to match the Path (@see Phaser.GameObjects.PathFollower#rotateToPath)\r\n         * this value is added to the rotation value. This allows you to rotate objects to a path but control\r\n         * the angle of the rotation as well.\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#pathRotationOffset\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.pathRotationOffset=0;/**\r\n         * An additional vector to add to the PathFollowers position, allowing you to offset it from the\r\n         * Path coordinates.\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#pathOffset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.pathOffset=new Vector2(x,y);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#pathVector\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.pathVector=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#pathTween\r\n         * @type {Phaser.Tweens.Tween}\r\n         * @since 3.0.0\r\n         */this.pathTween;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#pathConfig\r\n         * @type {?PathConfig}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.pathConfig=null;/**\r\n         * Records the direction of the follower so it can change direction.\r\n         *\r\n         * @name Phaser.GameObjects.PathFollower#_prevDirection\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._prevDirection=TWEEN_CONST.PLAYING_FORWARD;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.PathFollower#setPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Curves.Path} path - The Path this PathFollower is following. It can only follow one Path at a time.\r\n     * @param {PathConfig} [config] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n     */setPath:function setPath(path,config){if(config===undefined){config=this.pathConfig;}var tween=this.pathTween;if(tween&&tween.isPlaying()){tween.stop();}this.path=path;if(config){this.startFollow(config);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.PathFollower#setRotateToPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     * @param {number} [offset=0] - Rotation offset in degrees.\r\n     * @param {boolean} [verticalAdjust=false] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n     */setRotateToPath:function setRotateToPath(value,offset,verticalAdjust){if(offset===undefined){offset=0;}if(verticalAdjust===undefined){verticalAdjust=false;}this.rotateToPath=value;this.pathRotationOffset=offset;this.pathRotationVerticalAdjust=verticalAdjust;return this;},/**\r\n     * Is this PathFollower actively following a Path or not?\r\n     * To be considered as `isFollowing` it must be currently moving on a Path, and not paused.\r\n     *\r\n     * @method Phaser.GameObjects.PathFollower#isFollowing\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` is this PathFollower is actively following a Path, otherwise `false`.\r\n     */isFollowing:function isFollowing(){var tween=this.pathTween;return tween&&tween.isPlaying();},/**\r\n     * Starts this PathFollower following its given Path.\r\n     *\r\n     * @method Phaser.GameObjects.PathFollower#startFollow\r\n     * @since 3.3.0\r\n     *\r\n     * @param {(number|PathConfig)} [config={}] - [description]\r\n     * @param {number} [startAt=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n     */startFollow:function startFollow(config,startAt){if(config===undefined){config={};}if(startAt===undefined){startAt=0;}var tween=this.pathTween;if(tween&&tween.isPlaying()){tween.stop();}if(typeof config==='number'){config={duration:config};}//  Override in case they've been specified in the config\nconfig.from=0;config.to=1;//  Can also read extra values out of the config:\nvar positionOnPath=GetBoolean(config,'positionOnPath',false);this.rotateToPath=GetBoolean(config,'rotateToPath',false);this.pathRotationOffset=GetValue(config,'rotationOffset',0);this.pathRotationVerticalAdjust=GetBoolean(config,'verticalAdjust',false);this.pathTween=this.scene.sys.tweens.addCounter(config);//  The starting point of the path, relative to this follower\nthis.path.getStartPoint(this.pathOffset);if(positionOnPath){this.x=this.pathOffset.x;this.y=this.pathOffset.y;}this.pathOffset.x=this.x-this.pathOffset.x;this.pathOffset.y=this.y-this.pathOffset.y;this._prevDirection=TWEEN_CONST.PLAYING_FORWARD;if(this.rotateToPath){//  Set the rotation now (in case the tween has a delay on it, etc)\nvar nextPoint=this.path.getPoint(0.1);this.rotation=Math.atan2(nextPoint.y-this.y,nextPoint.x-this.x)+DegToRad(this.pathRotationOffset);}this.pathConfig=config;return this;},/**\r\n     * Pauses this PathFollower. It will still continue to render, but it will remain motionless at the\r\n     * point on the Path at which you paused it.\r\n     *\r\n     * @method Phaser.GameObjects.PathFollower#pauseFollow\r\n     * @since 3.3.0\r\n     *\r\n     * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n     */pauseFollow:function pauseFollow(){var tween=this.pathTween;if(tween&&tween.isPlaying()){tween.pause();}return this;},/**\r\n     * Resumes a previously paused PathFollower.\r\n     * If the PathFollower was not paused this has no effect.\r\n     *\r\n     * @method Phaser.GameObjects.PathFollower#resumeFollow\r\n     * @since 3.3.0\r\n     *\r\n     * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n     */resumeFollow:function resumeFollow(){var tween=this.pathTween;if(tween&&tween.isPaused()){tween.resume();}return this;},/**\r\n     * Stops this PathFollower from following the path any longer.\r\n     * This will invoke any 'stop' conditions that may exist on the Path, or for the follower.\r\n     *\r\n     * @method Phaser.GameObjects.PathFollower#stopFollow\r\n     * @since 3.3.0\r\n     *\r\n     * @return {Phaser.GameObjects.PathFollower} This Game Object.\r\n     */stopFollow:function stopFollow(){var tween=this.pathTween;if(tween&&tween.isPlaying()){tween.stop();}return this;},/**\r\n     * Internal update handler that advances this PathFollower along the path.\r\n     * Called automatically by the Scene step, should not typically be called directly.\r\n     *\r\n     * @method Phaser.GameObjects.PathFollower#preUpdate\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */preUpdate:function preUpdate(time,delta){this.anims.update(time,delta);var tween=this.pathTween;if(tween){var tweenData=tween.data[0];if(tweenData.state!==TWEEN_CONST.PLAYING_FORWARD&&tweenData.state!==TWEEN_CONST.PLAYING_BACKWARD){//  If delayed, etc then bail out\nreturn;}var pathVector=this.pathVector;this.path.getPoint(tween.getValue(),pathVector);pathVector.add(this.pathOffset);var oldX=this.x;var oldY=this.y;this.setPosition(pathVector.x,pathVector.y);var speedX=this.x-oldX;var speedY=this.y-oldY;if(speedX===0&&speedY===0){//  Bail out early\nreturn;}if(tweenData.state!==this._prevDirection){//  We've changed direction, so don't do a rotate this frame\nthis._prevDirection=tweenData.state;return;}if(this.rotateToPath){this.rotation=Math.atan2(speedY,speedX)+DegToRad(this.pathRotationOffset);if(this.pathRotationVerticalAdjust){this.flipY=this.rotation!==0&&tweenData.state===TWEEN_CONST.PLAYING_BACKWARD;}}}}});module.exports=PathFollower;/***/},/* 252 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class RandomZone\r\n * @memberOf Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - [description]\r\n */var RandomZone=new Class({initialize:function RandomZone(source){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.RandomZone#source\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.source=source;/**\r\n         * Internal calculation vector.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.RandomZone#_tempVec\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tempVec=new Vector2();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.RandomZone#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n     */getPoint:function getPoint(particle){var vec=this._tempVec;this.source.getRandomPoint(vec);particle.x=vec.x;particle.y=vec.y;}});module.exports=RandomZone;/***/},/* 253 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Verifies that an object contains at least one of the requested keys\r\n *\r\n * @function Phaser.Utils.Object.HasAny\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - an object on which to check for key existence\r\n * @param {string[]} keys - an array of keys to search the object for\r\n *\r\n * @return {boolean} true if the source object contains at least one of the keys, false otherwise\r\n */var HasAny=function HasAny(source,keys){for(var i=0;i<keys.length;i++){if(source.hasOwnProperty(keys[i])){return true;}}return false;};module.exports=HasAny;/***/},/* 254 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Stepped\nmodule.exports=__webpack_require__(718);/***/},/* 255 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Sine\nmodule.exports={In:__webpack_require__(721),Out:__webpack_require__(720),InOut:__webpack_require__(719)};/***/},/* 256 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Quintic\nmodule.exports={In:__webpack_require__(724),Out:__webpack_require__(723),InOut:__webpack_require__(722)};/***/},/* 257 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Quartic\nmodule.exports={In:__webpack_require__(727),Out:__webpack_require__(726),InOut:__webpack_require__(725)};/***/},/* 258 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Quadratic\nmodule.exports={In:__webpack_require__(730),Out:__webpack_require__(729),InOut:__webpack_require__(728)};/***/},/* 259 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Linear\nmodule.exports=__webpack_require__(731);/***/},/* 260 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Expo\nmodule.exports={In:__webpack_require__(734),Out:__webpack_require__(733),InOut:__webpack_require__(732)};/***/},/* 261 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Elastic\nmodule.exports={In:__webpack_require__(737),Out:__webpack_require__(736),InOut:__webpack_require__(735)};/***/},/* 262 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Cubic\nmodule.exports={In:__webpack_require__(740),Out:__webpack_require__(739),InOut:__webpack_require__(738)};/***/},/* 263 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Circular\nmodule.exports={In:__webpack_require__(743),Out:__webpack_require__(742),InOut:__webpack_require__(741)};/***/},/* 264 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Bounce\nmodule.exports={In:__webpack_require__(746),Out:__webpack_require__(745),InOut:__webpack_require__(744)};/***/},/* 265 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Phaser.Math.Easing.Back\nmodule.exports={In:__webpack_require__(749),Out:__webpack_require__(748),InOut:__webpack_require__(747)};/***/},/* 266 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.FloatBetween\r\n * @since 3.0.0\r\n *\r\n * @param {float} min - [description]\r\n * @param {float} max - [description]\r\n *\r\n * @return {float} [description]\r\n */var FloatBetween=function FloatBetween(min,max){return Math.random()*(max-min)+min;};module.exports=FloatBetween;/***/},/* 267 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class EdgeZone\r\n * @memberOf Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - [description]\r\n * @param {number} quantity - [description]\r\n * @param {number} stepRate - [description]\r\n * @param {boolean} [yoyo=false] - [description]\r\n * @param {boolean} [seamless=true] - [description]\r\n */var EdgeZone=new Class({initialize:function EdgeZone(source,quantity,stepRate,yoyo,seamless){if(yoyo===undefined){yoyo=false;}if(seamless===undefined){seamless=true;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#source\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.source=source;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#points\r\n         * @type {Phaser.Geom.Point[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.points=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#quantity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.quantity=quantity;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#stepRate\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.stepRate=stepRate;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#yoyo\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.yoyo=yoyo;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#counter\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */this.counter=-1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#seamless\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.seamless=seamless;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_length\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._length=0;/**\r\n         * 0 = forwards, 1 = backwards\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_direction\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._direction=0;this.updateSource();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#updateSource\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Zones.EdgeZone} This Edge Zone.\r\n     */updateSource:function updateSource(){this.points=this.source.getPoints(this.quantity,this.stepRate);//  Remove ends?\nif(this.seamless){var a=this.points[0];var b=this.points[this.points.length-1];if(a.x===b.x&&a.y===b.y){this.points.pop();}}var oldLength=this._length;this._length=this.points.length;//  Adjust counter if we now have less points than before\nif(this._length<oldLength&&this.counter>this._length){this.counter=this._length-1;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#changeSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Zones.EdgeZone} This Edge Zone.\r\n     */changeSource:function changeSource(source){this.source=source;return this.updateSource();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n     */getPoint:function getPoint(particle){if(this._direction===0){this.counter++;if(this.counter>=this._length){if(this.yoyo){this._direction=1;this.counter=this._length-1;}else{this.counter=0;}}}else{this.counter--;if(this.counter===-1){if(this.yoyo){this._direction=0;this.counter=0;}else{this.counter=this._length-1;}}}var point=this.points[this.counter];if(point){particle.x=point.x;particle.y=point.y;}}});module.exports=EdgeZone;/***/},/* 268 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * A Death Zone.\r\n *\r\n * A Death Zone is a special type of zone that will kill a Particle as soon as it either enters, or leaves, the zone.\r\n *\r\n * The zone consists of a `source` which could be a Geometric shape, such as a Rectangle or Ellipse, or your own\r\n * object as long as it includes a `contains` method for which the Particles can be tested against.\r\n *\r\n * @class DeathZone\r\n * @memberOf Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.\r\n * @param {boolean} killOnEnter - Should the Particle be killed when it enters the zone? `true` or leaves it? `false`\r\n */var DeathZone=new Class({initialize:function DeathZone(source,killOnEnter){/**\r\n         * An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.\r\n         * This could be a Geometry shape, such as `Phaser.Geom.Circle`, or your own custom object.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.DeathZone#source\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.source=source;/**\r\n         * Set to `true` if the Particle should be killed if it enters this zone.\r\n         * Set to `false` to kill the Particle if it leaves this zone.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.DeathZone#killOnEnter\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.killOnEnter=killOnEnter;},/**\r\n     * Checks if the given Particle will be killed or not by this zone.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.DeathZone#willKill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle to be checked against this zone.\r\n     *\r\n     * @return {boolean} Return `true` if the Particle is to be killed, otherwise return `false`.\r\n     */willKill:function willKill(particle){var withinZone=this.source.contains(particle.x,particle.y);return withinZone&&this.killOnEnter||!withinZone&&!this.killOnEnter;}});module.exports=DeathZone;/***/},/* 269 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BlendModes=__webpack_require__(64);var Class=__webpack_require__(0);var Components=__webpack_require__(12);var DeathZone=__webpack_require__(268);var EdgeZone=__webpack_require__(267);var EmitterOp=__webpack_require__(751);var GetFastValue=__webpack_require__(2);var GetRandom=__webpack_require__(144);var HasAny=__webpack_require__(253);var HasValue=__webpack_require__(71);var Particle=__webpack_require__(270);var RandomZone=__webpack_require__(252);var Rectangle=__webpack_require__(10);var StableSort=__webpack_require__(98);var Vector2=__webpack_require__(6);var Wrap=__webpack_require__(44);/**\r\n * @callback ParticleEmitterCallback\r\n *\r\n * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - [description]\r\n *//**\r\n * @callback ParticleDeathCallback\r\n *\r\n * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ParticleEmitter\r\n * @memberOf Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} manager - The Emitter Manager this Emitter belongs to.\r\n * @param {object} config - [description]\r\n */var ParticleEmitter=new Class({Mixins:[Components.BlendMode,Components.ScrollFactor,Components.Visible],initialize:function ParticleEmitter(manager,config){/**\r\n         * The Emitter Manager this Emitter belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#manager\r\n         * @type {Phaser.GameObjects.Particles.ParticleEmitterManager}\r\n         * @since 3.0.0\r\n         */this.manager=manager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.0.0\r\n         */this.texture=manager.texture;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frames\r\n         * @type {Phaser.Textures.Frame[]}\r\n         * @since 3.0.0\r\n         */this.frames=[manager.defaultFrame];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#defaultFrame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.0.0\r\n         */this.defaultFrame=manager.defaultFrame;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#configFastMap\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.configFastMap=['active','blendMode','collideBottom','collideLeft','collideRight','collideTop','deathCallback','deathCallbackScope','emitCallback','emitCallbackScope','follow','frequency','gravityX','gravityY','maxParticles','name','on','particleBringToTop','particleClass','radial','timeScale','trackVisible','visible'];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#configOpMap\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.configOpMap=['accelerationX','accelerationY','alpha','bounce','delay','lifespan','maxVelocityX','maxVelocityY','moveToX','moveToY','quantity','rotate','scaleX','scaleY','speedX','speedY','tint','x','y'];/**\r\n         * The name of this Game Object.\r\n         *\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.name='';/**\r\n         * The Particle Class which will be emitted by this Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#particleClass\r\n         * @type {Phaser.GameObjects.Particles.Particle}\r\n         * @since 3.0.0\r\n         */this.particleClass=Particle;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.x=new EmitterOp(config,'x',0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.y=new EmitterOp(config,'y',0);/**\r\n         * A radial emitter will emit particles in all directions between angle min and max,\r\n         * using speed as the value. If set to false then this acts as a point Emitter.\r\n         * A point emitter will emit particles only in the direction derived from the speedX and speedY values.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#radial\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.radial=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#gravityX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.gravityX=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#gravityY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.gravityY=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#acceleration\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.acceleration=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#accelerationX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accelerationX=new EmitterOp(config,'accelerationX',0,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#accelerationY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accelerationY=new EmitterOp(config,'accelerationY',0,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityX\r\n         * @type {number}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */this.maxVelocityX=new EmitterOp(config,'maxVelocityX',10000,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityY\r\n         * @type {number}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */this.maxVelocityY=new EmitterOp(config,'maxVelocityY',10000,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#speedX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.speedX=new EmitterOp(config,'speedX',0,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#speedY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.speedY=new EmitterOp(config,'speedY',0,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveTo\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.moveTo=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveToX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.moveToX=new EmitterOp(config,'moveToX',0,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveToY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.moveToY=new EmitterOp(config,'moveToY',0,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#bounce\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.bounce=new EmitterOp(config,'bounce',0,true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#scaleX\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.scaleX=new EmitterOp(config,'scaleX',1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#scaleY\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.scaleY=new EmitterOp(config,'scaleY',1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#tint\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.tint=new EmitterOp(config,'tint',0xffffffff);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#alpha\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.alpha=new EmitterOp(config,'alpha',1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#lifespan\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */this.lifespan=new EmitterOp(config,'lifespan',1000);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#angle\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.angle=new EmitterOp(config,'angle',{min:0,max:360});/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#rotate\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.rotate=new EmitterOp(config,'rotate',0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitCallback\r\n         * @type {?ParticleEmitterCallback}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.emitCallback=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitCallbackScope\r\n         * @type {?*}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.emitCallbackScope=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathCallback\r\n         * @type {?ParticleDeathCallback}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.deathCallback=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathCallbackScope\r\n         * @type {?*}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.deathCallbackScope=null;/**\r\n         * Set to hard limit the amount of particle objects this emitter is allowed to create.\r\n         * 0 means unlimited.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxParticles\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.maxParticles=0;/**\r\n         * How many particles are emitted each time the emitter updates.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#quantity\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.quantity=new EmitterOp(config,'quantity',1,true);/**\r\n         * How many ms to wait after emission before the particles start updating.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#delay\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.delay=new EmitterOp(config,'delay',0,true);/**\r\n         * How often a particle is emitted in ms (if emitter is a constant / flow emitter)\r\n         * If emitter is an explosion emitter this value will be -1.\r\n         * Anything > -1 sets this to be a flow emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frequency\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.frequency=0;/**\r\n         * Controls if the emitter is currently emitting particles.\r\n         * Already alive particles will continue to update until they expire.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#on\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.on=true;/**\r\n         * Newly emitted particles are added to the top of the particle list, i.e. rendered above those already alive.\r\n         * Set to false to send them to the back.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#particleBringToTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.particleBringToTop=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.timeScale=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitZone\r\n         * @type {?object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.emitZone=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathZone\r\n         * @type {?object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.deathZone=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#bounds\r\n         * @type {?Phaser.Geom.Rectangle}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.bounds=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideLeft\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.collideLeft=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideRight\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.collideRight=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.collideTop=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideBottom\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.collideBottom=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.active=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#visible\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.visible=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#blendMode\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.blendMode=BlendModes.NORMAL;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#follow\r\n         * @type {?Phaser.GameObjects.Particles.Particle}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.follow=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#followOffset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.followOffset=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#trackVisible\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.trackVisible=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#currentFrame\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.currentFrame=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#randomFrame\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.randomFrame=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frameQuantity\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.frameQuantity=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#dead\r\n         * @type {Phaser.GameObjects.Particles.Particle[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.dead=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#alive\r\n         * @type {Phaser.GameObjects.Particles.Particle[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.alive=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#_counter\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._counter=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#_frameCounter\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._frameCounter=0;if(config){this.fromJSON(config);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */fromJSON:function fromJSON(config){if(!config){return this;}//  Only update properties from their current state if they exist in the given config\nvar i=0;var key='';for(i=0;i<this.configFastMap.length;i++){key=this.configFastMap[i];if(HasValue(config,key)){this[key]=GetFastValue(config,key);}}for(i=0;i<this.configOpMap.length;i++){key=this.configOpMap[i];if(HasValue(config,key)){this[key].loadConfig(config);}}this.acceleration=this.accelerationX.propertyValue!==0||this.accelerationY.propertyValue!==0;this.moveTo=this.moveToX.propertyValue!==0||this.moveToY.propertyValue!==0;//  Special 'speed' override\nif(HasValue(config,'speed')){this.speedX.loadConfig(config,'speed');this.speedY=null;}//  If you specify speedX, speedY ot moveTo then it changes the emitter from radial to a point emitter\nif(HasAny(config,['speedX','speedY'])||this.moveTo){this.radial=false;}//  Special 'scale' override\nif(HasValue(config,'scale')){this.scaleX.loadConfig(config,'scale');this.scaleY=null;}if(HasValue(config,'callbackScope')){var callbackScope=GetFastValue(config,'callbackScope',null);this.emitCallbackScope=callbackScope;this.deathCallbackScope=callbackScope;}if(HasValue(config,'emitZone')){this.setEmitZone(config.emitZone);}if(HasValue(config,'deathZone')){this.setDeathZone(config.deathZone);}if(HasValue(config,'bounds')){this.setBounds(config.bounds);}if(HasValue(config,'followOffset')){this.followOffset.setFromObject(GetFastValue(config,'followOffset',0));}if(HasValue(config,'frame')){this.setFrame(config.frame);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} output - [description]\r\n     *\r\n     * @return {object} [description]\r\n     */toJSON:function toJSON(output){if(output===undefined){output={};}var i=0;var key='';for(i=0;i<this.configFastMap.length;i++){key=this.configFastMap[i];output[key]=this[key];}for(i=0;i<this.configOpMap.length;i++){key=this.configOpMap[i];if(this[key]){output[key]=this[key].toJSON();}}//  special handlers\nif(!this.speedY){delete output.speedX;output.speed=this.speedX.toJSON();}if(!this.scaleY){delete output.scaleX;output.scale=this.scaleX.toJSON();}return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} target - [description]\r\n     * @param {number} [offsetX=0] - [description]\r\n     * @param {number} [offsetY=0] - [description]\r\n     * @param {boolean} [trackVisible=false] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */startFollow:function startFollow(target,offsetX,offsetY,trackVisible){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}if(trackVisible===undefined){trackVisible=false;}this.follow=target;this.followOffset.set(offsetX,offsetY);this.trackVisible=trackVisible;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#stopFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */stopFollow:function stopFollow(){this.follow=null;this.followOffset.set(0,0);this.trackVisible=false;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} [description]\r\n     */getFrame:function getFrame(){if(this.frames.length===1){return this.defaultFrame;}else if(this.randomFrame){return GetRandom(this.frames);}else{var frame=this.frames[this.currentFrame];this._frameCounter++;if(this._frameCounter===this.frameQuantity){this._frameCounter=0;this.currentFrame=Wrap(this.currentFrame+1,0,this._frameLength);}return frame;}},// frame: 0\n// frame: 'red'\n// frame: [ 0, 1, 2, 3 ]\n// frame: [ 'red', 'green', 'blue', 'pink', 'white' ]\n// frame: { frames: [ 'red', 'green', 'blue', 'pink', 'white' ], [cycle: bool], [quantity: int] }\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|string|integer|object)} frames - [description]\r\n     * @param {boolean} [pickRandom=true] - [description]\r\n     * @param {integer} [quantity=1] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setFrame:function setFrame(frames,pickRandom,quantity){if(pickRandom===undefined){pickRandom=true;}if(quantity===undefined){quantity=1;}this.randomFrame=pickRandom;this.frameQuantity=quantity;this.currentFrame=0;this._frameCounter=0;var t=typeof frames==='undefined'?'undefined':_typeof(frames);if(Array.isArray(frames)||t==='string'||t==='number'){this.manager.setEmitterFrames(frames,this);}else if(t==='object'){var frameConfig=frames;frames=GetFastValue(frameConfig,'frames',null);if(frames){this.manager.setEmitterFrames(frames,this);}var isCycle=GetFastValue(frameConfig,'cycle',false);this.randomFrame=isCycle?false:true;this.frameQuantity=GetFastValue(frameConfig,'quantity',quantity);}this._frameLength=this.frames.length;if(this._frameLength===1){this.frameQuantity=1;this.randomFrame=false;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setRadial\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setRadial:function setRadial(value){if(value===undefined){value=true;}this.radial=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setPosition:function setPosition(x,y){this.x.onChange(x);this.y.onChange(y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setBounds:function setBounds(x,y,width,height){if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){var obj=x;x=obj.x;y=obj.y;width=HasValue(obj,'w')?obj.w:obj.width;height=HasValue(obj,'h')?obj.h:obj.height;}if(this.bounds){this.bounds.setTo(x,y,width,height);}else{this.bounds=new Rectangle(x,y,width,height);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeedX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setSpeedX:function setSpeedX(value){this.speedX.onChange(value);//  If you specify speedX and Y then it changes the emitter from radial to a point emitter\nthis.radial=false;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeedY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setSpeedY:function setSpeedY(value){if(this.speedY){this.speedY.onChange(value);//  If you specify speedX and Y then it changes the emitter from radial to a point emitter\nthis.radial=false;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeed\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setSpeed:function setSpeed(value){this.speedX.onChange(value);this.speedY=null;//  If you specify speedX and Y then it changes the emitter from radial to a point emitter\nthis.radial=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScaleX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setScaleX:function setScaleX(value){this.scaleX.onChange(value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScaleY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setScaleY:function setScaleY(value){this.scaleY.onChange(value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setScale:function setScale(value){this.scaleX.onChange(value);this.scaleY=null;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setGravityX:function setGravityX(value){this.gravityX=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setGravityY:function setGravityY(value){this.gravityY=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setGravity:function setGravity(x,y){this.gravityX=x;this.gravityY=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setAlpha:function setAlpha(value){this.alpha.onChange(value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setEmitterAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setEmitterAngle:function setEmitterAngle(value){this.angle.onChange(value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setAngle:function setAngle(value){this.angle.onChange(value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setLifespan\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setLifespan:function setLifespan(value){this.lifespan.onChange(value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setQuantity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} quantity - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setQuantity:function setQuantity(quantity){this.quantity.onChange(quantity);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setFrequency\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} frequency - [description]\r\n     * @param {integer} [quantity] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setFrequency:function setFrequency(frequency,quantity){this.frequency=frequency;this._counter=0;if(quantity){this.quantity.onChange(quantity);}return this;},/**\r\n     * The zone must have a function called `getPoint` that takes a particle object and sets\r\n     * its x and y properties accordingly then returns that object.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setEmitZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [zoneConfig] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setEmitZone:function setEmitZone(zoneConfig){if(zoneConfig===undefined){this.emitZone=null;}else{//  Where source = Geom like Circle, or a Path or Curve\n//  emitZone: { type: 'random', source: X }\n//  emitZone: { type: 'edge', source: X, quantity: 32, [stepRate=0], [yoyo=false], [seamless=true] }\nvar type=GetFastValue(zoneConfig,'type','random');var source=GetFastValue(zoneConfig,'source',null);if(source&&typeof source.getPoint==='function'){switch(type){case'random':this.emitZone=new RandomZone(source);break;case'edge':var quantity=GetFastValue(zoneConfig,'quantity',1);var stepRate=GetFastValue(zoneConfig,'stepRate',0);var yoyo=GetFastValue(zoneConfig,'yoyo',false);var seamless=GetFastValue(zoneConfig,'seamless',true);this.emitZone=new EdgeZone(source,quantity,stepRate,yoyo,seamless);break;}}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setDeathZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [zoneConfig] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */setDeathZone:function setDeathZone(zoneConfig){if(zoneConfig===undefined){this.deathZone=null;}else{//  Where source = Geom like Circle or Rect that supports a 'contains' function\n//  deathZone: { type: 'onEnter', source: X }\n//  deathZone: { type: 'onLeave', source: X }\nvar type=GetFastValue(zoneConfig,'type','onEnter');var source=GetFastValue(zoneConfig,'source',null);if(source&&typeof source.contains==='function'){var killOnEnter=type==='onEnter'?true:false;this.deathZone=new DeathZone(source,killOnEnter);}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#reserve\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} particleCount - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */reserve:function reserve(particleCount){var dead=this.dead;for(var i=0;i<particleCount;i++){dead.push(new this.particleClass(this));}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getAliveParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} The number of currently alive Particles in this Emitter.\r\n     */getAliveParticleCount:function getAliveParticleCount(){return this.alive.length;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getDeadParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} The number of currently dead Particles in this Emitter.\r\n     */getDeadParticleCount:function getDeadParticleCount(){return this.dead.length;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} The number of Particles in this Emitter, including both alive and dead.\r\n     */getParticleCount:function getParticleCount(){return this.getAliveParticleCount()+this.getDeadParticleCount();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#atLimit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Returns `true` if this Emitter is at its limit, or `false` if no limit, or below the `maxParticles` level.\r\n     */atLimit:function atLimit(){return this.maxParticles>0&&this.getParticleCount()===this.maxParticles;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#onParticleEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ParticleEmitterCallback} callback - [description]\r\n     * @param {*} [context] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */onParticleEmit:function onParticleEmit(callback,context){if(callback===undefined){//  Clear any previously set callback\nthis.emitCallback=null;this.emitCallbackScope=null;}else if(typeof callback==='function'){this.emitCallback=callback;if(context){this.emitCallbackScope=context;}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#onParticleDeath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ParticleDeathCallback} callback - [description]\r\n     * @param {*} [context] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */onParticleDeath:function onParticleDeath(callback,context){if(callback===undefined){//  Clear any previously set callback\nthis.deathCallback=null;this.deathCallbackScope=null;}else if(typeof callback==='function'){this.deathCallback=callback;if(context){this.deathCallbackScope=context;}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#killAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */killAll:function killAll(){var dead=this.dead;var alive=this.alive;while(alive.length>0){dead.push(alive.pop());}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#forEachAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ParticleEmitterCallback} callback - [description]\r\n     * @param {*} thisArg - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */forEachAlive:function forEachAlive(callback,thisArg){var alive=this.alive;var length=alive.length;for(var index=0;index<length;++index){//  Sends the Particle and the Emitter\ncallback.call(thisArg,alive[index],this);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#forEachDead\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ParticleEmitterCallback} callback - [description]\r\n     * @param {*} thisArg - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */forEachDead:function forEachDead(callback,thisArg){var dead=this.dead;var length=dead.length;for(var index=0;index<length;++index){//  Sends the Particle and the Emitter\ncallback.call(thisArg,dead[index],this);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#start\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */start:function start(){this.on=true;this._counter=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */pause:function pause(){this.active=false;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */resume:function resume(){this.active=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#depthSort\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */depthSort:function depthSort(){StableSort.inplace(this.alive,this.depthSortCallback);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#flow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} frequency - [description]\r\n     * @param {integer} [count=1] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} This Particle Emitter.\r\n     */flow:function flow(frequency,count){if(count===undefined){count=1;}this.frequency=frequency;this.quantity.onChange(count);return this.start();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#explode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} count - The amount of Particles to emit.\r\n     * @param {number} x - The x coordinate to emit the Particles from.\r\n     * @param {number} y - The y coordinate to emit the Particles from.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     */explode:function explode(count,x,y){this.frequency=-1;return this.emitParticle(count,x,y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#emitParticleAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to emit the Particles from.\r\n     * @param {number} y - The y coordinate to emit the Particles from.\r\n     * @param {integer} count - The amount of Particles to emit.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     */emitParticleAt:function emitParticleAt(x,y,count){return this.emitParticle(count,x,y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#emitParticle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} count - The amount of Particles to emit.\r\n     * @param {number} x - The x coordinate to emit the Particles from.\r\n     * @param {number} y - The y coordinate to emit the Particles from.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     */emitParticle:function emitParticle(count,x,y){if(this.atLimit()){return;}if(count===undefined){count=this.quantity.onEmit();}var dead=this.dead;for(var i=0;i<count;i++){var particle;if(dead.length>0){particle=dead.pop();}else{particle=new this.particleClass(this);}particle.fire(x,y);if(this.particleBringToTop){this.alive.push(particle);}else{this.alive.unshift(particle);}if(this.emitCallback){this.emitCallback.call(this.emitCallbackScope,particle,this);}if(this.atLimit()){break;}}return particle;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */preUpdate:function preUpdate(time,delta){//  Scale the delta\ndelta*=this.timeScale;var step=delta/1000;if(this.trackVisible){this.visible=this.follow.visible;}//  Any particle processors?\nvar processors=this.manager.getProcessors();var particles=this.alive;var length=particles.length;for(var index=0;index<length;index++){var particle=particles[index];//  update returns `true` if the particle is now dead (lifeStep < 0)\nif(particle.update(delta,step,processors)){//  Moves the dead particle to the end of the particles array (ready for splicing out later)\nvar last=particles[length-1];particles[length-1]=particle;particles[index]=last;index-=1;length-=1;}}//  Move dead particles to the dead array\nvar deadLength=particles.length-length;if(deadLength>0){var rip=particles.splice(particles.length-deadLength,deadLength);var deathCallback=this.deathCallback;var deathCallbackScope=this.deathCallbackScope;if(deathCallback){for(var i=0;i<rip.length;i++){deathCallback.call(deathCallbackScope,rip[i]);}}this.dead.concat(rip);StableSort.inplace(particles,this.indexSortCallback);}if(!this.on){return;}if(this.frequency===0){this.emitParticle();}else if(this.frequency>0){this._counter-=delta;if(this._counter<=0){this.emitParticle();//  counter = frequency - remained from previous delta\nthis._counter=this.frequency-Math.abs(this._counter);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} a - [description]\r\n     * @param {object} b - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */depthSortCallback:function depthSortCallback(a,b){return a.y-b.y;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#indexSortCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} a - [description]\r\n     * @param {object} b - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */indexSortCallback:function indexSortCallback(a,b){return a.index-b.index;}});module.exports=ParticleEmitter;/***/},/* 270 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var DegToRad=__webpack_require__(43);var DistanceBetween=__webpack_require__(49);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Particle\r\n * @memberOf Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter to which this Particle belongs.\r\n */var Particle=new Class({initialize:function Particle(emitter){/**\r\n         * The Emitter to which this Particle belongs.\r\n         *\r\n         * A Particle can only belong to a single Emitter and is created, updated and destroyed via it.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#emitter\r\n         * @type {Phaser.GameObjects.Particles.ParticleEmitter}\r\n         * @since 3.0.0\r\n         */this.emitter=emitter;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.frame=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#index\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.index=0;/**\r\n         * The x coordinate of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.x=0;/**\r\n         * The y coordinate of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.y=0;/**\r\n         * The x velocity of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#velocityX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.velocityX=0;/**\r\n         * The y velocity of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#velocityY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.velocityY=0;/**\r\n         * The x acceleration of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#accelerationX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accelerationX=0;/**\r\n         * The y acceleration of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#accelerationY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accelerationY=0;/**\r\n         * The maximum horizontal velocity this Particle can travel at.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#maxVelocityX\r\n         * @type {number}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */this.maxVelocityX=10000;/**\r\n         * The maximum vertical velocity this Particle can travel at.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#maxVelocityY\r\n         * @type {number}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */this.maxVelocityY=10000;/**\r\n         * The bounciness, or restitution, of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#bounce\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.bounce=0;/**\r\n         * The horizontal scale of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#scaleX\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.scaleX=1;/**\r\n         * The vertical scale of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#scaleY\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.scaleY=1;/**\r\n         * The alpha value of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#alpha\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.alpha=1;/**\r\n         * The angle of this Particle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#angle\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.angle=0;/**\r\n         * The angle of this Particle in radians.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#rotation\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.rotation=0;/**\r\n         * The horizontal scroll factor of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#scrollFactorX\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.scrollFactorX=1;/**\r\n         * The vertical scroll factor of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#scrollFactorY\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.scrollFactorY=1;/**\r\n         * The tint applied to this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#tint\r\n         * @type {number}\r\n         * @webglOnly\r\n         * @since 3.0.0\r\n         */this.tint=0xffffffff;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#color\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.color=0xffffffff;/**\r\n         * The lifespan of this Particle in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#life\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */this.life=1000;/**\r\n         * The current life of this Particle in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#lifeCurrent\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */this.lifeCurrent=1000;/**\r\n         * The delay applied to this Particle upon emission, in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#delayCurrent\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.delayCurrent=0;/**\r\n         * The normalized lifespan T value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#lifeT\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.lifeT=0;/**\r\n         * The data used by the ease equation.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#data\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.data={tint:{min:0xffffff,max:0xffffff,current:0xffffff},alpha:{min:1,max:1},rotate:{min:0,max:0},scaleX:{min:1,max:1},scaleY:{min:1,max:1}};},/**\r\n     * Checks to see if this Particle is alive and updating.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#isAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Particle is alive and updating, otherwise `false`.\r\n     */isAlive:function isAlive(){return this.lifeCurrent>0;},/**\r\n     * Starts this Particle from the given coordinates.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#fire\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to launch this Particle from.\r\n     * @param {number} y - The y coordinate to launch this Particle from.\r\n     */fire:function fire(x,y){var emitter=this.emitter;this.frame=emitter.getFrame();if(emitter.emitZone){//  Updates particle.x and particle.y during this call\nemitter.emitZone.getPoint(this);}if(x===undefined){if(emitter.follow){this.x+=emitter.follow.x+emitter.followOffset.x;}this.x+=emitter.x.onEmit(this,'x');}else{this.x+=x;}if(y===undefined){if(emitter.follow){this.y+=emitter.follow.y+emitter.followOffset.y;}this.y+=emitter.y.onEmit(this,'y');}else{this.y+=y;}this.life=emitter.lifespan.onEmit(this,'lifespan');this.lifeCurrent=this.life;this.lifeT=0;var sx=emitter.speedX.onEmit(this,'speedX');var sy=emitter.speedY?emitter.speedY.onEmit(this,'speedY'):sx;if(emitter.radial){var rad=DegToRad(emitter.angle.onEmit(this,'angle'));this.velocityX=Math.cos(rad)*Math.abs(sx);this.velocityY=Math.sin(rad)*Math.abs(sy);}else if(emitter.moveTo){var mx=emitter.moveToX.onEmit(this,'moveToX');var my=emitter.moveToY?emitter.moveToY.onEmit(this,'moveToY'):mx;var angle=Math.atan2(my-this.y,mx-this.x);var speed=DistanceBetween(this.x,this.y,mx,my)/(this.life/1000);//  We know how many pixels we need to move, but how fast?\n// var speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1000);\nthis.velocityX=Math.cos(angle)*speed;this.velocityY=Math.sin(angle)*speed;}else{this.velocityX=sx;this.velocityY=sy;}if(emitter.acceleration){this.accelerationX=emitter.accelerationX.onEmit(this,'accelerationX');this.accelerationY=emitter.accelerationY.onEmit(this,'accelerationY');}this.maxVelocityX=emitter.maxVelocityX.onEmit(this,'maxVelocityX');this.maxVelocityY=emitter.maxVelocityY.onEmit(this,'maxVelocityY');this.delayCurrent=emitter.delay.onEmit(this,'delay');this.scaleX=emitter.scaleX.onEmit(this,'scaleX');this.scaleY=emitter.scaleY?emitter.scaleY.onEmit(this,'scaleY'):this.scaleX;this.angle=emitter.rotate.onEmit(this,'rotate');this.rotation=DegToRad(this.angle);this.bounce=emitter.bounce.onEmit(this,'bounce');this.alpha=emitter.alpha.onEmit(this,'alpha');this.tint=emitter.tint.onEmit(this,'tint');this.color=this.tint&0x00FFFFFF|(this.alpha*0xFF|0)<<24;this.index=emitter.alive.length;},/**\r\n     * An internal method that calculates the velocity of the Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#computeVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter that is updating this Particle.\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {float} step - The delta value divided by 1000.\r\n     * @param {array} processors - [description]\r\n     */computeVelocity:function computeVelocity(emitter,delta,step,processors){var vx=this.velocityX;var vy=this.velocityY;var ax=this.accelerationX;var ay=this.accelerationY;var mx=this.maxVelocityX;var my=this.maxVelocityY;vx+=emitter.gravityX*step;vy+=emitter.gravityY*step;if(ax){vx+=ax*step;}if(ay){vy+=ay*step;}if(vx>mx){vx=mx;}else if(vx<-mx){vx=-mx;}if(vy>my){vy=my;}else if(vy<-my){vy=-my;}this.velocityX=vx;this.velocityY=vy;//  Apply any additional processors\nfor(var i=0;i<processors.length;i++){processors[i].update(this,delta,step);}},/**\r\n     * Checks if this Particle is still within the bounds defined by the given Emitter.\r\n     *\r\n     * If not, and depending on the Emitter collision flags, the Particle may either stop or rebound.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#checkBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter to check the bounds against.\r\n     */checkBounds:function checkBounds(emitter){var bounds=emitter.bounds;var bounce=-this.bounce;if(this.x<bounds.x&&emitter.collideLeft){this.x=bounds.x;this.velocityX*=bounce;}else if(this.x>bounds.right&&emitter.collideRight){this.x=bounds.right;this.velocityX*=bounce;}if(this.y<bounds.y&&emitter.collideTop){this.y=bounds.y;this.velocityY*=bounce;}else if(this.y>bounds.bottom&&emitter.collideBottom){this.y=bounds.bottom;this.velocityY*=bounce;}},/**\r\n     * The main update method for this Particle.\r\n     *\r\n     * Updates its life values, computes the velocity and repositions the Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {float} step - The delta value divided by 1000.\r\n     * @param {array} processors - An optional array of update processors.\r\n     *\r\n     * @return {boolean} Returns `true` if this Particle has now expired and should be removed, otherwise `false` if still active.\r\n     */update:function update(delta,step,processors){if(this.delayCurrent>0){this.delayCurrent-=delta;return false;}var emitter=this.emitter;//  How far along in life is this particle? (t = 0 to 1)\nvar t=1-this.lifeCurrent/this.life;this.lifeT=t;this.computeVelocity(emitter,delta,step,processors);this.x+=this.velocityX*step;this.y+=this.velocityY*step;if(emitter.bounds){this.checkBounds(emitter);}if(emitter.deathZone&&emitter.deathZone.willKill(this)){this.lifeCurrent=0;//  No need to go any further, particle has been killed\nreturn true;}this.scaleX=emitter.scaleX.onUpdate(this,'scaleX',t,this.scaleX);if(emitter.scaleY){this.scaleY=emitter.scaleY.onUpdate(this,'scaleY',t,this.scaleY);}else{this.scaleY=this.scaleX;}this.angle=emitter.rotate.onUpdate(this,'rotate',t,this.angle);this.rotation=DegToRad(this.angle);this.alpha=emitter.alpha.onUpdate(this,'alpha',t,this.alpha);this.tint=emitter.tint.onUpdate(this,'tint',t,this.tint);this.color=this.tint&0x00FFFFFF|(this.alpha*0xFF|0)<<24;this.lifeCurrent-=delta;return this.lifeCurrent<=0;}});module.exports=Particle;/***/},/* 271 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetFastValue=__webpack_require__(2);/**\r\n * @typedef {object} GravityWellConfig\r\n *\r\n * @property {number} [x=0] - The x coordinate of the Gravity Well, in world space.\r\n * @property {number} [y=0] - The y coordinate of the Gravity Well, in world space.\r\n * @property {number} [power=0] - The power of the Gravity Well.\r\n * @property {number} [epsilon=100] - [description]\r\n * @property {number} [gravity=50] - The gravitational force of this Gravity Well.\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class GravityWell\r\n * @memberOf Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(number|GravityWellConfig)} [x=0] - The x coordinate of the Gravity Well, in world space.\r\n * @param {number} [y=0] - The y coordinate of the Gravity Well, in world space.\r\n * @param {number} [power=0] - The power of the Gravity Well.\r\n * @param {number} [epsilon=100] - [description]\r\n * @param {number} [gravity=50] - The gravitational force of this Gravity Well.\r\n */var GravityWell=new Class({initialize:function GravityWell(x,y,power,epsilon,gravity){if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){var config=x;x=GetFastValue(config,'x',0);y=GetFastValue(config,'y',0);power=GetFastValue(config,'power',0);epsilon=GetFastValue(config,'epsilon',100);gravity=GetFastValue(config,'gravity',50);}else{if(x===undefined){x=0;}if(y===undefined){y=0;}if(power===undefined){power=0;}if(epsilon===undefined){epsilon=100;}if(gravity===undefined){gravity=50;}}/**\r\n         * The x coordinate of the Gravity Well, in world space.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * The y coordinate of the Gravity Well, in world space.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.y=y;/**\r\n         * The active state of the Gravity Well. An inactive Gravity Well will not influence any particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.active=true;/**\r\n         * Internal gravity value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_gravity\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._gravity=gravity;/**\r\n         * Internal power value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_power\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._power=0;/**\r\n         * Internal epsilon value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_epsilon\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._epsilon=0;/**\r\n         * The power of the Gravity Well.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#power\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.power=power;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#epsilon\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.epsilon=epsilon;},/**\r\n     * Takes a Particle and updates it based on the properties of this Gravity Well.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.GravityWell#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle to update.\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {float} step - The delta value divided by 1000.\r\n     */update:function update(particle,delta){var x=this.x-particle.x;var y=this.y-particle.y;var dSq=x*x+y*y;if(dSq===0){return;}var d=Math.sqrt(dSq);if(dSq<this._epsilon){dSq=this._epsilon;}var factor=this._power*delta/(dSq*d)*100;particle.velocityX+=x*factor;particle.velocityY+=y*factor;},epsilon:{get:function get(){return Math.sqrt(this._epsilon);},set:function set(value){this._epsilon=value*value;}},power:{get:function get(){return this._power/this._gravity;},set:function set(value){this._power=value*this._gravity;}},gravity:{get:function get(){return this._gravity;},set:function set(value){var pwr=this.power;this._gravity=value;this.power=pwr;}}});module.exports=GravityWell;/***/},/* 272 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Commands=__webpack_require__(150);var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n * @param {CanvasRenderingContext2D} renderTargetCtx - [description]\r\n * @param {boolean} allowClip - [description]\r\n */var GraphicsCanvasRenderer=function GraphicsCanvasRenderer(renderer,src,interpolationPercentage,camera,parentMatrix,renderTargetCtx,allowClip){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}var cameraScrollX=camera.scrollX*src.scrollFactorX;var cameraScrollY=camera.scrollY*src.scrollFactorY;var srcX=src.x;var srcY=src.y;var srcScaleX=src.scaleX;var srcScaleY=src.scaleY;var srcRotation=src.rotation;var commandBuffer=src.commandBuffer;var ctx=renderTargetCtx||renderer.currentContext;var lineAlpha=1.0;var fillAlpha=1.0;var lineColor=0;var fillColor=0;var lineWidth=1.0;var red=0;var green=0;var blue=0;//  Blend Mode\nif(renderer.currentBlendMode!==src.blendMode){renderer.currentBlendMode=src.blendMode;ctx.globalCompositeOperation=renderer.blendModes[src.blendMode];}//  Alpha\nif(renderer.currentAlpha!==src.alpha){renderer.currentAlpha=src.alpha;ctx.globalAlpha=src.alpha;}//  Smoothing\nif(renderer.currentScaleMode!==src.scaleMode){renderer.currentScaleMode=src.scaleMode;}ctx.save();if(parentMatrix){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}ctx.translate(srcX-cameraScrollX,srcY-cameraScrollY);ctx.rotate(srcRotation);ctx.scale(srcScaleX,srcScaleY);ctx.fillStyle='#fff';ctx.globalAlpha=src.alpha;for(var index=0,length=commandBuffer.length;index<length;++index){var commandID=commandBuffer[index];switch(commandID){case Commands.ARC:ctx.arc(commandBuffer[index+1],commandBuffer[index+2],commandBuffer[index+3],commandBuffer[index+4],commandBuffer[index+5],commandBuffer[index+6]);index+=6;break;case Commands.LINE_STYLE:lineWidth=commandBuffer[index+1];lineColor=commandBuffer[index+2];lineAlpha=commandBuffer[index+3];red=(lineColor&0xFF0000)>>>16;green=(lineColor&0xFF00)>>>8;blue=lineColor&0xFF;ctx.strokeStyle='rgba('+red+','+green+','+blue+','+lineAlpha+')';ctx.lineWidth=lineWidth;index+=3;break;case Commands.FILL_STYLE:fillColor=commandBuffer[index+1];fillAlpha=commandBuffer[index+2];red=(fillColor&0xFF0000)>>>16;green=(fillColor&0xFF00)>>>8;blue=fillColor&0xFF;ctx.fillStyle='rgba('+red+','+green+','+blue+','+fillAlpha+')';index+=2;break;case Commands.BEGIN_PATH:ctx.beginPath();break;case Commands.CLOSE_PATH:ctx.closePath();break;case Commands.FILL_PATH:if(!allowClip){ctx.fill();}break;case Commands.STROKE_PATH:if(!allowClip){ctx.stroke();}break;case Commands.FILL_RECT:if(!allowClip){ctx.fillRect(commandBuffer[index+1],commandBuffer[index+2],commandBuffer[index+3],commandBuffer[index+4]);}else{ctx.rect(commandBuffer[index+1],commandBuffer[index+2],commandBuffer[index+3],commandBuffer[index+4]);}index+=4;break;case Commands.FILL_TRIANGLE:ctx.beginPath();ctx.moveTo(commandBuffer[index+1],commandBuffer[index+2]);ctx.lineTo(commandBuffer[index+3],commandBuffer[index+4]);ctx.lineTo(commandBuffer[index+5],commandBuffer[index+6]);ctx.closePath();if(!allowClip){ctx.fill();}index+=6;break;case Commands.STROKE_TRIANGLE:ctx.beginPath();ctx.moveTo(commandBuffer[index+1],commandBuffer[index+2]);ctx.lineTo(commandBuffer[index+3],commandBuffer[index+4]);ctx.lineTo(commandBuffer[index+5],commandBuffer[index+6]);ctx.closePath();if(!allowClip){ctx.stroke();}index+=6;break;case Commands.LINE_TO:ctx.lineTo(commandBuffer[index+1],commandBuffer[index+2]);index+=2;break;case Commands.MOVE_TO:ctx.moveTo(commandBuffer[index+1],commandBuffer[index+2]);index+=2;break;case Commands.LINE_FX_TO:ctx.lineTo(commandBuffer[index+1],commandBuffer[index+2]);index+=5;break;case Commands.MOVE_FX_TO:ctx.moveTo(commandBuffer[index+1],commandBuffer[index+2]);index+=5;break;case Commands.SAVE:ctx.save();break;case Commands.RESTORE:ctx.restore();break;case Commands.TRANSLATE:ctx.translate(commandBuffer[index+1],commandBuffer[index+2]);index+=2;break;case Commands.SCALE:ctx.scale(commandBuffer[index+1],commandBuffer[index+2]);index+=2;break;case Commands.ROTATE:ctx.rotate(commandBuffer[index+1]);index+=1;break;default:// console.error('Phaser: Invalid Graphics Command ID ' + commandID);\nbreak;}}ctx.restore();};module.exports=GraphicsCanvasRenderer;/***/},/* 273 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the circumference of the given Ellipse.\r\n *\r\n * @function Phaser.Geom.Ellipse.Circumference\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the circumference of.\r\n *\r\n * @return {number} The circumference of th Ellipse.\r\n */var Circumference=function Circumference(ellipse){var rx=ellipse.width/2;var ry=ellipse.height/2;var h=Math.pow(rx-ry,2)/Math.pow(rx+ry,2);return Math.PI*(rx+ry)*(1+3*h/(10+Math.sqrt(4-3*h)));};module.exports=Circumference;/***/},/* 274 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Circumference=__webpack_require__(273);var CircumferencePoint=__webpack_require__(136);var FromPercent=__webpack_require__(80);var MATH_CONST=__webpack_require__(16);/**\r\n * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,\r\n * based on the given quantity or stepRate values.\r\n *\r\n * @function Phaser.Geom.Ellipse.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the points from.\r\n * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n * @param {number} [stepRate] - Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.\r\n * @param {(array|Phaser.Geom.Point[])} [out] - An array to insert the points in to. If not provided a new array will be created.\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the ellipse.\r\n */var GetPoints=function GetPoints(ellipse,quantity,stepRate,out){if(out===undefined){out=[];}//  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\nif(!quantity){quantity=Circumference(ellipse)/stepRate;}for(var i=0;i<quantity;i++){var angle=FromPercent(i/quantity,0,MATH_CONST.PI2);out.push(CircumferencePoint(ellipse,angle));}return out;};module.exports=GetPoints;/***/},/* 275 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CircumferencePoint=__webpack_require__(136);var FromPercent=__webpack_require__(80);var MATH_CONST=__webpack_require__(16);var Point=__webpack_require__(4);/**\r\n * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse\r\n * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\r\n * at 180 degrees around the circle.\r\n *\r\n * @function Phaser.Geom.Ellipse.GetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the circumference point on.\r\n * @param {float} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the ellipse.\r\n */var GetPoint=function GetPoint(ellipse,position,out){if(out===undefined){out=new Point();}var angle=FromPercent(position,0,MATH_CONST.PI2);return CircumferencePoint(ellipse,angle,out);};module.exports=GetPoint;/***/},/* 276 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Ellipse=__webpack_require__(137);Ellipse.Area=__webpack_require__(766);Ellipse.Circumference=__webpack_require__(273);Ellipse.CircumferencePoint=__webpack_require__(136);Ellipse.Clone=__webpack_require__(765);Ellipse.Contains=__webpack_require__(75);Ellipse.ContainsPoint=__webpack_require__(764);Ellipse.ContainsRect=__webpack_require__(763);Ellipse.CopyFrom=__webpack_require__(762);Ellipse.Equals=__webpack_require__(761);Ellipse.GetBounds=__webpack_require__(760);Ellipse.GetPoint=__webpack_require__(275);Ellipse.GetPoints=__webpack_require__(274);Ellipse.Offset=__webpack_require__(759);Ellipse.OffsetPoint=__webpack_require__(758);Ellipse.Random=__webpack_require__(169);module.exports=Ellipse;/***/},/* 277 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Union\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - [description]\r\n * @param {Phaser.Geom.Rectangle} rectB - [description]\r\n * @param {Phaser.Geom.Rectangle} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var Union=function Union(rectA,rectB,out){if(out===undefined){out=new Rectangle();}//  Cache vars so we can use one of the input rects as the output rect\nvar x=Math.min(rectA.x,rectB.x);var y=Math.min(rectA.y,rectB.y);var w=Math.max(rectA.right,rectB.right)-x;var h=Math.max(rectA.bottom,rectB.bottom)-y;return out.setTo(x,y,w,h);};module.exports=Union;/***/},/* 278 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @function getValue\r\n * @since 3.0.0\r\n * @private\r\n */function getValue(node,attribute){return parseInt(node.getAttribute(attribute),10);}/**\r\n * @function ParseXMLBitmapFont\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {XMLDocument} xml - [description]\r\n * @param {integer} [xSpacing=0] - [description]\r\n * @param {integer} [ySpacing=0] - [description]\r\n * @param {Phaser.Textures.Frame} [frame] - [description]\r\n */var ParseXMLBitmapFont=function ParseXMLBitmapFont(xml,xSpacing,ySpacing,frame){if(xSpacing===undefined){xSpacing=0;}if(ySpacing===undefined){ySpacing=0;}var data={};var info=xml.getElementsByTagName('info')[0];var common=xml.getElementsByTagName('common')[0];data.font=info.getAttribute('face');data.size=getValue(info,'size');data.lineHeight=getValue(common,'lineHeight')+ySpacing;data.chars={};var letters=xml.getElementsByTagName('char');var adjustForTrim=frame!==undefined&&frame.trimmed;if(adjustForTrim){var top=frame.height;var left=frame.width;}for(var i=0;i<letters.length;i++){var node=letters[i];var charCode=getValue(node,'id');var gx=getValue(node,'x');var gy=getValue(node,'y');var gw=getValue(node,'width');var gh=getValue(node,'height');//  Handle frame trim issues\nif(adjustForTrim){if(gx<left){left=gx;}if(gy<top){top=gy;}}data.chars[charCode]={x:gx,y:gy,width:gw,height:gh,centerX:Math.floor(gw/2),centerY:Math.floor(gh/2),xOffset:getValue(node,'xoffset'),yOffset:getValue(node,'yoffset'),xAdvance:getValue(node,'xadvance')+xSpacing,data:{},kerning:{}};}if(adjustForTrim&&top!==0&&left!==0){// console.log('top and left', top, left, frame.x, frame.y);\n//  Now we know the top and left coordinates of the glyphs in the original data\n//  so we can work out how much to adjust the glyphs by\nfor(var code in data.chars){var glyph=data.chars[code];glyph.x-=frame.x;glyph.y-=frame.y;}}var kernings=xml.getElementsByTagName('kerning');for(i=0;i<kernings.length;i++){var kern=kernings[i];var first=getValue(kern,'first');var second=getValue(kern,'second');var amount=getValue(kern,'amount');data.chars[second].kerning[first]=amount;}return data;};module.exports=ParseXMLBitmapFont;/***/},/* 279 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function GetBitmapTextSize\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {(Phaser.GameObjects.DynamicBitmapText|Phaser.GameObjects.BitmapText)} src - [description]\r\n * @param {boolean} round - [description]\r\n */var GetBitmapTextSize=function GetBitmapTextSize(src,round){var text=src.text;var textLength=text.length;var bx=Number.MAX_VALUE;var by=Number.MAX_VALUE;var bw=0;var bh=0;var chars=src.fontData.chars;var lineHeight=src.fontData.lineHeight;var letterSpacing=src.letterSpacing;var xAdvance=0;var yAdvance=0;var indexCount=0;var charCode=0;var glyph=null;var glyphW=0;var glyphH=0;var x=0;var y=0;var lastGlyph=null;var lastCharCode=0;for(var index=0;index<textLength;++index){charCode=text.charCodeAt(index);if(charCode===10){xAdvance=0;indexCount=0;yAdvance+=lineHeight;lastGlyph=null;continue;}glyph=chars[charCode];if(!glyph){continue;}glyphW=glyph.width;glyphH=glyph.height;x=indexCount+glyph.xOffset+xAdvance;y=glyph.yOffset+yAdvance;if(lastGlyph!==null){var kerningOffset=glyph.kerning[lastCharCode];x+=kerningOffset!==undefined?kerningOffset:0;}if(bx>x){bx=x;}if(by>y){by=y;}var gw=x+glyphW-bx;var gh=y+glyphH-by;if(bw<gw){bw=gw;}if(bh<gh){bh=gh;}xAdvance+=glyph.xAdvance+letterSpacing;indexCount+=1;lastGlyph=glyph;lastCharCode=charCode;}var scale=src.fontSize/src.fontData.size;var sx=scale*src.scaleX;var sy=scale*src.scaleY;var out={local:{x:bx*scale,y:by*scale,width:bw*scale,height:bh*scale},global:{x:src.x+bx*sx,y:src.y+by*sy,width:bw*sx,height:bh*sy}};if(round){out.local.x=Math.round(out.local.x);out.local.y=Math.round(out.local.y);out.local.width=Math.round(out.local.width);out.local.height=Math.round(out.local.height);out.global.x=Math.round(out.global.x);out.global.y=Math.round(out.global.y);out.global.width=Math.round(out.global.width);out.global.height=Math.round(out.global.height);}return out;};module.exports=GetBitmapTextSize;/***/},/* 280 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetValue=__webpack_require__(5);var Shuffle=__webpack_require__(106);var BuildChunk=function BuildChunk(a,b,qty){var out=[];for(var aIndex=0;aIndex<a.length;aIndex++){for(var bIndex=0;bIndex<b.length;bIndex++){for(var i=0;i<qty;i++){out.push({a:a[aIndex],b:b[bIndex]});}}}return out;};//  options = repeat, random, randomB, yoyo, max, qty\n//  Range ([a,b,c], [1,2,3]) =\n//  a1, a2, a3, b1, b2, b3, c1, c2, c3\n//  Range ([a,b], [1,2,3], qty = 3) =\n//  a1, a1, a1, a2, a2, a2, a3, a3, a3, b1, b1, b1, b2, b2, b2, b3, b3, b3\n//  Range ([a,b,c], [1,2,3], repeat x1) =\n//  a1, a2, a3, b1, b2, b3, c1, c2, c3, a1, a2, a3, b1, b2, b3, c1, c2, c3\n//  Range ([a,b], [1,2], repeat -1 = endless, max = 14) =\n//  Maybe if max is set then repeat goes to -1 automatically?\n//  a1, a2, b1, b2, a1, a2, b1, b2, a1, a2, b1, b2, a1, a2 (capped at 14 elements)\n//  Range ([a], [1,2,3,4,5], random = true) =\n//  a4, a1, a5, a2, a3\n//  Range ([a, b], [1,2,3], random = true) =\n//  b3, a2, a1, b1, a3, b2\n//  Range ([a, b, c], [1,2,3], randomB = true) =\n//  a3, a1, a2, b2, b3, b1, c1, c3, c2\n//  Range ([a], [1,2,3,4,5], yoyo = true) =\n//  a1, a2, a3, a4, a5, a5, a4, a3, a2, a1\n//  Range ([a, b], [1,2,3], yoyo = true) =\n//  a1, a2, a3, b1, b2, b3, b3, b2, b1, a3, a2, a1\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Range\r\n * @since 3.0.0\r\n *\r\n * @param {array} a - [description]\r\n * @param {array} b - [description]\r\n * @param {object} options - [description]\r\n *\r\n * @return {array} [description]\r\n */var Range=function Range(a,b,options){var max=GetValue(options,'max',0);var qty=GetValue(options,'qty',1);var random=GetValue(options,'random',false);var randomB=GetValue(options,'randomB',false);var repeat=GetValue(options,'repeat',0);var yoyo=GetValue(options,'yoyo',false);var out=[];if(randomB){Shuffle(b);}//  Endless repeat, so limit by max\nif(repeat===-1){if(max===0){repeat=0;}else{//  Work out how many repeats we need\nvar total=a.length*b.length*qty;if(yoyo){total*=2;}repeat=Math.ceil(max/total);}}for(var i=0;i<=repeat;i++){var chunk=BuildChunk(a,b,qty);if(random){Shuffle(chunk);}out=out.concat(chunk);if(yoyo){chunk.reverse();out=out.concat(chunk);}}if(max){out.splice(max);}return out;};module.exports=Range;/***/},/* 281 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  This is from the quickselect npm package: https://www.npmjs.com/package/quickselect\n//  Coded by https://www.npmjs.com/~mourner (Vladimir Agafonkin)\n// https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm\n// Floyd-Rivest selection algorithm:\n// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];\n// The k-th element will have the (k - left + 1)th smallest value in [left, right]\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.QuickSelect\r\n * @since 3.0.0\r\n *\r\n * @param {array} arr - [description]\r\n * @param {number} k - [description]\r\n * @param {number} left - [description]\r\n * @param {number} right - [description]\r\n * @param {function} compare - [description]\r\n */var QuickSelect=function QuickSelect(arr,k,left,right,compare){left=left||0;right=right||arr.length-1;compare=compare||defaultCompare;while(right>left){if(right-left>600){var n=right-left+1;var m=k-left+1;var z=Math.log(n);var s=0.5*Math.exp(2*z/3);var sd=0.5*Math.sqrt(z*s*(n-s)/n)*(m-n/2<0?-1:1);var newLeft=Math.max(left,Math.floor(k-m*s/n+sd));var newRight=Math.min(right,Math.floor(k+(n-m)*s/n+sd));QuickSelect(arr,k,newLeft,newRight,compare);}var t=arr[k];var i=left;var j=right;swap(arr,left,k);if(compare(arr[right],t)>0){swap(arr,left,right);}while(i<j){swap(arr,i,j);i++;j--;while(compare(arr[i],t)<0){i++;}while(compare(arr[j],t)>0){j--;}}if(compare(arr[left],t)===0){swap(arr,left,j);}else{j++;swap(arr,j,right);}if(j<=k){left=j+1;}if(k<=j){right=j-1;}}};function swap(arr,i,j){var tmp=arr[i];arr[i]=arr[j];arr[j]=tmp;}function defaultCompare(a,b){return a<b?-1:a>b?1:0;}module.exports=QuickSelect;/***/},/* 282 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.RoundAwayFromZero\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n *\r\n * @return {number} [description]\r\n */var RoundAwayFromZero=function RoundAwayFromZero(value){// \"Opposite\" of truncate.\nreturn value>0?Math.ceil(value):Math.floor(value);};module.exports=RoundAwayFromZero;/***/},/* 283 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Create an array representing the range of numbers (usually integers), between, and inclusive of,\r\n * the given `start` and `end` arguments. For example:\r\n *\r\n * `var array = numberArray(2, 4); // array = [2, 3, 4]`\r\n * `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`\r\n *\r\n * This is equivalent to `numberArrayStep(start, end, 1)`.\r\n *\r\n * You can optionally provide a prefix and / or suffix string. If given the array will contain\r\n * strings, not integers. For example:\r\n *\r\n * `var array = numberArray(1, 4, 'Level '); // array = [\"Level 1\", \"Level 2\", \"Level 3\", \"Level 4\"]`\r\n * `var array = numberArray(5, 7, 'HD-', '.png'); // array = [\"HD-5.png\", \"HD-6.png\", \"HD-7.png\"]`\r\n *\r\n * @function Phaser.Utils.Array.NumberArray\r\n * @since 3.0.0\r\n *\r\n * @param {number} start - The minimum value the array starts with.\r\n * @param {number} end - The maximum value the array contains.\r\n * @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.\r\n * @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.\r\n *\r\n * @return {(number[]|string[])} The array of number values, or strings if a prefix or suffix was provided.\r\n */var NumberArray=function NumberArray(start,end,prefix,suffix){var result=[];for(var i=start;i<=end;i++){if(prefix||suffix){var key=prefix?prefix+i.toString():i.toString();if(suffix){key=key.concat(suffix);}result.push(key);}else{result.push(i);}}return result;};module.exports=NumberArray;/***/},/* 284 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */// Transposes the elements of the given matrix (array of arrays).\n// The transpose of a matrix is a new matrix whose rows are the columns of the original.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.TransposeMatrix\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array matrix to transpose.\r\n *\r\n * @return {array} A new array matrix which is a transposed version of the given array.\r\n */var TransposeMatrix=function TransposeMatrix(array){var sourceRowCount=array.length;var sourceColCount=array[0].length;var result=new Array(sourceColCount);for(var i=0;i<sourceColCount;i++){result[i]=new Array(sourceRowCount);for(var j=sourceRowCount-1;j>-1;j--){result[i][j]=array[j][i];}}return result;};module.exports=TransposeMatrix;/***/},/* 285 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(22);var IsSizePowerOfTwo=__webpack_require__(151);var ScaleModes=__webpack_require__(82);/**\r\n * @classdesc\r\n * A Texture Source is the encapsulation of the actual source data for a Texture.\r\n * This is typically an Image Element, loaded from the file system or network, or a Canvas Element.\r\n *\r\n * A Texture can contain multiple Texture Sources, which only happens when a multi-atlas is loaded.\r\n *\r\n * @class TextureSource\r\n * @memberOf Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture this TextureSource belongs to.\r\n * @param {(Image|HTMLCanvasElement)} source - The source image data.\r\n * @param {integer} [width] - Optional width of the source image. If not given it's derived from the source itself.\r\n * @param {integer} [height] - Optional height of the source image. If not given it's derived from the source itself.\r\n */var TextureSource=new Class({initialize:function TextureSource(texture,source,width,height){var game=texture.manager.game;/**\r\n         * The Texture this TextureSource belongs to.\r\n         *\r\n         * @name Phaser.Textures.TextureSource#texture\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.texture=texture;/**\r\n         * The source image data. This is either an Image Element, or a Canvas Element.\r\n         *\r\n         * @name Phaser.Textures.TextureSource#image\r\n         * @type {(HTMLImageElement|HTMLCanvasElement)}\r\n         * @since 3.0.0\r\n         */this.image=source;/**\r\n         * Currently un-used.\r\n         *\r\n         * @name Phaser.Textures.TextureSource#compressionAlgorithm\r\n         * @type {integer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.compressionAlgorithm=null;/**\r\n         * The resolution of the source image.\r\n         *\r\n         * @name Phaser.Textures.TextureSource#resolution\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.resolution=1;/**\r\n         * The width of the source image. If not specified in the constructor it will check\r\n         * the `naturalWidth` and then `width` properties of the source image.\r\n         *\r\n         * @name Phaser.Textures.TextureSource#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.width=width||source.naturalWidth||source.width||0;/**\r\n         * The height of the source image. If not specified in the constructor it will check\r\n         * the `naturalHeight` and then `height` properties of the source image.\r\n         *\r\n         * @name Phaser.Textures.TextureSource#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.height=height||source.naturalHeight||source.height||0;/**\r\n         * The Scale Mode the image will use when rendering.\r\n         * Either Linear or Nearest.\r\n         *\r\n         * @name Phaser.Textures.TextureSource#scaleMode\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.scaleMode=ScaleModes.DEFAULT;/**\r\n         * Is the source image a Canvas Element?\r\n         *\r\n         * @name Phaser.Textures.TextureSource#isCanvas\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.isCanvas=source instanceof HTMLCanvasElement;/**\r\n         * Are the source image dimensions a power of two?\r\n         *\r\n         * @name Phaser.Textures.TextureSource#isPowerOf2\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.isPowerOf2=IsSizePowerOfTwo(this.width,this.height);/**\r\n         * The WebGL Texture of the source image.\r\n         *\r\n         * @name Phaser.Textures.TextureSource#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.glTexture=null;this.init(game);},/**\r\n     * Creates a WebGL Texture, if required, and sets the Texture filter mode.\r\n     *\r\n     * @method Phaser.Textures.TextureSource#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Game} game - A reference to the Phaser Game instance.\r\n     */init:function init(game){if(game.config.renderType===CONST.WEBGL){this.glTexture=game.renderer.createTextureFromSource(this.image,this.width,this.height,this.scaleMode);}if(game.config.pixelArt){this.setFilter(1);}},/**\r\n     * Sets the Filter Mode for this Texture.\r\n     *\r\n     * The mode can be either Linear, the default, or Nearest.\r\n     *\r\n     * For pixel-art you should use Nearest.\r\n     *\r\n     * @method Phaser.Textures.TextureSource#setFilter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.FilterMode} filterMode - The Filter Mode.\r\n     */setFilter:function setFilter(filterMode){var game=this.texture.manager.game;if(game.config.renderType===CONST.WEBGL){game.renderer.setTextureFilter(this.glTexture,filterMode);}},/**\r\n     * Destroys this Texture Source and nulls the source image reference.\r\n     *\r\n     * @method Phaser.Textures.TextureSource#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.texture=null;this.image=null;}});module.exports=TextureSource;/***/},/* 286 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Frame=__webpack_require__(147);var TextureSource=__webpack_require__(285);/**\r\n * @classdesc\r\n * A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection\r\n * of Frames. The Frames represent the different areas of the Texture. For example a texture atlas\r\n * may have many Frames, one for each element within the atlas. Where-as a single image would have\r\n * just one frame, that encompasses the whole image.\r\n *\r\n * Textures are managed by the global TextureManager. This is a singleton class that is\r\n * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.\r\n *\r\n * Sprites and other Game Objects get the texture data they need from the TextureManager.\r\n *\r\n * @class Texture\r\n * @memberOf Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} manager - A reference to the Texture Manager this Texture belongs to.\r\n * @param {string} key - The unique string-based key of this Texture.\r\n * @param {(Image|HTMLCanvasElement)} source - The source that is used to create the texture. Usually an Image, but can also be a Canvas.\r\n * @param {number} [width] - The width of the Texture. This is optional and automatically derived from the source images.\r\n * @param {number} [height] - The height of the Texture. This is optional and automatically derived from the source images.\r\n */var Texture=new Class({initialize:function Texture(manager,key,source,width,height){if(!Array.isArray(source)){source=[source];}/**\r\n         * A reference to the Texture Manager this Texture belongs to.\r\n         *\r\n         * @name Phaser.Textures.Texture#manager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.0.0\r\n         */this.manager=manager;/**\r\n         * The unique string-based key of this Texture.\r\n         *\r\n         * @name Phaser.Textures.Texture#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.key=key;/**\r\n         * An array of TextureSource instances.\r\n         * These are unique to this Texture and contain the actual Image (or Canvas) data.\r\n         *\r\n         * @name Phaser.Textures.Texture#source\r\n         * @type {Phaser.Textures.TextureSource[]}\r\n         * @since 3.0.0\r\n         */this.source=[];/**\r\n         * An array of TextureSource data instances.\r\n         * Used to store additional data images, such as normal maps or specular maps.\r\n         *\r\n         * @name Phaser.Textures.Texture#dataSource\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.dataSource=[];/**\r\n         * A key-value object pair associating the unique Frame keys with the Frames objects.\r\n         *\r\n         * @name Phaser.Textures.Texture#frames\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.frames={};/**\r\n         * Any additional data that was set in the source JSON (if any),\r\n         * or any extra data you'd like to store relating to this texture\r\n         *\r\n         * @name Phaser.Textures.Texture#customData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.customData={};/**\r\n         * The name of the first frame of the Texture.\r\n         *\r\n         * @name Phaser.Textures.Texture#firstFrame\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.firstFrame='__BASE';/**\r\n         * The total number of Frames in this Texture.\r\n         *\r\n         * @name Phaser.Textures.Texture#frameTotal\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.frameTotal=0;//  Load the Sources\nfor(var i=0;i<source.length;i++){this.source.push(new TextureSource(this,source[i],width,height));}},/**\r\n     * Adds a new Frame to this Texture.\r\n     *\r\n     * A Frame is a rectangular region of a TextureSource with a unique index or string-based key.\r\n     *\r\n     * @method Phaser.Textures.Texture#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|string)} name - The name of this Frame. The name is unique within the Texture.\r\n     * @param {integer} sourceIndex - The index of the TextureSource that this Frame is a part of.\r\n     * @param {number} x - The x coordinate of the top-left of this Frame.\r\n     * @param {number} y - The y coordinate of the top-left of this Frame.\r\n     * @param {number} width - The width of this Frame.\r\n     * @param {number} height - The height of this Frame.\r\n     *\r\n     * @return {Phaser.Textures.Frame} The Frame that was added to this Texture.\r\n     */add:function add(name,sourceIndex,x,y,width,height){var frame=new Frame(this,name,sourceIndex,x,y,width,height);this.frames[name]=frame;//  Set the first frame of the Texture (other than __BASE)\n//  This is used to ensure we don't spam the display with entire\n//  atlases of sprite sheets, but instead just the first frame of them\n//  should the dev incorrectly specify the frame index\nif(this.frameTotal===1){this.firstFrame=name;}this.frameTotal++;return frame;},/**\r\n     * Checks to see if a Frame matching the given key exists within this Texture.\r\n     *\r\n     * @method Phaser.Textures.Texture#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The key of the Frame to check for.\r\n     *\r\n     * @return {boolean} True if a Frame with the matching key exists in this Texture.\r\n     */has:function has(name){return this.frames[name];},/**\r\n     * Gets a Frame from this Texture based on either the key or the index of the Frame.\r\n     *\r\n     * In a Texture Atlas Frames are typically referenced by a key.\r\n     * In a Sprite Sheet Frames are referenced by an index.\r\n     * Passing no value for the name returns the base texture.\r\n     *\r\n     * @method Phaser.Textures.Texture#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.\r\n     *\r\n     * @return {Phaser.Textures.Frame} The Texture Frame.\r\n     */get:function get(name){//  null, undefined, empty string, zero\nif(!name){name=this.firstFrame;}var frame=this.frames[name];if(!frame){console.warn('No Texture.frame found with name '+name);frame=this.frames[this.firstFrame];}return frame;},/**\r\n     * Takes the given TextureSource and returns the index of it within this Texture.\r\n     * If it's not in this Texture, it returns -1.\r\n     * Unless this Texture has multiple TextureSources, such as with a multi-atlas, this\r\n     * method will always return zero or -1.\r\n     *\r\n     * @method Phaser.Textures.Texture#getTextureSourceIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.TextureSource} source - The TextureSource to check.\r\n     *\r\n     * @return {integer} The index of the TextureSource within this Texture, or -1 if not in this Texture.\r\n     */getTextureSourceIndex:function getTextureSourceIndex(source){for(var i=0;i<this.source.length;i++){if(this.source[i]===source){return i;}}return-1;},/**\r\n     * Returns an array of all the Frames in the given TextureSource.\r\n     *\r\n     * @method Phaser.Textures.Texture#getFramesFromTextureSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} sourceIndex - The index of the TextureSource to get the Frames from.\r\n     *\r\n     * @return {Phaser.Textures.Frame[]} An array of Texture Frames.\r\n     */getFramesFromTextureSource:function getFramesFromTextureSource(sourceIndex){var out=[];for(var frameName in this.frames){if(frameName==='__BASE'){continue;}var frame=this.frames[frameName];if(frame.sourceIndex===sourceIndex){out.push(frame.name);}}return out;},/**\r\n     * Returns an array with all of the names of the Frames in this Texture.\r\n     *\r\n     * Useful if you want to randomly assign a Frame to a Game Object, as you can\r\n     * pick a random element from the returned array.\r\n     *\r\n     * @method Phaser.Textures.Texture#getFrameNames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [includeBase=false] - Include the `__BASE` Frame in the output array?\r\n     *\r\n     * @return {string[]} An array of all Frame names in this Texture.\r\n     */getFrameNames:function getFrameNames(includeBase){if(includeBase===undefined){includeBase=false;}var out=Object.keys(this.frames);if(!includeBase){var idx=out.indexOf('__BASE');if(idx!==-1){out.splice(idx,1);}}return out;},/**\r\n     * Given a Frame name, return the source image it uses to render with.\r\n     *\r\n     * This will return the actual DOM Image or Canvas element.\r\n     *\r\n     * @method Phaser.Textures.Texture#getSourceImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.\r\n     *\r\n     * @return {(HTMLImageElement|HTMLCanvasElement)} The DOM Image or Canvas Element.\r\n     */getSourceImage:function getSourceImage(name){if(name===undefined||name===null||this.frameTotal===1){name='__BASE';}var frame=this.frames[name];if(!frame){console.warn('No Texture.frame found with name '+name);return this.frames['__BASE'].source.image;}else{return frame.source.image;}},/**\r\n     * Adds a data source image to this Texture.\r\n     *\r\n     * An example of a data source image would be a normal map, where all of the Frames for this Texture\r\n     * equally apply to the normal map.\r\n     *\r\n     * @method Phaser.Textures.Texture#setDataSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Image|HTMLCanvasElement)} data - The source image.\r\n     */setDataSource:function setDataSource(data){if(!Array.isArray(data)){data=[data];}for(var i=0;i<data.length;i++){var source=this.source[i];this.dataSource.push(new TextureSource(this,data[i],source.width,source.height));}},/**\r\n     * Sets the Filter Mode for this Texture.\r\n     *\r\n     * The mode can be either Linear, the default, or Nearest.\r\n     *\r\n     * For pixel-art you should use Nearest.\r\n     *\r\n     * The mode applies to the entire Texture, not just a specific Frame of it.\r\n     *\r\n     * @method Phaser.Textures.Texture#setFilter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.FilterMode} filterMode - The Filter Mode.\r\n     */setFilter:function setFilter(filterMode){var i;for(i=0;i<this.source.length;i++){this.source[i].setFilter(filterMode);}for(i=0;i<this.dataSource.length;i++){this.dataSource[i].setFilter(filterMode);}},/**\r\n     * Destroys this Texture and releases references to its sources and frames.\r\n     *\r\n     * @method Phaser.Textures.Texture#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){var i;for(i=0;i<this.source.length;i++){this.source[i].destroy();}for(i=0;i<this.dataSource.length;i++){this.dataSource[i].destroy();}for(var frameName in this.frames){var frame=this.frames[frameName];frame.destroy();}this.source=[];this.dataSource=[];this.frames={};}});module.exports=Texture;/***/},/* 287 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Textures.Parsers\r\n */module.exports={Canvas:__webpack_require__(822),Image:__webpack_require__(821),JSONArray:__webpack_require__(820),JSONHash:__webpack_require__(819),Pyxel:__webpack_require__(818),SpriteSheet:__webpack_require__(817),SpriteSheetFromAtlas:__webpack_require__(816),StarlingXML:__webpack_require__(815),UnityYAML:__webpack_require__(814)};/***/},/* 288 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CanvasPool=__webpack_require__(23);var Class=__webpack_require__(0);var Color=__webpack_require__(42);var EventEmitter=__webpack_require__(14);var GenerateTexture=__webpack_require__(334);var GetValue=__webpack_require__(5);var Parser=__webpack_require__(287);var Texture=__webpack_require__(286);/**\r\n * @callback EachTextureCallback\r\n *\r\n * @param {Phaser.Textures.Texture} texture - [description]\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n *//**\r\n * @classdesc\r\n * Textures are managed by the global TextureManager. This is a singleton class that is\r\n * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.\r\n *\r\n * Sprites and other Game Objects get the texture data they need from the TextureManager.\r\n *\r\n * Access it via `scene.textures`.\r\n *\r\n * @class TextureManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - [description]\r\n */var TextureManager=new Class({Extends:EventEmitter,initialize:function TextureManager(game){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Textures.TextureManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Textures.TextureManager#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.name='TextureManager';/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Textures.TextureManager#list\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */this.list={};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_tempCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tempCanvas=CanvasPool.create2D(this,1,1);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_tempContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tempContext=this._tempCanvas.getContext('2d');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_pending\r\n         * @type {integer}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._pending=0;game.events.once('boot',this.boot,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Textures.TextureManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){this._pending=2;this.on('onload',this.updatePending,this);this.on('onerror',this.updatePending,this);this.addBase64('__DEFAULT',this.game.config.defaultImage);this.addBase64('__MISSING',this.game.config.missingImage);this.game.events.once('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Textures.TextureManager#updatePending\r\n     * @since 3.0.0\r\n     */updatePending:function updatePending(){this._pending--;if(this._pending===0){this.off('onload');this.off('onerror');this.game.events.emit('ready');}},/**\r\n     * Adds a new Texture to the Texture Manager created from the given Base64 encoded data.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addBase64\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {*} data - The Base64 encoded data.\r\n     */addBase64:function addBase64(key,data){var _this=this;var image=new Image();image.onerror=function(){_this.emit('onerror',key);};image.onload=function(){var texture=_this.create(key,image);Parser.Image(texture,0);_this.emit('onload',key,texture);};image.src=data;},/**\r\n     * Adds a new Texture to the Texture Manager created from the given Image element.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {HTMLImageElement} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addImage:function addImage(key,source,dataSource){var texture=this.create(key,source);Parser.Image(texture,0);if(dataSource){texture.setDataSource(dataSource);}return texture;},/**\r\n     * Creates a new Texture using the given config values.\r\n     * Generated textures consist of a Canvas element to which the texture data is drawn.\r\n     * See the Phaser.Create function for the more direct way to create textures.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#generate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */generate:function generate(key,config){var canvas=CanvasPool.create(this,1,1);config.canvas=canvas;GenerateTexture(config);return this.addCanvas(key,canvas);},/**\r\n     * Creates a new Texture using a blank Canvas element of the size given.\r\n     *\r\n     * Canvas elements are automatically pooled and calling this method will\r\n     * extract a free canvas from the CanvasPool, or create one if none are available.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#createCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {integer} width - The width of the Canvas element.\r\n     * @param {integer} height - The height of the Canvas element.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */createCanvas:function createCanvas(key,width,height){if(width===undefined){width=256;}if(height===undefined){height=256;}var canvas=CanvasPool.create(this,width,height);return this.addCanvas(key,canvas);},/**\r\n     * Creates a new Texture object from an existing Canvas element and adds\r\n     * it to this Texture Manager.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLCanvasElement} source - The Canvas element to form the base of the new Texture.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addCanvas:function addCanvas(key,source){var texture=this.create(key,source);Parser.Canvas(texture,0);return texture;},/**\r\n     * Adds a new Texture Atlas to this Texture Manager.\r\n     * It can accept either JSON Array or JSON Hash formats, as exported by Texture Packer and similar software.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addAtlas:function addAtlas(key,source,data){//  New Texture Packer format?\nif(Array.isArray(data.textures)||Array.isArray(data.frames)){return this.addAtlasJSONArray(key,source,data);}else{return this.addAtlasJSONHash(key,source,data);}},/**\r\n     * Adds a Texture Atlas to this Texture Manager.\r\n     * The frame data of the atlas must be stored in an Array within the JSON.\r\n     * This is known as a JSON Array in software such as Texture Packer.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasJSONArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addAtlasJSONArray:function addAtlasJSONArray(key,source,data){var texture=this.create(key,source);if(Array.isArray(data)){var singleAtlasFile=data.length===1;// multi-pack with one atlas file for all images\nfor(var i=0;i<texture.source.length;i++){var atlasData=singleAtlasFile?data[0]:data[i];Parser.JSONArray(texture,i,atlasData);}}else{Parser.JSONArray(texture,0,data);}return texture;},/**\r\n     * Adds a Texture Atlas to this Texture Manager.\r\n     * The frame data of the atlas must be stored in an Object within the JSON.\r\n     * This is known as a JSON Hash in software such as Texture Packer.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasJSONHash\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addAtlasJSONHash:function addAtlasJSONHash(key,source,data){var texture=this.create(key,source);if(Array.isArray(data)){for(var i=0;i<data.length;i++){Parser.JSONHash(texture,i,data[i]);}}else{Parser.JSONHash(texture,0,data);}return texture;},/**\r\n     * Adds a Unity Texture Atlas to this Texture Manager.\r\n     * The data must be in the form of a Unity YAML file.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addUnityAtlas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addUnityAtlas:function addUnityAtlas(key,source,data){var texture=this.create(key,source);Parser.UnityYAML(texture,0,data);return texture;},/**\r\n     * Adds a Sprite Sheet to this Texture Manager.\r\n     *\r\n     * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n     * same size and cannot be trimmed or rotated.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addSpriteSheet\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} config - The configuration object for this Sprite Sheet.\r\n     * @param {integer} config.frameWidth - The fixed width of each frame.\r\n     * @param {integer} [config.frameHeight] - The fixed height of each frame. If not set it will use the frameWidth as the height.\r\n     * @param {integer} [config.startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.\r\n     * @param {integer} [config.endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means \"extract all frames\".\r\n     * @param {integer} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.\r\n     * @param {integer} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addSpriteSheet:function addSpriteSheet(key,source,config){var texture=this.create(key,source);var width=texture.source[0].width;var height=texture.source[0].height;Parser.SpriteSheet(texture,0,0,0,width,height,config);return texture;},/**\r\n     * Adds a Sprite Sheet to this Texture Manager, where the Sprite Sheet exists as a Frame within a Texture Atlas.\r\n     *\r\n     * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n     * same size and cannot be trimmed or rotated.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addSpriteSheetFromAtlas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {object} config - The configuration object for this Sprite Sheet.\r\n     * @param {string} config.atlas - The key of the Texture Atlas in which this Sprite Sheet can be found.\r\n     * @param {string} config.frame - The key of the Texture Atlas Frame in which this Sprite Sheet can be found.\r\n     * @param {integer} config.frameWidth - The fixed width of each frame.\r\n     * @param {integer} [config.frameHeight] - The fixed height of each frame. If not set it will use the frameWidth as the height.\r\n     * @param {integer} [config.startFrame=0] - Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.\r\n     * @param {integer} [config.endFrame=-1] - The total number of frames to extract from the Sprite Sheet. The default value of -1 means \"extract all frames\".\r\n     * @param {integer} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.\r\n     * @param {integer} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addSpriteSheetFromAtlas:function addSpriteSheetFromAtlas(key,config){var atlasKey=GetValue(config,'atlas',null);var atlasFrame=GetValue(config,'frame',null);if(!atlasKey||!atlasFrame){return;}var atlas=this.get(atlasKey);var sheet=atlas.get(atlasFrame);if(sheet){var texture=this.create(key,sheet.source.image);if(sheet.trimmed){//  If trimmed we need to help the parser adjust\nParser.SpriteSheetFromAtlas(texture,sheet,config);}else{Parser.SpriteSheet(texture,0,sheet.cutX,sheet.cutY,sheet.cutWidth,sheet.cutHeight,config);}return texture;}},/**\r\n     * Adds a Texture Atlas to this Texture Manager, where the atlas data is given\r\n     * in the Starling XML format.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasStarlingXML\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas XML data.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addAtlasStarlingXML:function addAtlasStarlingXML(key,source,data){var texture=this.create(key,source);if(Array.isArray(data)){for(var i=0;i<data.length;i++){Parser.StarlingXML(texture,i,data[i]);}}else{Parser.StarlingXML(texture,0,data);}return texture;},/**\r\n     * Adds a Texture Atlas to this Texture Manager, where the atlas data is given\r\n     * in the Pyxel JSON format.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasPyxel\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas XML data.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */addAtlasPyxel:function addAtlasPyxel(key,source,data){var texture=this.create(key,source);if(Array.isArray(data)){for(var i=0;i<data.length;i++){Parser.Pyxel(texture,i,data[i]);}}else{Parser.Pyxel(texture,0,data);}return texture;},/**\r\n     * Creates a new Texture using the given source and dimensions.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {integer} width - The width of the Texture.\r\n     * @param {integer} height - The height of the Texture.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */create:function create(key,source,width,height){var texture=new Texture(this,key,source,width,height);this.list[key]=texture;return texture;},/**\r\n     * Checks the given key to see if a Texture using it exists within this Texture Manager.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#exists\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     *\r\n     * @return {boolean} Returns `true` if a Texture matching the given key exists in this Texture Manager.\r\n     */exists:function exists(key){return this.list.hasOwnProperty(key);},/**\r\n     * Returns a Texture from the Texture Manager that matches the given key.\r\n     * If the key is undefined it will return the `__DEFAULT` Texture.\r\n     * If the key is given, but not found, it will return the `__MISSING` Texture.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */get:function get(key){if(key===undefined){key='__DEFAULT';}if(this.list[key]){return this.list[key];}else{return this.list['__MISSING'];}},/**\r\n     * Takes a Texture key and Frame name and returns a clone of that Frame if found.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#cloneFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} frame - The string or index of the Frame to be cloned.\r\n     *\r\n     * @return {Phaser.Textures.Frame} A Clone of the given Frame.\r\n     */cloneFrame:function cloneFrame(key,frame){if(this.list[key]){return this.list[key].get(frame).clone();}},/**\r\n     * Takes a Texture key and Frame name and returns a reference to that Frame, if found.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} frame - The string or index of the Frame.\r\n     *\r\n     * @return {Phaser.Textures.Frame} A Texture Frame object.\r\n     */getFrame:function getFrame(key,frame){if(this.list[key]){return this.list[key].get(frame);}},/**\r\n     * Returns an array with all of the keys of all Textures in this Texture Manager.\r\n     * The output array will exclude the `__DEFAULT` and `__MISSING` keys.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getTextureKeys\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string[]} An array containing all of the Texture keys stored in this Texture Manager.\r\n     */getTextureKeys:function getTextureKeys(){var output=[];for(var key in this.list){if(key!=='__DEFAULT'&&key!=='__MISSING'){output.push(key);}}return output;},/**\r\n     * Given a Texture and an `x` and `y` coordinate this method will return a new\r\n     * Color object that has been populated with the color and alpha values of the pixel\r\n     * at that location in the Texture.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getPixel\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} x - The x coordinate of the pixel within the Texture.\r\n     * @param {integer} y - The y coordinate of the pixel within the Texture.\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} frame - The string or index of the Frame.\r\n     *\r\n     * @return {?Phaser.Display.Color} A Color object populated with the color values of the requested pixel,\r\n     * or `null` if the coordinates were out of bounds.\r\n     */getPixel:function getPixel(x,y,key,frame){var textureFrame=this.getFrame(key,frame);if(textureFrame){var source=textureFrame.source.image;if(x>=0&&x<=source.width&&y>=0&&y<=source.height){x+=textureFrame.cutX;y+=textureFrame.cutY;// if (textureFrame.trimmed)\n// {\n//     x -= this.sprite.texture.trim.x;\n//     y -= this.sprite.texture.trim.y;\n// }\nvar context=this._tempContext;context.clearRect(0,0,1,1);context.drawImage(source,x,y,1,1,0,0,1,1);var rgb=context.getImageData(0,0,1,1);return new Color(rgb.data[0],rgb.data[1],rgb.data[2],rgb.data[3]);}}return null;},/**\r\n     * Sets the given Game Objects `texture` and `frame` properties so that it uses\r\n     * the Texture and Frame specified in the `key` and `frame` arguments to this method.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} frame - The string or index of the Frame.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object the texture was set on.\r\n     */setTexture:function setTexture(gameObject,key,frame){if(this.list[key]){gameObject.texture=this.list[key];gameObject.frame=gameObject.texture.get(frame);}return gameObject;},/**\r\n     * Passes all Textures to the given callback.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#each\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachTextureCallback} callback - The callback function to be sent the Textures.\r\n     * @param {object} scope - The value to use as `this` when executing the callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     */each:function each(callback,scope){var args=[null];for(var i=1;i<arguments.length;i++){args.push(arguments[i]);}for(var texture in this.list){args[0]=this.list[texture];callback.apply(scope,args);}},/**\r\n     * Destroys the Texture Manager and all Textures stored within it.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){for(var texture in this.list){this.list[texture].destroy();}this.list={};this.game=null;}});module.exports=TextureManager;/***/},/* 289 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BaseSound=__webpack_require__(102);var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * Web Audio API implementation of the sound.\r\n *\r\n * @class WebAudioSound\r\n * @extends Phaser.Sound.BaseSound\r\n * @memberOf Phaser.Sound\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Sound.WebAudioSoundManager} manager - Reference to the current sound manager instance.\r\n * @param {string} key - Asset key for the sound.\r\n * @param {SoundConfig} [config={}] - An optional config object containing default sound settings.\r\n */var WebAudioSound=new Class({Extends:BaseSound,initialize:function WebAudioSound(manager,key,config){if(config===undefined){config={};}/**\r\n         * Audio buffer containing decoded data of the audio asset to be played.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#audioBuffer\r\n         * @type {AudioBuffer}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.audioBuffer=manager.game.cache.audio.get(key);if(!this.audioBuffer){// eslint-disable-next-line no-console\nconsole.error('No audio loaded in cache with key: \\''+key+'\\'!');return;}/**\r\n         * A reference to an audio source node used for playing back audio from\r\n         * audio data stored in Phaser.Sound.WebAudioSound#audioBuffer.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#source\r\n         * @type {AudioBufferSourceNode}\r\n         * @private\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.source=null;/**\r\n         * A reference to a second audio source used for gapless looped playback.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#loopSource\r\n         * @type {AudioBufferSourceNode}\r\n         * @private\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.loopSource=null;/**\r\n         * Gain node responsible for controlling this sound's muting.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#muteNode\r\n         * @type {GainNode}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.muteNode=manager.context.createGain();/**\r\n         * Gain node responsible for controlling this sound's volume.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#volumeNode\r\n         * @type {GainNode}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.volumeNode=manager.context.createGain();/**\r\n         * The time at which the sound should have started playback from the beginning.\r\n         * Based on BaseAudioContext.currentTime value.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#playTime\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.playTime=0;/**\r\n         * The time at which the sound source should have actually started playback.\r\n         * Based on BaseAudioContext.currentTime value.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#startTime\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.startTime=0;/**\r\n         * The time at which the sound loop source should actually start playback.\r\n         * Based on BaseAudioContext.currentTime value.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#loopTime\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.loopTime=0;/**\r\n         * An array where we keep track of all rate updates during playback.\r\n         * Array of object types: { time: number, rate: number }\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#rateUpdates\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.rateUpdates=[];/**\r\n         * Used for keeping track when sound source playback has ended\r\n         * so its state can be updated accordingly.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#hasEnded\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.hasEnded=false;/**\r\n         * Used for keeping track when sound source has looped\r\n         * so its state can be updated accordingly.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSound#hasLooped\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.hasLooped=false;this.muteNode.connect(this.volumeNode);this.volumeNode.connect(manager.destination);this.duration=this.audioBuffer.duration;this.totalDuration=this.audioBuffer.duration;BaseSound.call(this,manager,key,config);},/**\r\n     * @event Phaser.Sound.WebAudioSound#playEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the Sound that emitted event.\r\n     *//**\r\n     * Play this sound, or a marked section of it.\r\n     * \r\n     * It always plays the sound from the start. If you want to start playback from a specific time\r\n     * you can set 'seek' setting of the config object, provided to this call, to that value.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#play\r\n     * @fires Phaser.Sound.WebAudioSound#playEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [markerName=''] - If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound.\r\n     * @param {SoundConfig} [config] - Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.\r\n     *\r\n     * @return {boolean} Whether the sound started playing successfully.\r\n     */play:function play(markerName,config){if(!BaseSound.prototype.play.call(this,markerName,config)){return false;}//  \\/\\/\\/ isPlaying = true, isPaused = false \\/\\/\\/\nthis.stopAndRemoveBufferSource();this.createAndStartBufferSource();this.emit('play',this);return true;},/**\r\n     * @event Phaser.Sound.WebAudioSound#pauseEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the Sound that emitted event.\r\n     *//**\r\n     * Pauses the sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#pause\r\n     * @fires Phaser.Sound.WebAudioSound#pauseEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was paused successfully.\r\n     */pause:function pause(){if(this.manager.context.currentTime<this.startTime){return false;}if(!BaseSound.prototype.pause.call(this)){return false;}//  \\/\\/\\/ isPlaying = false, isPaused = true \\/\\/\\/\nthis.currentConfig.seek=this.getCurrentTime();// Equivalent to setting paused time\nthis.stopAndRemoveBufferSource();this.emit('pause',this);return true;},/**\r\n     * @event Phaser.Sound.WebAudioSound#resumeEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the Sound that emitted event.\r\n     *//**\r\n     * Resumes the sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#resume\r\n     * @fires Phaser.Sound.WebAudioSound#resumeEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was resumed successfully.\r\n     */resume:function resume(){if(this.manager.context.currentTime<this.startTime){return false;}if(!BaseSound.prototype.resume.call(this)){return false;}//  \\/\\/\\/ isPlaying = true, isPaused = false \\/\\/\\/\nthis.createAndStartBufferSource();this.emit('resume',this);return true;},/**\r\n     * @event Phaser.Sound.WebAudioSound#stopEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the Sound that emitted event.\r\n     *//**\r\n     * Stop playing this sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#stop\r\n     * @fires Phaser.Sound.WebAudioSound#stopEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was stopped successfully.\r\n     */stop:function stop(){if(!BaseSound.prototype.stop.call(this)){return false;}//  \\/\\/\\/ isPlaying = false, isPaused = false \\/\\/\\/\nthis.stopAndRemoveBufferSource();this.emit('stop',this);return true;},/**\r\n     * Used internally.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#createAndStartBufferSource\r\n     * @private\r\n     * @since 3.0.0\r\n     */createAndStartBufferSource:function createAndStartBufferSource(){var seek=this.currentConfig.seek;var delay=this.currentConfig.delay;var when=this.manager.context.currentTime+delay;var offset=(this.currentMarker?this.currentMarker.start:0)+seek;var duration=this.duration-seek;this.playTime=when-seek;this.startTime=when;this.source=this.createBufferSource();this.applyConfig();this.source.start(Math.max(0,when),Math.max(0,offset),Math.max(0,duration));this.resetConfig();},/**\r\n     * Used internally.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#createAndStartLoopBufferSource\r\n     * @private\r\n     * @since 3.0.0\r\n     */createAndStartLoopBufferSource:function createAndStartLoopBufferSource(){var when=this.getLoopTime();var offset=this.currentMarker?this.currentMarker.start:0;var duration=this.duration;this.loopTime=when;this.loopSource=this.createBufferSource();this.loopSource.playbackRate.setValueAtTime(this.totalRate,0);this.loopSource.start(Math.max(0,when),Math.max(0,offset),Math.max(0,duration));},/**\r\n     * Used internally.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#createBufferSource\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @return {AudioBufferSourceNode}\r\n     */createBufferSource:function createBufferSource(){var _this=this;var source=this.manager.context.createBufferSource();source.buffer=this.audioBuffer;source.connect(this.muteNode);source.onended=function(ev){if(ev.target===_this.source){// sound ended\nif(_this.currentConfig.loop){_this.hasLooped=true;}else{_this.hasEnded=true;}}// else was stopped\n};return source;},/**\r\n     * Used internally.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#stopAndRemoveBufferSource\r\n     * @private\r\n     * @since 3.0.0\r\n     */stopAndRemoveBufferSource:function stopAndRemoveBufferSource(){if(this.source){this.source.stop();this.source.disconnect();this.source=null;}this.playTime=0;this.startTime=0;this.stopAndRemoveLoopBufferSource();},/**\r\n     * Used internally.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#stopAndRemoveLoopBufferSource\r\n     * @private\r\n     * @since 3.0.0\r\n     */stopAndRemoveLoopBufferSource:function stopAndRemoveLoopBufferSource(){if(this.loopSource){this.loopSource.stop();this.loopSource.disconnect();this.loopSource=null;}this.loopTime=0;},/**\r\n     * Method used internally for applying config values to some of the sound properties.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#applyConfig\r\n     * @protected\r\n     * @since 3.0.0\r\n     */applyConfig:function applyConfig(){this.rateUpdates.length=0;this.rateUpdates.push({time:0,rate:1});BaseSound.prototype.applyConfig.call(this);},/**\r\n     * @event Phaser.Sound.WebAudioSound#endedEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the sound that emitted event.\r\n     *//**\r\n     * @event Phaser.Sound.WebAudioSound#loopedEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the sound that emitted event.\r\n     *//**\r\n     * Update method called automatically by sound manager on every game step.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#update\r\n     * @fires Phaser.Sound.WebAudioSound#endedEvent\r\n     * @fires Phaser.Sound.WebAudioSound#loopedEvent\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */// eslint-disable-next-line no-unused-vars\nupdate:function update(time,delta){if(this.hasEnded){this.hasEnded=false;BaseSound.prototype.stop.call(this);this.stopAndRemoveBufferSource();this.emit('ended',this);}else if(this.hasLooped){this.hasLooped=false;this.source=this.loopSource;this.loopSource=null;this.playTime=this.startTime=this.loopTime;this.rateUpdates.length=0;this.rateUpdates.push({time:0,rate:this.totalRate});this.createAndStartLoopBufferSource();this.emit('looped',this);}},/**\r\n     * Calls Phaser.Sound.BaseSound#destroy method\r\n     * and cleans up all Web Audio API related stuff.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){BaseSound.prototype.destroy.call(this);this.audioBuffer=null;this.stopAndRemoveBufferSource();this.muteNode.disconnect();this.muteNode=null;this.volumeNode.disconnect();this.volumeNode=null;this.rateUpdates.length=0;this.rateUpdates=null;},/**\r\n     * Method used internally to calculate total playback rate of the sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#calculateRate\r\n     * @protected\r\n     * @since 3.0.0\r\n     */calculateRate:function calculateRate(){BaseSound.prototype.calculateRate.call(this);var now=this.manager.context.currentTime;if(this.source&&typeof this.totalRate==='number'){this.source.playbackRate.setValueAtTime(this.totalRate,now);}if(this.isPlaying){this.rateUpdates.push({time:Math.max(this.startTime,now)-this.playTime,rate:this.totalRate});if(this.loopSource){this.stopAndRemoveLoopBufferSource();this.createAndStartLoopBufferSource();}}},/**\r\n     * Method used internally for calculating current playback time of a playing sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#getCurrentTime\r\n     * @private\r\n     * @since 3.0.0\r\n     */getCurrentTime:function getCurrentTime(){var currentTime=0;for(var i=0;i<this.rateUpdates.length;i++){var nextTime=0;if(i<this.rateUpdates.length-1){nextTime=this.rateUpdates[i+1].time;}else{nextTime=this.manager.context.currentTime-this.playTime;}currentTime+=(nextTime-this.rateUpdates[i].time)*this.rateUpdates[i].rate;}return currentTime;},/**\r\n     * Method used internally for calculating the time\r\n     * at witch the loop source should start playing.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#getLoopTime\r\n     * @private\r\n     * @since 3.0.0\r\n     */getLoopTime:function getLoopTime(){var lastRateUpdateCurrentTime=0;for(var i=0;i<this.rateUpdates.length-1;i++){lastRateUpdateCurrentTime+=(this.rateUpdates[i+1].time-this.rateUpdates[i].time)*this.rateUpdates[i].rate;}var lastRateUpdate=this.rateUpdates[this.rateUpdates.length-1];return this.playTime+lastRateUpdate.time+(this.duration-lastRateUpdateCurrentTime)/lastRateUpdate.rate;},/**\r\n     * @event Phaser.Sound.WebAudioSound#rateEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the sound that emitted the event.\r\n     * @param {number} value - An updated value of Phaser.Sound.WebAudioSound#rate property.\r\n     *//**\r\n     * Rate at which this Sound will be played.\r\n     * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed\r\n     * and 2.0 doubles the audios playback speed.\r\n     *\r\n     * @name Phaser.Sound.WebAudioSound#rate\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */rate:{get:function get(){return this.currentConfig.rate;},set:function set(value){this.currentConfig.rate=value;this.calculateRate();this.emit('rate',this,value);}},/**\r\n     * Sets the playback rate of this Sound.\r\n     * \r\n     * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed\r\n     * and 2.0 doubles the audios playback speed.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#setRate\r\n     * @fires Phaser.Sound.WebAudioSound#rateEvent\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} value - The playback rate at of this Sound.\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSound} This Sound.\r\n     */setRate:function setRate(value){this.rate=value;return this;},/**\r\n     * @event Phaser.Sound.WebAudioSound#detuneEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the Sound that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.WebAudioSound#detune property.\r\n     *//**\r\n     * The detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).\r\n     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @name Phaser.Sound.WebAudioSound#detune\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */detune:{get:function get(){return this.currentConfig.detune;},set:function set(value){this.currentConfig.detune=value;this.calculateRate();this.emit('detune',this,value);}},/**\r\n     * Sets the detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).\r\n     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#setDetune\r\n     * @fires Phaser.Sound.WebAudioSound#detuneEvent\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} value - The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSound} This Sound.\r\n     */setDetune:function setDetune(value){this.detune=value;return this;},/**\r\n     * @event Phaser.Sound.WebAudioSound#muteEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the sound that emitted event.\r\n     * @param {boolean} value - An updated value of Phaser.Sound.WebAudioSound#mute property.\r\n     *//**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Sound.WebAudioSound#mute\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */mute:{get:function get(){return this.muteNode.gain.value===0;},set:function set(value){this.currentConfig.mute=value;this.muteNode.gain.setValueAtTime(value?0:1,0);this.emit('mute',this,value);}},/**\r\n     * Sets the muted state of this Sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#setMute\r\n     * @fires Phaser.Sound.WebAudioSound#muteEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} value - `true` to mute this sound, `false` to unmute it.\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSound} This Sound instance.\r\n     */setMute:function setMute(value){this.mute=value;return this;},/**\r\n     * @event Phaser.Sound.WebAudioSound#volumeEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the sound that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.WebAudioSound#volume property.\r\n     *//**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Sound.WebAudioSound#volume\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */volume:{get:function get(){return this.volumeNode.gain.value;},set:function set(value){this.currentConfig.volume=value;this.volumeNode.gain.setValueAtTime(value,0);this.emit('volume',this,value);}},/**\r\n     * Sets the volume of this Sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#setVolume\r\n     * @fires Phaser.Sound.WebAudioSound#volumeEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} value - The volume of the sound.\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSound} This Sound instance.\r\n     */setVolume:function setVolume(value){this.volume=value;return this;},/**\r\n     * @event Phaser.Sound.WebAudioSound#seekEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the sound that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.WebAudioSound#seek property.\r\n     *//**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Sound.WebAudioSound#seek\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */seek:{get:function get(){if(this.isPlaying){if(this.manager.context.currentTime<this.startTime){return this.startTime-this.playTime;}return this.getCurrentTime();}else if(this.isPaused){return this.currentConfig.seek;}else{return 0;}},set:function set(value){if(this.manager.context.currentTime<this.startTime){return;}if(this.isPlaying||this.isPaused){value=Math.min(Math.max(0,value),this.duration);this.currentConfig.seek=value;if(this.isPlaying){this.stopAndRemoveBufferSource();this.createAndStartBufferSource();}this.emit('seek',this,value);}}},/**\r\n     * Seeks to a specific point in this sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#setSeek\r\n     * @fires Phaser.Sound.WebAudioSound#seekEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} value - The point in the sound to seek to.\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSound} This Sound instance.\r\n     */setSeek:function setSeek(value){this.seek=value;return this;},/**\r\n     * @event Phaser.Sound.WebAudioSound#loopEvent\r\n     * @param {Phaser.Sound.WebAudioSound} sound - Reference to the sound that emitted event.\r\n     * @param {boolean} value - An updated value of Phaser.Sound.WebAudioSound#loop property.\r\n     *//**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Sound.WebAudioSound#loop\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */loop:{get:function get(){return this.currentConfig.loop;},set:function set(value){this.currentConfig.loop=value;if(this.isPlaying){this.stopAndRemoveLoopBufferSource();if(value){this.createAndStartLoopBufferSource();}}this.emit('loop',this,value);}},/**\r\n     * Sets the loop state of this Sound.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSound#setLoop\r\n     * @fires Phaser.Sound.WebAudioSound#loopEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} value - `true` to loop this sound, `false` to not loop it.\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSound} This Sound instance.\r\n     */setLoop:function setLoop(value){this.loop=value;return this;}});module.exports=WebAudioSound;/***/},/* 290 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BaseSoundManager=__webpack_require__(103);var Class=__webpack_require__(0);var WebAudioSound=__webpack_require__(289);/**\r\n * @classdesc\r\n * Web Audio API implementation of the sound manager.\r\n *\r\n * @class WebAudioSoundManager\r\n * @extends Phaser.Sound.BaseSoundManager\r\n * @memberOf Phaser.Sound\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - Reference to the current game instance.\r\n */var WebAudioSoundManager=new Class({Extends:BaseSoundManager,initialize:function WebAudioSoundManager(game){/**\r\n         * The AudioContext being used for playback.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSoundManager#context\r\n         * @type {AudioContext}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.context=this.createAudioContext(game);/**\r\n         * Gain node responsible for controlling global muting.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSoundManager#masterMuteNode\r\n         * @type {GainNode}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.masterMuteNode=this.context.createGain();/**\r\n         * Gain node responsible for controlling global volume.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSoundManager#masterVolumeNode\r\n         * @type {GainNode}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.masterVolumeNode=this.context.createGain();this.masterMuteNode.connect(this.masterVolumeNode);this.masterVolumeNode.connect(this.context.destination);/**\r\n         * Destination node for connecting individual sounds to.\r\n         *\r\n         * @name Phaser.Sound.WebAudioSoundManager#destination\r\n         * @type {AudioNode}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.destination=this.masterMuteNode;this.locked=this.context.state==='suspended'&&'ontouchstart'in window;BaseSoundManager.call(this,game);},/**\r\n     * Method responsible for instantiating and returning AudioContext instance.\r\n     * If an instance of an AudioContext class was provided trough the game config,\r\n     * that instance will be returned instead. This can come in handy if you are reloading\r\n     * a Phaser game on a page that never properly refreshes (such as in an SPA project)\r\n     * and you want to reuse already instantiated AudioContext.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSoundManager#createAudioContext\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Game} game - Reference to the current game instance.\r\n     *\r\n     * @return {AudioContext} The AudioContext instance to be used for playback.\r\n     */createAudioContext:function createAudioContext(game){var audioConfig=game.config.audio;if(audioConfig&&audioConfig.context){audioConfig.context.resume();return audioConfig.context;}return new AudioContext();},/**\r\n     * Adds a new sound into the sound manager.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSoundManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - Asset key for the sound.\r\n     * @param {SoundConfig} [config] - An optional config object containing default sound settings.\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSound} The new sound instance.\r\n     */add:function add(key,config){var sound=new WebAudioSound(this,key,config);this.sounds.push(sound);return sound;},/**\r\n     * Unlocks Web Audio API on iOS devices on the initial touch event.\r\n     *\r\n     * Read more about how this issue is handled here in [this article](https://medium.com/@pgoloskokovic/unlocking-web-audio-the-smarter-way-8858218c0e09).\r\n     *\r\n     * @method Phaser.Sound.WebAudioSoundManager#unlock\r\n     * @since 3.0.0\r\n     */unlock:function unlock(){var _this=this;var unlock=function unlock(){_this.context.resume().then(function(){document.body.removeEventListener('touchstart',unlock);document.body.removeEventListener('touchend',unlock);_this.unlocked=true;});};document.body.addEventListener('touchstart',unlock,false);document.body.addEventListener('touchend',unlock,false);},/**\r\n     * Method used internally for pausing sound manager if\r\n     * Phaser.Sound.WebAudioSoundManager#pauseOnBlur is set to true.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSoundManager#onBlur\r\n     * @protected\r\n     * @since 3.0.0\r\n     */onBlur:function onBlur(){this.context.suspend();},/**\r\n     * Method used internally for resuming sound manager if\r\n     * Phaser.Sound.WebAudioSoundManager#pauseOnBlur is set to true.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSoundManager#onFocus\r\n     * @protected\r\n     * @since 3.0.0\r\n     */onFocus:function onFocus(){this.context.resume();},/**\r\n     * Calls Phaser.Sound.BaseSoundManager#destroy method\r\n     * and cleans up all Web Audio API related stuff.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSoundManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.destination=null;this.masterVolumeNode.disconnect();this.masterVolumeNode=null;this.masterMuteNode.disconnect();this.masterMuteNode=null;if(this.game.config.audio&&this.game.config.audio.context){this.context.suspend();}else{this.context.close();}this.context=null;BaseSoundManager.prototype.destroy.call(this);},/**\r\n     * @event Phaser.Sound.WebAudioSoundManager#muteEvent\r\n     * @param {Phaser.Sound.WebAudioSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     * @param {boolean} value - An updated value of Phaser.Sound.WebAudioSoundManager#mute property.\r\n     *//**\r\n     * Sets the muted state of all this Sound Manager.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSoundManager#setMute\r\n     * @fires Phaser.Sound.WebAudioSoundManager#muteEvent\r\n     * @since 3.3.0\r\n     *\r\n     * @param {boolean} value - `true` to mute all sounds, `false` to unmute them.\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSoundManager} This Sound Manager.\r\n     */setMute:function setMute(value){this.mute=value;return this;},/**\r\n     * @name Phaser.Sound.WebAudioSoundManager#mute\r\n     * @type {boolean}\r\n     * @fires Phaser.Sound.WebAudioSoundManager#MuteEvent\r\n     * @since 3.0.0\r\n     */mute:{get:function get(){return this.masterMuteNode.gain.value===0;},set:function set(value){this.masterMuteNode.gain.setValueAtTime(value?0:1,0);this.emit('mute',this,value);}},/**\r\n     * @event Phaser.Sound.WebAudioSoundManager#VolumeEvent\r\n     * @param {Phaser.Sound.WebAudioSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.WebAudioSoundManager#volume property.\r\n     *//**\r\n     * Sets the volume of this Sound Manager.\r\n     *\r\n     * @method Phaser.Sound.WebAudioSoundManager#setVolume\r\n     * @fires Phaser.Sound.WebAudioSoundManager#VolumeEvent\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} value - The global volume of this Sound Manager.\r\n     *\r\n     * @return {Phaser.Sound.WebAudioSoundManager} This Sound Manager.\r\n     */setVolume:function setVolume(value){this.volume=value;return this;},/**\r\n     * @name Phaser.Sound.WebAudioSoundManager#volume\r\n     * @type {number}\r\n     * @fires Phaser.Sound.WebAudioSoundManager#VolumeEvent\r\n     * @since 3.0.0\r\n     */volume:{get:function get(){return this.masterVolumeNode.gain.value;},set:function set(value){this.masterVolumeNode.gain.setValueAtTime(value,0);this.emit('volume',this,value);}}});module.exports=WebAudioSoundManager;/***/},/* 291 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BaseSound=__webpack_require__(102);var Class=__webpack_require__(0);var EventEmitter=__webpack_require__(14);var Extend=__webpack_require__(18);/**\r\n * @classdesc\r\n * No audio implementation of the sound. It is used if audio has been\r\n * disabled in the game config or the device doesn't support any audio.\r\n *\r\n * It represents a graceful degradation of sound logic that provides\r\n * minimal functionality and prevents Phaser projects that use audio from\r\n * breaking on devices that don't support any audio playback technologies.\r\n *\r\n * @class NoAudioSound\r\n * @extends Phaser.Sound.BaseSound\r\n * @memberOf Phaser.Sound\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Sound.NoAudioSoundManager} manager - Reference to the current sound manager instance.\r\n * @param {string} key - Asset key for the sound.\r\n * @param {SoundConfig} [config={}] - An optional config object containing default sound settings.\r\n */var NoAudioSound=new Class({Extends:EventEmitter,initialize:function NoAudioSound(manager,key,config){if(config===void 0){config={};}EventEmitter.call(this);this.manager=manager;this.key=key;this.isPlaying=false;this.isPaused=false;this.totalRate=1;this.duration=0;this.totalDuration=0;this.config=Extend({mute:false,volume:1,rate:1,detune:0,seek:0,loop:false,delay:0},config);this.currentConfig=this.config;this.mute=false;this.volume=1;this.rate=1;this.detune=0;this.seek=0;this.loop=false;this.markers={};this.currentMarker=null;this.pendingRemove=false;},// eslint-disable-next-line no-unused-vars\naddMarker:function addMarker(marker){return false;},// eslint-disable-next-line no-unused-vars\nupdateMarker:function updateMarker(marker){return false;},// eslint-disable-next-line no-unused-vars\nremoveMarker:function removeMarker(markerName){return null;},// eslint-disable-next-line no-unused-vars\nplay:function play(markerName,config){return false;},pause:function pause(){return false;},resume:function resume(){return false;},stop:function stop(){return false;},destroy:function destroy(){this.manager.remove(this);BaseSound.prototype.destroy.call(this);}});module.exports=NoAudioSound;/***/},/* 292 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BaseSoundManager=__webpack_require__(103);var Class=__webpack_require__(0);var EventEmitter=__webpack_require__(14);var NoAudioSound=__webpack_require__(291);var NOOP=__webpack_require__(3);/**\r\n * @classdesc\r\n * No audio implementation of the sound manager. It is used if audio has been\r\n * disabled in the game config or the device doesn't support any audio.\r\n *\r\n * It represents a graceful degradation of sound manager logic that provides\r\n * minimal functionality and prevents Phaser projects that use audio from\r\n * breaking on devices that don't support any audio playback technologies.\r\n *\r\n * @class NoAudioSoundManager\r\n * @extends Phaser.Sound.BaseSoundManager\r\n * @memberOf Phaser.Sound\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - Reference to the current game instance.\r\n */var NoAudioSoundManager=new Class({Extends:EventEmitter,initialize:function NoAudioSoundManager(game){EventEmitter.call(this);this.game=game;this.sounds=[];this.mute=false;this.volume=1;this.rate=1;this.detune=0;this.pauseOnBlur=true;this.locked=false;},add:function add(key,config){var sound=new NoAudioSound(this,key,config);this.sounds.push(sound);return sound;},addAudioSprite:function addAudioSprite(key,config){var sound=this.add(key,config);sound.spritemap={};return sound;},// eslint-disable-next-line no-unused-vars\nplay:function play(key,extra){return false;},// eslint-disable-next-line no-unused-vars\nplayAudioSprite:function playAudioSprite(key,spriteName,config){return false;},remove:function remove(sound){return BaseSoundManager.prototype.remove.call(this,sound);},removeByKey:function removeByKey(key){return BaseSoundManager.prototype.removeByKey.call(this,key);},pauseAll:NOOP,resumeAll:NOOP,stopAll:NOOP,update:NOOP,setRate:NOOP,setDetune:NOOP,setMute:NOOP,setVolume:NOOP,forEachActiveSound:function forEachActiveSound(callbackfn,scope){BaseSoundManager.prototype.forEachActiveSound.call(this,callbackfn,scope);},destroy:function destroy(){BaseSoundManager.prototype.destroy.call(this);}});module.exports=NoAudioSoundManager;/***/},/* 293 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BaseSound=__webpack_require__(102);var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * HTML5 Audio implementation of the sound.\r\n *\r\n * @class HTML5AudioSound\r\n * @extends Phaser.Sound.BaseSound\r\n * @memberOf Phaser.Sound\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Sound.HTML5AudioSoundManager} manager - Reference to the current sound manager instance.\r\n * @param {string} key - Asset key for the sound.\r\n * @param {SoundConfig} [config={}] - An optional config object containing default sound settings.\r\n */var HTML5AudioSound=new Class({Extends:BaseSound,initialize:function HTML5AudioSound(manager,key,config){if(config===undefined){config={};}/**\r\n         * An array containing all HTML5 Audio tags that could be used for individual\r\n         * sound's playback. Number of instances depends on the config value passed\r\n         * to the Loader#audio method call, default is 1.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSound#tags\r\n         * @type {HTMLAudioElement[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.tags=manager.game.cache.audio.get(key);if(!this.tags){// eslint-disable-next-line no-console\nconsole.error('No audio loaded in cache with key: \\''+key+'\\'!');return;}/**\r\n         * Reference to an HTML5 Audio tag used for playing sound.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSound#audio\r\n         * @type {HTMLAudioElement}\r\n         * @private\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.audio=null;/**\r\n         * Timestamp as generated by the Request Animation Frame or SetTimeout\r\n         * representing the time at which the delayed sound playback should start.\r\n         * Set to 0 if sound playback is not delayed.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSound#startTime\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.startTime=0;/**\r\n         * Audio tag's playback position recorded on previous\r\n         * update method call. Set to 0 if sound is not playing.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSound#previousTime\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.previousTime=0;this.duration=this.tags[0].duration;this.totalDuration=this.tags[0].duration;BaseSound.call(this,manager,key,config);},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#playEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     *//**\r\n     * Play this sound, or a marked section of it.\r\n     * It always plays the sound from the start. If you want to start playback from a specific time\r\n     * you can set 'seek' setting of the config object, provided to this call, to that value.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#play\r\n     * @fires Phaser.Sound.HTML5AudioSound#playEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [markerName=''] - If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound.\r\n     * @param {SoundConfig} [config] - Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.\r\n     *\r\n     * @return {boolean} Whether the sound started playing successfully.\r\n     */play:function play(markerName,config){if(this.manager.isLocked(this,'play',[markerName,config])){return false;}if(!BaseSound.prototype.play.call(this,markerName,config)){return false;}//  \\/\\/\\/ isPlaying = true, isPaused = false \\/\\/\\/\nif(!this.pickAndPlayAudioTag()){return false;}this.emit('play',this);return true;},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#pauseEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     *//**\r\n     * Pauses the sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#pause\r\n     * @fires Phaser.Sound.HTML5AudioSound#pauseEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was paused successfully.\r\n     */pause:function pause(){if(this.manager.isLocked(this,'pause')){return false;}if(this.startTime>0){return false;}if(!BaseSound.prototype.pause.call(this)){return false;}//  \\/\\/\\/ isPlaying = false, isPaused = true \\/\\/\\/\nthis.currentConfig.seek=this.audio.currentTime-(this.currentMarker?this.currentMarker.start:0);this.stopAndReleaseAudioTag();this.emit('pause',this);return true;},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#resumeEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     *//**\r\n     * Resumes the sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#resume\r\n     * @fires Phaser.Sound.HTML5AudioSound#resumeEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was resumed successfully.\r\n     */resume:function resume(){if(this.manager.isLocked(this,'resume')){return false;}if(this.startTime>0){return false;}if(!BaseSound.prototype.resume.call(this)){return false;}//  \\/\\/\\/ isPlaying = true, isPaused = false \\/\\/\\/\nif(!this.pickAndPlayAudioTag()){return false;}this.emit('resume',this);return true;},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#stopEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     *//**\r\n     * Stop playing this sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#stop\r\n     * @fires Phaser.Sound.HTML5AudioSound#stopEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was stopped successfully.\r\n     */stop:function stop(){if(this.manager.isLocked(this,'stop')){return false;}if(!BaseSound.prototype.stop.call(this)){return false;}//  \\/\\/\\/ isPlaying = false, isPaused = false \\/\\/\\/\nthis.stopAndReleaseAudioTag();this.emit('stop',this);return true;},/**\r\n     * Used internally to do what the name says.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#pickAndPlayAudioTag\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was assigned an audio tag successfully.\r\n     */pickAndPlayAudioTag:function pickAndPlayAudioTag(){if(!this.pickAudioTag()){this.reset();return false;}var seek=this.currentConfig.seek;var delay=this.currentConfig.delay;var offset=(this.currentMarker?this.currentMarker.start:0)+seek;this.previousTime=offset;this.audio.currentTime=offset;this.applyConfig();if(delay===0){this.startTime=0;if(this.audio.paused){this.playCatchPromise();}}else{this.startTime=window.performance.now()+delay*1000;if(!this.audio.paused){this.audio.pause();}}this.resetConfig();return true;},/**\r\n     * This method performs the audio tag pooling logic. It first looks for\r\n     * unused audio tag to assign to this sound object. If there are no unused\r\n     * audio tags, based on HTML5AudioSoundManager#override property value, it\r\n     * looks for sound with most advanced playback and hijacks its audio tag or\r\n     * does nothing.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#pickAudioTag\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether the sound was assigned an audio tag successfully.\r\n     */pickAudioTag:function pickAudioTag(){if(this.audio){return true;}for(var i=0;i<this.tags.length;i++){var audio=this.tags[i];if(audio.dataset.used==='false'){audio.dataset.used='true';this.audio=audio;return true;}}if(!this.manager.override){return false;}var otherSounds=[];this.manager.forEachActiveSound(function(sound){if(sound.key===this.key&&sound.audio){otherSounds.push(sound);}},this);otherSounds.sort(function(a1,a2){if(a1.loop===a2.loop){// sort by progress\nreturn a2.seek/a2.duration-a1.seek/a1.duration;}return a1.loop?1:-1;});var selectedSound=otherSounds[0];this.audio=selectedSound.audio;selectedSound.reset();selectedSound.audio=null;selectedSound.startTime=0;selectedSound.previousTime=0;return true;},/**\r\n     * Method used for playing audio tag and catching possible exceptions\r\n     * thrown from rejected Promise returned from play method call.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#playCatchPromise\r\n     * @private\r\n     * @since 3.0.0\r\n     */playCatchPromise:function playCatchPromise(){var playPromise=this.audio.play();if(playPromise){// eslint-disable-next-line no-unused-vars\nplayPromise.catch(function(reason){console.warn(reason);});}},/**\r\n     * Used internally to do what the name says.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#stopAndReleaseAudioTag\r\n     * @private\r\n     * @since 3.0.0\r\n     */stopAndReleaseAudioTag:function stopAndReleaseAudioTag(){this.audio.pause();this.audio.dataset.used='false';this.audio=null;this.startTime=0;this.previousTime=0;},/**\r\n     * Method used internally to reset sound state, usually when stopping sound\r\n     * or when hijacking audio tag from another sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#reset\r\n     * @private\r\n     * @since 3.0.0\r\n     */reset:function reset(){BaseSound.prototype.stop.call(this);},/**\r\n     * Method used internally by sound manager for pausing sound if\r\n     * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#onBlur\r\n     * @private\r\n     * @since 3.0.0\r\n     */onBlur:function onBlur(){this.isPlaying=false;this.isPaused=true;this.currentConfig.seek=this.audio.currentTime-(this.currentMarker?this.currentMarker.start:0);this.currentConfig.delay=Math.max(0,(this.startTime-window.performance.now())/1000);this.stopAndReleaseAudioTag();},/**\r\n     * Method used internally by sound manager for resuming sound if\r\n     * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#onFocus\r\n     * @private\r\n     * @since 3.0.0\r\n     */onFocus:function onFocus(){this.isPlaying=true;this.isPaused=false;this.pickAndPlayAudioTag();},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#loopedEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     *//**\r\n     * @event Phaser.Sound.HTML5AudioSound#endedEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     *//**\r\n     * Update method called automatically by sound manager on every game step.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#update\r\n     * @fires Phaser.Sound.HTML5AudioSound#loopedEvent\r\n     * @fires Phaser.Sound.HTML5AudioSound#endedEvent\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */// eslint-disable-next-line no-unused-vars\nupdate:function update(time,delta){if(!this.isPlaying){return;}// handling delayed playback\nif(this.startTime>0){if(this.startTime<time-this.manager.audioPlayDelay){this.audio.currentTime+=Math.max(0,time-this.startTime)/1000;this.startTime=0;this.previousTime=this.audio.currentTime;this.playCatchPromise();}return;}// handle looping and ending\nvar startTime=this.currentMarker?this.currentMarker.start:0;var endTime=startTime+this.duration;var currentTime=this.audio.currentTime;if(this.currentConfig.loop){if(currentTime>=endTime-this.manager.loopEndOffset){this.audio.currentTime=startTime+Math.max(0,currentTime-endTime);currentTime=this.audio.currentTime;}else if(currentTime<startTime){this.audio.currentTime+=startTime;currentTime=this.audio.currentTime;}if(currentTime<this.previousTime){this.emit('looped',this);}}else if(currentTime>=endTime){this.reset();this.stopAndReleaseAudioTag();this.emit('ended',this);return;}this.previousTime=currentTime;},/**\r\n     * Calls Phaser.Sound.BaseSound#destroy method\r\n     * and cleans up all HTML5 Audio related stuff.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){BaseSound.prototype.destroy.call(this);this.tags=null;if(this.audio){this.stopAndReleaseAudioTag();}},/**\r\n     * Method used internally to determine mute setting of the sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#updateMute\r\n     * @private\r\n     * @since 3.0.0\r\n     */updateMute:function updateMute(){if(this.audio){this.audio.muted=this.currentConfig.mute||this.manager.mute;}},/**\r\n     * Method used internally to calculate total volume of the sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#updateVolume\r\n     * @private\r\n     * @since 3.0.0\r\n     */updateVolume:function updateVolume(){if(this.audio){this.audio.volume=this.currentConfig.volume*this.manager.volume;}},/**\r\n     * Method used internally to calculate total playback rate of the sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#calculateRate\r\n     * @protected\r\n     * @since 3.0.0\r\n     */calculateRate:function calculateRate(){BaseSound.prototype.calculateRate.call(this);if(this.audio){this.audio.playbackRate=this.totalRate;}},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#muteEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     * @param {boolean} value - An updated value of Phaser.Sound.HTML5AudioSound#mute property.\r\n     *//**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Sound.HTML5AudioSound#mute\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */mute:{get:function get(){return this.currentConfig.mute;},set:function set(value){this.currentConfig.mute=value;if(this.manager.isLocked(this,'mute',value)){return;}this.setMute();this.emit('mute',this,value);}},/**\r\n     * Sets the muted state of this Sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#setMute\r\n     * @fires Phaser.Sound.HTML5AudioSound#muteEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} value - `true` to mute this sound, `false` to unmute it.\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSound} This Sound instance.\r\n     */setMute:function setMute(value){this.mute=value;return this;},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#volumeEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.HTML5AudioSound#volume property.\r\n     *//**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Sound.HTML5AudioSound#volume\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */volume:{get:function get(){return this.currentConfig.volume;},set:function set(value){this.currentConfig.volume=value;if(this.manager.isLocked(this,'volume',value)){return;}this.setVolume();this.emit('volume',this,value);}},/**\r\n     * Sets the volume of this Sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#setVolume\r\n     * @fires Phaser.Sound.HTML5AudioSound#volumeEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} value - The volume of the sound.\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSound} This Sound instance.\r\n     */setVolume:function setVolume(value){this.volume=value;return this;},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#rateEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted the event.\r\n     * @param {number} value - An updated value of Phaser.Sound.HTML5AudioSound#rate property.\r\n     *//**\r\n     * Rate at which this Sound will be played.\r\n     * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed\r\n     * and 2.0 doubles the audios playback speed.\r\n     *\r\n     * @name Phaser.Sound.HTML5AudioSound#rate\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */rate:{get:function get(){return this.currentConfig.rate;},set:function set(value){this.currentConfig.rate=value;if(this.manager.isLocked(this,'rate',value)){return;}else{this.calculateRate();this.emit('rate',this,value);}}},/**\r\n     * Sets the playback rate of this Sound.\r\n     * \r\n     * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed\r\n     * and 2.0 doubles the audios playback speed.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#setRate\r\n     * @fires Phaser.Sound.HTML5AudioSound#rateEvent\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} value - The playback rate at of this Sound.\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSound} This Sound.\r\n     */setRate:function setRate(value){this.rate=value;return this;},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#detuneEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the Sound that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.HTML5AudioSound#detune property.\r\n     *//**\r\n     * The detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).\r\n     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @name Phaser.Sound.HTML5AudioSound#detune\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */detune:{get:function get(){return this.currentConfig.detune;},set:function set(value){this.currentConfig.detune=value;if(this.manager.isLocked(this,'detune',value)){return;}else{this.calculateRate();this.emit('detune',this,value);}}},/**\r\n     * Sets the detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).\r\n     * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#setDetune\r\n     * @fires Phaser.Sound.HTML5AudioSound#detuneEvent\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} value - The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSound} This Sound.\r\n     */setDetune:function setDetune(value){this.detune=value;return this;},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#seekEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.HTML5AudioSound#seek property.\r\n     *//**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Sound.HTML5AudioSound#seek\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */seek:{get:function get(){if(this.isPlaying){return this.audio.currentTime-(this.currentMarker?this.currentMarker.start:0);}else if(this.isPaused){return this.currentConfig.seek;}else{return 0;}},set:function set(value){if(this.manager.isLocked(this,'seek',value)){return;}if(this.startTime>0){return;}if(this.isPlaying||this.isPaused){value=Math.min(Math.max(0,value),this.duration);if(this.isPlaying){this.previousTime=value;this.audio.currentTime=value;}else if(this.isPaused){this.currentConfig.seek=value;}this.emit('seek',this,value);}}},/**\r\n     * Seeks to a specific point in this sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#setSeek\r\n     * @fires Phaser.Sound.HTML5AudioSound#seekEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} value - The point in the sound to seek to.\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSound} This Sound instance.\r\n     */setSeek:function setSeek(value){this.seek=value;return this;},/**\r\n     * @event Phaser.Sound.HTML5AudioSound#loopEvent\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Reference to the sound that emitted event.\r\n     * @param {boolean} value - An updated value of Phaser.Sound.HTML5AudioSound#loop property.\r\n     *//**\r\n     * [description]\r\n     * \r\n     * @name Phaser.Sound.HTML5AudioSound#loop\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */loop:{get:function get(){return this.currentConfig.loop;},set:function set(value){this.currentConfig.loop=value;if(this.manager.isLocked(this,'loop',value)){return;}if(this.audio){this.audio.loop=value;}this.emit('loop',this,value);}},/**\r\n     * Sets the loop state of this Sound.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSound#setLoop\r\n     * @fires Phaser.Sound.HTML5AudioSound#loopEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} value - `true` to loop this sound, `false` to not loop it.\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSound} This Sound instance.\r\n     */setLoop:function setLoop(value){this.loop=value;return this;}});module.exports=HTML5AudioSound;/***/},/* 294 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BaseSoundManager=__webpack_require__(103);var Class=__webpack_require__(0);var HTML5AudioSound=__webpack_require__(293);/**\r\n * HTML5 Audio implementation of the sound manager.\r\n *\r\n * @class HTML5AudioSoundManager\r\n * @extends Phaser.Sound.BaseSoundManager\r\n * @memberOf Phaser.Sound\r\n * @constructor\r\n * @author Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - Reference to the current game instance.\r\n */var HTML5AudioSoundManager=new Class({Extends:BaseSoundManager,initialize:function HTML5AudioSoundManager(game){/**\r\n         * Flag indicating whether if there are no idle instances of HTML5 Audio tag,\r\n         * for any particular sound, if one of the used tags should be hijacked and used\r\n         * for succeeding playback or if succeeding Phaser.Sound.HTML5AudioSound#play\r\n         * call should be ignored.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSoundManager#override\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.override=true;/**\r\n         * Value representing time difference, in seconds, between calling\r\n         * play method on an audio tag and when it actually starts playing.\r\n         * It is used to achieve more accurate delayed sound playback.\r\n         *\r\n         * You might need to tweak this value to get the desired results\r\n         * since audio play delay varies depending on the browser/platform.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSoundManager#audioPlayDelay\r\n         * @type {number}\r\n         * @default 0.1\r\n         * @since 3.0.0\r\n         */this.audioPlayDelay=0.1;/**\r\n         * A value by which we should offset the loop end marker of the\r\n         * looping sound to compensate for lag, caused by changing audio\r\n         * tag playback position, in order to achieve gapless looping.\r\n         *\r\n         * You might need to tweak this value to get the desired results\r\n         * since loop lag varies depending on the browser/platform.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSoundManager#loopEndOffset\r\n         * @type {number}\r\n         * @default 0.05\r\n         * @since 3.0.0\r\n         */this.loopEndOffset=0.05;/**\r\n         * An array for keeping track of all the sounds\r\n         * that were paused when game lost focus.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSoundManager#onBlurPausedSounds\r\n         * @type {Phaser.Sound.HTML5AudioSound[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.onBlurPausedSounds=[];this.locked='ontouchstart'in window;/**\r\n         * A queue of all actions performed on sound objects while audio was locked.\r\n         * Once the audio gets unlocked, after an explicit user interaction,\r\n         * all actions will be performed in chronological order.\r\n         * Array of object types: { sound: Phaser.Sound.HTML5AudioSound, name: string, value?: * }\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSoundManager#lockedActionsQueue\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.lockedActionsQueue=this.locked?[]:null;/**\r\n         * Property that actually holds the value of global mute\r\n         * for HTML5 Audio sound manager implementation.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSoundManager#_mute\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this._mute=false;/**\r\n         * Property that actually holds the value of global volume\r\n         * for HTML5 Audio sound manager implementation.\r\n         *\r\n         * @name Phaser.Sound.HTML5AudioSoundManager#_volume\r\n         * @type {boolean}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this._volume=1;BaseSoundManager.call(this,game);},/**\r\n     * Adds a new sound into the sound manager.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - Asset key for the sound.\r\n     * @param {SoundConfig} [config] - An optional config object containing default sound settings.\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSound} The new sound instance.\r\n     */add:function add(key,config){var sound=new HTML5AudioSound(this,key,config);this.sounds.push(sound);return sound;},/**\r\n     * Unlocks HTML5 Audio loading and playback on mobile\r\n     * devices on the initial explicit user interaction.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#unlock\r\n     * @since 3.0.0\r\n     */unlock:function unlock(){var _this=this;var moved=false;var detectMove=function detectMove(){moved=true;};var unlock=function unlock(){if(!_this.game.cache.audio.entries.size){return;}if(moved){moved=false;return;}document.body.removeEventListener('touchmove',detectMove);document.body.removeEventListener('touchend',unlock);var allTags=[];_this.game.cache.audio.entries.each(function(key,tags){for(var i=0;i<tags.length;i++){allTags.push(tags[i]);}return true;});var lastTag=allTags[allTags.length-1];lastTag.oncanplaythrough=function(){lastTag.oncanplaythrough=null;_this.unlocked=true;};allTags.forEach(function(tag){tag.load();});};this.once('unlocked',function(){this.forEachActiveSound(function(sound){sound.duration=sound.tags[0].duration;sound.totalDuration=sound.tags[0].duration;});this.lockedActionsQueue.forEach(function(lockedAction){if(lockedAction.sound[lockedAction.prop].apply){lockedAction.sound[lockedAction.prop].apply(lockedAction.sound,lockedAction.value||[]);}else{lockedAction.sound[lockedAction.prop]=lockedAction.value;}});this.lockedActionsQueue.length=0;this.lockedActionsQueue=null;},this);document.body.addEventListener('touchmove',detectMove,false);document.body.addEventListener('touchend',unlock,false);},/**\r\n     * Method used internally for pausing sound manager if\r\n     * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#onBlur\r\n     * @protected\r\n     * @since 3.0.0\r\n     */onBlur:function onBlur(){this.forEachActiveSound(function(sound){if(sound.isPlaying){this.onBlurPausedSounds.push(sound);sound.onBlur();}});},/**\r\n     * Method used internally for resuming sound manager if\r\n     * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#onFocus\r\n     * @protected\r\n     * @since 3.0.0\r\n     */onFocus:function onFocus(){this.onBlurPausedSounds.forEach(function(sound){sound.onFocus();});this.onBlurPausedSounds.length=0;},/**\r\n     * Calls Phaser.Sound.BaseSoundManager#destroy method\r\n     * and cleans up all HTML5 Audio related stuff.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){BaseSoundManager.prototype.destroy.call(this);this.onBlurPausedSounds.length=0;this.onBlurPausedSounds=null;},/**\r\n     * Method used internally by Phaser.Sound.HTML5AudioSound class methods and property setters\r\n     * to check if sound manager is locked and then either perform action immediately or queue it\r\n     * to be performed once the sound manager gets unlocked.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#isLocked\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Sound.HTML5AudioSound} sound - Sound object on which to perform queued action.\r\n     * @param {string} prop - Name of the method to be called or property to be assigned a value to.\r\n     * @param {*} [value] - An optional parameter that either holds an array of arguments to be passed to the method call or value to be set to the property.\r\n     *\r\n     * @return {boolean} Whether the sound manager is locked.\r\n     */isLocked:function isLocked(sound,prop,value){if(this.locked){this.lockedActionsQueue.push({sound:sound,prop:prop,value:value});return true;}return false;},/**\r\n     * @event Phaser.Sound.HTML5AudioSoundManager#muteEvent\r\n     * @param {Phaser.Sound.HTML5AudioSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     * @param {boolean} value - An updated value of Phaser.Sound.HTML5AudioSoundManager#mute property.\r\n     *//**\r\n     * Sets the muted state of all this Sound Manager.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#setMute\r\n     * @fires Phaser.Sound.HTML5AudioSoundManager#muteEvent\r\n     * @since 3.3.0\r\n     *\r\n     * @param {boolean} value - `true` to mute all sounds, `false` to unmute them.\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSoundManager} This Sound Manager.\r\n     */setMute:function setMute(value){this.mute=value;return this;},/**\r\n     * @name Phaser.Sound.HTML5AudioSoundManager#mute\r\n     * @type {boolean}\r\n     * @fires Phaser.Sound.HTML5AudioSoundManager#muteEvent\r\n     * @since 3.0.0\r\n     */mute:{get:function get(){return this._mute;},set:function set(value){this._mute=value;this.forEachActiveSound(function(sound){sound.updateMute();});this.emit('mute',this,value);}},/**\r\n     * @event Phaser.Sound.HTML5AudioSoundManager#volumeEvent\r\n     * @param {Phaser.Sound.HTML5AudioSoundManager} soundManager - Reference to the sound manager that emitted event.\r\n     * @param {number} value - An updated value of Phaser.Sound.HTML5AudioSoundManager#volume property.\r\n     *//**\r\n     * Sets the volume of this Sound Manager.\r\n     *\r\n     * @method Phaser.Sound.HTML5AudioSoundManager#setVolume\r\n     * @fires Phaser.Sound.HTML5AudioSoundManager#volumeEvent\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} value - The global volume of this Sound Manager.\r\n     *\r\n     * @return {Phaser.Sound.HTML5AudioSoundManager} This Sound Manager.\r\n     */setVolume:function setVolume(value){this.volume=value;return this;},/**\r\n     * @name Phaser.Sound.HTML5AudioSoundManager#volume\r\n     * @type {number}\r\n     * @fires Phaser.Sound.HTML5AudioSoundManager#volumeEvent\r\n     * @since 3.0.0\r\n     */volume:{get:function get(){return this._volume;},set:function set(value){this._volume=value;this.forEachActiveSound(function(sound){sound.updateVolume();});this.emit('volume',this,value);}}});module.exports=HTML5AudioSoundManager;/***/},/* 295 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var HTML5AudioSoundManager=__webpack_require__(294);var NoAudioSoundManager=__webpack_require__(292);var WebAudioSoundManager=__webpack_require__(290);/**\r\n * Creates a Web Audio, HTML5 Audio or No Audio Sound Manager based on config and device settings.\r\n *\r\n * @function Phaser.Sound.SoundManagerCreator\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - Reference to the current game instance.\r\n */var SoundManagerCreator={create:function create(game){var audioConfig=game.config.audio;var deviceAudio=game.device.audio;if(audioConfig&&audioConfig.noAudio||!deviceAudio.webAudio&&!deviceAudio.audioData){return new NoAudioSoundManager(game);}if(deviceAudio.webAudio&&!(audioConfig&&audioConfig.disableWebAudio)){return new WebAudioSoundManager(game);}return new HTML5AudioSoundManager(game);}};module.exports=SoundManagerCreator;/***/},/* 296 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(76);var GetValue=__webpack_require__(5);var Merge=__webpack_require__(84);var InjectionMap=__webpack_require__(823);// TODO 22/03/2018 Fix \"plugins\" type\n/**\r\n * @typedef {object} SettingsConfig\r\n *\r\n * @property {string} [key] - [description]\r\n * @property {boolean} [active=false] - [description]\r\n * @property {boolean} [visible=true] - [description]\r\n * @property {(false|LoaderFileObject[])} [files=false] - [description]\r\n * @property {?(InputJSONCameraObject|InputJSONCameraObject[])} [cameras=null] - [description]\r\n * @property {Object.<string, string>} [map] - Overwrites the default injection map for a scene.\r\n * @property {Object.<string, string>} [mapAdd] - Extends the injection map for a scene.\r\n * @property {object} [physics={}] - [description]\r\n * @property {object} [loader={}] - [description]\r\n * @property {(false|*)} [plugins=false] - [description]\r\n *//**\r\n * @typedef {object} SettingsObject\r\n *\r\n * @property {number} status - [description]\r\n * @property {string} key - [description]\r\n * @property {boolean} active - [description]\r\n * @property {boolean} visible - [description]\r\n * @property {boolean} isBooted - [description]\r\n * @property {object} data - [description]\r\n * @property {(false|LoaderFileObject[])} files - [description]\r\n * @property {?(InputJSONCameraObject|InputJSONCameraObject[])} cameras - [description]\r\n * @property {Object.<string, string>} map - [description]\r\n * @property {object} physics - [description]\r\n * @property {object} loader - [description]\r\n * @property {(false|*)} plugins - [description]\r\n */var Settings={/**\r\n     * Takes a Scene configuration object and returns a fully formed Systems object.\r\n     *\r\n     * @function Phaser.Scenes.Settings.create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|SettingsConfig)} config - [description]\r\n     *\r\n     * @return {SettingsObject} [description]\r\n     */create:function create(config){if(typeof config==='string'){config={key:config};}else if(config===undefined){//  Pass the 'hasOwnProperty' checks\nconfig={};}return{status:CONST.PENDING,key:GetValue(config,'key',''),active:GetValue(config,'active',false),visible:GetValue(config,'visible',true),isBooted:false,//  Loader payload array\ndata:{},files:GetValue(config,'files',false),//  Cameras\ncameras:GetValue(config,'cameras',null),//  Scene Property Injection Map\nmap:GetValue(config,'map',Merge(InjectionMap,GetValue(config,'mapAdd',{}))),//  Physics\nphysics:GetValue(config,'physics',{}),//  Loader\nloader:GetValue(config,'loader',{}),//  Plugins\nplugins:GetValue(config,'plugins',false)};}};module.exports=Settings;/***/},/* 297 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Capitalizes the first letter of a string if there is one.\r\n * @example\r\n * UppercaseFirst('abc');\r\n * // returns 'Abc'\r\n * @example\r\n * UppercaseFirst('the happy family');\r\n * // returns 'The happy family'\r\n * @example\r\n * UppercaseFirst('');\r\n * // returns ''\r\n *\r\n * @function Phaser.Utils.String.UppercaseFirst\r\n * @since 3.0.0\r\n *\r\n * @param {string} str - The string to capitalize.\r\n *\r\n * @return {string} A new string, same as the first, but with the first letter capitalized.\r\n */var UppercaseFirst=function UppercaseFirst(str){return str&&str[0].toUpperCase()+str.slice(1);};module.exports=UppercaseFirst;/***/},/* 298 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Systems=__webpack_require__(148);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Scene\r\n * @memberOf Phaser\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(string|SettingsConfig)} config - Scene specific configuration settings.\r\n */var Scene=new Class({initialize:function Scene(config){/**\r\n         * The Scene Systems. You must never overwrite this property, or all hell will break lose.\r\n         *\r\n         * @name Phaser.Scene#sys\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.sys=new Systems(this,config);/**\r\n         * A reference to the Phaser.Game instance.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game;/**\r\n         * A reference to the global Animation Manager.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#anims\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */this.anims;/**\r\n         * A reference to the global Cache.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#cache\r\n         * @type {Phaser.Cache.CacheManager}\r\n         * @since 3.0.0\r\n         */this.cache;/**\r\n         * A reference to the game level Data Manager.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#registry\r\n         * @type {Phaser.Data.DataManager}\r\n         * @since 3.0.0\r\n         */this.registry;/**\r\n         * A reference to the Sound Manager.\r\n         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.\r\n         *\r\n         * @name Phaser.Scene#sound\r\n         * @type {Phaser.Sound.BaseSoundManager}\r\n         * @since 3.0.0\r\n         */this.sound;/**\r\n         * A reference to the Texture Manager.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#textures\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.0.0\r\n         */this.textures;/**\r\n         * A scene level Event Emitter.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */this.events;/**\r\n         * A scene level Camera System.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */this.cameras;/**\r\n         * A scene level 3D Camera System.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#cameras3d\r\n         * @type {Phaser.Cameras.Sprite3D.CameraManager}\r\n         * @since 3.0.0\r\n         */this.cameras3d;/**\r\n         * A scene level Game Object Factory.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#add\r\n         * @type {Phaser.GameObjects.GameObjectFactory}\r\n         * @since 3.0.0\r\n         */this.add;/**\r\n         * A scene level Game Object Creator.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#make\r\n         * @type {Phaser.GameObjects.GameObjectCreator}\r\n         * @since 3.0.0\r\n         */this.make;/**\r\n         * A reference to the Scene Manager Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#scene\r\n         * @type {Phaser.Scenes.ScenePlugin}\r\n         * @since 3.0.0\r\n         */this.scene;/**\r\n         * A scene level Game Object Display List.\r\n         * This property will only be available if defined in the Scene Injection Map.\r\n         *\r\n         * @name Phaser.Scene#children\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */this.children;/**\r\n         * A scene level Lights Manager Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.\r\n         *\r\n         * @name Phaser.Scene#lights\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */this.lights;/**\r\n         * A scene level Data Manager Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.\r\n         *\r\n         * @name Phaser.Scene#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @since 3.0.0\r\n         */this.data;/**\r\n         * A scene level Input Manager Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.\r\n         *\r\n         * @name Phaser.Scene#input\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.0.0\r\n         */this.input;/**\r\n         * A scene level Loader Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.\r\n         *\r\n         * @name Phaser.Scene#load\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.0.0\r\n         */this.load;/**\r\n         * A scene level Time and Clock Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.\r\n         *\r\n         * @name Phaser.Scene#time\r\n         * @type {Phaser.Time.Clock}\r\n         * @since 3.0.0\r\n         */this.time;/**\r\n         * A scene level Tween Manager Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.\r\n         *\r\n         * @name Phaser.Scene#tweens\r\n         * @type {Phaser.Tweens.TweenManager}\r\n         * @since 3.0.0\r\n         */this.tweens;/**\r\n         * A scene level Arcade Physics Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.\r\n         *\r\n         * @name Phaser.Scene#physics\r\n         * @type {Phaser.Physics.Arcade.ArcadePhysics}\r\n         * @since 3.0.0\r\n         */this.physics;/**\r\n         * A scene level Impact Physics Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.\r\n         *\r\n         * @name Phaser.Scene#impact\r\n         * @type {Phaser.Physics.Impact.ImpactPhysics}\r\n         * @since 3.0.0\r\n         */this.impact;/**\r\n         * A scene level Matter Physics Plugin.\r\n         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.\r\n         *\r\n         * @name Phaser.Scene#matter\r\n         * @type {Phaser.Physics.Matter.MatterPhysics}\r\n         * @since 3.0.0\r\n         */this.matter;},/**\r\n     * Should be overridden by your own Scenes.\r\n     *\r\n     * @method Phaser.Scene#update\r\n     * @override\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(){}});module.exports=Scene;/***/},/* 299 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(76);var GetValue=__webpack_require__(5);var NOOP=__webpack_require__(3);var Scene=__webpack_require__(298);var Systems=__webpack_require__(148);/**\r\n * @classdesc\r\n * The Scene Manager.\r\n *\r\n * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the\r\n * Scenes in a Game instance.\r\n *\r\n *\r\n * @class SceneManager\r\n * @memberOf Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Scene Manager belongs to.\r\n * @param {object} sceneConfig - Scene specific configuration settings.\r\n */var SceneManager=new Class({initialize:function SceneManager(game,sceneConfig){/**\r\n         * The Game that this SceneManager belongs to.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#keys\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.keys={};/**\r\n         * The array in which all of the scenes are kept.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#scenes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.scenes=[];/**\r\n         * Scenes pending to be added are stored in here until the manager has time to add it.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_pending\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._pending=[];/**\r\n         * An array of scenes waiting to be started once the game has booted.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_start\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._start=[];/**\r\n         * An operations queue, because we don't manipulate the scenes array during processing.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_queue\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._queue=[];/**\r\n         * Boot time data to merge.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_data\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.4.0\r\n         */this._data={};/**\r\n         * Is the Scene Manager actively processing the Scenes list?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isProcessing\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isProcessing=false;/**\r\n         * Has the Scene Manager properly started?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isBooted\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.4.0\r\n         */this.isBooted=false;if(sceneConfig){if(!Array.isArray(sceneConfig)){sceneConfig=[sceneConfig];}for(var i=0;i<sceneConfig.length;i++){//  The i === 0 part just autostarts the first Scene given (unless it says otherwise in its config)\nthis._pending.push({key:'default',scene:sceneConfig[i],autoStart:i===0,data:{}});}//  Only need to wait for the boot event if we've scenes to actually boot\ngame.events.once('ready',this.bootQueue,this);}},/**\r\n     * Internal first-time Scene boot handler.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootQueue\r\n     * @private\r\n     * @since 3.2.0\r\n     */bootQueue:function bootQueue(){if(this.isBooted){return;}var i;var entry;var key;var sceneConfig;for(i=0;i<this._pending.length;i++){entry=this._pending[i];key=entry.key;sceneConfig=entry.scene;var newScene;if(sceneConfig instanceof Scene){newScene=this.createSceneFromInstance(key,sceneConfig);}else if((typeof sceneConfig==='undefined'?'undefined':_typeof(sceneConfig))==='object'){newScene=this.createSceneFromObject(key,sceneConfig);}else if(typeof sceneConfig==='function'){newScene=this.createSceneFromFunction(key,sceneConfig);}//  Replace key in case the scene changed it\nkey=newScene.sys.settings.key;this.keys[key]=newScene;this.scenes.push(newScene);//  Any data to inject?\nif(this._data[key]){newScene.sys.settings.data=this._data[key].data;if(this._data[key].autoStart){entry.autoStart=true;}}if(entry.autoStart||newScene.sys.settings.active){this._start.push(key);}}//  Clear the pending lists\nthis._pending.length=0;this._data={};this.isBooted=true;//  _start might have been populated by the above\nfor(i=0;i<this._start.length;i++){entry=this._start[i];this.start(entry);}this._start.length=0;},/**\r\n     * Process the Scene operations queue.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#processQueue\r\n     * @since 3.0.0\r\n     */processQueue:function processQueue(){var pendingLength=this._pending.length;var queueLength=this._queue.length;if(pendingLength===0&&queueLength===0){return;}var i;var entry;if(pendingLength){for(i=0;i<pendingLength;i++){entry=this._pending[i];this.add(entry.key,entry.scene,entry.autoStart,entry.data);}//  _start might have been populated by this.add\nfor(i=0;i<this._start.length;i++){entry=this._start[i];this.start(entry);}//  Clear the pending lists\nthis._start.length=0;this._pending.length=0;return;}for(i=0;i<this._queue.length;i++){entry=this._queue[i];this[entry.op](entry.keyA,entry.keyB);}this._queue.length=0;},/**\r\n     * Adds a new Scene into the SceneManager.\r\n     * You must give each Scene a unique key by which you'll identify it.\r\n     *\r\n     * The `sceneConfig` can be:\r\n     *\r\n     * * A `Phaser.Scene` object, or an object that extends it.\r\n     * * A plain JavaScript object\r\n     * * A JavaScript ES6 Class that extends `Phaser.Scene`\r\n     * * A JavaScript ES5 prototype based Class\r\n     * * A JavaScript function\r\n     *\r\n     * If a function is given then a new Scene will be created by calling it.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n     * @param {(Phaser.Scene|SettingsConfig|function)} sceneConfig - The config for the Scene\r\n     * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.\r\n     * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n     *\r\n     * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.\r\n     */add:function add(key,sceneConfig,autoStart,data){if(autoStart===undefined){autoStart=false;}if(data===undefined){data={};}//  If processing or not booted then put scene into a holding pattern\nif(this.isProcessing||!this.isBooted){this._pending.push({key:key,scene:sceneConfig,autoStart:autoStart,data:data});return null;}key=this.getKey(key,sceneConfig);var newScene;if(sceneConfig instanceof Scene){newScene=this.createSceneFromInstance(key,sceneConfig);}else if((typeof sceneConfig==='undefined'?'undefined':_typeof(sceneConfig))==='object'){sceneConfig.key=key;newScene=this.createSceneFromObject(key,sceneConfig);}else if(typeof sceneConfig==='function'){newScene=this.createSceneFromFunction(key,sceneConfig);}//  Any data to inject?\nnewScene.sys.settings.data=data;//  Replace key in case the scene changed it\nkey=newScene.sys.settings.key;this.keys[key]=newScene;this.scenes.push(newScene);if(autoStart||newScene.sys.settings.active){if(this._pending.length){this._start.push(key);}else{this.start(key);}}return newScene;},/**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it wil\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} scene - The Scene to be removed.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */remove:function remove(key){if(this.isProcessing){this._queue.push({op:'remove',keyA:key,keyB:null});}else{var sceneToRemove=this.getScene(key);if(!sceneToRemove){return this;}var index=this.scenes.indexOf(sceneToRemove);var sceneKey=sceneToRemove.sys.settings.key;if(index>-1){delete this.keys[sceneKey];this.scenes.splice(index,1);if(this._start.indexOf(sceneKey)>-1){index=this._start.indexOf(sceneKey);this._start.splice(index,1);}sceneToRemove.sys.destroy();}}return this;},/**\r\n     * Boot the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootScene\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to boot.\r\n     */bootScene:function bootScene(scene){if(scene.init){scene.init.call(scene,scene.sys.settings.data);}var loader;if(scene.sys.load){loader=scene.sys.load;loader.reset();}if(loader&&scene.preload){scene.preload.call(scene);//  Is the loader empty?\nif(loader.list.size===0){this.create(scene);}else{scene.sys.settings.status=CONST.LOADING;//  Start the loader going as we have something in the queue\nloader.once('complete',this.loadComplete,this);loader.start();}}else{//  No preload? Then there was nothing to load either\nthis.create(scene);}},/**\r\n     * Handles load completion for a Scene's Loader.\r\n     *\r\n     * Starts the Scene that the Loader belongs to.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#loadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading.\r\n     */loadComplete:function loadComplete(loader){var scene=loader.scene;this.create(scene);},/**\r\n     * Handle payload completion for a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#payloadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading its Scene's payload.\r\n     */payloadComplete:function payloadComplete(loader){this.bootScene(loader.scene);},/**\r\n     * Updates the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - Time elapsed.\r\n     * @param {number} delta - Delta time from the last update.\r\n     */update:function update(time,delta){this.processQueue();this.isProcessing=true;//  Loop through the active scenes in reverse order\nfor(var i=this.scenes.length-1;i>=0;i--){var sys=this.scenes[i].sys;if(sys.settings.status===CONST.RUNNING){sys.step(time,delta);}}},/**\r\n     * Informs the Scenes of the Game being resized.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#resize\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     */resize:function resize(width,height){//  Loop through the scenes in forward order\nfor(var i=0;i<this.scenes.length;i++){var sys=this.scenes[i].sys;sys.resize(width,height);}},/**\r\n     * Renders the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer to use.\r\n     */render:function render(renderer){//  Loop through the scenes in forward order\nfor(var i=0;i<this.scenes.length;i++){var sys=this.scenes[i].sys;if(sys.settings.visible&&sys.settings.status>=CONST.LOADING&&sys.settings.status<CONST.SLEEPING){sys.render(renderer);}}this.isProcessing=false;},/**\r\n     * Calls the given Scene's {@link Phaser.Scene#create} method and updates its status.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#create\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to create.\r\n     */create:function create(scene){if(scene.create){scene.sys.settings.status=CONST.CREATING;scene.create.call(scene,scene.sys.settings.data);}scene.sys.settings.status=CONST.RUNNING;},/**\r\n     * Creates and initializes a Scene from a function.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromFunction\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {function} scene - The function to create the Scene from.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */createSceneFromFunction:function createSceneFromFunction(key,scene){var newScene=new scene();if(newScene instanceof Scene){var configKey=newScene.sys.settings.key;if(configKey!==''){key=configKey;}if(this.keys.hasOwnProperty(key)){throw new Error('Cannot add a Scene with duplicate key: '+key);}return this.createSceneFromInstance(key,newScene);}else{newScene.sys=new Systems(newScene);newScene.sys.settings.key=key;newScene.sys.init(this.game);if(!newScene.update){newScene.update=NOOP;}return newScene;}},/**\r\n     * Creates and initializes a Scene instance.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromInstance\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {Phaser.Scene} newScene - The Scene instance.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */createSceneFromInstance:function createSceneFromInstance(key,newScene){var configKey=newScene.sys.settings.key;if(configKey!==''){key=configKey;}else{newScene.sys.settings.key=key;}newScene.sys.init(this.game);return newScene;},/**\r\n     * Creates and initializes a Scene from an Object definition.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromObject\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {(string|SettingsConfig)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */createSceneFromObject:function createSceneFromObject(key,sceneConfig){var newScene=new Scene(sceneConfig);var configKey=newScene.sys.settings.key;if(configKey!==''){key=configKey;}else{newScene.sys.settings.key=key;}newScene.sys.init(this.game);//  Extract callbacks\nvar defaults=['init','preload','create','update','render'];for(var i=0;i<defaults.length;i++){var sceneCallback=GetValue(sceneConfig,defaults[i],null);//  Must always have an update function, no matter what (the rest are optional)\nif(defaults[i]==='update'&&!sceneCallback){sceneCallback=NOOP;}if(sceneCallback){newScene[defaults[i]]=sceneCallback;}}//  Now let's move across any other functions or properties that may exist in the extend object:\n/*\r\n        scene: {\r\n            preload: preload,\r\n            create: create,\r\n            extend: {\r\n                hello: 1,\r\n                test: 'atari',\r\n                addImage: addImage\r\n            }\r\n        }\r\n        */if(sceneConfig.hasOwnProperty('extend')){for(var propertyKey in sceneConfig.extend){var value=sceneConfig.extend[propertyKey];if(propertyKey==='data'&&newScene.hasOwnProperty('data')&&(typeof value==='undefined'?'undefined':_typeof(value))==='object'){//  Populate the DataManager\nnewScene.data.merge(value);}else if(propertyKey!=='sys'){newScene[propertyKey]=value;}}}return newScene;},/**\r\n     * Retrieves the key of a Scene from a Scene config.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getKey\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check in the Scene config.\r\n     * @param {(Phaser.Scene|SettingsConfig|function)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {string} The Scene key.\r\n     */getKey:function getKey(key,sceneConfig){if(!key){key='default';}if(typeof sceneConfig==='function'){return key;}else if(sceneConfig instanceof Scene){key=sceneConfig.sys.settings.key;}else if((typeof sceneConfig==='undefined'?'undefined':_typeof(sceneConfig))==='object'&&sceneConfig.hasOwnProperty('key')){key=sceneConfig.key;}//  By this point it's either 'default' or extracted from the Scene\nif(this.keys.hasOwnProperty(key)){throw new Error('Cannot add a Scene with duplicate key: '+key);}else{return key;}},/**\r\n     * Retrieves a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to retrieve.\r\n     *\r\n     * @return {?Phaser.Scene} The Scene.\r\n     */getScene:function getScene(key){if(typeof key==='string'){if(this.keys[key]){return this.keys[key];}}else{for(var i=0;i<this.scenes.length;i++){if(key===this.scenes[i]){return key;}}}return null;},/**\r\n     * Determines whether a Scene is active.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is active.\r\n     */isActive:function isActive(key){var scene=this.getScene(key);if(scene){return scene.sys.isActive();}return null;},/**\r\n     * Determines whether a Scene is visible.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible.\r\n     */isVisible:function isVisible(key){var scene=this.getScene(key);if(scene){return scene.sys.isVisible();}return null;},/**\r\n     * Determines whether a Scene is sleeping.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping.\r\n     */isSleeping:function isSleeping(key){var scene=this.getScene(key);if(scene){return scene.sys.isSleeping();}return null;},/**\r\n     * Pauses the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to pause.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */pause:function pause(key){var scene=this.getScene(key);if(scene){scene.sys.pause();}return this;},/**\r\n     * Resumes the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to resume.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */resume:function resume(key){var scene=this.getScene(key);if(scene){scene.sys.resume();}return this;},/**\r\n     * Puts the given Scene to sleep.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to put to sleep.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */sleep:function sleep(key){var scene=this.getScene(key);if(scene){scene.sys.sleep();}return this;},/**\r\n     * Awakens the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to wake up.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */wake:function wake(key){var scene=this.getScene(key);if(scene){scene.sys.wake();}return this;},/**\r\n     * Starts the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to start.\r\n     * @param {object} [data] - Optional data object to pass to Scene.Settings and Scene.init.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */start:function start(key,data){//  If the Scene Manager is not running, then put the Scene into a holding pattern\nif(!this.isBooted){this._data[key]={autoStart:true,data:data};return this;}var scene=this.getScene(key);if(scene){scene.sys.start(data);var loader;if(scene.sys.load){loader=scene.sys.load;}//  Files payload?\nif(loader&&Array.isArray(scene.sys.settings.files)){loader.reset();if(loader.loadArray(scene.sys.settings.files)){scene.sys.settings.status=CONST.LOADING;loader.once('complete',this.payloadComplete,this);loader.start();return this;}}this.bootScene(scene);}return this;},/**\r\n     * Stops the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to stop.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */stop:function stop(key){var scene=this.getScene(key);if(scene){scene.sys.shutdown();}return this;},/**\r\n     * Sleeps one one Scene and starts the other.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} from - The Scene to sleep.\r\n     * @param {string} to - The Scene to start.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */switch:function _switch(from,to){var sceneA=this.getScene(from);var sceneB=this.getScene(to);if(sceneA&&sceneB&&sceneA!==sceneB){this.sleep(from);if(this.isSleeping(to)){this.wake(to);}else{this.start(to);}}return this;},/**\r\n     * Retrieves a Scene by numeric index.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index of the Scene to retrieve.\r\n     *\r\n     * @return {(Phaser.Scene|undefined)} The Scene.\r\n     */getAt:function getAt(index){return this.scenes[index];},/**\r\n     * Retrieves the numeric index of a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The key of the Scene.\r\n     *\r\n     * @return {integer} The index of the Scene.\r\n     */getIndex:function getIndex(key){var scene=this.getScene(key);return this.scenes.indexOf(scene);},/**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */bringToTop:function bringToTop(key){if(this.isProcessing){this._queue.push({op:'bringToTop',keyA:key,keyB:null});}else{var index=this.getIndex(key);if(index!==-1&&index<this.scenes.length){var scene=this.getScene(key);this.scenes.splice(index,1);this.scenes.push(scene);}}return this;},/**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */sendToBack:function sendToBack(key){if(this.isProcessing){this._queue.push({op:'sendToBack',keyA:key,keyB:null});}else{var index=this.getIndex(key);if(index!==-1&&index>0){var scene=this.getScene(key);this.scenes.splice(index,1);this.scenes.unshift(scene);}}return this;},/**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */moveDown:function moveDown(key){if(this.isProcessing){this._queue.push({op:'moveDown',keyA:key,keyB:null});}else{var indexA=this.getIndex(key);if(indexA>0){var indexB=indexA-1;var sceneA=this.getScene(key);var sceneB=this.getAt(indexB);this.scenes[indexA]=sceneB;this.scenes[indexB]=sceneA;}}return this;},/**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */moveUp:function moveUp(key){if(this.isProcessing){this._queue.push({op:'moveUp',keyA:key,keyB:null});}else{var indexA=this.getIndex(key);if(indexA<this.scenes.length-1){var indexB=indexA+1;var sceneA=this.getScene(key);var sceneB=this.getAt(indexB);this.scenes[indexA]=sceneB;this.scenes[indexB]=sceneA;}}return this;},/**\r\n     * Moves a Scene so it is immediately above another Scene in the Scenes list.\r\n     *\r\n     * This means it will render over the top of the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */moveAbove:function moveAbove(keyA,keyB){if(keyA===keyB){return this;}if(this.isProcessing){this._queue.push({op:'moveAbove',keyA:keyA,keyB:keyB});}else{var indexA=this.getIndex(keyA);var indexB=this.getIndex(keyB);if(indexA>indexB&&indexA!==-1&&indexB!==-1){var tempScene=this.getAt(indexB);//  Remove\nthis.scenes.splice(indexB,1);//  Add in new location\nthis.scenes.splice(indexA,0,tempScene);}}return this;},/**\r\n     * Moves a Scene so it is immediately below another Scene in the Scenes list.\r\n     *\r\n     * This means it will render behind the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */moveBelow:function moveBelow(keyA,keyB){if(keyA===keyB){return this;}if(this.isProcessing){this._queue.push({op:'moveBelow',keyA:keyA,keyB:keyB});}else{var indexA=this.getIndex(keyA);var indexB=this.getIndex(keyB);if(indexA<indexB&&indexA!==-1&&indexB!==-1){var tempScene=this.getAt(indexB);//  Remove\nthis.scenes.splice(indexB,1);//  Add in new location\nthis.scenes.splice(indexA,0,tempScene);}}return this;},/**\r\n     * Queue a Scene operation for the next update.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#queueOp\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} op - The operation to perform.\r\n     * @param {(string|Phaser.Scene)} keyA - Scene A.\r\n     * @param {(string|Phaser.Scene)} [keyB] - Scene B.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */queueOp:function queueOp(op,keyA,keyB){this._queue.push({op:op,keyA:keyA,keyB:keyB});return this;},/**\r\n     * Swaps the positions of two Scenes in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#swapPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.\r\n     * @param {(string|Phaser.Scene)} keyB - The second Scene to swap.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */swapPosition:function swapPosition(keyA,keyB){if(keyA===keyB){return this;}if(this.isProcessing){this._queue.push({op:'swapPosition',keyA:keyA,keyB:keyB});}else{var indexA=this.getIndex(keyA);var indexB=this.getIndex(keyB);if(indexA!==indexB&&indexA!==-1&&indexB!==-1){var tempScene=this.getAt(indexA);this.scenes[indexA]=this.scenes[indexB];this.scenes[indexB]=tempScene;}}return this;},/**\r\n     * Dumps debug information about each Scene to the developer console.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#dump\r\n     * @since 3.2.0\r\n     */dump:function dump(){var out=[];var map=['pending','init','start','loading','creating','running','paused','sleeping','shutdown','destroyed'];for(var i=0;i<this.scenes.length;i++){var sys=this.scenes[i].sys;var key=sys.settings.visible&&(sys.settings.status===CONST.RUNNING||sys.settings.status===CONST.PAUSED)?'[*] ':'[-] ';key+=sys.settings.key+' ('+map[sys.settings.status]+')';out.push(key);}console.log(out.join('\\n'));},/**\r\n     * Destroy the SceneManager and all of its Scene's systems.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){for(var i=this.scenes.length-1;i>=0;i--){var sys=this.scenes[i].sys;sys.destroy();}this.scenes=[];this._pending=[];this._start=[];this._queue=[];this.game=null;}});module.exports=SceneManager;/***/},/* 300 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Vector2=__webpack_require__(6);/**\r\n * Takes the `x` and `y` coordinates and transforms them into the same space as\r\n * defined by the position, rotation and scale values.\r\n *\r\n * @function Phaser.Math.TransformXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x coordinate to be transformed.\r\n * @param {number} y - The y coordinate to be transformed.\r\n * @param {number} positionX - Horizontal position of the transform point.\r\n * @param {number} positionY - Vertical position of the transform point.\r\n * @param {number} rotation - Rotation of the transform point, in radians.\r\n * @param {number} scaleX - Horizontal scale of the transform point.\r\n * @param {number} scaleY - Vertical scale of the transform point.\r\n * @param {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} [output] - [description]\r\n *\r\n * @return {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} The translated point.\r\n */var TransformXY=function TransformXY(x,y,positionX,positionY,rotation,scaleX,scaleY,output){if(output===undefined){output=new Vector2();}//  ITRS\nvar sr=Math.sin(-rotation);var cr=Math.cos(-rotation);var a=cr*scaleX;var b=-sr*scaleX;var c=sr*scaleY;var d=cr*scaleY;//  Invert\nvar n=a*d-b*c;var m0=d/n;var m1=-b/n;var m2=-c/n;var m3=a/n;var m4=(c*positionY-d*positionX)/n;var m5=-(a*positionY-b*positionX)/n;//  Transform\noutput.x=x*m0+y*m2+m4;output.y=x*m1+y*m3+m5;return output;};module.exports=TransformXY;/***/},/* 301 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);// https://developer.mozilla.org/en-US/docs/Web/API/Touch_events\n// https://patrickhlauke.github.io/touch/tests/results/\n// https://www.html5rocks.com/en/mobile/touch/\n/**\r\n * @callback TouchHandler\r\n *\r\n * @param {TouchEvent} event - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TouchManager\r\n * @memberOf Phaser.Input.Touch\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.InputManager} inputManager - [description]\r\n */var TouchManager=new Class({initialize:function TouchManager(inputManager){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Touch.TouchManager#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */this.manager=inputManager;/**\r\n         * If true the DOM events will have event.preventDefault applied to them, if false they will propagate fully.\r\n         *\r\n         * @name Phaser.Input.Touch.TouchManager#capture\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.capture=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Touch.TouchManager#enabled\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.enabled=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Touch.TouchManager#target\r\n         * @type {null}\r\n         * @since 3.0.0\r\n         */this.target;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Touch.TouchManager#handler\r\n         * @type {?TouchHandler}\r\n         * @since 3.0.0\r\n         */this.handler;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Touch.TouchManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var config=this.manager.config;this.enabled=config.inputTouch;this.target=config.inputTouchEventTarget;this.capture=config.inputTouchCapture;if(!this.target){this.target=this.manager.game.canvas;}if(this.enabled){this.startListeners();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Touch.TouchManager#startListeners\r\n     * @since 3.0.0\r\n     */startListeners:function startListeners(){var queue=this.manager.queue;var target=this.target;var passive={passive:true};var nonPassive={passive:false};var handler;if(this.capture){handler=function handler(event){if(event.defaultPrevented){// Do nothing if event already handled\nreturn;}// console.log('touch', event);\nqueue.push(event);event.preventDefault();};target.addEventListener('touchstart',handler,nonPassive);target.addEventListener('touchmove',handler,nonPassive);target.addEventListener('touchend',handler,nonPassive);}else{handler=function handler(event){if(event.defaultPrevented){// Do nothing if event already handled\nreturn;}queue.push(event);};target.addEventListener('touchstart',handler,passive);target.addEventListener('touchmove',handler,passive);target.addEventListener('touchend',handler,passive);}this.handler=handler;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Touch.TouchManager#stopListeners\r\n     * @since 3.0.0\r\n     */stopListeners:function stopListeners(){var target=this.target;target.removeEventListener('touchstart',this.handler);target.removeEventListener('touchmove',this.handler);target.removeEventListener('touchend',this.handler);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Touch.TouchManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.stopListeners();this.manager=null;}});module.exports=TouchManager;/***/},/* 302 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Vector2=__webpack_require__(6);// DOM event button value:\n// A number representing a given button:\n// 0: Main button pressed, usually the left button or the un-initialized state\n// 1: Auxiliary button pressed, usually the wheel button or the middle button (if present)\n// 2: Secondary button pressed, usually the right button\n// 3: Fourth button, typically the Browser Back button\n// 4: Fifth button, typically the Browser Forward button\n// For a mouse configured for left-handed use, the button actions are reversed. In this case, the values are read from right to left.\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Pointer\r\n * @memberOf Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.InputManager} manager - [description]\r\n * @param {integer} id - [description]\r\n */var Pointer=new Class({initialize:function Pointer(manager,id){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Pointer#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */this.manager=manager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Pointer#id\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.id=id;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Pointer#event\r\n         * @type {null}\r\n         * @since 3.0.0\r\n         */this.event;/**\r\n         * The camera the Pointer interacted with during its last update.\r\n         * A Pointer can only ever interact with one camera at once, which will be the top-most camera\r\n         * in the list should multiple cameras be positioned on-top of each other.\r\n         *\r\n         * @name Phaser.Input.Pointer#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.camera=null;/**\r\n         * 0: No button or un-initialized\r\n         * 1: Left button\r\n         * 2: Right button\r\n         * 4: Wheel button or middle button\r\n         * 8: 4th button (typically the \"Browser Back\" button)\r\n         * 16: 5th button (typically the \"Browser Forward\" button)\r\n         *\r\n         * @name Phaser.Input.Pointer#buttons\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.buttons=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Pointer#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.position=new Vector2();/**\r\n         * X coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.\r\n         *\r\n         * @name Phaser.Input.Pointer#downX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.downX=0;/**\r\n         * Y coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.\r\n         *\r\n         * @name Phaser.Input.Pointer#downY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.downY=0;/**\r\n         * Time when Button 1 (left button), or Touch, was pressed, used for dragging objects.\r\n         *\r\n         * @name Phaser.Input.Pointer#downTime\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.downTime=0;/**\r\n         * X coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.\r\n         *\r\n         * @name Phaser.Input.Pointer#upX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.upX=0;/**\r\n         * Y coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.\r\n         *\r\n         * @name Phaser.Input.Pointer#upY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.upY=0;/**\r\n         * Time when Button 1 (left button), or Touch, was released, used for dragging objects.\r\n         *\r\n         * @name Phaser.Input.Pointer#upTime\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.upTime=0;/**\r\n         * Is the primary button down? (usually button 0, the left mouse button)\r\n         *\r\n         * @name Phaser.Input.Pointer#primaryDown\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.primaryDown=false;/**\r\n         * The Drag State of the Pointer:\r\n         *\r\n         * 0 = Not dragging anything\r\n         * 1 = Being checked if dragging\r\n         * 2 = Dragging something\r\n         *\r\n         * @name Phaser.Input.Pointer#dragState\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.dragState=0;/**\r\n         * Is _any_ button on this pointer considered as being down?\r\n         *\r\n         * @name Phaser.Input.Pointer#isDown\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isDown=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Pointer#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.dirty=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Pointer#justDown\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.justDown=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Pointer#justUp\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.justUp=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Pointer#justMoved\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.justMoved=false;/**\r\n         * Did the previous input event come from a Touch input (true) or Mouse? (false)\r\n         *\r\n         * @name Phaser.Input.Pointer#wasTouch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.wasTouch=false;/**\r\n         * If the mouse is locked, the horizontal relative movement of the Pointer in pixels since last frame.\r\n         *\r\n         * @name Phaser.Input.Pointer#movementX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.movementX=0;/**\r\n         * If the mouse is locked, the vertical relative movement of the Pointer in pixels since last frame.\r\n         *\r\n         * @name Phaser.Input.Pointer#movementY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.movementY=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#positionToCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - [description]\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} [description]\r\n     */positionToCamera:function positionToCamera(camera,output){return camera.getWorldPoint(this.x,this.y,output);},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Input.Pointer#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */x:{get:function get(){return this.position.x;},set:function set(value){this.position.x=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Input.Pointer#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */y:{get:function get(){return this.position.y;},set:function set(value){this.position.y=value;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#reset\r\n     * @since 3.0.0\r\n     */reset:function reset(){// this.buttons = 0;\nthis.dirty=false;this.justDown=false;this.justUp=false;this.justMoved=false;this.movementX=0;this.movementY=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#touchmove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TouchEvent} event - [description]\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     */touchmove:function touchmove(event){this.event=event;this.x=this.manager.transformX(event.changedTouches[0].pageX);this.y=this.manager.transformY(event.changedTouches[0].pageY);this.justMoved=true;this.dirty=true;this.wasTouch=true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#move\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MouseEvent} event - [description]\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     */move:function move(event){if(event.buttons){this.buttons=event.buttons;}this.event=event;this.x=this.manager.transformX(event.pageX);this.y=this.manager.transformY(event.pageY);if(this.manager.mouse.locked){// Multiple DOM events may occur within one frame, but only one Phaser event will fire\nthis.movementX+=event.movementX||event.mozMovementX||event.webkitMovementX||0;this.movementY+=event.movementY||event.mozMovementY||event.webkitMovementY||0;}this.justMoved=true;this.dirty=true;this.wasTouch=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#down\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MouseEvent} event - [description]\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     */down:function down(event,time){if(event.buttons){this.buttons=event.buttons;}this.event=event;this.x=this.manager.transformX(event.pageX);this.y=this.manager.transformY(event.pageY);//  0: Main button pressed, usually the left button or the un-initialized state\nif(event.button===0){this.primaryDown=true;this.downX=this.x;this.downY=this.y;this.downTime=time;}this.justDown=true;this.isDown=true;this.dirty=true;this.wasTouch=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#touchstart\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TouchEvent} event - [description]\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     */touchstart:function touchstart(event,time){this.buttons=1;this.event=event;this.x=this.manager.transformX(event.changedTouches[0].pageX);this.y=this.manager.transformY(event.changedTouches[0].pageY);this.primaryDown=true;this.downX=this.x;this.downY=this.y;this.downTime=time;this.justDown=true;this.isDown=true;this.dirty=true;this.wasTouch=true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#up\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MouseEvent} event - [description]\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     */up:function up(event,time){if(event.buttons){this.buttons=event.buttons;}this.event=event;this.x=this.manager.transformX(event.pageX);this.y=this.manager.transformY(event.pageY);//  0: Main button pressed, usually the left button or the un-initialized state\nif(event.button===0){this.primaryDown=false;this.upX=this.x;this.upY=this.y;this.upTime=time;}this.justUp=true;this.isDown=false;this.dirty=true;this.wasTouch=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#touchend\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TouchEvent} event - [description]\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     */touchend:function touchend(event,time){this.buttons=0;this.event=event;this.x=this.manager.transformX(event.changedTouches[0].pageX);this.y=this.manager.transformY(event.changedTouches[0].pageY);this.primaryDown=false;this.upX=this.x;this.upY=this.y;this.upTime=time;this.justUp=true;this.isDown=false;this.dirty=true;this.wasTouch=true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#noButtonDown\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */noButtonDown:function noButtonDown(){return this.buttons===0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#leftButtonDown\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */leftButtonDown:function leftButtonDown(){return this.buttons&1;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#rightButtonDown\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */rightButtonDown:function rightButtonDown(){return this.buttons&2;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#middleButtonDown\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */middleButtonDown:function middleButtonDown(){return this.buttons&4;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#backButtonDown\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */backButtonDown:function backButtonDown(){return this.buttons&8;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#forwardButtonDown\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */forwardButtonDown:function forwardButtonDown(){return this.buttons&16;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Pointer#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.camera=null;this.manager=null;this.position=null;}});module.exports=Pointer;/***/},/* 303 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Features=__webpack_require__(152);//  https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n//  https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n/**\r\n * @callback MouseHandler\r\n *\r\n * @property {MouseEvent} event - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class MouseManager\r\n * @memberOf Phaser.Input.Mouse\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.InputManager} inputManager - [description]\r\n */var MouseManager=new Class({initialize:function MouseManager(inputManager){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Mouse.MouseManager#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */this.manager=inputManager;/**\r\n         * If true the DOM mouse events will have event.preventDefault applied to them, if false they will propagate fully.\r\n         *\r\n         * @name Phaser.Input.Mouse.MouseManager#capture\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.capture=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Mouse.MouseManager#enabled\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.enabled=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Mouse.MouseManager#target\r\n         * @type {null}\r\n         * @since 3.0.0\r\n         */this.target;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Mouse.MouseManager#handler\r\n         * @type {?MouseHandler}\r\n         * @since 3.0.0\r\n         */this.handler;/**\r\n         * If the mouse has been pointer locked successfully this will be set to true.\r\n         *\r\n         * @name Phaser.Input.Mouse.MouseManager#locked\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.locked=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Mouse.MouseManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var config=this.manager.config;this.enabled=config.inputMouse;this.target=config.inputMouseEventTarget;this.capture=config.inputMouseCapture;if(!this.target){this.target=this.manager.game.canvas;}if(config.disableContextMenu){this.disableContextMenu();}if(this.enabled){this.startListeners();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Mouse.MouseManager#disableContextMenu\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.Mouse.MouseManager} [description]\r\n     */disableContextMenu:function disableContextMenu(){document.body.addEventListener('contextmenu',function(event){event.preventDefault();return false;});return this;},/**\r\n     * If the browser supports it, you can request that the pointer be locked to the browser window.\r\n     *\r\n     * This is classically known as 'FPS controls', where the pointer can't leave the browser until\r\n     * the user presses an exit key.\r\n     *\r\n     * If the browser successfully enters a locked state, a `POINTER_LOCK_CHANGE_EVENT` will be dispatched,\r\n     * from the games Input Manager, with an `isPointerLocked` property.\r\n     *\r\n     * It is important to note that pointer lock can only be enabled after an 'engagement gesture',\r\n     * see: https://w3c.github.io/pointerlock/#dfn-engagement-gesture.\r\n     *\r\n     * @method Phaser.Input.Mouse.MouseManager#requestPointerLock\r\n     * @since 3.0.0\r\n     */requestPointerLock:function requestPointerLock(){if(Features.pointerLock){var element=this.target;element.requestPointerLock=element.requestPointerLock||element.mozRequestPointerLock||element.webkitRequestPointerLock;element.requestPointerLock();}},/**\r\n     * Internal pointerLockChange handler.\r\n     *\r\n     * @method Phaser.Input.Mouse.MouseManager#pointerLockChange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MouseHandler} event - The native event from the browser.\r\n     */pointerLockChange:function pointerLockChange(event){var element=this.target;this.locked=document.pointerLockElement===element||document.mozPointerLockElement===element||document.webkitPointerLockElement===element?true:false;this.manager.queue.push(event);},/**\r\n     * If the browser supports pointer lock, this will request that the pointer lock is released. If\r\n     * the browser successfully enters a locked state, a 'POINTER_LOCK_CHANGE_EVENT' will be\r\n     * dispatched - from the game's input manager - with an `isPointerLocked` property.\r\n     *\r\n     * @method Phaser.Input.Mouse.MouseManager#releasePointerLock\r\n     * @since 3.0.0\r\n     */releasePointerLock:function releasePointerLock(){if(Features.pointerLock){document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock;document.exitPointerLock();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Mouse.MouseManager#startListeners\r\n     * @since 3.0.0\r\n     */startListeners:function startListeners(){var queue=this.manager.queue;var target=this.target;var passive={passive:true};var nonPassive={passive:false};var handler;if(this.capture){handler=function handler(event){if(event.defaultPrevented){// Do nothing if event already handled\nreturn;}// console.log('mouse', event);\nqueue.push(event);event.preventDefault();};target.addEventListener('mousemove',handler,nonPassive);target.addEventListener('mousedown',handler,nonPassive);target.addEventListener('mouseup',handler,nonPassive);}else{handler=function handler(event){if(event.defaultPrevented){// Do nothing if event already handled\nreturn;}queue.push(event);};target.addEventListener('mousemove',handler,passive);target.addEventListener('mousedown',handler,passive);target.addEventListener('mouseup',handler,passive);}this.handler=handler;if(Features.pointerLock){this.pointerLockChange=this.pointerLockChange.bind(this);document.addEventListener('pointerlockchange',this.pointerLockChange,true);document.addEventListener('mozpointerlockchange',this.pointerLockChange,true);document.addEventListener('webkitpointerlockchange',this.pointerLockChange,true);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Mouse.MouseManager#stopListeners\r\n     * @since 3.0.0\r\n     */stopListeners:function stopListeners(){var target=this.target;target.removeEventListener('mousemove',this.handler);target.removeEventListener('mousedown',this.handler);target.removeEventListener('mouseup',this.handler);if(Features.pointerLock){document.removeEventListener('pointerlockchange',this.pointerLockChange,true);document.removeEventListener('mozpointerlockchange',this.pointerLockChange,true);document.removeEventListener('webkitpointerlockchange',this.pointerLockChange,true);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Mouse.MouseManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.stopListeners();this.manager=null;}});module.exports=MouseManager;/***/},/* 304 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetFastValue=__webpack_require__(2);var ProcessKeyCombo=__webpack_require__(831);var ResetKeyCombo=__webpack_require__(829);/**\r\n * @callback KeyboardKeydownCallback\r\n *\r\n * @param {KeyboardEvent} event - [description]\r\n *//**\r\n * @typedef {object} KeyComboConfig\r\n *\r\n * @property {boolean} [resetOnWrongKey=true] - [description]\r\n * @property {number} [maxKeyDelay=0] - [description]\r\n * @property {boolean} [resetOnMatch=false] - [description]\r\n * @property {boolean} [deleteOnMatch=false] - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * `keys` argument can be:\r\n *\r\n * A string (ATARI)\r\n * An array of either integers (key codes) or strings, or a mixture of both\r\n * An array of objects (such as Key objects) with a public 'keyCode' property\r\n *\r\n * @class KeyCombo\r\n * @memberOf Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardManager} keyboardManager - [description]\r\n * @param {(string|integer[]|object[])} keys - [description]\r\n * @param {KeyComboConfig} [config] - [description]\r\n */var KeyCombo=new Class({initialize:function KeyCombo(keyboardManager,keys,config){if(config===undefined){config={};}//  Can't have a zero or single length combo (string or array based)\nif(keys.length<2){return false;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#manager\r\n         * @type {Phaser.Input.Keyboard.KeyboardManager}\r\n         * @since 3.0.0\r\n         */this.manager=keyboardManager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.enabled=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#keyCodes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.keyCodes=[];//  if 'keys' is a string we need to get the keycode of each character in it\nfor(var i=0;i<keys.length;i++){var char=keys[i];if(typeof char==='string'){this.keyCodes.push(char.toUpperCase().charCodeAt(0));}else if(typeof char==='number'){this.keyCodes.push(char);}else if(char.hasOwnProperty('keyCode')){this.keyCodes.push(char.keyCode);}}/**\r\n         * The current keyCode the combo is waiting for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#current\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.current=this.keyCodes[0];/**\r\n         * The current index of the key being waited for in the 'keys' string.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#index\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.index=0;/**\r\n         * The length of this combo (in keycodes)\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#size\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.size=this.keyCodes.length;/**\r\n         * The time the previous key in the combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeLastMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.timeLastMatched=0;/**\r\n         * Has this Key Combo been matched yet?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#matched\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.matched=false;/**\r\n         * The time the entire combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.timeMatched=0;/**\r\n         * If they press the wrong key do we reset the combo?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnWrongKey\r\n         * @type {boolean}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.resetOnWrongKey=GetFastValue(config,'resetOnWrongKey',true);/**\r\n         * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#maxKeyDelay\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.maxKeyDelay=GetFastValue(config,'maxKeyDelay',0);/**\r\n         * If previously matched and they press Key 1 again, will it reset?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.resetOnMatch=GetFastValue(config,'resetOnMatch',false);/**\r\n         * If the combo matches, will it delete itself?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#deleteOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.deleteOnMatch=GetFastValue(config,'deleteOnMatch',false);var _this=this;var onKeyDownHandler=function onKeyDownHandler(event){if(_this.matched||!_this.enabled){return;}var matched=ProcessKeyCombo(event,_this);if(matched){_this.manager.emit('keycombomatch',_this,event);if(_this.resetOnMatch){ResetKeyCombo(_this);}else if(_this.deleteOnMatch){_this.destroy();}}};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#onKeyDown\r\n         * @type {KeyboardKeydownCallback}\r\n         * @since 3.0.0\r\n         */this.onKeyDown=onKeyDownHandler;this.manager.on('keydown',onKeyDownHandler);},/**\r\n     * How far complete is this combo? A value between 0 and 1.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#progress\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */progress:{get:function get(){return this.index/this.size;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyCombo#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.enabled=false;this.keyCodes=[];this.manager.off('keydown',this.onKeyDown);this.manager=undefined;}});module.exports=KeyCombo;/***/},/* 305 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * A generic Key object which can be passed to the Process functions (and so on)\r\n * keycode must be an integer\r\n *\r\n * @class Key\r\n * @memberOf Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} keyCode - The keycode of this key.\r\n */var Key=new Class({initialize:function Key(keyCode){/**\r\n         * The keycode of this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#keyCode\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.keyCode=keyCode;/**\r\n         * The original DOM event.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#originalEvent\r\n         * @type {KeyboardEvent}\r\n         * @since 3.0.0\r\n         */this.originalEvent=undefined;/**\r\n         * Should this Key prevent event propagation?\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#preventDefault\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.preventDefault=true;/**\r\n         * Can this Key be processed?\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.enabled=true;/**\r\n         * The \"down\" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#isDown\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isDown=false;/**\r\n         * The \"up\" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#isUp\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.isUp=true;/**\r\n         * The down state of the ALT key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#altKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.altKey=false;/**\r\n         * The down state of the CTRL key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#ctrlKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.ctrlKey=false;/**\r\n         * The down state of the SHIFT key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#shiftKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.shiftKey=false;/**\r\n         * The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#location\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.location=0;/**\r\n         * The timestamp when the key was last pressed down.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#timeDown\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.timeDown=0;/**\r\n         * The number of milliseconds this key has been held down for.\r\n         * If the key is down this value holds the duration of that key press and is constantly updated.\r\n         * If the key is up it holds the duration of the previous down session.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.duration=0;/**\r\n         * The timestamp when the key was last released.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#timeUp\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.timeUp=0;/**\r\n         * If a key is held down this holds down the number of times the key has 'repeated'.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#repeats\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.repeats=0;/**\r\n         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_justDown\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this._justDown=false;/**\r\n         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_justUp\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this._justUp=false;}});module.exports=Key;/***/},/* 306 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var EventEmitter=__webpack_require__(14);var Key=__webpack_require__(305);var KeyCodes=__webpack_require__(149);var KeyCombo=__webpack_require__(304);var KeyMap=__webpack_require__(828);var ProcessKeyDown=__webpack_require__(827);var ProcessKeyUp=__webpack_require__(826);/**\r\n * @callback KeyboardHandler\r\n *\r\n * @property {KeyboardEvent} event - [description]\r\n *//**\r\n * @classdesc\r\n * The Keyboard class monitors keyboard input and dispatches keyboard events.\r\n *\r\n * _Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.\r\n *\r\n * Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.\r\n * For example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.\r\n * So please check your extensions before opening Phaser issues.\r\n *\r\n * @class KeyboardManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.InputManager} inputManager - [description]\r\n */var KeyboardManager=new Class({Extends:EventEmitter,initialize:function KeyboardManager(inputManager){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardManager#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */this.manager=inputManager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardManager#enabled\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.enabled=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardManager#target\r\n         * @type {?object}\r\n         * @since 3.0.0\r\n         */this.target;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardManager#keys\r\n         * @type {Phaser.Input.Keyboard.Key[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.keys=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardManager#combos\r\n         * @type {Phaser.Input.Keyboard.KeyCombo[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.combos=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardManager#captures\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.captures=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardManager#queue\r\n         * @type {KeyboardEvent[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.queue=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardManager#handler\r\n         * @type {?KeyboardHandler}\r\n         * @since 3.0.0\r\n         */this.handler;},/**\r\n     * The Boot handler is called by Phaser.Game when it first starts up.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var config=this.manager.config;this.enabled=config.inputKeyboard;this.target=config.inputKeyboardEventTarget;if(this.enabled){this.startListeners();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#startListeners\r\n     * @since 3.0.0\r\n     */startListeners:function startListeners(){var queue=this.queue;var captures=this.captures;var handler=function handler(event){if(event.defaultPrevented){// Do nothing if event already handled\nreturn;}queue.push(event);if(captures[event.keyCode]){event.preventDefault();}};this.handler=handler;this.target.addEventListener('keydown',handler,false);this.target.addEventListener('keyup',handler,false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#stopListeners\r\n     * @since 3.0.0\r\n     */stopListeners:function stopListeners(){this.target.removeEventListener('keydown',this.handler);this.target.removeEventListener('keyup',this.handler);},/**\r\n     * @typedef {object} CursorKeys\r\n     *\r\n     * @property {Phaser.Input.Keyboard.Key} [up] - [description]\r\n     * @property {Phaser.Input.Keyboard.Key} [down] - [description]\r\n     * @property {Phaser.Input.Keyboard.Key} [left] - [description]\r\n     * @property {Phaser.Input.Keyboard.Key} [right] - [description]\r\n     * @property {Phaser.Input.Keyboard.Key} [space] - [description]\r\n     * @property {Phaser.Input.Keyboard.Key} [shift] - [description]\r\n     *//**\r\n     * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also space and shift.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#createCursorKeys\r\n     * @since 3.0.0\r\n     *\r\n     * @return {CursorKeys} [description]\r\n     */createCursorKeys:function createCursorKeys(){return this.addKeys({up:KeyCodes.UP,down:KeyCodes.DOWN,left:KeyCodes.LEFT,right:KeyCodes.RIGHT,space:KeyCodes.SPACE,shift:KeyCodes.SHIFT});},/**\r\n     * A practical way to create an object containing user selected hotkeys.\r\n     *\r\n     * For example,\r\n     *\r\n     *     addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });\r\n     *\r\n     * would return an object containing properties (`up` and `down`) referring to {@link Phaser.Input.Keyboard.Key} objects.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#addKeys\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} keys - [description]\r\n     *\r\n     * @return {object} [description]\r\n     */addKeys:function addKeys(keys){var output={};for(var key in keys){output[key]=this.addKey(keys[key]);}return output;},/**\r\n     * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.\r\n     * The Key object can then be polled, have events attached to it, etc.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#addKey\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer)} keyCode - [description]\r\n     *\r\n     * @return {Phaser.Input.Keyboard.Key} [description]\r\n     */addKey:function addKey(keyCode){var keys=this.keys;if(!keys[keyCode]){keys[keyCode]=new Key(keyCode);this.captures[keyCode]=true;}return keys[keyCode];},/**\r\n     * Removes a Key object from the Keyboard manager.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#removeKey\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer)} keyCode - [description]\r\n     */removeKey:function removeKey(keyCode){if(this.keys[keyCode]){this.keys[keyCode]=undefined;this.captures[keyCode]=false;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#addKeyCapture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|string[]|integer[])} keyCodes - [description]\r\n     */addKeyCapture:function addKeyCapture(keyCodes){if(!Array.isArray(keyCodes)){keyCodes=[keyCodes];}for(var i=0;i<keyCodes.length;i++){this.captures[keyCodes[i]]=true;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#removeKeyCapture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|string[]|integer[])} keyCodes - [description]\r\n     */removeKeyCapture:function removeKeyCapture(keyCodes){if(!Array.isArray(keyCodes)){keyCodes=[keyCodes];}for(var i=0;i<keyCodes.length;i++){this.captures[keyCodes[i]]=false;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#createCombo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer[]|object[])} keys - [description]\r\n     * @param {KeyComboConfig} config - [description]\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyCombo} [description]\r\n     */createCombo:function createCombo(keys,config){return new KeyCombo(this,keys,config);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#update\r\n     * @since 3.0.0\r\n     */update:function update(){var len=this.queue.length;if(!this.enabled||len===0){return;}//  Clears the queue array, and also means we don't work on array data that could potentially\n//  be modified during the processing phase\nvar queue=this.queue.splice(0,len);var keys=this.keys;//  Process the event queue, dispatching all of the events that have stored up\nfor(var i=0;i<len;i++){var event=queue[i];var code=event.keyCode;if(event.type==='keydown'){if(KeyMap[code]&&(keys[code]===undefined||keys[code].isDown===false)){//  Will emit a keyboard or keyup event\nthis.emit(event.type,event);this.emit('keydown_'+KeyMap[code],event);}if(keys[code]){ProcessKeyDown(keys[code],event);}}else{//  Will emit a keyboard or keyup event\nthis.emit(event.type,event);this.emit('keyup_'+KeyMap[code],event);if(keys[code]){ProcessKeyUp(keys[code],event);}}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.removeAllListeners();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.stopListeners();this.removeAllListeners();this.keys=[];this.combos=[];this.captures=[];this.queue=[];this.handler=undefined;this.manager=null;}});module.exports=KeyboardManager;/***/},/* 307 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Button\r\n * @memberOf Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.Gamepad} pad - [description]\r\n * @param {integer} index - [description]\r\n */var Button=new Class({initialize:function Button(pad,index){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#pad\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @since 3.0.0\r\n         */this.pad=pad;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */this.events=pad.manager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#index\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.index=index;/**\r\n         * Between 0 and 1.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#value\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.value=0;/**\r\n         * Can be set for Analogue buttons to enable a 'pressure' threshold before considered as 'pressed'.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#threshold\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.threshold=1;/**\r\n         * Is the Button being pressed down or not?\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#pressed\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.pressed=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.Button#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {GamepadButton} data - [description]\r\n     */update:function update(data){this.value=data.value;if(this.value>=this.threshold){if(!this.pressed){this.pressed=true;this.events.emit('down',this.pad,this,this.value,data);}}else if(this.pressed){this.pressed=false;this.events.emit('up',this.pad,this,this.value,data);}}});module.exports=Button;/***/},/* 308 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Axis\r\n * @memberOf Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.Gamepad} pad - [description]\r\n * @param {integer} index - [description]\r\n */var Axis=new Class({initialize:function Axis(pad,index){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#pad\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @since 3.0.0\r\n         */this.pad=pad;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */this.events=pad.events;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#index\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.index=index;/**\r\n         * The raw axis value, between -1 and 1 with 0 being dead center.\r\n         * Use the method `getValue` to get a normalized value with the threshold applied.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#value\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.value=0;/**\r\n         * Movement tolerance threshold below which axis values are ignored in `getValue`.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#threshold\r\n         * @type {float}\r\n         * @default 0.1\r\n         * @since 3.0.0\r\n         */this.threshold=0.1;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} value - [description]\r\n     */update:function update(value){this.value=value;},/**\r\n     * Applies threshold to the value and returns it.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#getValue\r\n     * @since 3.0.0\r\n     *\r\n     * @return {float} [description]\r\n     */getValue:function getValue(){return Math.abs(this.value)<this.threshold?0:this.value;}});module.exports=Axis;/***/},/* 309 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Axis=__webpack_require__(308);var Button=__webpack_require__(307);var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Gamepad\r\n * @memberOf Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.GamepadManager} manager - [description]\r\n * @param {string} id - [description]\r\n * @param {number} index - [description]\r\n */var Gamepad=new Class({initialize:function Gamepad(manager,id,index){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#manager\r\n         * @type {Phaser.Input.Gamepad.GamepadManager}\r\n         * @since 3.0.0\r\n         */this.manager=manager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#id\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.id=id;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.index=index;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#connected\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.connected=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#timestamp\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.timestamp=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#buttons\r\n         * @type {Phaser.Input.Gamepad.Button[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.buttons=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#axes\r\n         * @type {Phaser.Input.Gamepad.Axis[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.axes=[];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Gamepad} data - [description]\r\n     */update:function update(data){this.timestamp=data.timestamp;this.connected=data.connected;var i;var axes=this.axes;var buttons=this.buttons;for(i=0;i<data.buttons.length;i++){var buttonData=data.buttons[i];if(buttons[i]===undefined){buttons[i]=new Button(this,i);}buttons[i].update(buttonData);}//  Axes\nfor(i=0;i<data.axes.length;i++){var axisData=data.axes[i];if(axes[i]===undefined){axes[i]=new Axis(this,i);}else{axes[i].update(axisData);}}}});module.exports=Gamepad;/***/},/* 310 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var EventEmitter=__webpack_require__(14);var Gamepad=__webpack_require__(309);// https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API\n// https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API\n// https://www.smashingmagazine.com/2015/11/gamepad-api-in-web-games/\n// http://html5gamepad.com/\n/**\r\n * @typedef {object} Pad\r\n *\r\n * @property {string} id - [description]\r\n * @property {integer} index - [description]\r\n *//**\r\n * @callback GamepadHandler\r\n *\r\n * @property {GamepadEvent} event - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class GamepadManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.InputManager} inputManager - [description]\r\n */var GamepadManager=new Class({Extends:EventEmitter,initialize:function GamepadManager(inputManager){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadManager#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */this.manager=inputManager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadManager#enabled\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.enabled=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadManager#target\r\n         * @type {?object}\r\n         * @since 3.0.0\r\n         */this.target;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadManager#handler\r\n         * @type {?GamepadHandler}\r\n         * @since 3.0.0\r\n         */this.handler;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadManager#gamepads\r\n         * @type {Phaser.Input.Gamepad.Gamepad[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.gamepads=[];/**\r\n         * Standard FIFO queue.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadManager#queue\r\n         * @type {GamepadEvent[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.queue=[];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var config=this.manager.config;this.enabled=config.inputGamepad&&this.manager.game.device.input.gamepads;this.target=window;if(this.enabled){this.startListeners();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#startListeners\r\n     * @since 3.0.0\r\n     */startListeners:function startListeners(){var queue=this.queue;var handler=function handler(event){if(event.defaultPrevented){// Do nothing if event already handled\nreturn;}queue.push(event);};this.handler=handler;var target=this.target;target.addEventListener('gamepadconnected',handler,false);target.addEventListener('gamepaddisconnected',handler,false);//  FF only for now:\ntarget.addEventListener('gamepadbuttondown',handler,false);target.addEventListener('gamepadbuttonup',handler,false);target.addEventListener('gamepadaxismove',handler,false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#stopListeners\r\n     * @since 3.0.0\r\n     */stopListeners:function stopListeners(){var target=this.target;var handler=this.handler;target.removeEventListener('gamepadconnected',handler);target.removeEventListener('gamepaddisconnected',handler);target.removeEventListener('gamepadbuttondown',handler);target.removeEventListener('gamepadbuttonup',handler);target.removeEventListener('gamepadaxismove',handler);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#disconnectAll\r\n     * @since 3.0.0\r\n     */disconnectAll:function disconnectAll(){for(var i=0;i<this.gamepads.length;i++){this.gamepads.connected=false;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#addPad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Pad} pad - [description]\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad} [description]\r\n     */addPad:function addPad(pad){var gamepad=new Gamepad(this,pad.id,pad.index);this.gamepads[pad.index]=gamepad;return gamepad;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#removePad\r\n     * @since 3.0.0\r\n     * @todo  Code this feature\r\n     *\r\n     * @param {number} index - [description]\r\n     * @param {Pad} pad - [description]\r\n     */removePad:function removePad(){//  TODO\n},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#refreshPads\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Pad[]} pads - [description]\r\n     */refreshPads:function refreshPads(pads){if(!pads){this.disconnectAll();}else{for(var i=0;i<pads.length;i++){var pad=pads[i];if(!pad){//  removePad?\ncontinue;}if(this.gamepads[pad.index]===undefined){this.addPad(pad);}this.gamepads[pad.index].update(pad);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#getAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad[]} [description]\r\n     */getAll:function getAll(){var out=[];for(var i=0;i<this.gamepads.length;i++){if(this.gamepads[i]){out.push(this.gamepads[i]);}}return out;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#getPad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - [description]\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad} [description]\r\n     */getPad:function getPad(index){for(var i=0;i<this.gamepads.length;i++){if(this.gamepads[i].index===index){return this.gamepads[i];}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#update\r\n     * @since 3.0.0\r\n     */update:function update(){if(!this.enabled){return;}this.refreshPads(navigator.getGamepads());var len=this.queue.length;if(len===0){return;}var queue=this.queue.splice(0,len);//  Process the event queue, dispatching all of the events that have stored up\nfor(var i=0;i<len;i++){var event=queue[i];var pad;switch(event.type){case'gamepadconnected':pad=this.getPad(event.gamepad.index);this.emit('connected',pad,event);break;case'gamepaddisconnected':pad=this.getPad(event.gamepad.index);this.emit('disconnected',pad,event);break;}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.stopListeners();this.disconnectAll();this.gamepads=[];},/**\r\n     * The total number of connected game pads.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadManager#total\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */total:{get:function get(){return this.gamepads.length;}}});module.exports=GamepadManager;/***/},/* 311 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var EventEmitter=__webpack_require__(14);var Gamepad=__webpack_require__(310);var Keyboard=__webpack_require__(306);var Mouse=__webpack_require__(303);var Pointer=__webpack_require__(302);var Rectangle=__webpack_require__(10);var Touch=__webpack_require__(301);var TransformMatrix=__webpack_require__(78);var TransformXY=__webpack_require__(300);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class InputManager\r\n * @memberOf Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - [description]\r\n * @param {object} config - [description]\r\n */var InputManager=new Class({initialize:function InputManager(game,config){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */this.canvas;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.config=config;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.enabled=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */this.events=new EventEmitter();/**\r\n         * Standard FIFO queue.\r\n         *\r\n         * @name Phaser.Input.InputManager#queue\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.queue=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#keyboard\r\n         * @type {Phaser.Input.Keyboard.KeyboardManager}\r\n         * @since 3.0.0\r\n         */this.keyboard=new Keyboard(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#mouse\r\n         * @type {Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */this.mouse=new Mouse(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#touch\r\n         * @type {Phaser.Input.Touch.TouchManager}\r\n         * @since 3.0.0\r\n         */this.touch=new Touch(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#gamepad\r\n         * @type {Phaser.Input.Gamepad.GamepadManager}\r\n         * @since 3.0.0\r\n         */this.gamepad=new Gamepad(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#activePointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @since 3.0.0\r\n         */this.activePointer=new Pointer(this,0);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#scale\r\n         * @type {{x:number,y:number}}\r\n         * @since 3.0.0\r\n         */this.scale={x:1,y:1};/**\r\n         * If the top-most Scene in the Scene List receives an input it will stop input from\r\n         * propagating any lower down the scene list, i.e. if you have a UI Scene at the top\r\n         * and click something on it, that click will not then be passed down to any other\r\n         * Scene below. Disable this to have input events passed through all Scenes, all the time.\r\n         *\r\n         * @name Phaser.Input.InputManager#globalTopOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.globalTopOnly=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#ignoreEvents\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.ignoreEvents=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.0.0\r\n         */this.bounds=new Rectangle();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempPoint\r\n         * @type {{x:number,y:number}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tempPoint={x:0,y:0};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempHitTest\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._tempHitTest=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.4.0\r\n         */this._tempMatrix=new TransformMatrix();game.events.once('boot',this.boot,this);},/**\r\n     * The Boot handler is called by Phaser.Game when it first starts up.\r\n     * The renderer is available by now.\r\n     *\r\n     * @method Phaser.Input.InputManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){this.canvas=this.game.canvas;this.updateBounds();this.keyboard.boot();this.mouse.boot();this.touch.boot();this.gamepad.boot();this.game.events.once('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#updateBounds\r\n     * @since 3.0.0\r\n     */updateBounds:function updateBounds(){var bounds=this.bounds;var clientRect=this.canvas.getBoundingClientRect();bounds.x=clientRect.left+window.pageXOffset-document.documentElement.clientLeft;bounds.y=clientRect.top+window.pageYOffset-document.documentElement.clientTop;bounds.width=clientRect.width;bounds.height=clientRect.height;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#resize\r\n     * @since 3.2.0\r\n     */resize:function resize(){this.updateBounds();//  Game config size\nvar gw=this.game.config.width;var gh=this.game.config.height;//  Actual canvas size\nvar bw=this.bounds.width;var bh=this.bounds.height;//  Scale factor\nthis.scale.x=gw/bw;this.scale.y=gh/bh;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     */update:function update(time){this.keyboard.update();this.gamepad.update();this.ignoreEvents=false;var len=this.queue.length;//  Currently just 1 pointer supported\nvar pointer=this.activePointer;pointer.reset();if(!this.enabled||len===0){return;}this.updateBounds();this.scale.x=this.game.config.width/this.bounds.width;this.scale.y=this.game.config.height/this.bounds.height;//  Clears the queue array, and also means we don't work on array data that could potentially\n//  be modified during the processing phase\nvar queue=this.queue.splice(0,len);//  Process the event queue, dispatching all of the events that have stored up\nfor(var i=0;i<len;i++){var event=queue[i];//  TODO: Move to CONSTs so we can do integer comparisons instead of strings.\nswitch(event.type){case'mousemove':pointer.move(event,time);break;case'mousedown':pointer.down(event,time);break;case'mouseup':pointer.up(event,time);break;case'touchmove':pointer.touchmove(event,time);break;case'touchstart':pointer.touchstart(event,time);break;case'touchend':pointer.touchend(event,time);break;case'pointerlockchange':this.events.emit('pointerlockchange',event,this.mouse.locked);break;}}},/**\r\n     * Will always return an array.\r\n     * Array contains matching Interactive Objects.\r\n     * Array will be empty if no objects were matched.\r\n     * x/y = pointer x/y (un-translated)\r\n     *\r\n     * @method Phaser.Input.InputManager#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {array} gameObjects - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {array} output - [description]\r\n     *\r\n     * @return {array} [description]\r\n     */hitTest:function hitTest(x,y,gameObjects,camera,output){if(output===undefined){output=this._tempHitTest;}var tempPoint=this._tempPoint;var cameraW=camera.width;var cameraH=camera.height;output.length=0;if(!(x>=camera.x&&y>=camera.y&&x<=camera.x+cameraW&&y<=camera.y+cameraH)){return output;}//  Stores the world point inside of tempPoint\ncamera.getWorldPoint(x,y,tempPoint);var culledGameObjects=camera.cull(gameObjects);var point={x:0,y:0};var res=this.game.config.resolution;var matrix=this._tempMatrix;for(var i=0;i<culledGameObjects.length;i++){var gameObject=culledGameObjects[i];if(!gameObject.input||!gameObject.input.enabled||!gameObject.willRender()){continue;}var px=tempPoint.x*res+camera.scrollX*gameObject.scrollFactorX-camera.scrollX;var py=tempPoint.y*res+camera.scrollY*gameObject.scrollFactorY-camera.scrollY;if(gameObject.parentContainer){gameObject.getWorldTransformMatrix(matrix);TransformXY(px,py,matrix.tx,matrix.ty,matrix.rotation,matrix.scaleX,matrix.scaleY,point);}else{TransformXY(px,py,gameObject.x,gameObject.y,gameObject.rotation,gameObject.scaleX,gameObject.scaleY,point);}if(this.pointWithinHitArea(gameObject,point.x,point.y)){output.push(gameObject);}}return output;},/*\r\n    debugHitTest: function (x, y, gameObject, camera, output)\r\n    {\r\n        if (output === undefined) { output = this._tempHitTest; }\r\n\r\n        var tempPoint = this._tempPoint;\r\n\r\n        //  Stores the translated world point inside of tempPoint\r\n        camera.getWorldPoint(x, y, tempPoint);\r\n\r\n        var point = { x: 0, y: 0 };\r\n\r\n        var res = this.game.config.resolution;\r\n\r\n        var matrix = this._tempMatrix;\r\n\r\n        var px = tempPoint.x * res + (camera.scrollX * gameObject.scrollFactorX) - camera.scrollX;\r\n        var py = tempPoint.y * res + (camera.scrollY * gameObject.scrollFactorY) - camera.scrollY;\r\n\r\n        gameObject.getWorldTransformMatrix(matrix);\r\n\r\n        // matrix.invert();\r\n        matrix.transformPoint(px, py, point);\r\n\r\n        // var tt = new TransformMatrix();\r\n\r\n        // tt.translate(px, py);\r\n\r\n        // matrix.invert();\r\n        // matrix.multiply(tt);\r\n\r\n        // TransformXY(px, py, matrix.tx, matrix.ty, matrix.rotation, matrix.scaleX, matrix.scaleY, point);\r\n\r\n        // point.x = px;\r\n        // point.y = py;\r\n\r\n        return [ matrix, point, this.pointWithinHitArea(gameObject, point.x, point.y) ];\r\n    },\r\n    *//**\r\n     * x/y MUST be translated before being passed to this function,\r\n     * unless the gameObject is guaranteed to not be rotated or scaled in any way.\r\n     *\r\n     * @method Phaser.Input.InputManager#pointWithinHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */pointWithinHitArea:function pointWithinHitArea(gameObject,x,y){var input=gameObject.input;//  Normalize the origin\nx+=gameObject.displayOriginX;y+=gameObject.displayOriginY;if(input.hitAreaCallback(input.hitArea,x,y,gameObject)){input.localX=x;input.localY=y;return true;}else{return false;}},/**\r\n     * x/y MUST be translated before being passed to this function,\r\n     * unless the gameObject is guaranteed to not be rotated or scaled in any way.\r\n     *\r\n     * @method Phaser.Input.InputManager#pointWithinInteractiveObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.InteractiveObject} object - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */pointWithinInteractiveObject:function pointWithinInteractiveObject(object,x,y){if(!object.hitArea){return false;}//  Normalize the origin\nx+=object.gameObject.displayOriginX;y+=object.gameObject.displayOriginY;object.localX=x;object.localY=y;return object.hitAreaCallback(object.hitArea,x,y,object);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#transformX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} pageX - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */transformX:function transformX(pageX){return(pageX-this.bounds.left)*this.scale.x;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#transformY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} pageY - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */transformY:function transformY(pageY){return(pageY-this.bounds.top)*this.scale.y;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#getOffsetX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getOffsetX:function getOffsetX(){return this.bounds.left;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#getOffsetY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getOffsetY:function getOffsetY(){return this.bounds.top;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#getScaleX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getScaleX:function getScaleX(){return this.game.config.width/this.bounds.width;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#getScaleY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getScaleY:function getScaleY(){return this.game.config.height/this.bounds.height;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.events.removeAllListeners();this.keyboard.destroy();this.mouse.destroy();this.touch.destroy();this.gamepad.destroy();this.activePointer.destroy();this.queue=[];this.game=null;}});module.exports=InputManager;/***/},/* 312 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ModelViewProjection={modelMatrixDirty:false,viewMatrixDirty:false,projectionMatrixDirty:false,modelMatrix:null,viewMatrix:null,projectionMatrix:null,mvpInit:function mvpInit(){this.modelMatrixDirty=true;this.viewMatrixDirty=true;this.projectionMatrixDirty=true;this.modelMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);this.viewMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);this.projectionMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);return this;},mvpUpdate:function mvpUpdate(){var program=this.program;if(this.modelMatrixDirty){this.renderer.setMatrix4(program,'uModelMatrix',false,this.modelMatrix);this.modelMatrixDirty=false;}if(this.viewMatrixDirty){this.renderer.setMatrix4(program,'uViewMatrix',false,this.viewMatrix);this.viewMatrixDirty=false;}if(this.projectionMatrixDirty){this.renderer.setMatrix4(program,'uProjectionMatrix',false,this.projectionMatrix);this.projectionMatrixDirty=false;}return this;},modelIdentity:function modelIdentity(){var modelMatrix=this.modelMatrix;modelMatrix[0]=1;modelMatrix[1]=0;modelMatrix[2]=0;modelMatrix[3]=0;modelMatrix[4]=0;modelMatrix[5]=1;modelMatrix[6]=0;modelMatrix[7]=0;modelMatrix[8]=0;modelMatrix[9]=0;modelMatrix[10]=1;modelMatrix[11]=0;modelMatrix[12]=0;modelMatrix[13]=0;modelMatrix[14]=0;modelMatrix[15]=1;this.modelMatrixDirty=true;return this;},modelScale:function modelScale(x,y,z){var modelMatrix=this.modelMatrix;modelMatrix[0]=modelMatrix[0]*x;modelMatrix[1]=modelMatrix[1]*x;modelMatrix[2]=modelMatrix[2]*x;modelMatrix[3]=modelMatrix[3]*x;modelMatrix[4]=modelMatrix[4]*y;modelMatrix[5]=modelMatrix[5]*y;modelMatrix[6]=modelMatrix[6]*y;modelMatrix[7]=modelMatrix[7]*y;modelMatrix[8]=modelMatrix[8]*z;modelMatrix[9]=modelMatrix[9]*z;modelMatrix[10]=modelMatrix[10]*z;modelMatrix[11]=modelMatrix[11]*z;this.modelMatrixDirty=true;return this;},modelTranslate:function modelTranslate(x,y,z){var modelMatrix=this.modelMatrix;modelMatrix[12]=modelMatrix[0]*x+modelMatrix[4]*y+modelMatrix[8]*z+modelMatrix[12];modelMatrix[13]=modelMatrix[1]*x+modelMatrix[5]*y+modelMatrix[9]*z+modelMatrix[13];modelMatrix[14]=modelMatrix[2]*x+modelMatrix[6]*y+modelMatrix[10]*z+modelMatrix[14];modelMatrix[15]=modelMatrix[3]*x+modelMatrix[7]*y+modelMatrix[11]*z+modelMatrix[15];this.modelMatrixDirty=true;return this;},modelRotateX:function modelRotateX(radians){var modelMatrix=this.modelMatrix;var s=Math.sin(radians);var c=Math.cos(radians);var a10=modelMatrix[4];var a11=modelMatrix[5];var a12=modelMatrix[6];var a13=modelMatrix[7];var a20=modelMatrix[8];var a21=modelMatrix[9];var a22=modelMatrix[10];var a23=modelMatrix[11];modelMatrix[4]=a10*c+a20*s;modelMatrix[5]=a11*c+a21*s;modelMatrix[6]=a12*c+a22*s;modelMatrix[7]=a13*c+a23*s;modelMatrix[8]=a20*c-a10*s;modelMatrix[9]=a21*c-a11*s;modelMatrix[10]=a22*c-a12*s;modelMatrix[11]=a23*c-a13*s;this.modelMatrixDirty=true;return this;},modelRotateY:function modelRotateY(radians){var modelMatrix=this.modelMatrix;var s=Math.sin(radians);var c=Math.cos(radians);var a00=modelMatrix[0];var a01=modelMatrix[1];var a02=modelMatrix[2];var a03=modelMatrix[3];var a20=modelMatrix[8];var a21=modelMatrix[9];var a22=modelMatrix[10];var a23=modelMatrix[11];modelMatrix[0]=a00*c-a20*s;modelMatrix[1]=a01*c-a21*s;modelMatrix[2]=a02*c-a22*s;modelMatrix[3]=a03*c-a23*s;modelMatrix[8]=a00*s+a20*c;modelMatrix[9]=a01*s+a21*c;modelMatrix[10]=a02*s+a22*c;modelMatrix[11]=a03*s+a23*c;this.modelMatrixDirty=true;return this;},modelRotateZ:function modelRotateZ(radians){var modelMatrix=this.modelMatrix;var s=Math.sin(radians);var c=Math.cos(radians);var a00=modelMatrix[0];var a01=modelMatrix[1];var a02=modelMatrix[2];var a03=modelMatrix[3];var a10=modelMatrix[4];var a11=modelMatrix[5];var a12=modelMatrix[6];var a13=modelMatrix[7];modelMatrix[0]=a00*c+a10*s;modelMatrix[1]=a01*c+a11*s;modelMatrix[2]=a02*c+a12*s;modelMatrix[3]=a03*c+a13*s;modelMatrix[4]=a10*c-a00*s;modelMatrix[5]=a11*c-a01*s;modelMatrix[6]=a12*c-a02*s;modelMatrix[7]=a13*c-a03*s;this.modelMatrixDirty=true;return this;},viewIdentity:function viewIdentity(){var viewMatrix=this.viewMatrix;viewMatrix[0]=1;viewMatrix[1]=0;viewMatrix[2]=0;viewMatrix[3]=0;viewMatrix[4]=0;viewMatrix[5]=1;viewMatrix[6]=0;viewMatrix[7]=0;viewMatrix[8]=0;viewMatrix[9]=0;viewMatrix[10]=1;viewMatrix[11]=0;viewMatrix[12]=0;viewMatrix[13]=0;viewMatrix[14]=0;viewMatrix[15]=1;this.viewMatrixDirty=true;return this;},viewScale:function viewScale(x,y,z){var viewMatrix=this.viewMatrix;viewMatrix[0]=viewMatrix[0]*x;viewMatrix[1]=viewMatrix[1]*x;viewMatrix[2]=viewMatrix[2]*x;viewMatrix[3]=viewMatrix[3]*x;viewMatrix[4]=viewMatrix[4]*y;viewMatrix[5]=viewMatrix[5]*y;viewMatrix[6]=viewMatrix[6]*y;viewMatrix[7]=viewMatrix[7]*y;viewMatrix[8]=viewMatrix[8]*z;viewMatrix[9]=viewMatrix[9]*z;viewMatrix[10]=viewMatrix[10]*z;viewMatrix[11]=viewMatrix[11]*z;this.viewMatrixDirty=true;return this;},viewTranslate:function viewTranslate(x,y,z){var viewMatrix=this.viewMatrix;viewMatrix[12]=viewMatrix[0]*x+viewMatrix[4]*y+viewMatrix[8]*z+viewMatrix[12];viewMatrix[13]=viewMatrix[1]*x+viewMatrix[5]*y+viewMatrix[9]*z+viewMatrix[13];viewMatrix[14]=viewMatrix[2]*x+viewMatrix[6]*y+viewMatrix[10]*z+viewMatrix[14];viewMatrix[15]=viewMatrix[3]*x+viewMatrix[7]*y+viewMatrix[11]*z+viewMatrix[15];this.viewMatrixDirty=true;return this;},viewRotateX:function viewRotateX(radians){var viewMatrix=this.viewMatrix;var s=Math.sin(radians);var c=Math.cos(radians);var a10=viewMatrix[4];var a11=viewMatrix[5];var a12=viewMatrix[6];var a13=viewMatrix[7];var a20=viewMatrix[8];var a21=viewMatrix[9];var a22=viewMatrix[10];var a23=viewMatrix[11];viewMatrix[4]=a10*c+a20*s;viewMatrix[5]=a11*c+a21*s;viewMatrix[6]=a12*c+a22*s;viewMatrix[7]=a13*c+a23*s;viewMatrix[8]=a20*c-a10*s;viewMatrix[9]=a21*c-a11*s;viewMatrix[10]=a22*c-a12*s;viewMatrix[11]=a23*c-a13*s;this.viewMatrixDirty=true;return this;},viewRotateY:function viewRotateY(radians){var viewMatrix=this.viewMatrix;var s=Math.sin(radians);var c=Math.cos(radians);var a00=viewMatrix[0];var a01=viewMatrix[1];var a02=viewMatrix[2];var a03=viewMatrix[3];var a20=viewMatrix[8];var a21=viewMatrix[9];var a22=viewMatrix[10];var a23=viewMatrix[11];viewMatrix[0]=a00*c-a20*s;viewMatrix[1]=a01*c-a21*s;viewMatrix[2]=a02*c-a22*s;viewMatrix[3]=a03*c-a23*s;viewMatrix[8]=a00*s+a20*c;viewMatrix[9]=a01*s+a21*c;viewMatrix[10]=a02*s+a22*c;viewMatrix[11]=a03*s+a23*c;this.viewMatrixDirty=true;return this;},viewRotateZ:function viewRotateZ(radians){var viewMatrix=this.viewMatrix;var s=Math.sin(radians);var c=Math.cos(radians);var a00=viewMatrix[0];var a01=viewMatrix[1];var a02=viewMatrix[2];var a03=viewMatrix[3];var a10=viewMatrix[4];var a11=viewMatrix[5];var a12=viewMatrix[6];var a13=viewMatrix[7];viewMatrix[0]=a00*c+a10*s;viewMatrix[1]=a01*c+a11*s;viewMatrix[2]=a02*c+a12*s;viewMatrix[3]=a03*c+a13*s;viewMatrix[4]=a10*c-a00*s;viewMatrix[5]=a11*c-a01*s;viewMatrix[6]=a12*c-a02*s;viewMatrix[7]=a13*c-a03*s;this.viewMatrixDirty=true;return this;},viewLoad2D:function viewLoad2D(matrix2D){var vm=this.viewMatrix;vm[0]=matrix2D[0];vm[1]=matrix2D[1];vm[2]=0.0;vm[3]=0.0;vm[4]=matrix2D[2];vm[5]=matrix2D[3];vm[6]=0.0;vm[7]=0.0;vm[8]=matrix2D[4];vm[9]=matrix2D[5];vm[10]=1.0;vm[11]=0.0;vm[12]=0.0;vm[13]=0.0;vm[14]=0.0;vm[15]=1.0;this.viewMatrixDirty=true;return this;},viewLoad:function viewLoad(matrix){var vm=this.viewMatrix;vm[0]=matrix[0];vm[1]=matrix[1];vm[2]=matrix[2];vm[3]=matrix[3];vm[4]=matrix[4];vm[5]=matrix[5];vm[6]=matrix[6];vm[7]=matrix[7];vm[8]=matrix[8];vm[9]=matrix[9];vm[10]=matrix[10];vm[11]=matrix[11];vm[12]=matrix[12];vm[13]=matrix[13];vm[14]=matrix[14];vm[15]=matrix[15];this.viewMatrixDirty=true;return this;},projIdentity:function projIdentity(){var projectionMatrix=this.projectionMatrix;projectionMatrix[0]=1;projectionMatrix[1]=0;projectionMatrix[2]=0;projectionMatrix[3]=0;projectionMatrix[4]=0;projectionMatrix[5]=1;projectionMatrix[6]=0;projectionMatrix[7]=0;projectionMatrix[8]=0;projectionMatrix[9]=0;projectionMatrix[10]=1;projectionMatrix[11]=0;projectionMatrix[12]=0;projectionMatrix[13]=0;projectionMatrix[14]=0;projectionMatrix[15]=1;this.projectionMatrixDirty=true;return this;},projOrtho:function projOrtho(left,right,bottom,top,near,far){var projectionMatrix=this.projectionMatrix;var leftRight=1.0/(left-right);var bottomTop=1.0/(bottom-top);var nearFar=1.0/(near-far);projectionMatrix[0]=-2.0*leftRight;projectionMatrix[1]=0.0;projectionMatrix[2]=0.0;projectionMatrix[3]=0.0;projectionMatrix[4]=0.0;projectionMatrix[5]=-2.0*bottomTop;projectionMatrix[6]=0.0;projectionMatrix[7]=0.0;projectionMatrix[8]=0.0;projectionMatrix[9]=0.0;projectionMatrix[10]=2.0*nearFar;projectionMatrix[11]=0.0;projectionMatrix[12]=(left+right)*leftRight;projectionMatrix[13]=(top+bottom)*bottomTop;projectionMatrix[14]=(far+near)*nearFar;projectionMatrix[15]=1.0;this.projectionMatrixDirty=true;return this;},projPersp:function projPersp(fovy,aspectRatio,near,far){var projectionMatrix=this.projectionMatrix;var fov=1.0/Math.tan(fovy/2.0);var nearFar=1.0/(near-far);projectionMatrix[0]=fov/aspectRatio;projectionMatrix[1]=0.0;projectionMatrix[2]=0.0;projectionMatrix[3]=0.0;projectionMatrix[4]=0.0;projectionMatrix[5]=fov;projectionMatrix[6]=0.0;projectionMatrix[7]=0.0;projectionMatrix[8]=0.0;projectionMatrix[9]=0.0;projectionMatrix[10]=(far+near)*nearFar;projectionMatrix[11]=-1.0;projectionMatrix[12]=0.0;projectionMatrix[13]=0.0;projectionMatrix[14]=2.0*far*near*nearFar;projectionMatrix[15]=0.0;this.projectionMatrixDirty=true;return this;}};module.exports=ModelViewProjection;/***/},/* 313 *//***/function(module,exports,__webpack_require__){\"use strict\";/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  2.1.1 (Mar 17, 2016)\n/*\r\nISC License\r\n\r\nCopyright (c) 2016, Mapbox\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any purpose\r\nwith or without fee is hereby granted, provided that the above copyright notice\r\nand this permission notice appear in all copies.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\r\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\r\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\r\nTHIS SOFTWARE.\r\n */module.exports=earcut;/*\r\nvertices is a flat array of vertice coordinates like [x0,y0, x1,y1, x2,y2, ...].\r\nholes is an array of hole indices if any (e.g. [5, 8] for a 12-vertice input would mean one hole with vertices 5–7 and another with 8–11).\r\ndimensions is the number of coordinates per vertice in the input array (2 by default).\r\nEach group of three vertice indices in the resulting array forms a triangle.\r\n */function earcut(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,true),triangles=[];if(!outerNode)return triangles;var minX,minY,maxX,maxY,x,y,size;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\nif(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and size are later used to transform coords into integers for z-order calculation\nsize=Math.max(maxX-minX,maxY-minY);}earcutLinked(outerNode,triangles,dim,minX,minY,size);return triangles;}// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim){last=insertNode(i,data[i],data[i+1],last);}}else{for(i=end-dim;i>=start;i-=dim){last=insertNode(i,data[i],data[i+1],last);}}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points\nfunction filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)return null;again=true;}else{p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear,triangles,dim,minX,minY,size,pass){if(!ear)return;// interlink polygon nodes in z-order\nif(!pass&&size)indexCurve(ear,minX,minY,size);var stop=ear,prev,next;// iterate through ears, slicing them one by one\nwhile(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(size?isEarHashed(ear,minX,minY,size):isEar(ear)){// cut off the triangle\ntriangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertice leads to less sliver triangles\near=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears\nif(ear===stop){// try filtering points and slicing again\nif(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,size,1);// if this didn't work, try curing all small self-intersections locally\n}else if(pass===1){ear=cureLocalIntersections(ear,triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,size,2);// as a last resort, try splitting the remaining polygon into two\n}else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,size);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear\n// now make sure we don't have other points inside the potential ear\nvar p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,size){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear\n// triangle bbox; min & max are calculated like this for speed\nvar minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;\nvar minZ=zOrder(minTX,minTY,minX,minY,size),maxZ=zOrder(maxTX,maxTY,minX,minY,size);// first look for points inside the triangle in increasing z-order\nvar p=ear.nextZ;while(p&&p.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.nextZ;}// then look for points in decreasing z-order\np=ear.prevZ;while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}return true;}// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved\nremoveNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return p;}// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start,triangles,dim,minX,minY,size){// look for a valid diagonal that divides the polygon into two\nvar a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal\nvar c=splitPolygon(a,b);// filter colinear points around the cuts\na=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half\nearcutLinked(a,triangles,dim,minX,minY,size);earcutLinked(c,triangles,dim,minX,minY,size);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data,holeIndices,outerNode,dim){var queue=[],i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right\nfor(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){var b=splitPolygon(outerNode,hole);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;\n// segment's endpoint with lesser x will be potential connection point\ndo{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m.prev;// hole touches outer segment; pick lower endpoint\n// look for points inside the triangle of hole point, segment intersection and endpoint;\n// if there are no points found, we have a valid connection;\n// otherwise choose the point of the minimum angle with the ray as connection point\nvar stop=m,mx=m.x,my=m.y,tanMin=Infinity,tan;p=m.next;while(p!==stop){if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential\nif((tan<tanMin||tan===tanMin&&p.x>m.x)&&locallyInside(p,hole)){m=p;tanMin=tan;}}p=p.next;}return m;}// interlink polygon nodes in z-order\nfunction indexCurve(start,minX,minY,size){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,size);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else{e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and size of the data bounding box\nfunction zOrder(x,y,minX,minY,size){// coords are transformed into non-negative 15-bit integer range\nx=32767*(x-minX)/size;y=32767*(y-minY)/size;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring\nfunction getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle\nfunction pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b);}// signed area of a triangle\nfunction area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal\nfunction equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect\nfunction intersects(p1,q1,p2,q2){if(equals(p1,q1)&&equals(p2,q2)||equals(p1,q2)&&equals(p2,q1))return true;return area(p1,q1,p2)>0!==area(p1,q1,q2)>0&&area(p2,q2,p1)>0!==area(p2,q2,q1)>0;}// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a,b){var p=a,inside=false,px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a,b){var a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i,x,y,last){var p=new Node(i,x,y);if(!last){p.prev=p;p.next=p;}else{p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node(i,x,y){// vertice index in coordinates array\nthis.i=i;// vertex coordinates\nthis.x=x;this.y=y;// previous and next vertice nodes in a polygon ring\nthis.prev=null;this.next=null;// z-order curve value\nthis.z=null;// previous and next nodes in z-order\nthis.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point\nthis.steiner=false;}// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation=function(data,holeIndices,dim,triangles){var hasHoles=holeIndices&&holeIndices.length;var outerLen=hasHoles?holeIndices[0]*dim:data.length;var polygonArea=Math.abs(signedArea(data,0,outerLen,dim));if(hasHoles){for(var i=0,len=holeIndices.length;i<len;i++){var start=holeIndices[i]*dim;var end=i<len-1?holeIndices[i+1]*dim:data.length;polygonArea-=Math.abs(signedArea(data,start,end,dim));}}var trianglesArea=0;for(i=0;i<triangles.length;i+=3){var a=triangles[i]*dim;var b=triangles[i+1]*dim;var c=triangles[i+2]*dim;trianglesArea+=Math.abs((data[a]-data[c])*(data[b+1]-data[a+1])-(data[a]-data[b])*(data[c+1]-data[a+1]));}return polygonArea===0&&trianglesArea===0?0:Math.abs((trianglesArea-polygonArea)/polygonArea);};function signedArea(data,start,end,dim){var sum=0;for(var i=start,j=end-dim;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten=function(data){var dim=data[0][0].length,result={vertices:[],holes:[],dimensions:dim},holeIndex=0;for(var i=0;i<data.length;i++){for(var j=0;j<data[i].length;j++){for(var d=0;d<dim;d++){result.vertices.push(data[i][j][d]);}}if(i>0){holeIndex+=data[i-1].length;result.holes.push(holeIndex);}}return result;};/***/},/* 314 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CanvasPool=__webpack_require__(23);/**\r\n * Determines the canvas features of the browser running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.canvasFeatures` from within any Scene.\r\n * \r\n * @typedef {object} Phaser.Device.CanvasFeatures\r\n * @since 3.0.0\r\n * \r\n * @property {boolean} supportInverseAlpha - Set to true if the browser supports inversed alpha.\r\n * @property {boolean} supportNewBlendModes - Set to true if the browser supports new canvas blend modes.\r\n */var CanvasFeatures={supportInverseAlpha:false,supportNewBlendModes:false};function checkBlendMode(){var pngHead='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';var pngEnd='AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';var magenta=new Image();magenta.onload=function(){var yellow=new Image();yellow.onload=function(){var canvas=CanvasPool.create(yellow,6,1);var context=canvas.getContext('2d');context.globalCompositeOperation='multiply';context.drawImage(magenta,0,0);context.drawImage(yellow,2,0);if(!context.getImageData(2,0,1,1)){return false;}var data=context.getImageData(2,0,1,1).data;CanvasPool.remove(yellow);CanvasFeatures.supportNewBlendModes=data[0]===255&&data[1]===0&&data[2]===0;};yellow.src=pngHead+'/wCKxvRF'+pngEnd;};magenta.src=pngHead+'AP804Oa6'+pngEnd;return false;}function checkInverseAlpha(){var canvas=CanvasPool.create(this,2,1);var context=canvas.getContext('2d');context.fillStyle='rgba(10, 20, 30, 0.5)';//  Draw a single pixel\ncontext.fillRect(0,0,1,1);//  Get the color values\nvar s1=context.getImageData(0,0,1,1);if(s1===null){return false;}//  Plot them to x2\ncontext.putImageData(s1,1,0);//  Get those values\nvar s2=context.getImageData(1,0,1,1);//  Compare and return\nreturn s2.data[0]===s1.data[0]&&s2.data[1]===s1.data[1]&&s2.data[2]===s1.data[2]&&s2.data[3]===s1.data[3];}function init(){if(document!==undefined){CanvasFeatures.supportNewBlendModes=checkBlendMode();CanvasFeatures.supportInverseAlpha=checkInverseAlpha();}return CanvasFeatures;}module.exports=init();/***/},/* 315 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Plugins\r\n */var Plugins={/**\r\n     * These are the Global Managers that are created by the Phaser.Game instance.\r\n     * They are referenced from Scene.Systems so that plugins can use them.\r\n     * \r\n     * @name Phaser.Plugins.Global\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */Global:['anims','cache','registry','sound','textures'],/**\r\n     * These are the core plugins that are installed into every Scene.Systems instance, no matter what.\r\n     * They are optionally exposed in the Scene as well (see the InjectionMap for details)\r\n     * \r\n     * They are created in the order in which they appear in this array and EventEmitter is always first.\r\n     * \r\n     * @name Phaser.Plugins.CoreScene\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */CoreScene:['EventEmitter','CameraManager','GameObjectCreator','GameObjectFactory','ScenePlugin','DisplayList','UpdateList'],/**\r\n     * These plugins are created in Scene.Systems in addition to the CoreScenePlugins.\r\n     * \r\n     * You can elect not to have these plugins by either creating a DefaultPlugins object as part\r\n     * of the Game Config, by creating a Plugins object as part of a Scene Config, or by modifying this array\r\n     * and building your own bundle.\r\n     * \r\n     * They are optionally exposed in the Scene as well (see the InjectionMap for details)\r\n     * \r\n     * They are always created in the order in which they appear in the array.\r\n     * \r\n     * @name Phaser.Plugins.DefaultScene\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */DefaultScene:['CameraManager3D','Clock','DataManagerPlugin','InputPlugin','Loader','TweenManager','LightsPlugin']};/*\r\n * \"Sometimes, the elegant implementation is just a function.\r\n * Not a method. Not a class. Not a framework. Just a function.\"\r\n *  -- John Carmack\r\n */module.exports=Plugins;/***/},/* 316 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var NOOP=__webpack_require__(3);/**\r\n * @classdesc\r\n * Abstracts away the use of RAF or setTimeOut for the core game update loop.\r\n * This is invoked automatically by the Phaser.Game instance.\r\n *\r\n * @class RequestAnimationFrame\r\n * @memberOf Phaser.DOM\r\n * @constructor\r\n * @since 3.0.0\r\n */var RequestAnimationFrame=new Class({initialize:function RequestAnimationFrame(){/**\r\n         * True if RequestAnimationFrame is running, otherwise false.\r\n         *\r\n         * @name Phaser.DOM.RequestAnimationFrame#isRunning\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isRunning=false;/**\r\n         * The callback to be invoked each step.\r\n         *\r\n         * @name Phaser.DOM.RequestAnimationFrame#callback\r\n         * @type {FrameRequestCallback}\r\n         * @since 3.0.0\r\n         */this.callback=NOOP;/**\r\n         * The most recent timestamp. Either a DOMHighResTimeStamp under RAF or `Date.now` under SetTimeout.\r\n         *\r\n         * @name Phaser.DOM.RequestAnimationFrame#tick\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.tick=0;/**\r\n         * True if the step is using setTimeout instead of RAF.\r\n         *\r\n         * @name Phaser.DOM.RequestAnimationFrame#isSetTimeOut\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isSetTimeOut=false;/**\r\n         * The setTimeout or RAF callback ID used when canceling them.\r\n         *\r\n         * @name Phaser.DOM.RequestAnimationFrame#timeOutID\r\n         * @type {?number}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.timeOutID=null;/**\r\n         * The previous time the step was called.\r\n         *\r\n         * @name Phaser.DOM.RequestAnimationFrame#lastTime\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.lastTime=0;var _this=this;/**\r\n         * The RAF step function.\r\n         * Updates the local tick value, invokes the callback and schedules another call to requestAnimationFrame.\r\n         *\r\n         * @name Phaser.DOM.RequestAnimationFrame#step\r\n         * @type {FrameRequestCallback}\r\n         * @since 3.0.0\r\n         */this.step=function step(timestamp){// DOMHighResTimeStamp\n_this.lastTime=_this.tick;_this.tick=timestamp;_this.callback(timestamp);_this.timeOutID=window.requestAnimationFrame(step);};/**\r\n         * The SetTimeout step function.\r\n         * Updates the local tick value, invokes the callback and schedules another call to setTimeout.\r\n         *\r\n         * @name Phaser.DOM.RequestAnimationFrame#stepTimeout\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */this.stepTimeout=function stepTimeout(){var d=Date.now();var delay=Math.max(16+_this.lastTime-d,0);_this.lastTime=_this.tick;_this.tick=d;_this.callback(d);_this.timeOutID=window.setTimeout(stepTimeout,delay);};},/**\r\n     * Starts the requestAnimationFrame or setTimeout process running.\r\n     *\r\n     * @method Phaser.DOM.RequestAnimationFrame#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {FrameRequestCallback} callback - The callback to invoke each step.\r\n     * @param {boolean} forceSetTimeOut - Should it use SetTimeout, even if RAF is available?\r\n     */start:function start(callback,forceSetTimeOut){if(this.isRunning){return;}this.callback=callback;this.isSetTimeOut=forceSetTimeOut;this.isRunning=true;this.timeOutID=forceSetTimeOut?window.setTimeout(this.stepTimeout,0):window.requestAnimationFrame(this.step);},/**\r\n     * Stops the requestAnimationFrame or setTimeout from running.\r\n     *\r\n     * @method Phaser.DOM.RequestAnimationFrame#stop\r\n     * @since 3.0.0\r\n     */stop:function stop(){this.isRunning=false;if(this.isSetTimeOut){clearTimeout(this.timeOutID);}else{window.cancelAnimationFrame(this.timeOutID);}},/**\r\n     * Stops the step from running and clears the callback reference.\r\n     *\r\n     * @method Phaser.DOM.RequestAnimationFrame#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.stop();this.callback=NOOP;}});module.exports=RequestAnimationFrame;/***/},/* 317 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Attempts to remove the element from its parentNode in the DOM.\r\n *\r\n * @function Phaser.DOM.RemoveFromDOM\r\n * @since 3.0.0\r\n *\r\n * @param {HTMLElement} element - The DOM element to remove from its parent node.\r\n */var RemoveFromDOM=function RemoveFromDOM(element){if(element.parentNode){element.parentNode.removeChild(element);}};module.exports=RemoveFromDOM;/***/},/* 318 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Takes the given data string and parses it as XML.\r\n * First tries to use the window.DOMParser and reverts to the Microsoft.XMLDOM if that fails.\r\n * The parsed XML object is returned, or `null` if there was an error while parsing the data.\r\n *\r\n * @function Phaser.DOM.ParseXML\r\n * @since 3.0.0\r\n *\r\n * @param {string} data - The XML source stored in a string.\r\n *\r\n * @return {?(DOMParser|ActiveXObject)} The parsed XML data, or `null` if the data could not be parsed.\r\n */var ParseXML=function ParseXML(data){var xml='';try{if(window['DOMParser']){var domparser=new DOMParser();xml=domparser.parseFromString(data,'text/xml');}else{xml=new ActiveXObject('Microsoft.XMLDOM');xml.loadXML(data);}}catch(e){xml=null;}if(!xml||!xml.documentElement||xml.getElementsByTagName('parsererror').length){return null;}else{return xml;}};module.exports=ParseXML;/***/},/* 319 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var OS=__webpack_require__(77);/**\r\n * @callback ContentLoadedCallback\r\n *//**\r\n * Inspects the readyState of the document. If the document is already complete then it invokes the given callback.\r\n * If not complete it sets up several event listeners such as `deviceready`, and once those fire, it invokes the callback.\r\n * Called automatically by the Phaser.Game instance. Should not usually be accessed directly.\r\n *\r\n * @function Phaser.DOM.DOMContentLoaded\r\n * @since 3.0.0\r\n *\r\n * @param {ContentLoadedCallback} callback - The callback to be invoked when the device is ready and the DOM content is loaded.\r\n */var DOMContentLoaded=function DOMContentLoaded(callback){if(document.readyState==='complete'||document.readyState==='interactive'){callback();return;}var check=function check(){document.removeEventListener('deviceready',check,true);document.removeEventListener('DOMContentLoaded',check,true);window.removeEventListener('load',check,true);callback();};if(!document.body){window.setTimeout(check,20);}else if(OS.cordova&&!OS.cocoonJS){//  Ref. http://docs.phonegap.com/en/3.5.0/cordova_events_events.md.html#deviceready\ndocument.addEventListener('deviceready',check,false);}else{document.addEventListener('DOMContentLoaded',check,true);window.addEventListener('load',check,true);}};module.exports=DOMContentLoaded;/***/},/* 320 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Between\r\n * @since 3.0.0\r\n *\r\n * @param {integer} min - [description]\r\n * @param {integer} max - [description]\r\n *\r\n * @return {integer} [description]\r\n */var Between=function Between(min,max){return Math.floor(Math.random()*(max-min+1)+min);};module.exports=Between;/***/},/* 321 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetColor=__webpack_require__(162);/**\r\n * Converts an HSV (hue, saturation and value) color value to RGB.\r\n * Conversion formula from http://en.wikipedia.org/wiki/HSL_color_space.\r\n * Assumes HSV values are contained in the set [0, 1].\r\n * Based on code by Michael Jackson (https://github.com/mjijackson)\r\n *\r\n * @function Phaser.Display.Color.HSVToRGB\r\n * @since 3.0.0\r\n *\r\n * @param {number} h - The hue, in the range 0 - 1.\r\n * @param {number} s - The saturation, in the range 0 - 1.\r\n * @param {number} v - The value, in the range 0 - 1.\r\n *\r\n * @return {ColorObject} An object with the red, green and blue values set in the r, g and b properties.\r\n */var HSVToRGB=function HSVToRGB(h,s,v){if(s===undefined){s=1;}if(v===undefined){v=1;}var i=Math.floor(h*6);var f=h*6-i;var p=Math.floor(v*(1-s)*255);var q=Math.floor(v*(1-f*s)*255);var t=Math.floor(v*(1-(1-f)*s)*255);v=Math.floor(v*=255);var output={r:v,g:v,b:v,color:0};var r=i%6;if(r===0){output.g=t;output.b=p;}else if(r===1){output.r=q;output.b=p;}else if(r===2){output.r=p;output.b=t;}else if(r===3){output.r=p;output.g=q;}else if(r===4){output.r=t;output.g=p;}else if(r===5){output.g=p;output.b=q;}output.color=GetColor(output.r,output.g,output.b);return output;};module.exports=HSVToRGB;/***/},/* 322 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Converts a hue to an RGB color.\r\n * Based on code by Michael Jackson (https://github.com/mjijackson)\r\n *\r\n * @function Phaser.Display.Color.HueToComponent\r\n * @since 3.0.0\r\n *\r\n * @param {number} p\r\n * @param {number} q\r\n * @param {number} t\r\n *\r\n * @return {number} The combined color value.\r\n */var HueToComponent=function HueToComponent(p,q,t){if(t<0){t+=1;}if(t>1){t-=1;}if(t<1/6){return p+(q-p)*6*t;}if(t<1/2){return q;}if(t<2/3){return p+(q-p)*(2/3-t)*6;}return p;};module.exports=HueToComponent;/***/},/* 323 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns a string containing a hex representation of the given color component.\r\n *\r\n * @function Phaser.Display.Color.ComponentToHex\r\n * @since 3.0.0\r\n *\r\n * @param {integer} color - The color channel to get the hex value for, must be a value between 0 and 255.\r\n *\r\n * @return {string} A string of length 2 characters, i.e. 255 = ff, 100 = 64.\r\n */var ComponentToHex=function ComponentToHex(color){var hex=color.toString(16);return hex.length===1?'0'+hex:hex;};module.exports=ComponentToHex;/***/},/* 324 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} InputColorObject\r\n *\r\n * @property {number} [r] - The red color value in the range 0 to 255.\r\n * @property {number} [g] - The green color value in the range 0 to 255.\r\n * @property {number} [b] - The blue color value in the range 0 to 255.\r\n * @property {number} [a] - The alpha color value in the range 0 to 255.\r\n *//**\r\n * @typedef {Object} ColorObject\r\n * @property {number} r - The red color value in the range 0 to 255.\r\n * @property {number} g - The green color value in the range 0 to 255.\r\n * @property {number} b - The blue color value in the range 0 to 255.\r\n * @property {number} a - The alpha color value in the range 0 to 255.\r\n *//**\r\n * @namespace Phaser.Display.Color\r\n */var Color=__webpack_require__(42);Color.ColorToRGBA=__webpack_require__(860);Color.ComponentToHex=__webpack_require__(323);Color.GetColor=__webpack_require__(162);Color.GetColor32=__webpack_require__(346);Color.HexStringToColor=__webpack_require__(347);Color.HSLToColor=__webpack_require__(859);Color.HSVColorWheel=__webpack_require__(858);Color.HSVToRGB=__webpack_require__(321);Color.HueToComponent=__webpack_require__(322);Color.IntegerToColor=__webpack_require__(345);Color.IntegerToRGB=__webpack_require__(344);Color.Interpolate=__webpack_require__(857);Color.ObjectToColor=__webpack_require__(343);Color.RandomRGB=__webpack_require__(856);Color.RGBStringToColor=__webpack_require__(342);Color.RGBToHSV=__webpack_require__(855);Color.RGBToString=__webpack_require__(854);Color.ValueToColor=__webpack_require__(163);module.exports=Color;/***/},/* 325 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Display.Canvas.CanvasInterpolation\r\n * @since 3.0.0\r\n */var CanvasInterpolation={/**\r\n     * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasInterpolation.setCrisp\r\n     * @since 3.0.0\r\n     * \r\n     * @param {HTMLCanvasElement} canvas - The canvas object to have the style set on.\r\n     * \r\n     * @return {HTMLCanvasElement} The canvas.\r\n     */setCrisp:function setCrisp(canvas){var types=['optimizeSpeed','crisp-edges','-moz-crisp-edges','-webkit-optimize-contrast','optimize-contrast','pixelated'];types.forEach(function(type){canvas.style['image-rendering']=type;});canvas.style.msInterpolationMode='nearest-neighbor';return canvas;},/**\r\n     * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasInterpolation.setBicubic\r\n     * @since 3.0.0\r\n     * \r\n     * @param {HTMLCanvasElement} canvas - The canvas object to have the style set on.\r\n     * \r\n     * @return {HTMLCanvasElement} The canvas.\r\n     */setBicubic:function setBicubic(canvas){canvas.style['image-rendering']='auto';canvas.style.msInterpolationMode='bicubic';return canvas;}};module.exports=CanvasInterpolation;/***/},/* 326 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar CatmullRom=__webpack_require__(155);var Class=__webpack_require__(0);var Curve=__webpack_require__(58);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class SplineCurve\r\n * @extends Phaser.Curves.Curve\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector2[]} [points] - [description]\r\n */var SplineCurve=new Class({Extends:Curve,initialize:function SplineCurve(points){if(points===undefined){points=[];}Curve.call(this,'SplineCurve');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.SplineCurve#points\r\n         * @type {Phaser.Math.Vector2[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.points=[];this.addPoints(points);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.SplineCurve#addPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2[]|number[]|number[][])} points - [description]\r\n     *\r\n     * @return {Phaser.Curves.SplineCurve} This curve object.\r\n     */addPoints:function addPoints(points){for(var i=0;i<points.length;i++){var p=new Vector2();if(typeof points[i]==='number'){p.x=points[i];p.y=points[i+1];i++;}else if(Array.isArray(points[i])){//  An array of arrays?\np.x=points[i][0];p.y=points[i][1];}else{p.x=points[i].x;p.y=points[i].y;}this.points.push(p);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.SplineCurve#addPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */addPoint:function addPoint(x,y){var vec=new Vector2(x,y);this.points.push(vec);return vec;},/**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.SplineCurve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getStartPoint:function getStartPoint(out){if(out===undefined){out=new Vector2();}return out.copy(this.points[0]);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.SplineCurve#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} divisions - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */getResolution:function getResolution(divisions){return divisions*this.points.length;},/**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.SplineCurve#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getPoint:function getPoint(t,out){if(out===undefined){out=new Vector2();}var points=this.points;var point=(points.length-1)*t;var intPoint=Math.floor(point);var weight=point-intPoint;var p0=points[intPoint===0?intPoint:intPoint-1];var p1=points[intPoint];var p2=points[intPoint>points.length-2?points.length-1:intPoint+1];var p3=points[intPoint>points.length-3?points.length-1:intPoint+2];return out.set(CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),CatmullRom(weight,p0.y,p1.y,p2.y,p3.y));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.SplineCurve#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONCurve} The JSON object containing this curve data.\r\n     */toJSON:function toJSON(){var points=[];for(var i=0;i<this.points.length;i++){points.push(this.points[i].x);points.push(this.points[i].y);}return{type:this.type,points:points};}});/**\r\n * [description]\r\n *\r\n * @function Phaser.Curves.SplineCurve.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.SplineCurve} [description]\r\n */SplineCurve.fromJSON=function(data){return new SplineCurve(data.points);};module.exports=SplineCurve;/***/},/* 327 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */function P0(t,p){var k=1-t;return k*k*p;}function P1(t,p){return 2*(1-t)*t*p;}function P2(t,p){return t*t*p;}//  p0 = start point\n//  p1 = control point 1\n//  p2 = end point\n// https://github.com/mrdoob/three.js/blob/master/src/extras/core/Interpolations.js\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Interpolation.QuadraticBezier\r\n * @since 3.2.0\r\n *\r\n * @param {float} t - [description]\r\n * @param {number} p0 - [description]\r\n * @param {number} p1 - [description]\r\n * @param {number} p2 - [description]\r\n *\r\n * @return {number} [description]\r\n */var QuadraticBezierInterpolation=function QuadraticBezierInterpolation(t,p0,p1,p2){return P0(t,p0)+P1(t,p1)+P2(t,p2);};module.exports=QuadraticBezierInterpolation;/***/},/* 328 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Curve=__webpack_require__(58);var QuadraticBezierInterpolation=__webpack_require__(327);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class QuadraticBezier\r\n * @extends Phaser.Curves.Curve\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @param {(Phaser.Math.Vector2|number[])} p0 - Start point, or an array of point pairs.\r\n * @param {Phaser.Math.Vector2} p1 - Control Point 1.\r\n * @param {Phaser.Math.Vector2} p2 - Control Point 2.\r\n */var QuadraticBezier=new Class({Extends:Curve,initialize:function QuadraticBezier(p0,p1,p2){Curve.call(this,'QuadraticBezier');if(Array.isArray(p0)){p2=new Vector2(p0[4],p0[5]);p1=new Vector2(p0[2],p0[3]);p0=new Vector2(p0[0],p0[1]);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.QuadraticBezier#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.2.0\r\n         */this.p0=p0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.QuadraticBezier#p1\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.2.0\r\n         */this.p1=p1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.QuadraticBezier#p2\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.2.0\r\n         */this.p2=p2;},/**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#getStartPoint\r\n     * @since 3.2.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getStartPoint:function getStartPoint(out){if(out===undefined){out=new Vector2();}return out.copy(this.p0);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#getResolution\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} divisions - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */getResolution:function getResolution(divisions){return divisions;},/**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#getPoint\r\n     * @since 3.2.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getPoint:function getPoint(t,out){if(out===undefined){out=new Vector2();}var p0=this.p0;var p1=this.p1;var p2=this.p2;return out.set(QuadraticBezierInterpolation(t,p0.x,p1.x,p2.x),QuadraticBezierInterpolation(t,p0.y,p1.y,p2.y));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#draw\r\n     * @since 3.2.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - [description]\r\n     * @param {integer} [pointsTotal=32] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} [description]\r\n     */draw:function draw(graphics,pointsTotal){if(pointsTotal===undefined){pointsTotal=32;}var points=this.getPoints(pointsTotal);graphics.beginPath();graphics.moveTo(this.p0.x,this.p0.y);for(var i=1;i<points.length;i++){graphics.lineTo(points[i].x,points[i].y);}graphics.strokePath();//  So you can chain graphics calls\nreturn graphics;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#toJSON\r\n     * @since 3.2.0\r\n     *\r\n     * @return {JSONCurve} The JSON object containing this curve data.\r\n     */toJSON:function toJSON(){return{type:this.type,points:[this.p0.x,this.p0.y,this.p1.x,this.p1.y,this.p2.x,this.p2.y]};}});/**\r\n * [description]\r\n *\r\n * @function Phaser.Curves.QuadraticBezier.fromJSON\r\n * @since 3.2.0\r\n *\r\n * @param {JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.QuadraticBezier} [description]\r\n */QuadraticBezier.fromJSON=function(data){var points=data.points;var p0=new Vector2(points[0],points[1]);var p1=new Vector2(points[2],points[3]);var p2=new Vector2(points[4],points[5]);return new QuadraticBezier(p0,p1,p2);};module.exports=QuadraticBezier;/***/},/* 329 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar Class=__webpack_require__(0);var Curve=__webpack_require__(58);var FromPoints=__webpack_require__(157);var Rectangle=__webpack_require__(10);var Vector2=__webpack_require__(6);var tmpVec2=new Vector2();/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class LineCurve\r\n * @extends Phaser.Curves.Curve\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Math.Vector2|number[])} p0 - [description]\r\n * @param {Phaser.Math.Vector2} [p1] - [description]\r\n */var LineCurve=new Class({Extends:Curve,initialize://  vec2s or array\nfunction LineCurve(p0,p1){Curve.call(this,'LineCurve');if(Array.isArray(p0)){p1=new Vector2(p0[2],p0[3]);p0=new Vector2(p0[0],p0[1]);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.LineCurve#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.p0=p0;/**\r\n         * [description]\r\n         *\r\n         * @property Phaser.Curves.LineCurve#p1\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.p1=p1;},/**\r\n     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n     *\r\n     * @method Phaser.Curves.LineCurve#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - A Rectangle object to store the bounds in. If not given a new Rectangle will be created.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n     */getBounds:function getBounds(out){if(out===undefined){out=new Rectangle();}return FromPoints([this.p0,this.p1],out);},/**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.LineCurve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getStartPoint:function getStartPoint(out){if(out===undefined){out=new Vector2();}return out.copy(this.p0);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.LineCurve#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [divisions=1] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */getResolution:function getResolution(divisions){if(divisions===undefined){divisions=1;}return divisions;},/**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.LineCurve#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getPoint:function getPoint(t,out){if(out===undefined){out=new Vector2();}if(t===1){return out.copy(this.p1);}out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);return out;},// Line curve is linear, so we can overwrite default getPointAt\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.LineCurve#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} u - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getPointAt:function getPointAt(u,out){return this.getPoint(u,out);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.LineCurve#getTangent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getTangent:function getTangent(){var tangent=tmpVec2.copy(this.p1).subtract(this.p0);return tangent.normalize();},//  Override default Curve.draw because this is better than calling getPoints on a line!\n/**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.lineBetween` so will be drawn at whatever the present Graphics line color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.LineCurve#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n     */draw:function draw(graphics){graphics.lineBetween(this.p0.x,this.p0.y,this.p1.x,this.p1.y);//  So you can chain graphics calls\nreturn graphics;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.LineCurve#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONCurve} The JSON object containing this curve data.\r\n     */toJSON:function toJSON(){return{type:this.type,points:[this.p0.x,this.p0.y,this.p1.x,this.p1.y]};}});/**\r\n * [description]\r\n *\r\n * @function Phaser.Curves.LineCurve.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.LineCurve} [description]\r\n */LineCurve.fromJSON=function(data){var points=data.points;var p0=new Vector2(points[0],points[1]);var p1=new Vector2(points[2],points[3]);return new LineCurve(p0,p1);};module.exports=LineCurve;/***/},/* 330 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar Class=__webpack_require__(0);var Curve=__webpack_require__(58);var DegToRad=__webpack_require__(43);var GetValue=__webpack_require__(5);var RadToDeg=__webpack_require__(156);var Vector2=__webpack_require__(6);/**\r\n * @typedef {object} JSONEllipseCurve\r\n *\r\n * @property {string} type - The of the curve.\r\n * @property {number} x - [description]\r\n * @property {number} y - [description]\r\n * @property {number} xRadius - The horizontal radius of ellipse.\r\n * @property {number} yRadius - The vertical radius of ellipse.\r\n * @property {integer} startAngle - The start angle of ellipse.\r\n * @property {integer} endAngle - The end angle of ellipse.\r\n * @property {boolean} clockwise - The clockwise of ellipse.\r\n * @property {integer} rotation - The rotation of ellipse.\r\n *//**\r\n * @typedef {object} EllipseCurveConfig\r\n *\r\n * @property {number} [x=0] - [description]\r\n * @property {number} [y=0] - [description]\r\n * @property {number} [xRadius=0] - [description]\r\n * @property {number} [yRadius=0] - [description]\r\n * @property {integer} [startAngle=0] - [description]\r\n * @property {integer} [endAngle=360] - [description]\r\n * @property {boolean} [clockwise=false] - [description]\r\n * @property {integer} [rotation=0] - [description]\r\n  *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class EllipseCurve\r\n * @extends Phaser.Curves.Curve\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(number|EllipseCurveConfig)} [x=0] - [description]\r\n * @param {number} [y=0] - [description]\r\n * @param {number} [xRadius=0] - [description]\r\n * @param {number} [yRadius=0] - [description]\r\n * @param {integer} [startAngle=0] - [description]\r\n * @param {integer} [endAngle=360] - [description]\r\n * @param {boolean} [clockwise=false] - [description]\r\n * @param {integer} [rotation=0] - [description]\r\n */var EllipseCurve=new Class({Extends:Curve,initialize:function EllipseCurve(x,y,xRadius,yRadius,startAngle,endAngle,clockwise,rotation){if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){var config=x;x=GetValue(config,'x',0);y=GetValue(config,'y',0);xRadius=GetValue(config,'xRadius',0);yRadius=GetValue(config,'yRadius',xRadius);startAngle=GetValue(config,'startAngle',0);endAngle=GetValue(config,'endAngle',360);clockwise=GetValue(config,'clockwise',false);rotation=GetValue(config,'rotation',0);}else{if(yRadius===undefined){yRadius=xRadius;}if(startAngle===undefined){startAngle=0;}if(endAngle===undefined){endAngle=360;}if(clockwise===undefined){clockwise=false;}if(rotation===undefined){rotation=0;}}Curve.call(this,'EllipseCurve');//  Center point\n/**\r\n         * [description]\r\n         *\r\n         * @name {Phaser.Curves.EllipseCurve#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.p0=new Vector2(x,y);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.EllipseCurve#_xRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._xRadius=xRadius;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.EllipseCurve#_yRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._yRadius=yRadius;//  Radians\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.EllipseCurve#_startAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._startAngle=DegToRad(startAngle);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.EllipseCurve#_endAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._endAngle=DegToRad(endAngle);/**\r\n         * Anti-clockwise direction.\r\n         *\r\n         * @name Phaser.Curves.EllipseCurve#_clockwise\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._clockwise=clockwise;/**\r\n         * The rotation of the arc.\r\n         *\r\n         * @name Phaser.Curves.EllipseCurve#_rotation\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._rotation=DegToRad(rotation);},/**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getStartPoint:function getStartPoint(out){if(out===undefined){out=new Vector2();}return this.getPoint(0,out);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} divisions - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */getResolution:function getResolution(divisions){return divisions*2;},/**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getPoint:function getPoint(t,out){if(out===undefined){out=new Vector2();}var twoPi=Math.PI*2;var deltaAngle=this._endAngle-this._startAngle;var samePoints=Math.abs(deltaAngle)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI\nwhile(deltaAngle<0){deltaAngle+=twoPi;}while(deltaAngle>twoPi){deltaAngle-=twoPi;}if(deltaAngle<Number.EPSILON){if(samePoints){deltaAngle=0;}else{deltaAngle=twoPi;}}if(this._clockwise&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else{deltaAngle=deltaAngle-twoPi;}}var angle=this._startAngle+t*deltaAngle;var x=this.p0.x+this._xRadius*Math.cos(angle);var y=this.p0.y+this._yRadius*Math.sin(angle);if(this._rotation!==0){var cos=Math.cos(this._rotation);var sin=Math.sin(this._rotation);var tx=x-this.p0.x;var ty=y-this.p0.y;// Rotate the point about the center of the ellipse.\nx=tx*cos-ty*sin+this.p0.x;y=tx*sin+ty*cos+this.p0.y;}return out.set(x,y);},/**\r\n     * Sets the horizontal radius of this curve.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#setXRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The horizontal radius of this curve.\r\n     *\r\n     * @return {Phaser.Curves.EllipseCurve} This curve object.\r\n     */setXRadius:function setXRadius(value){this.xRadius=value;return this;},/**\r\n     * Sets the vertical radius of this curve.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#setYRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The vertical radius of this curve.\r\n     *\r\n     * @return {Phaser.Curves.EllipseCurve} This curve object.\r\n     */setYRadius:function setYRadius(value){this.yRadius=value;return this;},/**\r\n     * Sets the width of this curve.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#setWidth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The width of this curve.\r\n     *\r\n     * @return {Phaser.Curves.EllipseCurve} This curve object.\r\n     */setWidth:function setWidth(value){this.xRadius=value*2;return this;},/**\r\n     * Sets the height of this curve.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#setHeight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The height of this curve.\r\n     *\r\n     * @return {Phaser.Curves.EllipseCurve} This curve object.\r\n     */setHeight:function setHeight(value){this.yRadius=value*2;return this;},/**\r\n     * Sets the start angle of this curve.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#setStartAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The start angle of this curve, in radians.\r\n     *\r\n     * @return {Phaser.Curves.EllipseCurve} This curve object.\r\n     */setStartAngle:function setStartAngle(value){this.startAngle=value;return this;},/**\r\n     * Sets the end angle of this curve.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#setEndAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The end angle of this curve, in radians.\r\n     *\r\n     * @return {Phaser.Curves.EllipseCurve} This curve object.\r\n     */setEndAngle:function setEndAngle(value){this.endAngle=value;return this;},/**\r\n     * Sets if this curve extends clockwise or anti-clockwise.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#setClockwise\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The clockwise state of this curve.\r\n     *\r\n     * @return {Phaser.Curves.EllipseCurve} This curve object.\r\n     */setClockwise:function setClockwise(value){this.clockwise=value;return this;},/**\r\n     * Sets the rotation of this curve.\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The rotation of this curve, in radians.\r\n     *\r\n     * @return {Phaser.Curves.EllipseCurve} This curve object.\r\n     */setRotation:function setRotation(value){this.rotation=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.EllipseCurve#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */x:{get:function get(){return this.p0.x;},set:function set(value){this.p0.x=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.EllipseCurve#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */y:{get:function get(){return this.p0.y;},set:function set(value){this.p0.y=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.EllipseCurve#xRadius\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */xRadius:{get:function get(){return this._xRadius;},set:function set(value){this._xRadius=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.EllipseCurve#yRadius\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */yRadius:{get:function get(){return this._yRadius;},set:function set(value){this._yRadius=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.EllipseCurve#startAngle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */startAngle:{get:function get(){return RadToDeg(this._startAngle);},set:function set(value){this._startAngle=DegToRad(value);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.EllipseCurve#endAngle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */endAngle:{get:function get(){return RadToDeg(this._endAngle);},set:function set(value){this._endAngle=DegToRad(value);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.EllipseCurve#clockwise\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */clockwise:{get:function get(){return this._clockwise;},set:function set(value){this._clockwise=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Curves.EllipseCurve#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */rotation:{get:function get(){return this._rotation;},set:function set(value){this._rotation=DegToRad(value);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.EllipseCurve#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONEllipseCurve} The JSON object containing this curve data.\r\n     */toJSON:function toJSON(){return{type:this.type,x:this.p0.x,y:this.p0.y,xRadius:this._xRadius,yRadius:this._yRadius,startAngle:RadToDeg(this._startAngle),endAngle:RadToDeg(this._endAngle),clockwise:this._clockwise,rotation:RadToDeg(this._rotation)};}});/**\r\n * [description]\r\n *\r\n * @function Phaser.Curves.EllipseCurve.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {JSONEllipseCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.EllipseCurve} [description]\r\n */EllipseCurve.fromJSON=function(data){return new EllipseCurve(data);};module.exports=EllipseCurve;/***/},/* 331 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */function P0(t,p){var k=1-t;return k*k*k*p;}function P1(t,p){var k=1-t;return 3*k*k*t*p;}function P2(t,p){return 3*(1-t)*t*t*p;}function P3(t,p){return t*t*t*p;}//  p0 = start point\n//  p1 = control point 1\n//  p2 = control point 2\n//  p3 = end point\n// https://medium.com/@adrian_cooney/bezier-interpolation-13b68563313a\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Interpolation.CubicBezier\r\n * @since 3.0.0\r\n *\r\n * @param {float} t - [description]\r\n * @param {number} p0 - [description]\r\n * @param {number} p1 - [description]\r\n * @param {number} p2 - [description]\r\n * @param {number} p3 - [description]\r\n *\r\n * @return {number} [description]\r\n */var CubicBezierInterpolation=function CubicBezierInterpolation(t,p0,p1,p2,p3){return P0(t,p0)+P1(t,p1)+P2(t,p2)+P3(t,p3);};module.exports=CubicBezierInterpolation;/***/},/* 332 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar Class=__webpack_require__(0);var CubicBezier=__webpack_require__(331);var Curve=__webpack_require__(58);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CubicBezierCurve\r\n * @extends Phaser.Curves.Curve\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Math.Vector2|Phaser.Math.Vector2[])} p0 - Start point, or an array of point pairs.\r\n * @param {Phaser.Math.Vector2} p1 - Control Point 1.\r\n * @param {Phaser.Math.Vector2} p2 - Control Point 2.\r\n * @param {Phaser.Math.Vector2} p3 - End Point.\r\n */var CubicBezierCurve=new Class({Extends:Curve,initialize:function CubicBezierCurve(p0,p1,p2,p3){Curve.call(this,'CubicBezierCurve');if(Array.isArray(p0)){p3=new Vector2(p0[6],p0[7]);p2=new Vector2(p0[4],p0[5]);p1=new Vector2(p0[2],p0[3]);p0=new Vector2(p0[0],p0[1]);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.CubicBezierCurve#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.p0=p0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.CubicBezierCurve#p1\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.p1=p1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.CubicBezierCurve#p2\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.p2=p2;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.CubicBezierCurve#p3\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.p3=p3;},/**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.CubicBezierCurve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getStartPoint:function getStartPoint(out){if(out===undefined){out=new Vector2();}return out.copy(this.p0);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.CubicBezierCurve#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} divisions - The amount of divisions used by this curve.\r\n     *\r\n     * @return {number} The resolution of the curve.\r\n     */getResolution:function getResolution(divisions){return divisions;},/**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.CubicBezierCurve#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getPoint:function getPoint(t,out){if(out===undefined){out=new Vector2();}var p0=this.p0;var p1=this.p1;var p2=this.p2;var p3=this.p3;return out.set(CubicBezier(t,p0.x,p1.x,p2.x,p3.x),CubicBezier(t,p0.y,p1.y,p2.y,p3.y));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.CubicBezierCurve#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [out,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - [description]\r\n     * @param {integer} [pointsTotal=32] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} [description]\r\n     */draw:function draw(graphics,pointsTotal){if(pointsTotal===undefined){pointsTotal=32;}var points=this.getPoints(pointsTotal);graphics.beginPath();graphics.moveTo(this.p0.x,this.p0.y);for(var i=1;i<points.length;i++){graphics.lineTo(points[i].x,points[i].y);}graphics.strokePath();//  So you can chain graphics calls\nreturn graphics;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.CubicBezierCurve#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONCurve} The JSON object containing this curve data.\r\n     */toJSON:function toJSON(){return{type:this.type,points:[this.p0.x,this.p0.y,this.p1.x,this.p1.y,this.p2.x,this.p2.y,this.p3.x,this.p3.y]};}});/**\r\n * [description]\r\n *\r\n * @function Phaser.Curves.CubicBezierCurve.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.CubicBezierCurve} [description]\r\n */CubicBezierCurve.fromJSON=function(data){var points=data.points;var p0=new Vector2(points[0],points[1]);var p1=new Vector2(points[2],points[3]);var p2=new Vector2(points[4],points[5]);var p3=new Vector2(points[6],points[7]);return new CubicBezierCurve(p0,p1,p2,p3);};module.exports=CubicBezierCurve;/***/},/* 333 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)\r\n *\r\n * @name Phaser.Create.Palettes.ARNE16\r\n * @since 3.0.0\r\n *\r\n * @type {Palette}\r\n */module.exports={0:'#000',1:'#9D9D9D',2:'#FFF',3:'#BE2633',4:'#E06F8B',5:'#493C2B',6:'#A46422',7:'#EB8931',8:'#F7E26B',9:'#2F484E',A:'#44891A',B:'#A3CE27',C:'#1B2632',D:'#005784',E:'#31A2F2',F:'#B2DCEF'};/***/},/* 334 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Arne16=__webpack_require__(333);var CanvasPool=__webpack_require__(23);var GetValue=__webpack_require__(5);/**\r\n * @callback GenerateTextureRendererCallback\r\n *\r\n * @param {HTMLCanvasElement} canvas - [description]\r\n * @param {CanvasRenderingContext2D} context - [description]\r\n *//**\r\n * @typedef {object} GenerateTextureConfig\r\n *\r\n * @property {array} [data=[]] - [description]\r\n * @property {HTMLCanvasElement} [canvas=null] - [description]\r\n * @property {Palette} [palette=Arne16] - [description]\r\n * @property {number} [pixelWidth=1] - [description]\r\n * @property {number} [pixelHeight=1] - [description]\r\n * @property {boolean} [resizeCanvas=true] - [description]\r\n * @property {boolean} [clearCanvas=true] - [description]\r\n * @property {GenerateTextureRendererCallback} [preRender] - [description]\r\n * @property {GenerateTextureRendererCallback} [postRender] - [description]\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Create.GenerateTexture\r\n * @since 3.0.0\r\n *\r\n * @param {GenerateTextureConfig} config - [description]\r\n *\r\n * @return {HTMLCanvasElement} [description]\r\n */var GenerateTexture=function GenerateTexture(config){var data=GetValue(config,'data',[]);var canvas=GetValue(config,'canvas',null);var palette=GetValue(config,'palette',Arne16);var pixelWidth=GetValue(config,'pixelWidth',1);var pixelHeight=GetValue(config,'pixelHeight',pixelWidth);var resizeCanvas=GetValue(config,'resizeCanvas',true);var clearCanvas=GetValue(config,'clearCanvas',true);var preRender=GetValue(config,'preRender',null);var postRender=GetValue(config,'postRender',null);var width=Math.floor(Math.abs(data[0].length*pixelWidth));var height=Math.floor(Math.abs(data.length*pixelHeight));if(!canvas){canvas=CanvasPool.create2D(this,width,height);resizeCanvas=false;clearCanvas=false;}if(resizeCanvas){canvas.width=width;canvas.height=height;}var ctx=canvas.getContext('2d');if(clearCanvas){ctx.clearRect(0,0,width,height);}//  preRender Callback?\nif(preRender){preRender(canvas,ctx);}//  Draw it\nfor(var y=0;y<data.length;y++){var row=data[y];for(var x=0;x<row.length;x++){var d=row[x];if(d!=='.'&&d!==' '){ctx.fillStyle=palette[d];ctx.fillRect(x*pixelWidth,y*pixelHeight,pixelWidth,pixelHeight);}}}//  postRender Callback?\nif(postRender){postRender(canvas,ctx);}return canvas;};module.exports=GenerateTexture;/***/},/* 335 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Camera=__webpack_require__(161);var Class=__webpack_require__(0);var Vector3=__webpack_require__(59);//  Local cache vars\nvar tmpVec3=new Vector3();/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class PerspectiveCamera\r\n * @extends Phaser.Cameras.Sprite3D.Camera\r\n * @memberOf Phaser.Cameras.Sprite3D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {integer} [fieldOfView=80] - [description]\r\n * @param {integer} [viewportWidth=0] - [description]\r\n * @param {integer} [viewportHeight=0] - [description]\r\n */var PerspectiveCamera=new Class({Extends:Camera,//  FOV is converted to radians automatically\ninitialize:function PerspectiveCamera(scene,fieldOfView,viewportWidth,viewportHeight){if(fieldOfView===undefined){fieldOfView=80;}if(viewportWidth===undefined){viewportWidth=0;}if(viewportHeight===undefined){viewportHeight=0;}Camera.call(this,scene);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#viewportWidth\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.viewportWidth=viewportWidth;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#viewportHeight\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.viewportHeight=viewportHeight;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#fieldOfView\r\n         * @type {integer}\r\n         * @default 80\r\n         * @since 3.0.0\r\n         */this.fieldOfView=fieldOfView*Math.PI/180;this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.PerspectiveCamera#setFOV\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]\r\n     */setFOV:function setFOV(value){this.fieldOfView=value*Math.PI/180;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.PerspectiveCamera#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]\r\n     */update:function update(){var aspect=this.viewportWidth/this.viewportHeight;//  Create a perspective matrix for our camera\nthis.projection.perspective(this.fieldOfView,aspect,Math.abs(this.near),Math.abs(this.far));//  Build the view matrix\ntmpVec3.copy(this.position).add(this.direction);this.view.lookAt(this.position,tmpVec3,this.up);//  Projection * view matrix\nthis.combined.copy(this.projection).multiply(this.view);//  Invert combined matrix, used for unproject\nthis.invProjectionView.copy(this.combined).invert();this.billboardMatrixDirty=true;this.updateChildren();return this;}});module.exports=PerspectiveCamera;/***/},/* 336 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Camera=__webpack_require__(161);var Class=__webpack_require__(0);var Vector3=__webpack_require__(59);//  Local cache vars\nvar tmpVec3=new Vector3();/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class OrthographicCamera\r\n * @extends Phaser.Cameras.Sprite3D.Camera\r\n * @memberOf Phaser.Cameras.Sprite3D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {integer} [viewportWidth=0] - [description]\r\n * @param {integer} [viewportHeight=0] - [description]\r\n */var OrthographicCamera=new Class({Extends:Camera,initialize:function OrthographicCamera(scene,viewportWidth,viewportHeight){if(viewportWidth===undefined){viewportWidth=0;}if(viewportHeight===undefined){viewportHeight=0;}Camera.call(this,scene);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#viewportWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.viewportWidth=viewportWidth;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#viewportHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.viewportHeight=viewportHeight;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#_zoom\r\n         * @type {float}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._zoom=1.0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#near\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.near=0;this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.OrthographicCamera#setToOrtho\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} yDown - [description]\r\n     * @param {number} [viewportWidth] - [description]\r\n     * @param {number} [viewportHeight] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]\r\n     */setToOrtho:function setToOrtho(yDown,viewportWidth,viewportHeight){if(viewportWidth===undefined){viewportWidth=this.viewportWidth;}if(viewportHeight===undefined){viewportHeight=this.viewportHeight;}var zoom=this.zoom;this.up.set(0,yDown?-1:1,0);this.direction.set(0,0,yDown?1:-1);this.position.set(zoom*viewportWidth/2,zoom*viewportHeight/2,0);this.viewportWidth=viewportWidth;this.viewportHeight=viewportHeight;return this.update();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.OrthographicCamera#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]\r\n     */update:function update(){var w=this.viewportWidth;var h=this.viewportHeight;var near=Math.abs(this.near);var far=Math.abs(this.far);var zoom=this.zoom;if(w===0||h===0){//  What to do here... hmm?\nreturn this;}this.projection.ortho(zoom*-w/2,zoom*w/2,zoom*-h/2,zoom*h/2,near,far);//  Build the view matrix\ntmpVec3.copy(this.position).add(this.direction);this.view.lookAt(this.position,tmpVec3,this.up);//  Projection * view matrix\nthis.combined.copy(this.projection).multiply(this.view);//  Invert combined matrix, used for unproject\nthis.invProjectionView.copy(this.combined).invert();this.billboardMatrixDirty=true;this.updateChildren();return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Cameras.Sprite3D.OrthographicCamera#zoom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */zoom:{get:function get(){return this._zoom;},set:function set(value){this._zoom=value;this.update();}}});module.exports=OrthographicCamera;/***/},/* 337 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Matrix3\r\n * @memberOf Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Matrix3} [m] - [description]\r\n */var Matrix3=new Class({initialize:function Matrix3(m){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Math.Matrix3#val\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.val=new Float32Array(9);if(m){//  Assume Matrix3 with val:\nthis.copy(m);}else{//  Default to identity\nthis.identity();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} A new Matrix3 object.\r\n     */clone:function clone(){return new Matrix3(this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */set:function set(src){return this.copy(src);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */copy:function copy(src){var out=this.val;var a=src.val;out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} m - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */fromMat4:function fromMat4(m){var a=m.val;var out=this.val;out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[4];out[4]=a[5];out[5]=a[6];out[6]=a[8];out[7]=a[9];out[8]=a[10];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} a - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */fromArray:function fromArray(a){var out=this.val;out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */identity:function identity(){var out=this.val;out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=1;out[5]=0;out[6]=0;out[7]=0;out[8]=1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#transpose\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */transpose:function transpose(){var a=this.val;var a01=a[1];var a02=a[2];var a12=a[5];a[1]=a[3];a[2]=a[6];a[3]=a01;a[5]=a[7];a[6]=a02;a[7]=a12;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */invert:function invert(){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a10=a[3];var a11=a[4];var a12=a[5];var a20=a[6];var a21=a[7];var a22=a[8];var b01=a22*a11-a12*a21;var b11=-a22*a10+a12*a20;var b21=a21*a10-a11*a20;// Calculate the determinant\nvar det=a00*b01+a01*b11+a02*b21;if(!det){return null;}det=1/det;a[0]=b01*det;a[1]=(-a22*a01+a02*a21)*det;a[2]=(a12*a01-a02*a11)*det;a[3]=b11*det;a[4]=(a22*a00-a02*a20)*det;a[5]=(-a12*a00+a02*a10)*det;a[6]=b21*det;a[7]=(-a21*a00+a01*a20)*det;a[8]=(a11*a00-a01*a10)*det;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#adjoint\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */adjoint:function adjoint(){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a10=a[3];var a11=a[4];var a12=a[5];var a20=a[6];var a21=a[7];var a22=a[8];a[0]=a11*a22-a12*a21;a[1]=a02*a21-a01*a22;a[2]=a01*a12-a02*a11;a[3]=a12*a20-a10*a22;a[4]=a00*a22-a02*a20;a[5]=a02*a10-a00*a12;a[6]=a10*a21-a11*a20;a[7]=a01*a20-a00*a21;a[8]=a00*a11-a01*a10;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#determinant\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */determinant:function determinant(){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a10=a[3];var a11=a[4];var a12=a[5];var a20=a[6];var a21=a[7];var a22=a[8];return a00*(a22*a11-a12*a21)+a01*(-a22*a10+a12*a20)+a02*(a21*a10-a11*a20);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */multiply:function multiply(src){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a10=a[3];var a11=a[4];var a12=a[5];var a20=a[6];var a21=a[7];var a22=a[8];var b=src.val;var b00=b[0];var b01=b[1];var b02=b[2];var b10=b[3];var b11=b[4];var b12=b[5];var b20=b[6];var b21=b[7];var b22=b[8];a[0]=b00*a00+b01*a10+b02*a20;a[1]=b00*a01+b01*a11+b02*a21;a[2]=b00*a02+b01*a12+b02*a22;a[3]=b10*a00+b11*a10+b12*a20;a[4]=b10*a01+b11*a11+b12*a21;a[5]=b10*a02+b11*a12+b12*a22;a[6]=b20*a00+b21*a10+b22*a20;a[7]=b20*a01+b21*a11+b22*a21;a[8]=b20*a02+b21*a12+b22*a22;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */translate:function translate(v){var a=this.val;var x=v.x;var y=v.y;a[6]=x*a[0]+y*a[3]+a[6];a[7]=x*a[1]+y*a[4]+a[7];a[8]=x*a[2]+y*a[5]+a[8];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */rotate:function rotate(rad){var a=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a10=a[3];var a11=a[4];var a12=a[5];var s=Math.sin(rad);var c=Math.cos(rad);a[0]=c*a00+s*a10;a[1]=c*a01+s*a11;a[2]=c*a02+s*a12;a[3]=c*a10-s*a00;a[4]=c*a11-s*a01;a[5]=c*a12-s*a02;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */scale:function scale(v){var a=this.val;var x=v.x;var y=v.y;a[0]=x*a[0];a[1]=x*a[1];a[2]=x*a[2];a[3]=y*a[3];a[4]=y*a[4];a[5]=y*a[5];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */fromQuat:function fromQuat(q){var x=q.x;var y=q.y;var z=q.z;var w=q.w;var x2=x+x;var y2=y+y;var z2=z+z;var xx=x*x2;var xy=x*y2;var xz=x*z2;var yy=y*y2;var yz=y*z2;var zz=z*z2;var wx=w*x2;var wy=w*y2;var wz=w*z2;var out=this.val;out[0]=1-(yy+zz);out[3]=xy+wz;out[6]=xz-wy;out[1]=xy-wz;out[4]=1-(xx+zz);out[7]=yz+wx;out[2]=xz+wy;out[5]=yz-wx;out[8]=1-(xx+yy);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#normalFromMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} m - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3 object.\r\n     */normalFromMat4:function normalFromMat4(m){var a=m.val;var out=this.val;var a00=a[0];var a01=a[1];var a02=a[2];var a03=a[3];var a10=a[4];var a11=a[5];var a12=a[6];var a13=a[7];var a20=a[8];var a21=a[9];var a22=a[10];var a23=a[11];var a30=a[12];var a31=a[13];var a32=a[14];var a33=a[15];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;// Calculate the determinant\nvar det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;if(!det){return null;}det=1/det;out[0]=(a11*b11-a12*b10+a13*b09)*det;out[1]=(a12*b08-a10*b11-a13*b07)*det;out[2]=(a10*b10-a11*b08+a13*b06)*det;out[3]=(a02*b10-a01*b11-a03*b09)*det;out[4]=(a00*b11-a02*b08+a03*b07)*det;out[5]=(a01*b08-a00*b10-a03*b06)*det;out[6]=(a31*b05-a32*b04+a33*b03)*det;out[7]=(a32*b02-a30*b05-a33*b01)*det;out[8]=(a30*b04-a31*b02+a33*b00)*det;return this;}});module.exports=Matrix3;/***/},/* 338 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class=__webpack_require__(0);var Vector3=__webpack_require__(59);var Matrix3=__webpack_require__(337);var EPSILON=0.000001;//  Some shared 'private' arrays\nvar siNext=new Int8Array([1,2,0]);var tmp=new Float32Array([0,0,0]);var xUnitVec3=new Vector3(1,0,0);var yUnitVec3=new Vector3(0,1,0);var tmpvec=new Vector3();var tmpMat3=new Matrix3();/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Quaternion\r\n * @memberOf Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - [description]\r\n * @param {number} [y] - [description]\r\n * @param {number} [z] - [description]\r\n * @param {number} [w] - [description]\r\n */var Quaternion=new Class({initialize:function Quaternion(x,y,z,w){/**\r\n         * The x component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         *//**\r\n         * The y component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         *//**\r\n         * The z component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         *//**\r\n         * The w component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#w\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.x=x.x||0;this.y=x.y||0;this.z=x.z||0;this.w=x.w||0;}else{this.x=x||0;this.y=y||0;this.z=z||0;this.w=w||0;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */copy:function copy(src){this.x=src.x;this.y=src.y;this.z=src.z;this.w=src.w;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} [x=0] - [description]\r\n     * @param {number} [y=0] - [description]\r\n     * @param {number} [z=0] - [description]\r\n     * @param {number} [w=0] - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */set:function set(x,y,z,w){if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.x=x.x||0;this.y=x.y||0;this.z=x.z||0;this.w=x.w||0;}else{this.x=x||0;this.y=y||0;this.z=z||0;this.w=w||0;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */add:function add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */subtract:function subtract(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */scale:function scale(_scale3){this.x*=_scale3;this.y*=_scale3;this.z*=_scale3;this.w*=_scale3;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */length:function length(){var x=this.x;var y=this.y;var z=this.z;var w=this.w;return Math.sqrt(x*x+y*y+z*z+w*w);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */lengthSq:function lengthSq(){var x=this.x;var y=this.y;var z=this.z;var w=this.w;return x*x+y*y+z*z+w*w;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */normalize:function normalize(){var x=this.x;var y=this.y;var z=this.z;var w=this.w;var len=x*x+y*y+z*z+w*w;if(len>0){len=1/Math.sqrt(len);this.x=x*len;this.y=y*len;this.z=z*len;this.w=w*len;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - [description]\r\n     * @param {number} [t=0] - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */lerp:function lerp(v,t){if(t===undefined){t=0;}var ax=this.x;var ay=this.y;var az=this.z;var aw=this.w;this.x=ax+t*(v.x-ax);this.y=ay+t*(v.y-ay);this.z=az+t*(v.z-az);this.w=aw+t*(v.w-aw);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotationTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} a - [description]\r\n     * @param {Phaser.Math.Vector3} b - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */rotationTo:function rotationTo(a,b){var dot=a.x*b.x+a.y*b.y+a.z*b.z;if(dot<-0.999999){if(tmpvec.copy(xUnitVec3).cross(a).length()<EPSILON){tmpvec.copy(yUnitVec3).cross(a);}tmpvec.normalize();return this.setAxisAngle(tmpvec,Math.PI);}else if(dot>0.999999){this.x=0;this.y=0;this.z=0;this.w=1;return this;}else{tmpvec.copy(a).cross(b);this.x=tmpvec.x;this.y=tmpvec.y;this.z=tmpvec.z;this.w=1+dot;return this.normalize();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#setAxes\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} view - [description]\r\n     * @param {Phaser.Math.Vector3} right - [description]\r\n     * @param {Phaser.Math.Vector3} up - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */setAxes:function setAxes(view,right,up){var m=tmpMat3.val;m[0]=right.x;m[3]=right.y;m[6]=right.z;m[1]=up.x;m[4]=up.y;m[7]=up.z;m[2]=-view.x;m[5]=-view.y;m[8]=-view.z;return this.fromMat3(tmpMat3).normalize();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */identity:function identity(){this.x=0;this.y=0;this.z=0;this.w=1;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#setAxisAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} axis - [description]\r\n     * @param {number} rad - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */setAxisAngle:function setAxisAngle(axis,rad){rad=rad*0.5;var s=Math.sin(rad);this.x=s*axis.x;this.y=s*axis.y;this.z=s*axis.z;this.w=Math.cos(rad);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */multiply:function multiply(b){var ax=this.x;var ay=this.y;var az=this.z;var aw=this.w;var bx=b.x;var by=b.y;var bz=b.z;var bw=b.w;this.x=ax*bw+aw*bx+ay*bz-az*by;this.y=ay*bw+aw*by+az*bx-ax*bz;this.z=az*bw+aw*bz+ax*by-ay*bx;this.w=aw*bw-ax*bx-ay*by-az*bz;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#slerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - [description]\r\n     * @param {number} t - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */slerp:function slerp(b,t){// benchmarks: http://jsperf.com/quaternion-slerp-implementations\nvar ax=this.x;var ay=this.y;var az=this.z;var aw=this.w;var bx=b.x;var by=b.y;var bz=b.z;var bw=b.w;// calc cosine\nvar cosom=ax*bx+ay*by+az*bz+aw*bw;// adjust signs (if necessary)\nif(cosom<0){cosom=-cosom;bx=-bx;by=-by;bz=-bz;bw=-bw;}// \"from\" and \"to\" quaternions are very close\n//  ... so we can do a linear interpolation\nvar scale0=1-t;var scale1=t;// calculate coefficients\nif(1-cosom>EPSILON){// standard case (slerp)\nvar omega=Math.acos(cosom);var sinom=Math.sin(omega);scale0=Math.sin((1.0-t)*omega)/sinom;scale1=Math.sin(t*omega)/sinom;}// calculate final values\nthis.x=scale0*ax+scale1*bx;this.y=scale0*ay+scale1*by;this.z=scale0*az+scale1*bz;this.w=scale0*aw+scale1*bw;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */invert:function invert(){var a0=this.x;var a1=this.y;var a2=this.z;var a3=this.w;var dot=a0*a0+a1*a1+a2*a2+a3*a3;var invDot=dot?1/dot:0;// TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\nthis.x=-a0*invDot;this.y=-a1*invDot;this.z=-a2*invDot;this.w=a3*invDot;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#conjugate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */conjugate:function conjugate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */rotateX:function rotateX(rad){rad*=0.5;var ax=this.x;var ay=this.y;var az=this.z;var aw=this.w;var bx=Math.sin(rad);var bw=Math.cos(rad);this.x=ax*bw+aw*bx;this.y=ay*bw+az*bx;this.z=az*bw-ay*bx;this.w=aw*bw-ax*bx;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */rotateY:function rotateY(rad){rad*=0.5;var ax=this.x;var ay=this.y;var az=this.z;var aw=this.w;var by=Math.sin(rad);var bw=Math.cos(rad);this.x=ax*bw-az*by;this.y=ay*bw+aw*by;this.z=az*bw+ax*by;this.w=aw*bw-ay*by;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */rotateZ:function rotateZ(rad){rad*=0.5;var ax=this.x;var ay=this.y;var az=this.z;var aw=this.w;var bz=Math.sin(rad);var bw=Math.cos(rad);this.x=ax*bw+ay*bz;this.y=ay*bw-ax*bz;this.z=az*bw+aw*bz;this.w=aw*bw-az*bz;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#calculateW\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */calculateW:function calculateW(){var x=this.x;var y=this.y;var z=this.z;this.w=-Math.sqrt(Math.abs(1.0-x*x-y*y-z*z));return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#fromMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion object.\r\n     */fromMat3:function fromMat3(mat){// benchmarks:\n//    http://jsperf.com/typed-array-access-speed\n//    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion\n// Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n// article \"Quaternion Calculus and Fast Animation\".\nvar m=mat.val;var fTrace=m[0]+m[4]+m[8];var fRoot;if(fTrace>0){// |w| > 1/2, may as well choose w > 1/2\nfRoot=Math.sqrt(fTrace+1.0);// 2w\nthis.w=0.5*fRoot;fRoot=0.5/fRoot;// 1/(4w)\nthis.x=(m[7]-m[5])*fRoot;this.y=(m[2]-m[6])*fRoot;this.z=(m[3]-m[1])*fRoot;}else{// |w| <= 1/2\nvar i=0;if(m[4]>m[0]){i=1;}if(m[8]>m[i*3+i]){i=2;}var j=siNext[i];var k=siNext[j];//  This isn't quite as clean without array access\nfRoot=Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k]+1);tmp[i]=0.5*fRoot;fRoot=0.5/fRoot;tmp[j]=(m[j*3+i]+m[i*3+j])*fRoot;tmp[k]=(m[k*3+i]+m[i*3+k])*fRoot;this.x=tmp[0];this.y=tmp[1];this.z=tmp[2];this.w=(m[k*3+j]-m[j*3+k])*fRoot;}return this;}});module.exports=Quaternion;/***/},/* 339 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Vector3=__webpack_require__(59);var Matrix4=__webpack_require__(160);var Quaternion=__webpack_require__(338);var tmpMat4=new Matrix4();var tmpQuat=new Quaternion();var tmpVec3=new Vector3();/**\r\n * Rotates a vector in place by axis angle.\r\n *\r\n * This is the same as transforming a point by an \r\n * axis-angle quaternion, but it has higher precision.\r\n *\r\n * @function Phaser.Math.RotateVec3\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector3} vec - [description]\r\n * @param {Phaser.Math.Vector3} axis - [description]\r\n * @param {float} radians - [description]\r\n *\r\n * @return {Phaser.Math.Vector3} [description]\r\n */var RotateVec3=function RotateVec3(vec,axis,radians){//  Set the quaternion to our axis angle\ntmpQuat.setAxisAngle(axis,radians);//  Create a rotation matrix from the axis angle\ntmpMat4.fromRotationTranslation(tmpQuat,tmpVec3.set(0,0,0));//  Multiply our vector by the rotation matrix\nreturn vec.transformMat4(tmpMat4);};module.exports=RotateVec3;/***/},/* 340 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.RandomXYZW\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector4} vec4 - [description]\r\n * @param {float} [scale=1] - [description]\r\n *\r\n * @return {Phaser.Math.Vector4} [description]\r\n */var RandomXYZW=function RandomXYZW(vec4,scale){if(scale===undefined){scale=1;}// Not spherical; should fix this for more uniform distribution\nvec4.x=(Math.random()*2-1)*scale;vec4.y=(Math.random()*2-1)*scale;vec4.z=(Math.random()*2-1)*scale;vec4.w=(Math.random()*2-1)*scale;return vec4;};module.exports=RandomXYZW;/***/},/* 341 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Position Vector randomly in a spherical area defined by the given radius\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.RandomXYZ\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector3} vec3 - [description]\r\n * @param {number} [radius=1] - [description]\r\n *\r\n * @return {Phaser.Math.Vector3} [description]\r\n */var RandomXYZ=function RandomXYZ(vec3,radius){if(radius===undefined){radius=1;}var r=Math.random()*2*Math.PI;var z=Math.random()*2-1;var zScale=Math.sqrt(1-z*z)*radius;vec3.x=Math.cos(r)*zScale;vec3.y=Math.sin(r)*zScale;vec3.z=z*radius;return vec3;};module.exports=RandomXYZ;/***/},/* 342 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Color=__webpack_require__(42);/**\r\n * Converts a CSS 'web' string into a Phaser Color object.\r\n * \r\n * The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].\r\n *\r\n * @function Phaser.Display.Color.RGBStringToColor\r\n * @since 3.0.0\r\n *\r\n * @param {string} rgb - The CSS format color string, using the `rgb` or `rgba` format.\r\n *\r\n * @return {Phaser.Display.Color} A Color object.\r\n */var RGBStringToColor=function RGBStringToColor(rgb){var color=new Color();var result=/^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d+(?:\\.\\d+)?))?\\s*\\)$/.exec(rgb.toLowerCase());if(result){var r=parseInt(result[1],10);var g=parseInt(result[2],10);var b=parseInt(result[3],10);var a=result[4]!==undefined?parseFloat(result[4]):1;color.setTo(r,g,b,a*255);}return color;};module.exports=RGBStringToColor;/***/},/* 343 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Color=__webpack_require__(42);/**\r\n * Converts an object containing `r`, `g`, `b` and `a` properties into a Color class instance.\r\n *\r\n * @function Phaser.Display.Color.ObjectToColor\r\n * @since 3.0.0\r\n *\r\n * @param {InputColorObject} input - An object containing `r`, `g`, `b` and `a` properties in the range 0 to 255.\r\n *\r\n * @return {Phaser.Display.Color} A Color object.\r\n */var ObjectToColor=function ObjectToColor(input){return new Color(input.r,input.g,input.b,input.a);};module.exports=ObjectToColor;/***/},/* 344 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Return the component parts of a color as an Object with the properties alpha, red, green, blue.\r\n *\r\n * Alpha will only be set if it exists in the given color (0xAARRGGBB)\r\n *\r\n * @function Phaser.Display.Color.IntegerToRGB\r\n * @since 3.0.0\r\n *\r\n * @param {integer} input - The color value to convert into a Color object.\r\n *\r\n * @return {ColorObject} An object with the red, green and blue values set in the r, g and b properties.\r\n */var IntegerToRGB=function IntegerToRGB(color){if(color>16777215){//  The color value has an alpha component\nreturn{a:color>>>24,r:color>>16&0xFF,g:color>>8&0xFF,b:color&0xFF};}else{return{a:255,r:color>>16&0xFF,g:color>>8&0xFF,b:color&0xFF};}};module.exports=IntegerToRGB;/***/},/* 345 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Color=__webpack_require__(42);var IntegerToRGB=__webpack_require__(344);/**\r\n * Converts the given color value into an instance of a Color object.\r\n *\r\n * @function Phaser.Display.Color.IntegerToColor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} input - The color value to convert into a Color object.\r\n *\r\n * @return {Phaser.Display.Color} A Color object.\r\n */var IntegerToColor=function IntegerToColor(input){var rgb=IntegerToRGB(input);return new Color(rgb.r,rgb.g,rgb.b,rgb.a);};module.exports=IntegerToColor;/***/},/* 346 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Given an alpha and 3 color values this will return an integer representation of it.\r\n *\r\n * @function Phaser.Display.Color.GetColor32\r\n * @since 3.0.0\r\n *\r\n * @param {integer} red - The red color value. A number between 0 and 255.\r\n * @param {integer} green - The green color value. A number between 0 and 255.\r\n * @param {integer} blue - The blue color value. A number between 0 and 255.\r\n * @param {integer} alpha - The alpha color value. A number between 0 and 255.\r\n *\r\n * @return {number} The combined color value.\r\n */var GetColor32=function GetColor32(red,green,blue,alpha){return alpha<<24|red<<16|green<<8|blue;};module.exports=GetColor32;/***/},/* 347 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Color=__webpack_require__(42);/**\r\n * Converts a hex string into a Phaser Color object.\r\n * \r\n * The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional \"#\" or \"0x\", or be unprefixed.\r\n *\r\n * An alpha channel is _not_ supported.\r\n *\r\n * @function Phaser.Display.Color.HexStringToColor\r\n * @since 3.0.0\r\n *\r\n * @param {string} hex - The hex color value to convert, such as `#0033ff` or the short-hand format: `#03f`.\r\n *\r\n * @return {Phaser.Display.Color} A Color object populated by the values of the given string.\r\n */var HexStringToColor=function HexStringToColor(hex){var color=new Color();// Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\nhex=hex.replace(/^(?:#|0x)?([a-f\\d])([a-f\\d])([a-f\\d])$/i,function(m,r,g,b){return r+r+g+g+b+b;});var result=/^(?:#|0x)?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);if(result){var r=parseInt(result[1],16);var g=parseInt(result[2],16);var b=parseInt(result[3],16);color.setTo(r,g,b);}return color;};module.exports=HexStringToColor;/***/},/* 348 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetValue=__webpack_require__(5);// var controlConfig = {\n//     camera: this.cameras.main,\n//     left: cursors.left,\n//     right: cursors.right,\n//     up: cursors.up,\n//     down: cursors.down,\n//     zoomIn: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),\n//     zoomOut: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),\n//     zoomSpeed: 0.02,\n//     acceleration: 0.06,\n//     drag: 0.0005,\n//     maxSpeed: 1.0\n// };\n/**\r\n * @typedef {object} SmoothedKeyControlConfig\r\n *\r\n * @property {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera that this Control will update.\r\n * @property {Phaser.Input.Keyboard.Key} [left] - The Key to be pressed that will move the Camera left.\r\n * @property {Phaser.Input.Keyboard.Key} [right] - The Key to be pressed that will move the Camera right.\r\n * @property {Phaser.Input.Keyboard.Key} [up] - The Key to be pressed that will move the Camera up.\r\n * @property {Phaser.Input.Keyboard.Key} [zoomIn] - The Key to be pressed that will zoom the Camera in.\r\n * @property {Phaser.Input.Keyboard.Key} [zoomOut] - The Key to be pressed that will zoom the Camera out.\r\n * @property {float} [zoomSpeed=0.01] - The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.\r\n * @property {(float|{x:float,y:float})} [acceleration=0] - The horizontal and vertical acceleration the camera will move.\r\n * @property {(float|{x:float,y:float})} [drag=0] - The horizontal and vertical drag applied to the camera when it is moving.\r\n * @property {(float|{x:float,y:float})} [maxSpeed=0] - The maximum horizontal and vertical speed the camera will move.\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class SmoothedKeyControl\r\n * @memberOf Phaser.Cameras.Controls\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {SmoothedKeyControlConfig} config - [description]\r\n */var SmoothedKeyControl=new Class({initialize:function SmoothedKeyControl(config){/**\r\n         * The Camera that this Control will update.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#camera\r\n         * @type {?Phaser.Cameras.Scene2D.Camera}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.camera=GetValue(config,'camera',null);/**\r\n         * The Key to be pressed that will move the Camera left.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#left\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.left=GetValue(config,'left',null);/**\r\n         * The Key to be pressed that will move the Camera right.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#right\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.right=GetValue(config,'right',null);/**\r\n         * The Key to be pressed that will move the Camera up.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#up\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.up=GetValue(config,'up',null);/**\r\n         * The Key to be pressed that will move the Camera down.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#down\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.down=GetValue(config,'down',null);/**\r\n         * The Key to be pressed that will zoom the Camera in.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomIn\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.zoomIn=GetValue(config,'zoomIn',null);/**\r\n         * The Key to be pressed that will zoom the Camera out.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomOut\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.zoomOut=GetValue(config,'zoomOut',null);/**\r\n         * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomSpeed\r\n         * @type {float}\r\n         * @default 0.01\r\n         * @since 3.0.0\r\n         */this.zoomSpeed=GetValue(config,'zoomSpeed',0.01);/**\r\n         * The horizontal acceleration the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#accelX\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accelX=0;/**\r\n         * The vertical acceleration the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#accelY\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accelY=0;var accel=GetValue(config,'acceleration',null);if(typeof accel==='number'){this.accelX=accel;this.accelY=accel;}else{this.accelX=GetValue(config,'acceleration.x',0);this.accelY=GetValue(config,'acceleration.y',0);}/**\r\n         * The horizontal drag applied to the camera when it is moving.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#dragX\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.dragX=0;/**\r\n         * The vertical drag applied to the camera when it is moving.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#dragY\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.dragY=0;var drag=GetValue(config,'drag',null);if(typeof drag==='number'){this.dragX=drag;this.dragY=drag;}else{this.dragX=GetValue(config,'drag.x',0);this.dragY=GetValue(config,'drag.y',0);}/**\r\n         * The maximum horizontal speed the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#maxSpeedX\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.maxSpeedX=0;/**\r\n         * The maximum vertical speed the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#maxSpeedY\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.maxSpeedY=0;var maxSpeed=GetValue(config,'maxSpeed',null);if(typeof maxSpeed==='number'){this.maxSpeedX=maxSpeed;this.maxSpeedY=maxSpeed;}else{this.maxSpeedX=GetValue(config,'maxSpeed.x',0);this.maxSpeedY=GetValue(config,'maxSpeed.y',0);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_speedX\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._speedX=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_speedY\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._speedY=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_zoom\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._zoom=0;/**\r\n         * A flag controlling if the Controls will update the Camera or not.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#active\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.active=this.camera!==null;},/**\r\n     * Starts the Key Control running, providing it has been linked to a camera.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#start\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Controls.SmoothedKeyControl} This Key Control instance.\r\n     */start:function start(){this.active=this.camera!==null;return this;},/**\r\n     * Stops this Key Control from running. Call `start` to start it again.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Controls.SmoothedKeyControl} This Key Control instance.\r\n     */stop:function stop(){this.active=false;return this;},/**\r\n     * Binds this Key Control to a camera.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#setCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to bind this Key Control to.\r\n     *\r\n     * @return {Phaser.Cameras.Controls.SmoothedKeyControl} This Key Control instance.\r\n     */setCamera:function setCamera(camera){this.camera=camera;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */update:function update(delta){if(!this.active){return;}if(delta===undefined){delta=1;}var cam=this.camera;//  Apply Deceleration\nif(this._speedX>0){this._speedX-=this.dragX*delta;if(this._speedX<0){this._speedX=0;}}else if(this._speedX<0){this._speedX+=this.dragX*delta;if(this._speedX>0){this._speedX=0;}}if(this._speedY>0){this._speedY-=this.dragY*delta;if(this._speedY<0){this._speedY=0;}}else if(this._speedY<0){this._speedY+=this.dragY*delta;if(this._speedY>0){this._speedY=0;}}//  Check for keys\nif(this.up&&this.up.isDown){this._speedY+=this.accelY;if(this._speedY>this.maxSpeedY){this._speedY=this.maxSpeedY;}}else if(this.down&&this.down.isDown){this._speedY-=this.accelY;if(this._speedY<-this.maxSpeedY){this._speedY=-this.maxSpeedY;}}if(this.left&&this.left.isDown){this._speedX+=this.accelX;if(this._speedX>this.maxSpeedX){this._speedX=this.maxSpeedX;}}else if(this.right&&this.right.isDown){this._speedX-=this.accelX;if(this._speedX<-this.maxSpeedX){this._speedX=-this.maxSpeedX;}}//  Camera zoom\nif(this.zoomIn&&this.zoomIn.isDown){this._zoom=-this.zoomSpeed;}else if(this.zoomOut&&this.zoomOut.isDown){this._zoom=this.zoomSpeed;}else{this._zoom=0;}//  Apply to Camera\nif(this._speedX!==0){cam.scrollX-=this._speedX*delta|0;}if(this._speedY!==0){cam.scrollY-=this._speedY*delta|0;}if(this._zoom!==0){cam.zoom+=this._zoom;if(cam.zoom<0.1){cam.zoom=0.1;}}},/**\r\n     * Destroys this Key Control.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.camera=null;this.left=null;this.right=null;this.up=null;this.down=null;this.zoomIn=null;this.zoomOut=null;}});module.exports=SmoothedKeyControl;/***/},/* 349 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetValue=__webpack_require__(5);//  var camControl = new CameraControl({\n//      camera: this.cameras.main,\n//      left: cursors.left,\n//      right: cursors.right,\n//      speed: float OR { x: 0, y: 0 }\n//  })\n/**\r\n * @typedef {object} FixedKeyControlConfig\r\n *\r\n * @property {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera that this Control will update.\r\n * @property {Phaser.Input.Keyboard.Key} [left] - The Key to be pressed that will move the Camera left.\r\n * @property {Phaser.Input.Keyboard.Key} [right] - The Key to be pressed that will move the Camera right.\r\n * @property {Phaser.Input.Keyboard.Key} [up] - The Key to be pressed that will move the Camera up.\r\n * @property {Phaser.Input.Keyboard.Key} [zoomIn] - The Key to be pressed that will zoom the Camera in.\r\n * @property {Phaser.Input.Keyboard.Key} [zoomOut] - The Key to be pressed that will zoom the Camera out.\r\n * @property {float} [zoomSpeed=0.01] - The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.\r\n * @property {(float|{x:float,y:float})} [speed=0] - The horizontal and vertical speed the camera will move.\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class FixedKeyControl\r\n * @memberOf Phaser.Cameras.Controls\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {FixedKeyControlConfig} config - [description]\r\n */var FixedKeyControl=new Class({initialize:function FixedKeyControl(config){/**\r\n         * The Camera that this Control will update.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#camera\r\n         * @type {?Phaser.Cameras.Scene2D.Camera}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.camera=GetValue(config,'camera',null);/**\r\n         * The Key to be pressed that will move the Camera left.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#left\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.left=GetValue(config,'left',null);/**\r\n         * The Key to be pressed that will move the Camera right.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#right\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.right=GetValue(config,'right',null);/**\r\n         * The Key to be pressed that will move the Camera up.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#up\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.up=GetValue(config,'up',null);/**\r\n         * The Key to be pressed that will move the Camera down.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#down\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.down=GetValue(config,'down',null);/**\r\n         * The Key to be pressed that will zoom the Camera in.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomIn\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.zoomIn=GetValue(config,'zoomIn',null);/**\r\n         * The Key to be pressed that will zoom the Camera out.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomOut\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.zoomOut=GetValue(config,'zoomOut',null);/**\r\n         * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomSpeed\r\n         * @type {float}\r\n         * @default 0.01\r\n         * @since 3.0.0\r\n         */this.zoomSpeed=GetValue(config,'zoomSpeed',0.01);/**\r\n         * The horizontal speed the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#speedX\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.speedX=0;/**\r\n         * The vertical speed the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#speedY\r\n         * @type {float}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.speedY=0;var speed=GetValue(config,'speed',null);if(typeof speed==='number'){this.speedX=speed;this.speedY=speed;}else{this.speedX=GetValue(config,'speed.x',0);this.speedY=GetValue(config,'speed.y',0);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#_zoom\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._zoom=0;/**\r\n         * A flag controlling if the Controls will update the Camera or not.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#active\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.active=this.camera!==null;},/**\r\n     * Starts the Key Control running, providing it has been linked to a camera.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#start\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Controls.FixedKeyControl} This Key Control instance.\r\n     */start:function start(){this.active=this.camera!==null;return this;},/**\r\n     * Stops this Key Control from running. Call `start` to start it again.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Controls.FixedKeyControl} This Key Control instance.\r\n     */stop:function stop(){this.active=false;return this;},/**\r\n     * Binds this Key Control to a camera.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#setCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to bind this Key Control to.\r\n     *\r\n     * @return {Phaser.Cameras.Controls.FixedKeyControl} This Key Control instance.\r\n     */setCamera:function setCamera(camera){this.camera=camera;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - [description]\r\n     */update:function update(delta){if(!this.active){return;}if(delta===undefined){delta=1;}var cam=this.camera;if(this.up&&this.up.isDown){cam.scrollY-=this.speedY*delta|0;}else if(this.down&&this.down.isDown){cam.scrollY+=this.speedY*delta|0;}if(this.left&&this.left.isDown){cam.scrollX-=this.speedX*delta|0;}else if(this.right&&this.right.isDown){cam.scrollX+=this.speedX*delta|0;}//  Camera zoom\nif(this.zoomIn&&this.zoomIn.isDown){cam.zoom-=this.zoomSpeed;if(cam.zoom<0.1){cam.zoom=0.1;}}else if(this.zoomOut&&this.zoomOut.isDown){cam.zoom+=this.zoomSpeed;}},/**\r\n     * Destroys this Key Control.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.camera=null;this.left=null;this.right=null;this.up=null;this.down=null;this.zoomIn=null;this.zoomOut=null;}});module.exports=FixedKeyControl;/***/},/* 350 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BaseCache=__webpack_require__(351);var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * The Cache Manager is the global cache owned and maintained by the Game instance.\r\n *\r\n * Various systems, such as the file Loader, rely on this cache in order to store the files\r\n * it has loaded. The manager itself doesn't store any files, but instead owns multiple BaseCache\r\n * instances, one per type of file. You can also add your own custom caches.\r\n *\r\n * @class CacheManager\r\n * @memberOf Phaser.Cache\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - A reference to the Phaser.Game instance that owns this CacheManager.\r\n */var CacheManager=new Class({initialize:function CacheManager(game){/**\r\n         * A reference to the Phaser.Game instance that owns this CacheManager.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#game\r\n         * @type {Phaser.Game}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * A Cache storing all binary files, typically added via the Loader.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#binary\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.binary=new BaseCache();/**\r\n         * A Cache storing all bitmap font data files, typically added via the Loader.\r\n         * Only the font data is stored in this cache, the textures are part of the Texture Manager.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#bitmapFont\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.bitmapFont=new BaseCache();/**\r\n         * A Cache storing all JSON data files, typically added via the Loader.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#json\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.json=new BaseCache();/**\r\n         * A Cache storing all physics data files, typically added via the Loader.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#physics\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.physics=new BaseCache();/**\r\n         * A Cache storing all shader source files, typically added via the Loader.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#shader\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.shader=new BaseCache();/**\r\n         * A Cache storing all non-streaming audio files, typically added via the Loader.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#audio\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.audio=new BaseCache();/**\r\n         * A Cache storing all text files, typically added via the Loader.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#text\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.text=new BaseCache();/**\r\n         * A Cache storing all WaveFront OBJ files, typically added via the Loader.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#obj\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.obj=new BaseCache();/**\r\n         * A Cache storing all tilemap data files, typically added via the Loader.\r\n         * Only the data is stored in this cache, the textures are part of the Texture Manager.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#tilemap\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.tilemap=new BaseCache();/**\r\n         * A Cache storing all xml data files, typically added via the Loader.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#xml\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.0.0\r\n         */this.xml=new BaseCache();/**\r\n         * An object that contains your own custom BaseCache entries.\r\n         * Add to this via the `addCustom` method.\r\n         *\r\n         * @name Phaser.Cache.CacheManager#custom\r\n         * @type {Object.<Phaser.Cache.BaseCache>}\r\n         * @since 3.0.0\r\n         */this.custom={};this.game.events.once('destroy',this.destroy,this);},/**\r\n     * Add your own custom Cache for storing your own files.\r\n     * The cache will be available under `Cache.custom.key`.\r\n     * The cache will only be created if the key is not already in use.\r\n     *\r\n     * @method Phaser.Cache.CacheManager#addCustom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique key of your custom cache.\r\n     *\r\n     * @return {Phaser.Cache.BaseCache} A reference to the BaseCache that was created. If the key was already in use, a reference to the existing cache is returned instead.\r\n     */addCustom:function addCustom(key){if(!this.custom.hasOwnProperty(key)){this.custom[key]=new BaseCache();}return this.custom[key];},/**\r\n     * Removes all entries from all BaseCaches and destroys all custom caches.\r\n     *\r\n     * @method Phaser.Cache.CacheManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){var keys=['binary','bitmapFont','json','physics','shader','audio','text','obj','tilemap','xml'];for(var i=0;i<keys.length;i++){this[keys[i]].destroy();this[keys[i]]=null;}for(var key in this.custom){this.custom[key].destroy();}this.custom=null;this.game=null;}});module.exports=CacheManager;/***/},/* 351 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CustomMap=__webpack_require__(166);var EventEmitter=__webpack_require__(14);/**\r\n * @classdesc\r\n * The BaseCache is a base Cache class that can be used for storing references to any kind of data.\r\n *\r\n * Data can be added, retrieved and removed based on the given keys.\r\n *\r\n * Keys are string-based.\r\n *\r\n * @class BaseCache\r\n * @memberOf Phaser.Cache\r\n * @constructor\r\n * @since 3.0.0\r\n */var BaseCache=new Class({initialize:function BaseCache(){/**\r\n         * The Map in which the cache objects are stored.\r\n         *\r\n         * You can query the Map directly or use the BaseCache methods.\r\n         *\r\n         * @name Phaser.Cache.BaseCache#entries\r\n         * @type {Phaser.Structs.Map.<String, *>}\r\n         * @since 3.0.0\r\n         */this.entries=new CustomMap();/**\r\n         * An instance of EventEmitter used by the cache to emit related events.\r\n         *\r\n         * @name Phaser.Cache.BaseCache#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */this.events=new EventEmitter();},/**\r\n     * Cache add event.\r\n     *\r\n     * This event is fired by the Cache each time a new object is added to it.\r\n     *\r\n     * @event Phaser.Cache.BaseCache#addEvent\r\n     * @param {Phaser.Cache.BaseCache} cache - The BaseCache to which the object was added.\r\n     * @param {string} key - The key of the object added to the cache.\r\n     * @param {*} object - A reference to the object added to the cache.\r\n     *//**\r\n     * Adds an item to this cache. The item is referenced by a unique string, which you are responsible\r\n     * for setting and keeping track of. The item can only be retrieved by using this string.\r\n     *\r\n     * @method Phaser.Cache.BaseCache#add\r\n     * @fires Phaser.Cache.BaseCache#addEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique key by which the data added to the cache will be referenced.\r\n     * @param {*} data - The data to be stored in the cache.\r\n     *\r\n     * @return {Phaser.Cache.BaseCache} This BaseCache object.\r\n     */add:function add(key,data){this.entries.set(key,data);this.events.emit('add',this,key,data);return this;},/**\r\n     * Checks if this cache contains an item matching the given key.\r\n     *\r\n     * @method Phaser.Cache.BaseCache#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique key of the item to be checked in this cache.\r\n     *\r\n     * @return {boolean} Returns `true` if the cache contains an item matching the given key, otherwise `false`.\r\n     */has:function has(key){return this.entries.has(key);},/**\r\n     * Gets an item from this cache based on the given key.\r\n     *\r\n     * @method Phaser.Cache.BaseCache#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique key of the item to be retrieved from this cache.\r\n     *\r\n     * @return {*} The item in the cache, or `null` if no item matching the given key was found.\r\n     */get:function get(key){return this.entries.get(key);},/**\r\n     * Cache remove event.\r\n     *\r\n     * This event is fired by the Cache each time an object is removed from it.\r\n     *\r\n     * @event Phaser.Cache.BaseCache#removeEvent\r\n     * @param {Phaser.Cache.BaseCache} cache - The BaseCache from which the object was removed.\r\n     * @param {string} key - The key of the object removed from the cache.\r\n     * @param {*} object - The object that was removed from the cache.\r\n     *//**\r\n     * Removes and item from this cache based on the given key.\r\n     *\r\n     * If an entry matching the key is found it is removed from the cache and a `remove` event emitted.\r\n     * No additional checks are done on the item removed. If other systems or parts of your game code\r\n     * are relying on this item, it is up to you to sever those relationships prior to removing the item.\r\n     *\r\n     * @method Phaser.Cache.BaseCache#remove\r\n     * @fires Phaser.Cache.BaseCache#removeEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique key of the item to remove from the cache.\r\n     *\r\n     * @return {Phaser.Cache.BaseCache} This BaseCache object.\r\n     */remove:function remove(key){var entry=this.get(key);if(entry){this.entries.delete(key);this.events.emit('remove',this,key,entry.data);}return this;},/**\r\n     * Destroys this cache and all items within it.\r\n     *\r\n     * @method Phaser.Cache.BaseCache#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.entries.clear();this.events.removeAllListeners();this.entries=null;this.events=null;}});module.exports=BaseCache;/***/},/* 352 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Animation=__webpack_require__(355);var Class=__webpack_require__(0);var CustomMap=__webpack_require__(166);var EventEmitter=__webpack_require__(14);var GetValue=__webpack_require__(5);var Pad=__webpack_require__(165);/**\r\n * @typedef {object} JSONAnimationManager\r\n *\r\n * @property {JSONAnimation[]} anims - [description]\r\n * @property {number} globalTimeScale - [description]\r\n *//**\r\n * @classdesc\r\n * The Animation Manager.\r\n *\r\n * Animations are managed by the global Animation Manager. This is a singleton class that is\r\n * responsible for creating and delivering animations and their corresponding data to all Game Objects.\r\n * Unlike plugins it is owned by the Game instance, not the Scene.\r\n *\r\n * Sprites and other Game Objects get the data they need from the AnimationManager.\r\n *\r\n * @class AnimationManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Animations\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - [description]\r\n */var AnimationManager=new Class({Extends:EventEmitter,initialize:function AnimationManager(game){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#game\r\n         * @type {Phaser.Game}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.textureManager=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#globalTimeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.globalTimeScale=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#anims\r\n         * @type {Phaser.Structs.Map.<string, Phaser.Animations.Animation>}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */this.anims=new CustomMap();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.paused=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.name='AnimationManager';game.events.once('boot',this.boot,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){this.textureManager=this.game.textures;this.game.events.once('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#add\r\n     * @fires AddAnimationEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {Phaser.Animations.Animation} animation - [description]\r\n     *\r\n     * @return {Phaser.Animations.AnimationManager} This Animation Manager.\r\n     */add:function add(key,animation){if(this.anims.has(key)){console.warn('Animation with key',key,'already exists');return;}animation.key=key;this.anims.set(key,animation);this.emit('add',key,animation);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#create\r\n     * @fires AddAnimationEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {AnimationConfig} config - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} The Animation that was created.\r\n     */create:function create(config){var key=config.key;if(!key||this.anims.has(key)){console.warn('Invalid Animation Key, or Key already in use: '+key);return;}var anim=new Animation(this,key,config);this.anims.set(key,anim);this.emit('add',key,anim);return anim;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|JSONAnimationManager|JSONAnimation)} data - [description]\r\n     * @param {boolean} [clearCurrentAnimations=false] - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation[]} An array containing all of the Animation objects that were created as a result of this call.\r\n     */fromJSON:function fromJSON(data,clearCurrentAnimations){if(clearCurrentAnimations===undefined){clearCurrentAnimations=false;}if(clearCurrentAnimations){this.anims.clear();}//  Do we have a String (i.e. from JSON, or an Object?)\nif(typeof data==='string'){data=JSON.parse(data);}var output=[];//  Array of animations, or a single animation?\nif(data.hasOwnProperty('anims')&&Array.isArray(data.anims)){for(var i=0;i<data.anims.length;i++){output.push(this.create(data.anims[i]));}if(data.hasOwnProperty('globalTimeScale')){this.globalTimeScale=data.globalTimeScale;}}else if(data.hasOwnProperty('key')&&data.type==='frame'){output.push(this.create(data));}return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#generateFrameNames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {object} config - [description]\r\n     * @param {string} [config.prefix=''] - [description]\r\n     * @param {integer} [config.start=0] - [description]\r\n     * @param {integer} [config.end=0] - [description]\r\n     * @param {string} [config.suffix=''] - [description]\r\n     * @param {integer} [config.zeroPad=0] - [description]\r\n     * @param {AnimationFrameConfig[]} [config.outputArray=[]] - [description]\r\n     * @param {boolean} [config.frames=false] - [description]\r\n     *\r\n     * @return {AnimationFrameConfig[]} [description]\r\n     */generateFrameNames:function generateFrameNames(key,config){var prefix=GetValue(config,'prefix','');var start=GetValue(config,'start',0);var end=GetValue(config,'end',0);var suffix=GetValue(config,'suffix','');var zeroPad=GetValue(config,'zeroPad',0);var out=GetValue(config,'outputArray',[]);var frames=GetValue(config,'frames',false);var texture=this.textureManager.get(key);if(!texture){return out;}var diff=start<end?1:-1;//  Adjust because we use i !== end in the for loop\nend+=diff;var i;var frame;//  Have they provided their own custom frame sequence array?\nif(Array.isArray(frames)){for(i=0;i<frames.length;i++){frame=prefix+Pad(frames[i],zeroPad,'0',1)+suffix;if(texture.has(frame)){out.push({key:key,frame:frame});}}}else{for(i=start;i!==end;i+=diff){frame=prefix+Pad(i,zeroPad,'0',1)+suffix;if(texture.has(frame)){out.push({key:key,frame:frame});}}}return out;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#generateFrameNumbers\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {object} config - [description]\r\n     * @param {integer} [config.start=0] - [description]\r\n     * @param {integer} [config.end=-1] - [description]\r\n     * @param {boolean} [config.first=false] - [description]\r\n     * @param {AnimationFrameConfig[]} [config.outputArray=[]] - [description]\r\n     * @param {boolean} [config.frames=false] - [description]\r\n     *\r\n     * @return {AnimationFrameConfig[]} [description]\r\n     */generateFrameNumbers:function generateFrameNumbers(key,config){var startFrame=GetValue(config,'start',0);var endFrame=GetValue(config,'end',-1);var firstFrame=GetValue(config,'first',false);var out=GetValue(config,'outputArray',[]);var frames=GetValue(config,'frames',false);var texture=this.textureManager.get(key);if(!texture){return out;}if(firstFrame&&texture.has(firstFrame)){out.push({key:key,frame:firstFrame});}var i;//  Have they provided their own custom frame sequence array?\nif(Array.isArray(frames)){for(i=0;i<frames.length;i++){if(texture.has(frames[i])){out.push({key:key,frame:frames[i]});}}}else{//  No endFrame then see if we can get it\nif(endFrame===-1){endFrame=texture.frameTotal;}for(i=startFrame;i<=endFrame;i++){if(texture.has(i)){out.push({key:key,frame:i});}}}return out;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} [description]\r\n     */get:function get(key){return this.anims.get(key);},/**\r\n     * Load an Animation into a Game Objects Animation Component.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#load\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     * @param {string} key - [description]\r\n     * @param {(string|integer)} [startFrame] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */load:function load(child,key,startFrame){var anim=this.get(key);if(anim){anim.load(child,startFrame);}return child;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#pauseAll\r\n     * @fires PauseAllAnimationEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Animations.AnimationManager} This Animation Manager.\r\n     */pauseAll:function pauseAll(){if(!this.paused){this.paused=true;this.emit('pauseall');}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#play\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     *\r\n     * @return {Phaser.Animations.AnimationManager} This Animation Manager.\r\n     */play:function play(key,child){if(!Array.isArray(child)){child=[child];}var anim=this.get(key);if(!anim){return;}for(var i=0;i<child.length;i++){child[i].anims.play(key);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#remove\r\n     * @fires RemoveAnimationEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} [description]\r\n     */remove:function remove(key){var anim=this.get(key);if(anim){this.emit('remove',key,anim);this.anims.delete(key);}return anim;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#resumeAll\r\n     * @fires ResumeAllAnimationEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Animations.AnimationManager} This Animation Manager.\r\n     */resumeAll:function resumeAll(){if(this.paused){this.paused=false;this.emit('resumeall');}return this;},/**\r\n     * Takes an array of Game Objects that have the Animation Component and then\r\n     * starts the given animation playing on them, each one offset by the\r\n     * `stagger` amount given to this method.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#staggerPlay\r\n     * @since 3.0.0\r\n     * \r\n     * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n     *\r\n     * @param {string} key - The key of the animation to play on the Game Objects.\r\n     * @param {Phaser.GameObjects.GameObject[]} children - An array of Game Objects to play the animation on. They must have the Animation Component.\r\n     * @param {number} [stagger=0] - The amount of time, in milliseconds, to offset each play time by.\r\n     *\r\n     * @return {Phaser.Animations.AnimationManager} This Animation Manager.\r\n     */staggerPlay:function staggerPlay(key,children,stagger){if(stagger===undefined){stagger=0;}if(!Array.isArray(children)){children=[children];}var anim=this.get(key);if(!anim){return;}for(var i=0;i<children.length;i++){children[i].anims.delayedPlay(stagger*i,key);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {JSONAnimationManager} [description]\r\n     */toJSON:function toJSON(key){if(key!==undefined&&key!==''){return this.anims.get(key).toJSON();}else{var output={anims:[],globalTimeScale:this.globalTimeScale};this.anims.each(function(animationKey,animation){output.anims.push(animation.toJSON());});return output;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.anims.clear();this.textureManager=null;this.game=null;}});module.exports=AnimationManager;/***/},/* 353 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @typedef {object} JSONAnimationFrame\r\n *\r\n * @property {string} key - The key of the Texture this AnimationFrame uses.\r\n * @property {(string|integer)} frame - The key of the Frame within the Texture that this AnimationFrame uses.\r\n * @property {number} duration - Additional time (in ms) that this frame should appear for during playback.\r\n *//**\r\n * @classdesc\r\n * A single frame in an Animation sequence.\r\n *\r\n * An AnimationFrame consists of a reference to the Texture it uses for rendering, references to other\r\n * frames in the animation, and index data. It also has the ability to fire its own `onUpdate` callback\r\n * and modify the animation timing.\r\n *\r\n * AnimationFrames are generated automatically by the Animation class.\r\n *\r\n * @class AnimationFrame\r\n * @memberOf Phaser.Animations\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} textureKey - The key of the Texture this AnimationFrame uses.\r\n * @param {(string|integer)} textureFrame - The key of the Frame within the Texture that this AnimationFrame uses.\r\n * @param {integer} index - The index of this AnimationFrame within the Animation sequence.\r\n * @param {Phaser.Textures.Frame} frame - A reference to the Texture Frame this AnimationFrame uses for rendering.\r\n */var AnimationFrame=new Class({initialize:function AnimationFrame(textureKey,textureFrame,index,frame){/**\r\n         * The key of the Texture this AnimationFrame uses.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#textureKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.textureKey=textureKey;/**\r\n         * The key of the Frame within the Texture that this AnimationFrame uses.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#textureFrame\r\n         * @type {(string|integer)}\r\n         * @since 3.0.0\r\n         */this.textureFrame=textureFrame;/**\r\n         * The index of this AnimationFrame within the Animation sequence.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#index\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.index=index;/**\r\n         * A reference to the Texture Frame this AnimationFrame uses for rendering.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.0.0\r\n         */this.frame=frame;/**\r\n         * Is this the first frame in an animation sequence?\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#isFirst\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isFirst=false;/**\r\n         * Is this the last frame in an animation sequence?\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#isLast\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isLast=false;/**\r\n         * A reference to the AnimationFrame that comes before this one in the animation, if any.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#prevFrame\r\n         * @type {?Phaser.Animations.AnimationFrame}\r\n         * @default null\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.prevFrame=null;/**\r\n         * A reference to the AnimationFrame that comes after this one in the animation, if any.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#nextFrame\r\n         * @type {?Phaser.Animations.AnimationFrame}\r\n         * @default null\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.nextFrame=null;/**\r\n         * Additional time (in ms) that this frame should appear for during playback.\r\n         * The value is added onto the msPerFrame set by the animation.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.duration=0;/**\r\n         * What % through the animation does this frame come?\r\n         * This value is generated when the animation is created and cached here.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.progress=0;},/**\r\n     * Generates a JavaScript object suitable for converting to JSON.\r\n     *\r\n     * @method Phaser.Animations.AnimationFrame#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONAnimationFrame} The AnimationFrame data.\r\n     */toJSON:function toJSON(){return{key:this.textureKey,frame:this.textureFrame,duration:this.duration};},/**\r\n     * Destroys this object by removing references to external resources and callbacks.\r\n     *\r\n     * @method Phaser.Animations.AnimationFrame#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.frame=undefined;}});module.exports=AnimationFrame;/***/},/* 354 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.FindClosestInSorted\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to search for in the array.\r\n * @param {array} array - The array to search, which must be sorted.\r\n * @param {string} [key] - An optional property key. If specified the array elements property will be checked against value.\r\n *\r\n * @return {number|object} The nearest value found in the array, or if a `key` was given, the nearest object with the matching property value.\r\n */var FindClosestInSorted=function FindClosestInSorted(value,array,key){if(!array.length){return NaN;}else if(array.length===1){return array[0];}var i=1;var low;var high;if(key){if(value<array[0][key]){return array[0];}while(array[i][key]<value){i++;}}else{while(array[i]<value){i++;}}if(i>array.length){i=array.length;}if(key){low=array[i-1][key];high=array[i][key];return high-value<=value-low?array[i]:array[i-1];}else{low=array[i-1];high=array[i];return high-value<=value-low?high:low;}};module.exports=FindClosestInSorted;/***/},/* 355 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clamp=__webpack_require__(50);var Class=__webpack_require__(0);var FindClosestInSorted=__webpack_require__(354);var Frame=__webpack_require__(353);var GetValue=__webpack_require__(5);/**\r\n * @typedef {object} JSONAnimation\r\n *\r\n * @property {string} key - [description]\r\n * @property {string} type - A frame based animation (as opposed to a bone based animation)\r\n * @property {JSONAnimationFrame[]} frames - [description]\r\n * @property {integer} frameRate - The frame rate of playback in frames per second (default 24 if duration is null)\r\n * @property {integer} duration - How long the animation should play for in milliseconds. If not given its derived from frameRate.\r\n * @property {boolean} skipMissedFrames - Skip frames if the time lags, or always advanced anyway?\r\n * @property {integer} delay - Delay before starting playback. Value given in milliseconds.\r\n * @property {integer} repeat - Number of times to repeat the animation (-1 for infinity)\r\n * @property {integer} repeatDelay - Delay before the animation repeats. Value given in milliseconds.\r\n * @property {boolean} yoyo - Should the animation yoyo? (reverse back down to the start) before repeating?\r\n * @property {boolean} showOnStart - Should sprite.visible = true when the animation starts to play?\r\n * @property {boolean} hideOnComplete - Should sprite.visible = false when the animation finishes?\r\n *//**\r\n * @typedef {object} AnimationFrameConfig\r\n *\r\n * @property {string} key - [description]\r\n * @property {(string|number)} frame - [description]\r\n * @property {float} [duration=0] - [description]\r\n * @property {boolean} [visible] - [description]\r\n *//**\r\n * @typedef {object} AnimationConfig\r\n *\r\n * @property {AnimationFrameConfig[]} [frames] - [description]\r\n * @property {string} [defaultTextureKey=null] - [description]\r\n * @property {integer} [frameRate] - The frame rate of playback in frames per second (default 24 if duration is null)\r\n * @property {integer} [duration] - How long the animation should play for in milliseconds. If not given its derived from frameRate.\r\n * @property {boolean} [skipMissedFrames=true] - Skip frames if the time lags, or always advanced anyway?\r\n * @property {integer} [delay=0] - Delay before starting playback. Value given in milliseconds.\r\n * @property {integer} [repeat=0] - Number of times to repeat the animation (-1 for infinity)\r\n * @property {integer} [repeatDelay=0] - Delay before the animation repeats. Value given in milliseconds.\r\n * @property {boolean} [yoyo=false] - Should the animation yoyo? (reverse back down to the start) before repeating?\r\n * @property {boolean} [showOnStart=false] - Should sprite.visible = true when the animation starts to play?\r\n * @property {boolean} [hideOnComplete=false] - Should sprite.visible = false when the animation finishes?\r\n *//**\r\n * @classdesc\r\n * A Frame based Animation.\r\n *\r\n * This consists of a key, some default values (like the frame rate) and a bunch of Frame objects.\r\n *\r\n * The Animation Manager creates these. Game Objects don't own an instance of these directly.\r\n * Game Objects have the Animation Component, which are like playheads to global Animations (these objects)\r\n * So multiple Game Objects can have playheads all pointing to this one Animation instance.\r\n *\r\n * @class Animation\r\n * @memberOf Phaser.Animations\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Animations.AnimationManager} manager - [description]\r\n * @param {string} key - [description]\r\n * @param {AnimationConfig} config - [description]\r\n */var Animation=new Class({initialize:function Animation(manager,key,config){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Animations.Animation#manager\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */this.manager=manager;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Animations.Animation#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.key=key;/**\r\n         * A frame based animation (as opposed to a bone based animation)\r\n         *\r\n         * @name Phaser.Animations.Animation#type\r\n         * @type {string}\r\n         * @default frame\r\n         * @since 3.0.0\r\n         */this.type='frame';/**\r\n         * Extract all the frame data into the frames array\r\n         *\r\n         * @name Phaser.Animations.Animation#frames\r\n         * @type {Phaser.Animations.AnimationFrame[]}\r\n         * @since 3.0.0\r\n         */this.frames=this.getFrames(manager.textureManager,GetValue(config,'frames',[]),GetValue(config,'defaultTextureKey',null));/**\r\n         * The frame rate of playback in frames per second (default 24 if duration is null)\r\n         *\r\n         * @name Phaser.Animations.Animation#frameRate\r\n         * @type {integer}\r\n         * @default 24\r\n         * @since 3.0.0\r\n         */this.frameRate=GetValue(config,'frameRate',null);/**\r\n         * How long the animation should play for, in milliseconds.\r\n         * If the `frameRate` property has been set then it overrides this value,\r\n         * otherwise the `frameRate` is derived from `duration`.\r\n         *\r\n         * @name Phaser.Animations.Animation#duration\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.duration=GetValue(config,'duration',null);if(this.duration===null&&this.frameRate===null){//  No duration or frameRate given, use default frameRate of 24fps\nthis.frameRate=24;this.duration=this.frameRate/this.frames.length*1000;}else if(this.duration&&this.frameRate===null){//  Duration given but no frameRate, so set the frameRate based on duration\n//  I.e. 12 frames in the animation, duration = 4000 ms\n//  So frameRate is 12 / (4000 / 1000) = 3 fps\nthis.frameRate=this.frames.length/(this.duration/1000);}else{//  frameRate given, derive duration from it (even if duration also specified)\n//  I.e. 15 frames in the animation, frameRate = 30 fps\n//  So duration is 15 / 30 = 0.5 * 1000 (half a second, or 500ms)\nthis.duration=this.frames.length/this.frameRate*1000;}/**\r\n         * How many ms per frame, not including frame specific modifiers.\r\n         *\r\n         * @name Phaser.Animations.Animation#msPerFrame\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.msPerFrame=1000/this.frameRate;/**\r\n         * Skip frames if the time lags, or always advanced anyway?\r\n         *\r\n         * @name Phaser.Animations.Animation#skipMissedFrames\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.skipMissedFrames=GetValue(config,'skipMissedFrames',true);/**\r\n         * The delay in ms before the playback will begin.\r\n         *\r\n         * @name Phaser.Animations.Animation#delay\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.delay=GetValue(config,'delay',0);/**\r\n         * Number of times to repeat the animation. Set to -1 to repeat forever.\r\n         *\r\n         * @name Phaser.Animations.Animation#repeat\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.repeat=GetValue(config,'repeat',0);/**\r\n         * The delay in ms before the a repeat playthrough starts.\r\n         *\r\n         * @name Phaser.Animations.Animation#repeatDelay\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.repeatDelay=GetValue(config,'repeatDelay',0);/**\r\n         * Should the animation yoyo? (reverse back down to the start) before repeating?\r\n         *\r\n         * @name Phaser.Animations.Animation#yoyo\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.yoyo=GetValue(config,'yoyo',false);/**\r\n         * Should sprite.visible = true when the animation starts to play?\r\n         *\r\n         * @name Phaser.Animations.Animation#showOnStart\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.showOnStart=GetValue(config,'showOnStart',false);/**\r\n         * Should sprite.visible = false when the animation finishes?\r\n         *\r\n         * @name Phaser.Animations.Animation#hideOnComplete\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.hideOnComplete=GetValue(config,'hideOnComplete',false);/**\r\n         * Global pause. All Game Objects using this Animation instance are impacted by this property.\r\n         *\r\n         * @name Phaser.Animations.Animation#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.paused=false;this.manager.on('pauseall',this.pause,this);this.manager.on('resumeall',this.resume,this);},/**\r\n     * Add frames to the end of the animation.\r\n     *\r\n     * @method Phaser.Animations.Animation#addFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|AnimationFrameConfig[])} config - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */addFrame:function addFrame(config){return this.addFrameAt(this.frames.length,config);},/**\r\n     * Add frame/s into the animation.\r\n     *\r\n     * @method Phaser.Animations.Animation#addFrameAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - [description]\r\n     * @param {(string|AnimationFrameConfig[])} config - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */addFrameAt:function addFrameAt(index,config){var newFrames=this.getFrames(this.manager.textureManager,config);if(newFrames.length>0){if(index===0){this.frames=newFrames.concat(this.frames);}else if(index===this.frames.length){this.frames=this.frames.concat(newFrames);}else{var pre=this.frames.slice(0,index);var post=this.frames.slice(index);this.frames=pre.concat(newFrames,post);}this.updateFrameSequence();}return this;},/**\r\n     * Check if the given frame index is valid.\r\n     *\r\n     * @method Phaser.Animations.Animation#checkFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index to be checked.\r\n     *\r\n     * @return {boolean} `true` if the index is valid, otherwise `false`.\r\n     */checkFrame:function checkFrame(index){return index>=0&&index<this.frames.length;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#completeAnimation\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */completeAnimation:function completeAnimation(component){if(this.hideOnComplete){component.parent.visible=false;}component.stop();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#getFirstTick\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     * @param {boolean} [includeDelay=true] - [description]\r\n     */getFirstTick:function getFirstTick(component,includeDelay){if(includeDelay===undefined){includeDelay=true;}//  When is the first update due?\ncomponent.accumulator=0;component.nextTick=component.msPerFrame+component.currentFrame.duration;if(includeDelay){component.nextTick+=component._delay;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#getFrameAt\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - [description]\r\n     *\r\n     * @return {Phaser.Animations.AnimationFrame} [description]\r\n     */getFrameAt:function getFrameAt(index){return this.frames[index];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#getFrames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.TextureManager} textureManager - [description]\r\n     * @param {(string|AnimationFrameConfig[])} frames - [description]\r\n     * @param {string} [defaultTextureKey] - [description]\r\n     *\r\n     * @return {Phaser.Animations.AnimationFrame[]} [description]\r\n     */getFrames:function getFrames(textureManager,frames,defaultTextureKey){var out=[];var prev;var animationFrame;var index=1;var i;var textureKey;//  if frames is a string, we'll get all the frames from the texture manager as if it's a sprite sheet\nif(typeof frames==='string'){textureKey=frames;var texture=textureManager.get(textureKey);var frameKeys=texture.getFrameNames();frames=[];frameKeys.forEach(function(idx,value){frames.push({key:textureKey,frame:value});});}if(!Array.isArray(frames)||frames.length===0){return out;}for(i=0;i<frames.length;i++){var item=frames[i];var key=GetValue(item,'key',defaultTextureKey);if(!key){continue;}//  Could be an integer or a string\nvar frame=GetValue(item,'frame',0);//  The actual texture frame\nvar textureFrame=textureManager.getFrame(key,frame);animationFrame=new Frame(key,frame,index,textureFrame);animationFrame.duration=GetValue(item,'duration',0);animationFrame.isFirst=!prev;//  The previously created animationFrame\nif(prev){prev.nextFrame=animationFrame;animationFrame.prevFrame=prev;}out.push(animationFrame);prev=animationFrame;index++;}if(out.length>0){animationFrame.isLast=true;//  Link them end-to-end, so they loop\nanimationFrame.nextFrame=out[0];out[0].prevFrame=animationFrame;//  Generate the progress data\nvar slice=1/(out.length-1);for(i=0;i<out.length;i++){out[i].progress=i*slice;}}return out;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#getNextTick\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */getNextTick:function getNextTick(component){// accumulator += delta * _timeScale\n// after a large delta surge (perf issue for example) we need to adjust for it here\n//  When is the next update due?\ncomponent.accumulator-=component.nextTick;component.nextTick=component.msPerFrame+component.currentFrame.duration;},/**\r\n     * Loads the Animation values into the Animation Component.\r\n     *\r\n     * @method Phaser.Animations.Animation#load\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     * @param {integer} startFrame - [description]\r\n     */load:function load(component,startFrame){if(startFrame>=this.frames.length){startFrame=0;}if(component.currentAnim!==this){component.currentAnim=this;component.frameRate=this.frameRate;component.duration=this.duration;component.msPerFrame=this.msPerFrame;component.skipMissedFrames=this.skipMissedFrames;component._timeScale=1;component._delay=this.delay;component._repeat=this.repeat;component._repeatDelay=this.repeatDelay;component._yoyo=this.yoyo;}component.updateFrame(this.frames[startFrame]);},/**\r\n     * Returns the frame closest to the given progress value between 0 and 1.\r\n     *\r\n     * @method Phaser.Animations.Animation#getFrameByProgress\r\n     * @since 3.4.0\r\n     *\r\n     * @param {float} value - A value between 0 and 1.\r\n     *\r\n     * @return {Phaser.Animations.AnimationFrame} [description]\r\n     */getFrameByProgress:function getFrameByProgress(value){value=Clamp(value,0,1);return FindClosestInSorted(value,this.frames,'progress');},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#nextFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */nextFrame:function nextFrame(component){var frame=component.currentFrame;//  TODO: Add frame skip support\nif(frame.isLast){//  We're at the end of the animation\n//  Yoyo? (happens before repeat)\nif(component.yoyo){component.forward=false;component.updateFrame(frame.prevFrame);//  Delay for the current frame\nthis.getNextTick(component);}else if(component.repeatCounter>0){//  Repeat (happens before complete)\nthis.repeatAnimation(component);}else{this.completeAnimation(component);}}else{component.updateFrame(frame.nextFrame);this.getNextTick(component);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#previousFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */previousFrame:function previousFrame(component){var frame=component.currentFrame;//  TODO: Add frame skip support\nif(frame.isFirst){//  We're at the start of the animation\nif(component.repeatCounter>0){//  Repeat (happens before complete)\nthis.repeatAnimation(component);}else{this.completeAnimation(component);}}else{component.updateFrame(frame.prevFrame);this.getNextTick(component);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#removeFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} frame - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */removeFrame:function removeFrame(frame){var index=this.frames.indexOf(frame);if(index!==-1){this.removeFrameAt(index);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#removeFrameAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - [description]\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */removeFrameAt:function removeFrameAt(index){this.frames.splice(index,1);this.updateFrameSequence();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#repeatAnimation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */repeatAnimation:function repeatAnimation(component){if(component._pendingStop===2){return this.completeAnimation(component);}if(component._repeatDelay>0&&component.pendingRepeat===false){component.pendingRepeat=true;component.accumulator-=component.nextTick;component.nextTick+=component._repeatDelay;}else{component.repeatCounter--;component.forward=true;component.updateFrame(component.currentFrame.nextFrame);if(component.isPlaying){this.getNextTick(component);component.pendingRepeat=false;component.parent.emit('animationrepeat',this,component.currentFrame,component.repeatCounter);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.Animation} component - [description]\r\n     */setFrame:function setFrame(component){//  Work out which frame should be set next on the child, and set it\nif(component.forward){this.nextFrame(component);}else{this.previousFrame(component);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONAnimation} [description]\r\n     */toJSON:function toJSON(){var output={key:this.key,type:this.type,frames:[],frameRate:this.frameRate,duration:this.duration,skipMissedFrames:this.skipMissedFrames,delay:this.delay,repeat:this.repeat,repeatDelay:this.repeatDelay,yoyo:this.yoyo,showOnStart:this.showOnStart,hideOnComplete:this.hideOnComplete};this.frames.forEach(function(frame){output.frames.push(frame.toJSON());});return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#updateFrameSequence\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */updateFrameSequence:function updateFrameSequence(){var len=this.frames.length;var slice=1/(len-1);for(var i=0;i<len;i++){var frame=this.frames[i];frame.index=i+1;frame.isFirst=false;frame.isLast=false;frame.progress=i*slice;if(i===0){frame.isFirst=true;frame.isLast=len===1;frame.prevFrame=this.frames[len-1];frame.nextFrame=this.frames[i+1];}else if(i===len-1){frame.isLast=true;frame.prevFrame=this.frames[len-2];frame.nextFrame=this.frames[0];}else if(len>1){frame.prevFrame=this.frames[i-1];frame.nextFrame=this.frames[i+1];}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */pause:function pause(){this.paused=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Animations.Animation} This Animation object.\r\n     */resume:function resume(){this.paused=false;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Animations.Animation#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.manager.off('pauseall',this.pause,this);this.manager.off('resumeall',this.resume,this);this.manager.remove(this.key);for(var i=0;i<this.frames.length;i++){this.frames[i].destroy();}this.frames=[];this.manager=null;}});module.exports=Animation;/***/},/* 356 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.SmoothStep\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - [description]\r\n * @param {number} min - [description]\r\n * @param {number} max - [description]\r\n *\r\n * @return {number} [description]\r\n */var SmoothStep=function SmoothStep(x,min,max){x=Math.max(0,Math.min(1,(x-min)/(max-min)));return x*x*(3-2*x);};module.exports=SmoothStep;/***/},/* 357 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.SmootherStep\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - [description]\r\n * @param {number} min - [description]\r\n * @param {number} max - [description]\r\n *\r\n * @return {number} [description]\r\n */var SmootherStep=function SmootherStep(x,min,max){x=Math.max(0,Math.min(1,(x-min)/(max-min)));return x*x*x*(x*(x*6-15)+10);};module.exports=SmootherStep;/***/},/* 358 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Using Bresenham's line algorithm this will return an array of all coordinates on this line.\r\n * The start and end points are rounded before this runs as the algorithm works on integers.\r\n *\r\n * @function Phaser.Geom.Line.BresenhamPoints\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {integer} [stepRate=1] - [description]\r\n * @param {array} [results] - [description]\r\n *\r\n * @return {array} [description]\r\n */var BresenhamPoints=function BresenhamPoints(line,stepRate,results){if(stepRate===undefined){stepRate=1;}if(results===undefined){results=[];}var x1=Math.round(line.x1);var y1=Math.round(line.y1);var x2=Math.round(line.x2);var y2=Math.round(line.y2);var dx=Math.abs(x2-x1);var dy=Math.abs(y2-y1);var sx=x1<x2?1:-1;var sy=y1<y2?1:-1;var err=dx-dy;results.push({x:x1,y:y1});var i=1;while(!(x1===x2&&y1===y2)){var e2=err<<1;if(e2>-dy){err-=dy;x1+=sx;}if(e2<dx){err+=dx;y1+=sy;}if(i%stepRate===0){results.push({x:x1,y:y1});}i++;}return results;};module.exports=BresenhamPoints;/***/},/* 359 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Moves the element at the end of the array to the start, shifting all items in the process.\r\n * The \"rotation\" happens to the right.\r\n *\r\n * @function Phaser.Utils.Array.RotateRight\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to shift to the right. This array is modified in place.\r\n * @param {integer} [total=1] - The number of times to shift the array.\r\n *\r\n * @return {*} The most recently shifted element.\r\n */var RotateRight=function RotateRight(array,total){if(total===undefined){total=1;}var element=null;for(var i=0;i<total;i++){element=array.pop();array.unshift(element);}return element;};module.exports=RotateRight;/***/},/* 360 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Moves the element at the start of the array to the end, shifting all items in the process.\r\n * The \"rotation\" happens to the left.\r\n *\r\n * @function Phaser.Utils.Array.RotateLeft\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to shift to the left. This array is modified in place.\r\n * @param {integer} [total=1] - The number of times to shift the array.\r\n *\r\n * @return {*} The most recently shifted element.\r\n */var RotateLeft=function RotateLeft(array,total){if(total===undefined){total=1;}var element=null;for(var i=0;i<total;i++){element=array.shift();array.push(element);}return element;};module.exports=RotateLeft;/***/},/* 361 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Perimeter=__webpack_require__(109);var Point=__webpack_require__(4);//  Return an array of points from the perimeter of the rectangle\n//  each spaced out based on the quantity or step required\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.MarchingAnts\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} step - [description]\r\n * @param {integer} quantity - [description]\r\n * @param {(array|Phaser.Geom.Point[])} [out] - [description]\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} [description]\r\n */var MarchingAnts=function MarchingAnts(rect,step,quantity,out){if(out===undefined){out=[];}if(!step&&!quantity){//  Bail out\nreturn out;}//  If step is a falsey value (false, null, 0, undefined, etc) then we calculate\n//  it based on the quantity instead, otherwise we always use the step value\nif(!step){step=Perimeter(rect)/quantity;}else{quantity=Math.round(Perimeter(rect)/step);}var x=rect.x;var y=rect.y;var face=0;//  Loop across each face of the rectangle\nfor(var i=0;i<quantity;i++){out.push(new Point(x,y));switch(face){//  Top face\ncase 0:x+=step;if(x>=rect.right){face=1;y+=x-rect.right;x=rect.right;}break;//  Right face\ncase 1:y+=step;if(y>=rect.bottom){face=2;x-=y-rect.bottom;y=rect.bottom;}break;//  Bottom face\ncase 2:x-=step;if(x<=rect.left){face=3;y-=rect.left-x;x=rect.left;}break;//  Left face\ncase 3:y-=step;if(y<=rect.top){face=0;y=rect.top;}break;}}return out;};module.exports=MarchingAnts;/***/},/* 362 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Provides methods used for setting the WebGL rendering pipeline of a Game Object.\r\n * \r\n * @name Phaser.GameObjects.Components.Pipeline\r\n * @webglOnly\r\n * @since 3.0.0\r\n */var Pipeline={/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.GameObjects.Components.Pipeline#defaultPipeline\r\n     * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n     * @default null\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */defaultPipeline:null,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.GameObjects.Components.Pipeline#pipeline\r\n     * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n     * @default null\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */pipeline:null,/**\r\n     * Sets the initial WebGL Pipeline of this Game Object.\r\n     * This should only be called during the instantiation of the Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Pipeline#initPipeline\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - The name of the pipeline to set on this Game Object.\r\n     * \r\n     * @return {boolean} `true` if the pipeline was set successfully, otherwise `false`.\r\n     */initPipeline:function initPipeline(pipelineName){var renderer=this.scene.sys.game.renderer;if(renderer&&renderer.gl&&renderer.hasPipeline(pipelineName)){this.defaultPipeline=renderer.getPipeline(pipelineName);this.pipeline=this.defaultPipeline;return true;}return false;},/**\r\n     * Sets the active WebGL Pipeline of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Pipeline#setPipeline\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - The name of the pipeline to set on this Game Object.\r\n     * \r\n     * @return {boolean} `true` if the pipeline was set successfully, otherwise `false`.\r\n     */setPipeline:function setPipeline(pipelineName){var renderer=this.scene.sys.game.renderer;if(renderer&&renderer.gl&&renderer.hasPipeline(pipelineName)){this.pipeline=renderer.getPipeline(pipelineName);return true;}return false;},/**\r\n     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Pipeline#resetPipeline\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the pipeline was set successfully, otherwise `false`.\r\n     */resetPipeline:function resetPipeline(){this.pipeline=this.defaultPipeline;return this.pipeline!==null;},/**\r\n     * Gets the name of the WebGL Pipeline this Game Object is currently using.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Pipeline#getPipelineName\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string} The string-based name of the pipeline being used by this Game Object.\r\n     */getPipelineName:function getPipelineName(){return this.pipeline.name;}};module.exports=Pipeline;/***/},/* 363 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.RotateAround\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {number} angle - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var RotateAround=function RotateAround(point,x,y,angle){var c=Math.cos(angle);var s=Math.sin(angle);var tx=point.x-x;var ty=point.y-y;point.x=tx*c-ty*s+x;point.y=tx*s+ty*c+y;return point;};module.exports=RotateAround;/***/},/* 364 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);//  Get a point on the given line 'progress' percentage along its length.\n//  progress is a value between 0 and 1.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.GetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {float} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var GetPoint=function GetPoint(line,position,out){if(out===undefined){out=new Point();}out.x=line.x1+(line.x2-line.x1)*position;out.y=line.y1+(line.y2-line.y1)*position;return out;};module.exports=GetPoint;/***/},/* 365 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetPoint=__webpack_require__(173);var Perimeter=__webpack_require__(109);//  Return an array of points from the perimeter of the rectangle\n//  each spaced out based on the quantity or step required\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectangle - [description]\r\n * @param {number} step - [description]\r\n * @param {integer} quantity - [description]\r\n * @param {(array|Phaser.Geom.Point[])} [out] - [description]\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} [description]\r\n */var GetPoints=function GetPoints(rectangle,quantity,stepRate,out){if(out===undefined){out=[];}//  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\nif(!quantity){quantity=Perimeter(rectangle)/stepRate;}for(var i=0;i<quantity;i++){var position=i/quantity;out.push(GetPoint(rectangle,position));}return out;};module.exports=GetPoints;/***/},/* 366 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the circumference of the given Circle.\r\n *\r\n * @function Phaser.Geom.Circle.Circumference\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference of.\r\n *\r\n * @return {number} The circumference of the Circle.\r\n */var Circumference=function Circumference(circle){return 2*(Math.PI*circle.radius);};module.exports=Circumference;/***/},/* 367 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Circumference=__webpack_require__(366);var CircumferencePoint=__webpack_require__(175);var FromPercent=__webpack_require__(80);var MATH_CONST=__webpack_require__(16);/**\r\n * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,\r\n * based on the given quantity or stepRate values.\r\n *\r\n * @function Phaser.Geom.Circle.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the points from.\r\n * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n * @param {number} [stepRate] - Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.\r\n * @param {array} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n *\r\n * @return {Phaser.Geom.Point[]} An array of Point objects pertaining to the points around the circumference of the circle.\r\n */var GetPoints=function GetPoints(circle,quantity,stepRate,out){if(out===undefined){out=[];}//  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\nif(!quantity){quantity=Circumference(circle)/stepRate;}for(var i=0;i<quantity;i++){var angle=FromPercent(i/quantity,0,MATH_CONST.PI2);out.push(CircumferencePoint(circle,angle));}return out;};module.exports=GetPoints;/***/},/* 368 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CircumferencePoint=__webpack_require__(175);var FromPercent=__webpack_require__(80);var MATH_CONST=__webpack_require__(16);var Point=__webpack_require__(4);/**\r\n * Returns a Point object containing the coordinates of a point on the circumference of the Circle\r\n * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\r\n * at 180 degrees around the circle.\r\n *\r\n * @function Phaser.Geom.Circle.GetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference point on.\r\n * @param {float} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the circle.\r\n */var GetPoint=function GetPoint(circle,position,out){if(out===undefined){out=new Point();}var angle=FromPercent(position,0,MATH_CONST.PI2);return CircumferencePoint(circle,angle,out);};module.exports=GetPoint;/***/},/* 369 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetRight=__webpack_require__(32);var GetTop=__webpack_require__(30);var SetRight=__webpack_require__(31);var SetTop=__webpack_require__(29);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the top right of the other.\r\n *\r\n * @function Phaser.Display.Align.In.TopRight\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var TopRight=function TopRight(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetRight(gameObject,GetRight(alignIn)+offsetX);SetTop(gameObject,GetTop(alignIn)-offsetY);return gameObject;};module.exports=TopRight;/***/},/* 370 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetLeft=__webpack_require__(34);var GetTop=__webpack_require__(30);var SetLeft=__webpack_require__(33);var SetTop=__webpack_require__(29);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the top left of the other.\r\n *\r\n * @function Phaser.Display.Align.In.TopLeft\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var TopLeft=function TopLeft(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetLeft(gameObject,GetLeft(alignIn)-offsetX);SetTop(gameObject,GetTop(alignIn)-offsetY);return gameObject;};module.exports=TopLeft;/***/},/* 371 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetCenterX=__webpack_require__(63);var GetTop=__webpack_require__(30);var SetCenterX=__webpack_require__(62);var SetTop=__webpack_require__(29);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the top center of the other.\r\n *\r\n * @function Phaser.Display.Align.In.TopCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var TopCenter=function TopCenter(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetCenterX(gameObject,GetCenterX(alignIn)+offsetX);SetTop(gameObject,GetTop(alignIn)-offsetY);return gameObject;};module.exports=TopCenter;/***/},/* 372 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetCenterY=__webpack_require__(60);var GetRight=__webpack_require__(32);var SetCenterY=__webpack_require__(61);var SetRight=__webpack_require__(31);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the right center of the other.\r\n *\r\n * @function Phaser.Display.Align.In.RightCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var RightCenter=function RightCenter(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetRight(gameObject,GetRight(alignIn)+offsetX);SetCenterY(gameObject,GetCenterY(alignIn)+offsetY);return gameObject;};module.exports=RightCenter;/***/},/* 373 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetCenterY=__webpack_require__(60);var GetLeft=__webpack_require__(34);var SetCenterY=__webpack_require__(61);var SetLeft=__webpack_require__(33);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the left center of the other.\r\n *\r\n * @function Phaser.Display.Align.In.LeftCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var LeftCenter=function LeftCenter(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetLeft(gameObject,GetLeft(alignIn)-offsetX);SetCenterY(gameObject,GetCenterY(alignIn)+offsetY);return gameObject;};module.exports=LeftCenter;/***/},/* 374 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SetCenterX=__webpack_require__(62);var SetCenterY=__webpack_require__(61);/**\r\n * Positions the Game Object so that it is centered on the given coordinates.\r\n *\r\n * @function Phaser.Display.Bounds.CenterOn\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be re-positioned.\r\n * @param {number} x - The horizontal coordinate to position the Game Object on.\r\n * @param {number} y - The vertical coordinate to position the Game Object on.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was positioned.\r\n */var CenterOn=function CenterOn(gameObject,x,y){SetCenterX(gameObject,x);return SetCenterY(gameObject,y);};module.exports=CenterOn;/***/},/* 375 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CenterOn=__webpack_require__(374);var GetCenterX=__webpack_require__(63);var GetCenterY=__webpack_require__(60);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the center of the other.\r\n *\r\n * @function Phaser.Display.Align.In.Center\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var Center=function Center(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}CenterOn(gameObject,GetCenterX(alignIn)+offsetX,GetCenterY(alignIn)+offsetY);return gameObject;};module.exports=Center;/***/},/* 376 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetBottom=__webpack_require__(36);var GetRight=__webpack_require__(32);var SetBottom=__webpack_require__(35);var SetRight=__webpack_require__(31);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the bottom right of the other.\r\n *\r\n * @function Phaser.Display.Align.In.BottomRight\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var BottomRight=function BottomRight(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetRight(gameObject,GetRight(alignIn)+offsetX);SetBottom(gameObject,GetBottom(alignIn)+offsetY);return gameObject;};module.exports=BottomRight;/***/},/* 377 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetBottom=__webpack_require__(36);var GetLeft=__webpack_require__(34);var SetBottom=__webpack_require__(35);var SetLeft=__webpack_require__(33);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the bottom left of the other.\r\n *\r\n * @function Phaser.Display.Align.In.BottomLeft\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var BottomLeft=function BottomLeft(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetLeft(gameObject,GetLeft(alignIn)-offsetX);SetBottom(gameObject,GetBottom(alignIn)+offsetY);return gameObject;};module.exports=BottomLeft;/***/},/* 378 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetBottom=__webpack_require__(36);var GetCenterX=__webpack_require__(63);var SetBottom=__webpack_require__(35);var SetCenterX=__webpack_require__(62);/**\r\n * Takes given Game Object and aligns it so that it is positioned in the bottom center of the other.\r\n *\r\n * @function Phaser.Display.Align.In.BottomCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var BottomCenter=function BottomCenter(gameObject,alignIn,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetCenterX(gameObject,GetCenterX(alignIn)+offsetX);SetBottom(gameObject,GetBottom(alignIn)+offsetY);return gameObject;};module.exports=BottomCenter;/***/},/* 379 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ALIGN_CONST=__webpack_require__(176);var AlignInMap=[];AlignInMap[ALIGN_CONST.BOTTOM_CENTER]=__webpack_require__(378);AlignInMap[ALIGN_CONST.BOTTOM_LEFT]=__webpack_require__(377);AlignInMap[ALIGN_CONST.BOTTOM_RIGHT]=__webpack_require__(376);AlignInMap[ALIGN_CONST.CENTER]=__webpack_require__(375);AlignInMap[ALIGN_CONST.LEFT_CENTER]=__webpack_require__(373);AlignInMap[ALIGN_CONST.RIGHT_CENTER]=__webpack_require__(372);AlignInMap[ALIGN_CONST.TOP_CENTER]=__webpack_require__(371);AlignInMap[ALIGN_CONST.TOP_LEFT]=__webpack_require__(370);AlignInMap[ALIGN_CONST.TOP_RIGHT]=__webpack_require__(369);/**\r\n * Takes given Game Object and aligns it so that it is positioned relative to the other.\r\n * The alignment used is based on the `position` argument, which is an `ALIGN_CONST` value, such as `LEFT_CENTER` or `TOP_RIGHT`.\r\n *\r\n * @function Phaser.Display.Align.In.QuickSet\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [child,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} child - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignIn - The Game Object to base the alignment position on.\r\n * @param {integer} position - The position to align the Game Object with. This is an align constant, such as `ALIGN_CONST.LEFT_CENTER`.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var QuickSet=function QuickSet(child,alignIn,position,offsetX,offsetY){return AlignInMap[position](child,alignIn,offsetX,offsetY);};module.exports=QuickSet;/***/},/* 380 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Actions\r\n */module.exports={Angle:__webpack_require__(968),Call:__webpack_require__(967),GetFirst:__webpack_require__(966),GetLast:__webpack_require__(965),GridAlign:__webpack_require__(964),IncAlpha:__webpack_require__(946),IncX:__webpack_require__(945),IncXY:__webpack_require__(944),IncY:__webpack_require__(943),PlaceOnCircle:__webpack_require__(942),PlaceOnEllipse:__webpack_require__(941),PlaceOnLine:__webpack_require__(940),PlaceOnRectangle:__webpack_require__(939),PlaceOnTriangle:__webpack_require__(938),PlayAnimation:__webpack_require__(937),PropertyValueInc:__webpack_require__(25),PropertyValueSet:__webpack_require__(21),RandomCircle:__webpack_require__(936),RandomEllipse:__webpack_require__(935),RandomLine:__webpack_require__(934),RandomRectangle:__webpack_require__(933),RandomTriangle:__webpack_require__(932),Rotate:__webpack_require__(931),RotateAround:__webpack_require__(930),RotateAroundDistance:__webpack_require__(929),ScaleX:__webpack_require__(928),ScaleXY:__webpack_require__(927),ScaleY:__webpack_require__(926),SetAlpha:__webpack_require__(925),SetBlendMode:__webpack_require__(924),SetDepth:__webpack_require__(923),SetHitArea:__webpack_require__(922),SetOrigin:__webpack_require__(921),SetRotation:__webpack_require__(920),SetScale:__webpack_require__(919),SetScaleX:__webpack_require__(918),SetScaleY:__webpack_require__(917),SetTint:__webpack_require__(916),SetVisible:__webpack_require__(915),SetX:__webpack_require__(914),SetXY:__webpack_require__(913),SetY:__webpack_require__(912),ShiftPosition:__webpack_require__(911),Shuffle:__webpack_require__(910),SmootherStep:__webpack_require__(909),SmoothStep:__webpack_require__(908),Spread:__webpack_require__(907),ToggleVisible:__webpack_require__(906),WrapInRectangle:__webpack_require__(905)};/***/},/* 381 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * This is a slightly modified version of jQuery.isPlainObject.\r\n * A plain object is an object whose internal class property is [object Object].\r\n *\r\n * @function Phaser.Utils.Object.IsPlainObject\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj - The object to inspect.\r\n *\r\n * @return {boolean} `true` if the object is plain, otherwise `false`.\r\n */var IsPlainObject=function IsPlainObject(obj){// Not plain objects:\n// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n// - DOM nodes\n// - window\nif((typeof obj==='undefined'?'undefined':_typeof(obj))!=='object'||obj.nodeType||obj===obj.window){return false;}// Support: Firefox <20\n// The try/catch suppresses exceptions thrown when attempting to access\n// the \"constructor\" property of certain host objects, ie. |window.location|\n// https://bugzilla.mozilla.org/show_bug.cgi?id=814622\ntry{if(obj.constructor&&!{}.hasOwnProperty.call(obj.constructor.prototype,'isPrototypeOf')){return false;}}catch(e){return false;}// If the function hasn't returned already, we're confident that\n// |obj| is a plain object, created by {} or constructed with new Object\nreturn true;};module.exports=IsPlainObject;/***/},/* 382 *//***/function(module,exports){var g;// This works in non-strict mode\ng=function(){return this;}();try{// This works if eval is allowed (see CSP)\ng=g||Function(\"return this\")()||(1,eval)(\"this\");}catch(e){// This works if the window reference is available\nif((typeof window==='undefined'?'undefined':_typeof(window))===\"object\")g=window;}// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\nmodule.exports=g;/***/},/* 383 *//***/function(module,exports){/**\r\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\r\n*\r\n* @class Pair\r\n*/var Pair={};module.exports=Pair;(function(){/**\r\n     * Creates a pair.\r\n     * @method create\r\n     * @param {collision} collision\r\n     * @param {number} timestamp\r\n     * @return {pair} A new pair\r\n     */Pair.create=function(collision,timestamp){var bodyA=collision.bodyA,bodyB=collision.bodyB;var pair={id:Pair.id(bodyA,bodyB),bodyA:bodyA,bodyB:bodyB,activeContacts:[],separation:0,isActive:true,confirmedActive:true,isSensor:bodyA.isSensor||bodyB.isSensor,timeCreated:timestamp,timeUpdated:timestamp,collision:null,inverseMass:0,friction:0,frictionStatic:0,restitution:0,slop:0};Pair.update(pair,collision,timestamp);return pair;};/**\r\n     * Updates a pair given a collision.\r\n     * @method update\r\n     * @param {pair} pair\r\n     * @param {collision} collision\r\n     * @param {number} timestamp\r\n     */Pair.update=function(pair,collision,timestamp){// var contacts = pair.contacts,\n//     supports = collision.supports,\n//     activeContacts = pair.activeContacts,\n//     parentA = collision.parentA,\n//     parentB = collision.parentB;\npair.collision=collision;// pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n// pair.friction = Math.min(parentA.friction, parentB.friction);\n// pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);\n// pair.restitution = Math.max(parentA.restitution, parentB.restitution);\n// pair.slop = Math.max(parentA.slop, parentB.slop);\n// activeContacts.length = 0;\nif(collision.collided){var supports=collision.supports,activeContacts=pair.activeContacts,parentA=collision.parentA,parentB=collision.parentB;pair.inverseMass=parentA.inverseMass+parentB.inverseMass;pair.friction=Math.min(parentA.friction,parentB.friction);pair.frictionStatic=Math.max(parentA.frictionStatic,parentB.frictionStatic);pair.restitution=Math.max(parentA.restitution,parentB.restitution);pair.slop=Math.max(parentA.slop,parentB.slop);for(var i=0;i<supports.length;i++){activeContacts[i]=supports[i].contact;}var supportCount=supports.length;if(supportCount<activeContacts.length){activeContacts.length=supportCount;}pair.separation=collision.depth;Pair.setActive(pair,true,timestamp);}else{if(pair.isActive===true)Pair.setActive(pair,false,timestamp);}};/**\r\n     * Set a pair as active or inactive.\r\n     * @method setActive\r\n     * @param {pair} pair\r\n     * @param {bool} isActive\r\n     * @param {number} timestamp\r\n     */Pair.setActive=function(pair,isActive,timestamp){if(isActive){pair.isActive=true;pair.timeUpdated=timestamp;}else{pair.isActive=false;pair.activeContacts.length=0;}};/**\r\n     * Get the id for the given pair.\r\n     * @method id\r\n     * @param {body} bodyA\r\n     * @param {body} bodyB\r\n     * @return {string} Unique pairId\r\n     */Pair.id=function(bodyA,bodyB){if(bodyA.id<bodyB.id){return'A'+bodyA.id+'B'+bodyB.id;}else{return'A'+bodyB.id+'B'+bodyA.id;}};})();/***/},/* 384 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Physics.Matter.Body.Components\r\n */module.exports={Bounce:__webpack_require__(1021),Collision:__webpack_require__(1020),Force:__webpack_require__(1019),Friction:__webpack_require__(1018),Gravity:__webpack_require__(1017),Mass:__webpack_require__(1016),Static:__webpack_require__(1015),Sensor:__webpack_require__(1014),SetBody:__webpack_require__(1013),Sleep:__webpack_require__(1012),Transform:__webpack_require__(1011),Velocity:__webpack_require__(1010)};/***/},/* 385 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Commands=__webpack_require__(150);var Earcut=__webpack_require__(313);var ModelViewProjection=__webpack_require__(312);var ShaderSourceFS=__webpack_require__(842);var ShaderSourceVS=__webpack_require__(841);var Utils=__webpack_require__(38);var WebGLPipeline=__webpack_require__(111);var Point=function Point(x,y,width,rgb,alpha){this.x=x;this.y=y;this.width=width;this.rgb=rgb;this.alpha=alpha;};var Path=function Path(x,y,width,rgb,alpha){this.points=[];this.pointsLength=1;this.points[0]=new Point(x,y,width,rgb,alpha);};var currentMatrix=new Float32Array([1,0,0,1,0,0]);var matrixStack=new Float32Array(6*1000);var matrixStackLength=0;var pathArray=[];/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class FlatTintPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberOf Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n */var FlatTintPipeline=new Class({Extends:WebGLPipeline,Mixins:[ModelViewProjection],initialize:function FlatTintPipeline(config){WebGLPipeline.call(this,{game:config.game,renderer:config.renderer,gl:config.renderer.gl,topology:config.topology?config.topology:config.renderer.gl.TRIANGLES,vertShader:config.vertShader?config.vertShader:ShaderSourceVS,fragShader:config.fragShader?config.fragShader:ShaderSourceFS,vertexCapacity:config.vertexCapcity?config.vertexCapacity:12000,vertexSize:config.vertexSize?config.vertexSize:Float32Array.BYTES_PER_ELEMENT*2+Uint8Array.BYTES_PER_ELEMENT*4,attributes:[{name:'inPosition',size:2,type:config.renderer.gl.FLOAT,normalized:false,offset:0},{name:'inTint',size:4,type:config.renderer.gl.UNSIGNED_BYTE,normalized:true,offset:Float32Array.BYTES_PER_ELEMENT*2}]});/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.FlatTintPipeline#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.vertexViewF32=new Float32Array(this.vertexData);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.FlatTintPipeline#vertexViewU32\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */this.vertexViewU32=new Uint32Array(this.vertexData);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.FlatTintPipeline#tempTriangle\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.tempTriangle=[{x:0,y:0,width:0,rgb:0xFFFFFF,alpha:1.0},{x:0,y:0,width:0,rgb:0xFFFFFF,alpha:1.0},{x:0,y:0,width:0,rgb:0xFFFFFF,alpha:1.0},{x:0,y:0,width:0,rgb:0xFFFFFF,alpha:1.0}];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.FlatTintPipeline#polygonCache\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.polygonCache=[];this.mvpInit();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#onBind\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.FlatTintPipeline} [description]\r\n     */onBind:function onBind(){WebGLPipeline.prototype.onBind.call(this);this.mvpUpdate();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} resolution - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.FlatTintPipeline} [description]\r\n     */resize:function resize(width,height,resolution){WebGLPipeline.prototype.resize.call(this,width,height,resolution);this.projOrtho(0,this.width,this.height,0,-1000.0,1000.0);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchFillRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} srcX - [description]\r\n     * @param {float} srcY - [description]\r\n     * @param {float} srcScaleX - [description]\r\n     * @param {float} srcScaleY - [description]\r\n     * @param {float} srcRotation - [description]\r\n     * @param {float} x - [description]\r\n     * @param {float} y - [description]\r\n     * @param {float} width - [description]\r\n     * @param {float} height - [description]\r\n     * @param {integer} fillColor - [description]\r\n     * @param {float} fillAlpha - [description]\r\n     * @param {float} a1 - [description]\r\n     * @param {float} b1 - [description]\r\n     * @param {float} c1 - [description]\r\n     * @param {float} d1 - [description]\r\n     * @param {float} e1 - [description]\r\n     * @param {float} f1 - [description]\r\n     * @param {Float32Array} currentMatrix - [description]\r\n     */batchFillRect:function batchFillRect(srcX,srcY,srcScaleX,srcScaleY,srcRotation,x,y,width,height,fillColor,fillAlpha,a1,b1,c1,d1,e1,f1,currentMatrix){this.renderer.setPipeline(this);if(this.vertexCount+6>this.vertexCapacity){this.flush();}var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var vertexOffset=this.vertexCount*this.vertexComponentCount;var xw=x+width;var yh=y+height;var a0=currentMatrix[0];var b0=currentMatrix[1];var c0=currentMatrix[2];var d0=currentMatrix[3];var e0=currentMatrix[4];var f0=currentMatrix[5];var a=a1*a0+b1*c0;var b=a1*b0+b1*d0;var c=c1*a0+d1*c0;var d=c1*b0+d1*d0;var e=e1*a0+f1*c0+e0;var f=e1*b0+f1*d0+f0;var tx0=x*a+y*c+e;var ty0=x*b+y*d+f;var tx1=x*a+yh*c+e;var ty1=x*b+yh*d+f;var tx2=xw*a+yh*c+e;var ty2=xw*b+yh*d+f;var tx3=xw*a+y*c+e;var ty3=xw*b+y*d+f;var tint=Utils.getTintAppendFloatAlphaAndSwap(fillColor,fillAlpha);vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewU32[vertexOffset+2]=tint;vertexViewF32[vertexOffset+3]=tx1;vertexViewF32[vertexOffset+4]=ty1;vertexViewU32[vertexOffset+5]=tint;vertexViewF32[vertexOffset+6]=tx2;vertexViewF32[vertexOffset+7]=ty2;vertexViewU32[vertexOffset+8]=tint;vertexViewF32[vertexOffset+9]=tx0;vertexViewF32[vertexOffset+10]=ty0;vertexViewU32[vertexOffset+11]=tint;vertexViewF32[vertexOffset+12]=tx2;vertexViewF32[vertexOffset+13]=ty2;vertexViewU32[vertexOffset+14]=tint;vertexViewF32[vertexOffset+15]=tx3;vertexViewF32[vertexOffset+16]=ty3;vertexViewU32[vertexOffset+17]=tint;this.vertexCount+=6;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchFillTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} srcX - [description]\r\n     * @param {float} srcY - [description]\r\n     * @param {float} srcScaleX - [description]\r\n     * @param {float} srcScaleY - [description]\r\n     * @param {float} srcRotation - [description]\r\n     * @param {float} x0 - [description]\r\n     * @param {float} y0 - [description]\r\n     * @param {float} x1 - [description]\r\n     * @param {float} y1 - [description]\r\n     * @param {float} x2 - [description]\r\n     * @param {float} y2 - [description]\r\n     * @param {integer} fillColor - [description]\r\n     * @param {float} fillAlpha - [description]\r\n     * @param {float} a1 - [description]\r\n     * @param {float} b1 - [description]\r\n     * @param {float} c1 - [description]\r\n     * @param {float} d1 - [description]\r\n     * @param {float} e1 - [description]\r\n     * @param {float} f1 - [description]\r\n     * @param {Float32Array} currentMatrix - [description]\r\n     */batchFillTriangle:function batchFillTriangle(srcX,srcY,srcScaleX,srcScaleY,srcRotation,x0,y0,x1,y1,x2,y2,fillColor,fillAlpha,a1,b1,c1,d1,e1,f1,currentMatrix){this.renderer.setPipeline(this);if(this.vertexCount+3>this.vertexCapacity){this.flush();}var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var vertexOffset=this.vertexCount*this.vertexComponentCount;var a0=currentMatrix[0];var b0=currentMatrix[1];var c0=currentMatrix[2];var d0=currentMatrix[3];var e0=currentMatrix[4];var f0=currentMatrix[5];var a=a1*a0+b1*c0;var b=a1*b0+b1*d0;var c=c1*a0+d1*c0;var d=c1*b0+d1*d0;var e=e1*a0+f1*c0+e0;var f=e1*b0+f1*d0+f0;var tx0=x0*a+y0*c+e;var ty0=x0*b+y0*d+f;var tx1=x1*a+y1*c+e;var ty1=x1*b+y1*d+f;var tx2=x2*a+y2*c+e;var ty2=x2*b+y2*d+f;var tint=Utils.getTintAppendFloatAlphaAndSwap(fillColor,fillAlpha);vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewU32[vertexOffset+2]=tint;vertexViewF32[vertexOffset+3]=tx1;vertexViewF32[vertexOffset+4]=ty1;vertexViewU32[vertexOffset+5]=tint;vertexViewF32[vertexOffset+6]=tx2;vertexViewF32[vertexOffset+7]=ty2;vertexViewU32[vertexOffset+8]=tint;this.vertexCount+=3;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchStrokeTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} srcX - [description]\r\n     * @param {float} srcY - [description]\r\n     * @param {float} srcScaleX - [description]\r\n     * @param {float} srcScaleY - [description]\r\n     * @param {float} srcRotation - [description]\r\n     * @param {float} x0 - [description]\r\n     * @param {float} y0 - [description]\r\n     * @param {float} x1 - [description]\r\n     * @param {float} y1 - [description]\r\n     * @param {float} x2 - [description]\r\n     * @param {float} y2 - [description]\r\n     * @param {float} lineWidth - [description]\r\n     * @param {integer} lineColor - [description]\r\n     * @param {float} lineAlpha - [description]\r\n     * @param {float} a - [description]\r\n     * @param {float} b - [description]\r\n     * @param {float} c - [description]\r\n     * @param {float} d - [description]\r\n     * @param {float} e - [description]\r\n     * @param {float} f - [description]\r\n     * @param {Float32Array} currentMatrix - [description]\r\n     */batchStrokeTriangle:function batchStrokeTriangle(srcX,srcY,srcScaleX,srcScaleY,srcRotation,x0,y0,x1,y1,x2,y2,lineWidth,lineColor,lineAlpha,a,b,c,d,e,f,currentMatrix){var tempTriangle=this.tempTriangle;tempTriangle[0].x=x0;tempTriangle[0].y=y0;tempTriangle[0].width=lineWidth;tempTriangle[0].rgb=lineColor;tempTriangle[0].alpha=lineAlpha;tempTriangle[1].x=x1;tempTriangle[1].y=y1;tempTriangle[1].width=lineWidth;tempTriangle[1].rgb=lineColor;tempTriangle[1].alpha=lineAlpha;tempTriangle[2].x=x2;tempTriangle[2].y=y2;tempTriangle[2].width=lineWidth;tempTriangle[2].rgb=lineColor;tempTriangle[2].alpha=lineAlpha;tempTriangle[3].x=x0;tempTriangle[3].y=y0;tempTriangle[3].width=lineWidth;tempTriangle[3].rgb=lineColor;tempTriangle[3].alpha=lineAlpha;this.batchStrokePath(srcX,srcY,srcScaleX,srcScaleY,srcRotation,tempTriangle,lineWidth,lineColor,lineAlpha,a,b,c,d,e,f,false,currentMatrix);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchFillPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} srcX - [description]\r\n     * @param {float} srcY - [description]\r\n     * @param {float} srcScaleX - [description]\r\n     * @param {float} srcScaleY - [description]\r\n     * @param {float} srcRotation - [description]\r\n     * @param {float} path - [description]\r\n     * @param {integer} fillColor - [description]\r\n     * @param {float} fillAlpha - [description]\r\n     * @param {float} a1 - [description]\r\n     * @param {float} b1 - [description]\r\n     * @param {float} c1 - [description]\r\n     * @param {float} d1 - [description]\r\n     * @param {float} e1 - [description]\r\n     * @param {float} f1 - [description]\r\n     * @param {Float32Array} currentMatrix - [description]\r\n     */batchFillPath:function batchFillPath(srcX,srcY,srcScaleX,srcScaleY,srcRotation,path,fillColor,fillAlpha,a1,b1,c1,d1,e1,f1,currentMatrix){this.renderer.setPipeline(this);var length=path.length;var polygonCache=this.polygonCache;var polygonIndexArray;var point;var v0,v1,v2;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var vertexOffset=0;var x0,y0,x1,y1,x2,y2;var tx0,ty0,tx1,ty1,tx2,ty2;var a0=currentMatrix[0];var b0=currentMatrix[1];var c0=currentMatrix[2];var d0=currentMatrix[3];var e0=currentMatrix[4];var f0=currentMatrix[5];var a=a1*a0+b1*c0;var b=a1*b0+b1*d0;var c=c1*a0+d1*c0;var d=c1*b0+d1*d0;var e=e1*a0+f1*c0+e0;var f=e1*b0+f1*d0+f0;var tint=Utils.getTintAppendFloatAlphaAndSwap(fillColor,fillAlpha);for(var pathIndex=0;pathIndex<length;++pathIndex){point=path[pathIndex];polygonCache.push(point.x,point.y);}polygonIndexArray=Earcut(polygonCache);length=polygonIndexArray.length;for(var index=0;index<length;index+=3){v0=polygonIndexArray[index+0]*2;v1=polygonIndexArray[index+1]*2;v2=polygonIndexArray[index+2]*2;if(this.vertexCount+3>this.vertexCapacity){this.flush();}vertexOffset=this.vertexCount*this.vertexComponentCount;x0=polygonCache[v0+0];y0=polygonCache[v0+1];x1=polygonCache[v1+0];y1=polygonCache[v1+1];x2=polygonCache[v2+0];y2=polygonCache[v2+1];tx0=x0*a+y0*c+e;ty0=x0*b+y0*d+f;tx1=x1*a+y1*c+e;ty1=x1*b+y1*d+f;tx2=x2*a+y2*c+e;ty2=x2*b+y2*d+f;vertexViewF32[vertexOffset+0]=tx0;vertexViewF32[vertexOffset+1]=ty0;vertexViewU32[vertexOffset+2]=tint;vertexViewF32[vertexOffset+3]=tx1;vertexViewF32[vertexOffset+4]=ty1;vertexViewU32[vertexOffset+5]=tint;vertexViewF32[vertexOffset+6]=tx2;vertexViewF32[vertexOffset+7]=ty2;vertexViewU32[vertexOffset+8]=tint;this.vertexCount+=3;}polygonCache.length=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchStrokePath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} srcX - [description]\r\n     * @param {float} srcY - [description]\r\n     * @param {float} srcScaleX - [description]\r\n     * @param {float} srcScaleY - [description]\r\n     * @param {float} srcRotation - [description]\r\n     * @param {array} path - [description]\r\n     * @param {float} lineWidth - [description]\r\n     * @param {integer} lineColor - [description]\r\n     * @param {float} lineAlpha - [description]\r\n     * @param {float} a - [description]\r\n     * @param {float} b - [description]\r\n     * @param {float} c - [description]\r\n     * @param {float} d - [description]\r\n     * @param {float} e - [description]\r\n     * @param {float} f - [description]\r\n     * @param {boolean} isLastPath - [description]\r\n     * @param {Float32Array} currentMatrix - [description]\r\n     */batchStrokePath:function batchStrokePath(srcX,srcY,srcScaleX,srcScaleY,srcRotation,path,lineWidth,lineColor,lineAlpha,a,b,c,d,e,f,isLastPath,currentMatrix){this.renderer.setPipeline(this);var point0,point1;var pathLength=path.length;var polylines=this.polygonCache;var last,curr;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var vertexOffset;var line;var getTint=Utils.getTintAppendFloatAlphaAndSwap;for(var pathIndex=0;pathIndex+1<pathLength;pathIndex+=1){point0=path[pathIndex];point1=path[pathIndex+1];line=this.batchLine(srcX,srcY,srcScaleX,srcScaleY,srcRotation,point0.x,point0.y,point1.x,point1.y,point0.width/2,point1.width/2,point0.rgb,point1.rgb,lineAlpha,a,b,c,d,e,f,currentMatrix);polylines.push(line);}/* Render joints */for(var index=1,polylinesLength=polylines.length;index<polylinesLength;++index){if(this.vertexCount+6>this.vertexCapacity){this.flush();}last=polylines[index-1]||polylines[polylinesLength-1];curr=polylines[index];vertexOffset=this.vertexCount*this.vertexComponentCount;vertexViewF32[vertexOffset+0]=last[3*2+0];vertexViewF32[vertexOffset+1]=last[3*2+1];vertexViewU32[vertexOffset+2]=getTint(last[3*2+2],lineAlpha);vertexViewF32[vertexOffset+3]=last[3*0+0];vertexViewF32[vertexOffset+4]=last[3*0+1];vertexViewU32[vertexOffset+5]=getTint(last[3*0+2],lineAlpha);vertexViewF32[vertexOffset+6]=curr[3*3+0];vertexViewF32[vertexOffset+7]=curr[3*3+1];vertexViewU32[vertexOffset+8]=getTint(curr[3*3+2],lineAlpha);vertexViewF32[vertexOffset+9]=last[3*0+0];vertexViewF32[vertexOffset+10]=last[3*0+1];vertexViewU32[vertexOffset+11]=getTint(last[3*0+2],lineAlpha);vertexViewF32[vertexOffset+12]=last[3*2+0];vertexViewF32[vertexOffset+13]=last[3*2+1];vertexViewU32[vertexOffset+14]=getTint(last[3*2+2],lineAlpha);vertexViewF32[vertexOffset+15]=curr[3*1+0];vertexViewF32[vertexOffset+16]=curr[3*1+1];vertexViewU32[vertexOffset+17]=getTint(curr[3*1+2],lineAlpha);this.vertexCount+=6;}polylines.length=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchLine\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} srcX - [description]\r\n     * @param {float} srcY - [description]\r\n     * @param {float} srcScaleX - [description]\r\n     * @param {float} srcScaleY - [description]\r\n     * @param {float} srcRotation - [description]\r\n     * @param {float} ax - [description]\r\n     * @param {float} ay - [description]\r\n     * @param {float} bx - [description]\r\n     * @param {float} by - [description]\r\n     * @param {float} aLineWidth - [description]\r\n     * @param {float} bLineWidth - [description]\r\n     * @param {integer} aLineColor - [description]\r\n     * @param {integer} bLineColor - [description]\r\n     * @param {float} lineAlpha - [description]\r\n     * @param {float} a1 - [description]\r\n     * @param {float} b1 - [description]\r\n     * @param {float} c1 - [description]\r\n     * @param {float} d1 - [description]\r\n     * @param {float} e1 - [description]\r\n     * @param {float} f1 - [description]\r\n     * @param {Float32Array} currentMatrix - [description]\r\n     */batchLine:function batchLine(srcX,srcY,srcScaleX,srcScaleY,srcRotation,ax,ay,bx,by,aLineWidth,bLineWidth,aLineColor,bLineColor,lineAlpha,a1,b1,c1,d1,e1,f1,currentMatrix){this.renderer.setPipeline(this);if(this.vertexCount+6>this.vertexCapacity){this.flush();}var a0=currentMatrix[0];var b0=currentMatrix[1];var c0=currentMatrix[2];var d0=currentMatrix[3];var e0=currentMatrix[4];var f0=currentMatrix[5];var a=a1*a0+b1*c0;var b=a1*b0+b1*d0;var c=c1*a0+d1*c0;var d=c1*b0+d1*d0;var e=e1*a0+f1*c0+e0;var f=e1*b0+f1*d0+f0;var vertexViewF32=this.vertexViewF32;var vertexViewU32=this.vertexViewU32;var dx=bx-ax;var dy=by-ay;var len=Math.sqrt(dx*dx+dy*dy);var al0=aLineWidth*(by-ay)/len;var al1=aLineWidth*(ax-bx)/len;var bl0=bLineWidth*(by-ay)/len;var bl1=bLineWidth*(ax-bx)/len;var lx0=bx-bl0;var ly0=by-bl1;var lx1=ax-al0;var ly1=ay-al1;var lx2=bx+bl0;var ly2=by+bl1;var lx3=ax+al0;var ly3=ay+al1;var x0=lx0*a+ly0*c+e;var y0=lx0*b+ly0*d+f;var x1=lx1*a+ly1*c+e;var y1=lx1*b+ly1*d+f;var x2=lx2*a+ly2*c+e;var y2=lx2*b+ly2*d+f;var x3=lx3*a+ly3*c+e;var y3=lx3*b+ly3*d+f;var getTint=Utils.getTintAppendFloatAlphaAndSwap;var aTint=getTint(aLineColor,lineAlpha);var bTint=getTint(bLineColor,lineAlpha);var vertexOffset=this.vertexCount*this.vertexComponentCount;vertexViewF32[vertexOffset+0]=x0;vertexViewF32[vertexOffset+1]=y0;vertexViewU32[vertexOffset+2]=bTint;vertexViewF32[vertexOffset+3]=x1;vertexViewF32[vertexOffset+4]=y1;vertexViewU32[vertexOffset+5]=aTint;vertexViewF32[vertexOffset+6]=x2;vertexViewF32[vertexOffset+7]=y2;vertexViewU32[vertexOffset+8]=bTint;vertexViewF32[vertexOffset+9]=x1;vertexViewF32[vertexOffset+10]=y1;vertexViewU32[vertexOffset+11]=aTint;vertexViewF32[vertexOffset+12]=x3;vertexViewF32[vertexOffset+13]=y3;vertexViewU32[vertexOffset+14]=aTint;vertexViewF32[vertexOffset+15]=x2;vertexViewF32[vertexOffset+16]=y2;vertexViewU32[vertexOffset+17]=bTint;this.vertexCount+=6;return[x0,y0,bLineColor,x1,y1,aLineColor,x2,y2,bLineColor,x3,y3,aLineColor];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchGraphics\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - [description]\r\n     */batchGraphics:function batchGraphics(graphics,camera,parentTransformMatrix){if(graphics.commandBuffer.length<=0){return;}var parentMatrix=null;if(parentTransformMatrix){parentMatrix=parentTransformMatrix.matrix;}this.renderer.setPipeline(this);var cameraScrollX=camera.scrollX*graphics.scrollFactorX;var cameraScrollY=camera.scrollY*graphics.scrollFactorY;var srcX=graphics.x-cameraScrollX;var srcY=graphics.y-cameraScrollY;var srcScaleX=graphics.scaleX;var srcScaleY=graphics.scaleY;var srcRotation=-graphics.rotation;var commands=graphics.commandBuffer;var alpha=graphics.alpha;var lineAlpha=1.0;var fillAlpha=1.0;var lineColor=0;var fillColor=0;var lineWidth=1.0;var cameraMatrix=camera.matrix.matrix;var lastPath=null;var iteration=0;var iterStep=0.01;var tx=0;var ty=0;var ta=0;var x=0;var y=0;var radius=0;var startAngle=0;var endAngle=0;var anticlockwise=0;var path=null;var sin=Math.sin;var cos=Math.cos;var PI2=Math.PI*2;var sr=sin(srcRotation);var cr=cos(srcRotation);var sra=cr*srcScaleX;var srb=-sr*srcScaleX;var src=sr*srcScaleY;var srd=cr*srcScaleY;var sre=srcX;var srf=srcY;var cma=cameraMatrix[0];var cmb=cameraMatrix[1];var cmc=cameraMatrix[2];var cmd=cameraMatrix[3];var cme=cameraMatrix[4];var cmf=cameraMatrix[5];var mva,mvb,mvc,mvd,mve,mvf;if(parentMatrix){var pma=parentMatrix[0];var pmb=parentMatrix[1];var pmc=parentMatrix[2];var pmd=parentMatrix[3];var pme=parentMatrix[4];var pmf=parentMatrix[5];var pca=cma*pma+cmb*pmc;var pcb=cma*pmb+cmb*pmd;var pcc=cmc*pma+cmd*pmc;var pcd=cmc*pmb+cmd*pmd;var pce=cme*pma+cmf*pmc+pme;var pcf=cme*pmb+cmf*pmd+pmf;mva=sra*pca+srb*pcc;mvb=sra*pcb+srb*pcd;mvc=src*pca+srd*pcc;mvd=src*pcb+srd*pcd;mve=sre*pca+srf*pcc+pce;mvf=sre*pcb+srf*pcd+pcf;}else{mva=sra*cma+srb*cmc;mvb=sra*cmb+srb*cmd;mvc=src*cma+srd*cmc;mvd=src*cmb+srd*cmd;mve=sre*cma+srf*cmc+cme;mvf=sre*cmb+srf*cmd+cmf;}var pathArrayIndex;var pathArrayLength;pathArray.length=0;for(var cmdIndex=0,cmdLength=commands.length;cmdIndex<cmdLength;++cmdIndex){cmd=commands[cmdIndex];switch(cmd){case Commands.ARC:iteration=0;x=commands[cmdIndex+1];y=commands[cmdIndex+2];radius=commands[cmdIndex+3];startAngle=commands[cmdIndex+4];endAngle=commands[cmdIndex+5];anticlockwise=commands[cmdIndex+6];if(lastPath===null){lastPath=new Path(x+cos(startAngle)*radius,y+sin(startAngle)*radius,lineWidth,lineColor,lineAlpha*alpha);pathArray.push(lastPath);iteration+=iterStep;}endAngle-=startAngle;if(anticlockwise){if(endAngle<-PI2){endAngle=-PI2;}else if(endAngle>0){endAngle=-PI2+endAngle%PI2;}}else if(endAngle>PI2){endAngle=PI2;}else if(endAngle<0){endAngle=PI2+endAngle%PI2;}while(iteration<1){ta=endAngle*iteration+startAngle;tx=x+cos(ta)*radius;ty=y+sin(ta)*radius;lastPath.points.push(new Point(tx,ty,lineWidth,lineColor,lineAlpha*alpha));iteration+=iterStep;}ta=endAngle+startAngle;tx=x+cos(ta)*radius;ty=y+sin(ta)*radius;lastPath.points.push(new Point(tx,ty,lineWidth,lineColor,lineAlpha*alpha));cmdIndex+=6;break;case Commands.LINE_STYLE:lineWidth=commands[cmdIndex+1];lineColor=commands[cmdIndex+2];lineAlpha=commands[cmdIndex+3];cmdIndex+=3;break;case Commands.FILL_STYLE:fillColor=commands[cmdIndex+1];fillAlpha=commands[cmdIndex+2];cmdIndex+=2;break;case Commands.BEGIN_PATH:pathArray.length=0;lastPath=null;break;case Commands.CLOSE_PATH:if(lastPath&&lastPath.points.length){lastPath.points.push(lastPath.points[0]);}break;case Commands.FILL_PATH:for(pathArrayIndex=0,pathArrayLength=pathArray.length;pathArrayIndex<pathArrayLength;++pathArrayIndex){this.batchFillPath(/* Graphics Game Object Properties */srcX,srcY,srcScaleX,srcScaleY,srcRotation,/* Rectangle properties */pathArray[pathArrayIndex].points,fillColor,fillAlpha*alpha,/* Transform */mva,mvb,mvc,mvd,mve,mvf,currentMatrix);}break;case Commands.STROKE_PATH:for(pathArrayIndex=0,pathArrayLength=pathArray.length;pathArrayIndex<pathArrayLength;++pathArrayIndex){path=pathArray[pathArrayIndex];this.batchStrokePath(/* Graphics Game Object Properties */srcX,srcY,srcScaleX,srcScaleY,srcRotation,/* Rectangle properties */path.points,lineWidth,lineColor,lineAlpha*alpha,/* Transform */mva,mvb,mvc,mvd,mve,mvf,path===this._lastPath,currentMatrix);}break;case Commands.FILL_RECT:this.batchFillRect(/* Graphics Game Object Properties */srcX,srcY,srcScaleX,srcScaleY,srcRotation,/* Rectangle properties */commands[cmdIndex+1],commands[cmdIndex+2],commands[cmdIndex+3],commands[cmdIndex+4],fillColor,fillAlpha*alpha,/* Transform */mva,mvb,mvc,mvd,mve,mvf,currentMatrix);cmdIndex+=4;break;case Commands.FILL_TRIANGLE:this.batchFillTriangle(/* Graphics Game Object Properties */srcX,srcY,srcScaleX,srcScaleY,srcRotation,/* Triangle properties */commands[cmdIndex+1],commands[cmdIndex+2],commands[cmdIndex+3],commands[cmdIndex+4],commands[cmdIndex+5],commands[cmdIndex+6],fillColor,fillAlpha*alpha,/* Transform */mva,mvb,mvc,mvd,mve,mvf,currentMatrix);cmdIndex+=6;break;case Commands.STROKE_TRIANGLE:this.batchStrokeTriangle(/* Graphics Game Object Properties */srcX,srcY,srcScaleX,srcScaleY,srcRotation,/* Triangle properties */commands[cmdIndex+1],commands[cmdIndex+2],commands[cmdIndex+3],commands[cmdIndex+4],commands[cmdIndex+5],commands[cmdIndex+6],lineWidth,lineColor,lineAlpha*alpha,/* Transform */mva,mvb,mvc,mvd,mve,mvf,currentMatrix);cmdIndex+=6;break;case Commands.LINE_TO:if(lastPath!==null){lastPath.points.push(new Point(commands[cmdIndex+1],commands[cmdIndex+2],lineWidth,lineColor,lineAlpha*alpha));}else{lastPath=new Path(commands[cmdIndex+1],commands[cmdIndex+2],lineWidth,lineColor,lineAlpha*alpha);pathArray.push(lastPath);}cmdIndex+=2;break;case Commands.MOVE_TO:lastPath=new Path(commands[cmdIndex+1],commands[cmdIndex+2],lineWidth,lineColor,lineAlpha*alpha);pathArray.push(lastPath);cmdIndex+=2;break;case Commands.LINE_FX_TO:if(lastPath!==null){lastPath.points.push(new Point(commands[cmdIndex+1],commands[cmdIndex+2],commands[cmdIndex+3],commands[cmdIndex+4],commands[cmdIndex+5]*alpha));}else{lastPath=new Path(commands[cmdIndex+1],commands[cmdIndex+2],commands[cmdIndex+3],commands[cmdIndex+4],commands[cmdIndex+5]*alpha);pathArray.push(lastPath);}cmdIndex+=5;break;case Commands.MOVE_FX_TO:lastPath=new Path(commands[cmdIndex+1],commands[cmdIndex+2],commands[cmdIndex+3],commands[cmdIndex+4],commands[cmdIndex+5]*alpha);pathArray.push(lastPath);cmdIndex+=5;break;case Commands.SAVE:matrixStack[matrixStackLength+0]=currentMatrix[0];matrixStack[matrixStackLength+1]=currentMatrix[1];matrixStack[matrixStackLength+2]=currentMatrix[2];matrixStack[matrixStackLength+3]=currentMatrix[3];matrixStack[matrixStackLength+4]=currentMatrix[4];matrixStack[matrixStackLength+5]=currentMatrix[5];matrixStackLength+=6;break;case Commands.RESTORE:matrixStackLength-=6;currentMatrix[0]=matrixStack[matrixStackLength+0];currentMatrix[1]=matrixStack[matrixStackLength+1];currentMatrix[2]=matrixStack[matrixStackLength+2];currentMatrix[3]=matrixStack[matrixStackLength+3];currentMatrix[4]=matrixStack[matrixStackLength+4];currentMatrix[5]=matrixStack[matrixStackLength+5];break;case Commands.TRANSLATE:x=commands[cmdIndex+1];y=commands[cmdIndex+2];currentMatrix[4]=currentMatrix[0]*x+currentMatrix[2]*y+currentMatrix[4];currentMatrix[5]=currentMatrix[1]*x+currentMatrix[3]*y+currentMatrix[5];cmdIndex+=2;break;case Commands.SCALE:x=commands[cmdIndex+1];y=commands[cmdIndex+2];currentMatrix[0]*=x;currentMatrix[1]*=x;currentMatrix[2]*=y;currentMatrix[3]*=y;cmdIndex+=2;break;case Commands.ROTATE:y=commands[cmdIndex+1];x=sin(y);y=cos(y);sra=currentMatrix[0];srb=currentMatrix[1];src=currentMatrix[2];srd=currentMatrix[3];currentMatrix[0]=y*sra+x*src;currentMatrix[1]=y*srb+x*srd;currentMatrix[2]=-x*sra+y*src;currentMatrix[3]=-x*srb+y*srd;cmdIndex+=1;break;default:// eslint-disable-next-line no-console\nconsole.error('Phaser: Invalid Graphics Command ID '+cmd);break;}}},// Stubs\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#drawStaticTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.StaticTilemapLayer} tilemap - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */drawStaticTilemapLayer:function drawStaticTilemapLayer(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#drawEmitterManager\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */drawEmitterManager:function drawEmitterManager(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#drawBlitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Blitter} blitter - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */drawBlitter:function drawBlitter(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Sprite} sprite - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */batchSprite:function batchSprite(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchMesh\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Mesh} mesh - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */batchMesh:function batchMesh(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchBitmapText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.BitmapText} bitmapText - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */batchBitmapText:function batchBitmapText(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchDynamicBitmapText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.DynamicBitmapText} bitmapText - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */batchDynamicBitmapText:function batchDynamicBitmapText(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Text} text - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */batchText:function batchText(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchDynamicTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.DynamicTilemapLayer} tilemapLayer - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */batchDynamicTilemapLayer:function batchDynamicTilemapLayer(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.FlatTintPipeline#batchTileSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.TileSprite} tileSprite - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */batchTileSprite:function batchTileSprite(){}});module.exports=FlatTintPipeline;/***/},/* 386 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var ShaderSourceFS=__webpack_require__(844);var ShaderSourceVS=__webpack_require__(843);var WebGLPipeline=__webpack_require__(111);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class BitmapMaskPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberOf Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n */var BitmapMaskPipeline=new Class({Extends:WebGLPipeline,initialize:function BitmapMaskPipeline(config){WebGLPipeline.call(this,{game:config.game,renderer:config.renderer,gl:config.renderer.gl,topology:config.topology?config.topology:config.renderer.gl.TRIANGLES,vertShader:config.vertShader?config.vertShader:ShaderSourceVS,fragShader:config.fragShader?config.fragShader:ShaderSourceFS,vertexCapacity:config.vertexCapacity?config.vertexCapacity:3,vertexSize:config.vertexSize?config.vertexSize:Float32Array.BYTES_PER_ELEMENT*2,vertices:new Float32Array([-1,+1,-1,-7,+7,+1]).buffer,attributes:[{name:'inPosition',size:2,type:config.renderer.gl.FLOAT,normalized:false,offset:0}]});/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.BitmapMaskPipeline#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */this.vertexViewF32=new Float32Array(this.vertexData);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.BitmapMaskPipeline#maxQuads\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.maxQuads=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.BitmapMaskPipeline#resolutionDirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.resolutionDirty=true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.BitmapMaskPipeline#onBind\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.BitmapMaskPipeline} [description]\r\n     */onBind:function onBind(){WebGLPipeline.prototype.onBind.call(this);var renderer=this.renderer;var program=this.program;if(this.resolutionDirty){renderer.setFloat2(program,'uResolution',this.width,this.height);renderer.setInt1(program,'uMainSampler',0);renderer.setInt1(program,'uMaskSampler',1);this.resolutionDirty=false;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.BitmapMaskPipeline#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} resolution - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.BitmapMaskPipeline} [description]\r\n     */resize:function resize(width,height,resolution){WebGLPipeline.prototype.resize.call(this,width,height,resolution);this.resolutionDirty=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.BitmapMaskPipeline#beginMask\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} mask - [description]\r\n     * @param {Phaser.GameObjects.GameObject} maskedObject - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */beginMask:function beginMask(mask,maskedObject,camera){var bitmapMask=mask.bitmapMask;var renderer=this.renderer;var gl=this.gl;var visible=bitmapMask.visible;if(bitmapMask&&gl){// First we clear the mask framebuffer\nrenderer.setFramebuffer(mask.maskFramebuffer);gl.clearColor(0,0,0,0);gl.clear(gl.COLOR_BUFFER_BIT);// We render out mask source\nbitmapMask.visible=true;bitmapMask.renderWebGL(renderer,bitmapMask,0.0,camera);bitmapMask.visible=visible;renderer.flush();// Bind and clear our main source (masked object)\nrenderer.setFramebuffer(mask.mainFramebuffer);gl.clearColor(0,0,0,0);gl.clear(gl.COLOR_BUFFER_BIT);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.BitmapMaskPipeline#endMask\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} mask - [description]\r\n     */endMask:function endMask(mask){var bitmapMask=mask.bitmapMask;var renderer=this.renderer;var gl=this.gl;if(bitmapMask){// Return to default framebuffer\nrenderer.setFramebuffer(null);// Bind bitmap mask pipeline and draw\nrenderer.setPipeline(this);renderer.setTexture2D(mask.maskTexture,1);renderer.setTexture2D(mask.mainTexture,0);renderer.setInt1(this.program,'uInvertMaskAlpha',mask.invertAlpha);// Finally draw a triangle filling the whole screen\ngl.drawArrays(this.topology,0,3);}}});module.exports=BitmapMaskPipeline;/***/},/* 387 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Renderer.Snapshot.WebGL\r\n * @since 3.0.0\r\n *\r\n * @param {HTMLCanvasElement} sourceCanvas - [description]\r\n * @param {string} [type='image/png'] - [description]\r\n * @param {float} [encoderOptions=0.92] - [description]\r\n *\r\n * @return {HTMLImageElement} [description]\r\n */var WebGLSnapshot=function WebGLSnapshot(sourceCanvas,type,encoderOptions){if(!type){type='image/png';}if(!encoderOptions){encoderOptions=0.92;}var gl=sourceCanvas.getContext('experimental-webgl');var pixels=new Uint8Array(gl.drawingBufferWidth*gl.drawingBufferHeight*4);gl.readPixels(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight,gl.RGBA,gl.UNSIGNED_BYTE,pixels);//  CanvasPool?\nvar canvas=document.createElement('canvas');var ctx=canvas.getContext('2d');var imageData;canvas.width=gl.drawingBufferWidth;canvas.height=gl.drawingBufferHeight;imageData=ctx.getImageData(0,0,canvas.width,canvas.height);var data=imageData.data;for(var y=0;y<canvas.height;y+=1){for(var x=0;x<canvas.width;x+=1){var si=((canvas.height-y)*canvas.width+x)*4;var di=(y*canvas.width+x)*4;data[di+0]=pixels[si+0];data[di+1]=pixels[si+1];data[di+2]=pixels[si+2];data[di+3]=pixels[si+3];}}ctx.putImageData(imageData,0,0);var src=canvas.toDataURL(type,encoderOptions);var image=new Image();image.src=src;return image;};module.exports=WebGLSnapshot;/***/},/* 388 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(22);var IsSizePowerOfTwo=__webpack_require__(151);var Utils=__webpack_require__(38);var WebGLSnapshot=__webpack_require__(387);// Default Pipelines\nvar BitmapMaskPipeline=__webpack_require__(386);var FlatTintPipeline=__webpack_require__(385);var ForwardDiffuseLightPipeline=__webpack_require__(180);var TextureTintPipeline=__webpack_require__(179);/**\r\n * @callback WebGLContextCallback\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - [description]\r\n *//**\r\n * @typedef {object} SnapshotState\r\n *\r\n * @property {SnapshotCallback} callback - [description]\r\n * @property {string} type - [description]\r\n * @property {float} encoder - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class WebGLRenderer\r\n * @memberOf Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - [description]\r\n */var WebGLRenderer=new Class({initialize:function WebGLRenderer(game){// eslint-disable-next-line consistent-this\nvar renderer=this;var gameConfig=game.config;var contextCreationConfig={alpha:gameConfig.transparent,depth:false,// enable when 3D is added in the future\nantialias:gameConfig.antialias,premultipliedAlpha:gameConfig.premultipliedAlpha,stencil:true,preserveDrawingBuffer:gameConfig.preserveDrawingBuffer,failIfMajorPerformanceCaveat:gameConfig.failIfMajorPerformanceCaveat,powerPreference:gameConfig.powerPreference};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#config\r\n         * @type {RendererConfig}\r\n         * @since 3.0.0\r\n         */this.config={clearBeforeRender:gameConfig.clearBeforeRender,pixelArt:gameConfig.pixelArt,backgroundColor:gameConfig.backgroundColor,contextCreation:contextCreationConfig,resolution:gameConfig.resolution,autoResize:gameConfig.autoResize,roundPixels:gameConfig.roundPixels};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#type\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.type=CONST.WEBGL;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=game.config.width;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=game.config.height;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */this.canvas=game.canvas;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#lostContextCallbacks\r\n         * @type {WebGLContextCallback[]}\r\n         * @since 3.0.0\r\n         */this.lostContextCallbacks=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#restoredContextCallbacks\r\n         * @type {WebGLContextCallback[]}\r\n         * @since 3.0.0\r\n         */this.restoredContextCallbacks=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#blendModes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.blendModes=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#nativeTextures\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.nativeTextures=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLost\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.contextLost=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#pipelines\r\n         * @type {object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.pipelines=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#snapshotState\r\n         * @type {SnapshotState}\r\n         * @since 3.0.0\r\n         */this.snapshotState={callback:null,type:null,encoder:null};// Internal Renderer State (Textures, Framebuffers, Pipelines, Buffers, etc)\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentActiveTextureUnit\r\n         * @type {integer}\r\n         * @since 3.1.0\r\n         */this.currentActiveTextureUnit=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentTextures\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.currentTextures=new Array(16);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentFramebuffer\r\n         * @type {WebGLFramebuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.currentFramebuffer=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentPipeline\r\n         * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.currentPipeline=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentProgram\r\n         * @type {WebGLProgram}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.currentProgram=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentVertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.currentVertexBuffer=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentIndexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.currentIndexBuffer=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentBlendMode\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.currentBlendMode=Infinity;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissorEnabled\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.currentScissorEnabled=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissor\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */this.currentScissor=new Uint32Array([0,0,this.width,this.height]);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissorIdx\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.currentScissorIdx=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#scissorStack\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */this.scissorStack=new Uint32Array(4*1000);// Setup context lost and restore event listeners\nthis.canvas.addEventListener('webglcontextlost',function(event){renderer.contextLost=true;event.preventDefault();for(var index=0;index<renderer.lostContextCallbacks.length;++index){var callback=renderer.lostContextCallbacks[index];callback[0].call(callback[1],renderer);}},false);this.canvas.addEventListener('webglcontextrestored',function(){renderer.contextLost=false;renderer.init(renderer.config);for(var index=0;index<renderer.restoredContextCallbacks.length;++index){var callback=renderer.restoredContextCallbacks[index];callback[0].call(callback[1],renderer);}},false);// This are initialized post context creation\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.gl=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#supportedExtensions\r\n         * @type {object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.supportedExtensions=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#extensions\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */this.extensions={};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFormats\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.2.0\r\n         */this.glFormats=[];this.init(this.config);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */init:function init(config){var canvas=this.canvas;var clearColor=config.backgroundColor;var gl=canvas.getContext('webgl',config.contextCreation)||canvas.getContext('experimental-webgl',config.contextCreation);if(!gl){this.contextLost=true;throw new Error('This browser does not support WebGL. Try using the Canvas pipeline.');}this.gl=gl;for(var i=0;i<=16;i++){this.blendModes.push({func:[gl.ONE,gl.ONE_MINUS_SRC_ALPHA],equation:gl.FUNC_ADD});}this.blendModes[1].func=[gl.ONE,gl.DST_ALPHA];this.blendModes[2].func=[gl.DST_COLOR,gl.ONE_MINUS_SRC_ALPHA];this.blendModes[3].func=[gl.ONE,gl.ONE_MINUS_SRC_COLOR];this.glFormats[0]=gl.BYTE;this.glFormats[1]=gl.SHORT;this.glFormats[2]=gl.UNSIGNED_BYTE;this.glFormats[3]=gl.UNSIGNED_SHORT;this.glFormats[4]=gl.FLOAT;// Load supported extensions\nthis.supportedExtensions=gl.getSupportedExtensions();// Setup initial WebGL state\ngl.disable(gl.DEPTH_TEST);gl.disable(gl.CULL_FACE);gl.disable(gl.SCISSOR_TEST);gl.enable(gl.BLEND);gl.clearColor(clearColor.redGL,clearColor.greenGL,clearColor.blueGL,1.0);// Initialize all textures to null\nfor(var index=0;index<this.currentTextures.length;++index){this.currentTextures[index]=null;}// Clear previous pipelines and reload default ones\nthis.pipelines={};this.addPipeline('TextureTintPipeline',new TextureTintPipeline({game:this.game,renderer:this}));this.addPipeline('FlatTintPipeline',new FlatTintPipeline({game:this.game,renderer:this}));this.addPipeline('BitmapMaskPipeline',new BitmapMaskPipeline({game:this.game,renderer:this}));this.addPipeline('Light2D',new ForwardDiffuseLightPipeline({game:this.game,renderer:this}));this.setBlendMode(CONST.BlendModes.NORMAL);this.resize(this.width,this.height);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */resize:function resize(width,height){var gl=this.gl;var pipelines=this.pipelines;var resolution=this.config.resolution;this.width=Math.floor(width*resolution);this.height=Math.floor(height*resolution);this.canvas.width=this.width;this.canvas.height=this.height;if(this.config.autoResize){this.canvas.style.width=this.width/resolution+'px';this.canvas.style.height=this.height/resolution+'px';}gl.viewport(0,0,this.width,this.height);// Update all registered pipelines\nfor(var pipelineName in pipelines){pipelines[pipelineName].resize(width,height,resolution);}this.currentScissor.set([0,0,this.width,this.height]);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#onContextRestored\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLContextCallback} callback - [description]\r\n     * @param {object} target - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */onContextRestored:function onContextRestored(callback,target){this.restoredContextCallbacks.push([callback,target]);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#onContextLost\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLContextCallback} callback - [description]\r\n     * @param {object} target - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */onContextLost:function onContextLost(callback,target){this.lostContextCallbacks.push([callback,target]);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasExtension\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} extensionName - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hasExtension:function hasExtension(extensionName){return this.supportedExtensions?this.supportedExtensions.indexOf(extensionName):false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getExtension\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} extensionName - [description]\r\n     *\r\n     * @return {object} [description]\r\n     */getExtension:function getExtension(extensionName){if(!this.hasExtension(extensionName)){return null;}if(!(extensionName in this.extensions)){this.extensions[extensionName]=this.gl.getExtension(extensionName);}return this.extensions[extensionName];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#flush\r\n     * @since 3.0.0\r\n     */flush:function flush(){if(this.currentPipeline){this.currentPipeline.flush();}},/* Renderer State Manipulation Functions *//**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hasPipeline:function hasPipeline(pipelineName){return pipelineName in this.pipelines;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */getPipeline:function getPipeline(pipelineName){return this.hasPipeline(pipelineName)?this.pipelines[pipelineName]:null;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#removePipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */removePipeline:function removePipeline(pipelineName){delete this.pipelines[pipelineName];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#addPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - [description]\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */addPipeline:function addPipeline(pipelineName,pipelineInstance){if(!this.hasPipeline(pipelineName)){this.pipelines[pipelineName]=pipelineInstance;}else{console.warn('Pipeline',pipelineName,' already exists.');}pipelineInstance.name=pipelineName;this.pipelines[pipelineName].resize(this.width,this.height,this.config.resolution);return pipelineInstance;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setScissor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} x - [description]\r\n     * @param {integer} y - [description]\r\n     * @param {integer} w - [description]\r\n     * @param {integer} h - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setScissor:function setScissor(x,y,w,h){var gl=this.gl;var currentScissor=this.currentScissor;var enabled=x===0&&y===0&&w===gl.canvas.width&&h===gl.canvas.height&&w>=0&&h>=0;if(currentScissor[0]!==x||currentScissor[1]!==y||currentScissor[2]!==w||currentScissor[3]!==h){this.flush();}currentScissor[0]=x;currentScissor[1]=y;currentScissor[2]=w;currentScissor[3]=h;this.currentScissorEnabled=enabled;if(enabled){gl.disable(gl.SCISSOR_TEST);return this;}gl.enable(gl.SCISSOR_TEST);gl.scissor(x,gl.drawingBufferHeight-y-h,w,h);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#pushScissor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} x - [description]\r\n     * @param {integer} y - [description]\r\n     * @param {integer} w - [description]\r\n     * @param {integer} h - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */pushScissor:function pushScissor(x,y,w,h){var scissorStack=this.scissorStack;var stackIndex=this.currentScissorIdx;var currentScissor=this.currentScissor;scissorStack[stackIndex+0]=currentScissor[0];scissorStack[stackIndex+1]=currentScissor[1];scissorStack[stackIndex+2]=currentScissor[2];scissorStack[stackIndex+3]=currentScissor[3];this.currentScissorIdx+=4;this.setScissor(x,y,w,h);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#popScissor\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */popScissor:function popScissor(){var scissorStack=this.scissorStack;var stackIndex=this.currentScissorIdx-4;var x=scissorStack[stackIndex+0];var y=scissorStack[stackIndex+1];var w=scissorStack[stackIndex+2];var h=scissorStack[stackIndex+3];this.currentScissorIdx=stackIndex;this.setScissor(x,y,w,h);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} [description]\r\n     */setPipeline:function setPipeline(pipelineInstance){if(this.currentPipeline!==pipelineInstance||this.currentPipeline.vertexBuffer!==this.currentVertexBuffer||this.currentPipeline.program!==this.currentProgram){this.flush();this.currentPipeline=pipelineInstance;this.currentPipeline.bind();}this.currentPipeline.onBind();return this.currentPipeline;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} blendModeId - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setBlendMode:function setBlendMode(blendModeId){var gl=this.gl;var blendMode=this.blendModes[blendModeId];if(blendModeId!==CONST.BlendModes.SKIP_CHECK&&this.currentBlendMode!==blendModeId){this.flush();gl.enable(gl.BLEND);gl.blendEquation(blendMode.equation);if(blendMode.func.length>2){gl.blendFuncSeparate(blendMode.func[0],blendMode.func[1],blendMode.func[2],blendMode.func[3]);}else{gl.blendFunc(blendMode.func[0],blendMode.func[1]);}this.currentBlendMode=blendModeId;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#addBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} func - [description]\r\n     * @param {function} equation - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */addBlendMode:function addBlendMode(func,equation){var index=this.blendModes.push({func:func,equation:equation});return index-1;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - [description]\r\n     * @param {function} func - [description]\r\n     * @param {function} equation - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */updateBlendMode:function updateBlendMode(index,func,equation){if(this.blendModes[index]){this.blendModes[index].func=func;if(equation){this.blendModes[index].equation=equation;}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#removeBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */removeBlendMode:function removeBlendMode(index){if(index>16&&this.blendModes[index]){this.blendModes.splice(index,1);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTexture2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLTexture} texture - [description]\r\n     * @param {integer} textureUnit - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */setTexture2D:function setTexture2D(texture,textureUnit){var gl=this.gl;if(texture!==this.currentTextures[textureUnit]){this.flush();if(this.currentActiveTextureUnit!==textureUnit){gl.activeTexture(gl.TEXTURE0+textureUnit);this.currentActiveTextureUnit=textureUnit;}gl.bindTexture(gl.TEXTURE_2D,texture);this.currentTextures[textureUnit]=texture;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */setFramebuffer:function setFramebuffer(framebuffer){var gl=this.gl;if(framebuffer!==this.currentFramebuffer){this.flush();gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);this.currentFramebuffer=framebuffer;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */setProgram:function setProgram(program){var gl=this.gl;if(program!==this.currentProgram){this.flush();gl.useProgram(program);this.currentProgram=program;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setVertexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} vertexBuffer - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */setVertexBuffer:function setVertexBuffer(vertexBuffer){var gl=this.gl;if(vertexBuffer!==this.currentVertexBuffer){this.flush();gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);this.currentVertexBuffer=vertexBuffer;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setIndexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} indexBuffer - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */setIndexBuffer:function setIndexBuffer(indexBuffer){var gl=this.gl;if(indexBuffer!==this.currentIndexBuffer){this.flush();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);this.currentIndexBuffer=indexBuffer;}return this;},/* Renderer Resource Creation Functions *//**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTextureFromSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - [description]\r\n     * @param {integer} width - [description]\r\n     * @param {integer} height - [description]\r\n     * @param {integer} scaleMode - [description]\r\n     *\r\n     * @return {WebGLTexture} [description]\r\n     */createTextureFromSource:function createTextureFromSource(source,width,height,scaleMode){var gl=this.gl;var filter=gl.NEAREST;var wrap=gl.CLAMP_TO_EDGE;var texture=null;width=source?source.width:width;height=source?source.height:height;if(IsSizePowerOfTwo(width,height)){wrap=gl.REPEAT;}if(scaleMode===CONST.ScaleModes.LINEAR){filter=gl.LINEAR;}else if(scaleMode===CONST.ScaleModes.NEAREST||this.config.pixelArt){filter=gl.NEAREST;}if(!source&&typeof width==='number'&&typeof height==='number'){texture=this.createTexture2D(0,filter,filter,wrap,wrap,gl.RGBA,null,width,height);}else{texture=this.createTexture2D(0,filter,filter,wrap,wrap,gl.RGBA,source);}return texture;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTexture2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} mipLevel - [description]\r\n     * @param {integer} minFilter - [description]\r\n     * @param {integer} magFilter - [description]\r\n     * @param {integer} wrapT - [description]\r\n     * @param {integer} wrapS - [description]\r\n     * @param {integer} format - [description]\r\n     * @param {object} pixels - [description]\r\n     * @param {integer} width - [description]\r\n     * @param {integer} height - [description]\r\n     * @param {boolean} pma - [description]\r\n     *\r\n     * @return {WebGLTexture} [description]\r\n     */createTexture2D:function createTexture2D(mipLevel,minFilter,magFilter,wrapT,wrapS,format,pixels,width,height,pma){var gl=this.gl;var texture=gl.createTexture();pma=pma===undefined||pma===null?true:pma;this.setTexture2D(texture,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,minFilter);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,magFilter);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,wrapS);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,wrapT);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,pma);if(pixels===null||pixels===undefined){gl.texImage2D(gl.TEXTURE_2D,mipLevel,format,width,height,0,format,gl.UNSIGNED_BYTE,null);}else{gl.texImage2D(gl.TEXTURE_2D,mipLevel,format,format,gl.UNSIGNED_BYTE,pixels);width=pixels.width;height=pixels.height;}this.setTexture2D(null,0);texture.isAlphaPremultiplied=pma;texture.isRenderTexture=false;texture.width=width;texture.height=height;this.nativeTextures.push(texture);return texture;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} width - [description]\r\n     * @param {integer} height - [description]\r\n     * @param {WebGLFramebuffer} renderTexture - [description]\r\n     * @param {boolean} addDepthStencilBuffer - [description]\r\n     *\r\n     * @return {WebGLFramebuffer} [description]\r\n     */createFramebuffer:function createFramebuffer(width,height,renderTexture,addDepthStencilBuffer){var gl=this.gl;var framebuffer=gl.createFramebuffer();var complete=0;this.setFramebuffer(framebuffer);if(addDepthStencilBuffer){var depthStencilBuffer=gl.createRenderbuffer();gl.bindRenderbuffer(gl.RENDERBUFFER,depthStencilBuffer);gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_STENCIL,width,height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,gl.RENDERBUFFER,depthStencilBuffer);}renderTexture.isRenderTexture=true;renderTexture.isAlphaPremultiplied=false;gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,renderTexture,0);complete=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(complete!==gl.FRAMEBUFFER_COMPLETE){var errors={36054:'Incomplete Attachment',36055:'Missing Attachment',36057:'Incomplete Dimensions',36061:'Framebuffer Unsupported'};throw new Error('Framebuffer incomplete. Framebuffer status: '+errors[complete]);}framebuffer.renderTexture=renderTexture;this.setFramebuffer(null);return framebuffer;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} vertexShader - [description]\r\n     * @param {string} fragmentShader - [description]\r\n     *\r\n     * @return {WebGLProgram} [description]\r\n     */createProgram:function createProgram(vertexShader,fragmentShader){var gl=this.gl;var program=gl.createProgram();var vs=gl.createShader(gl.VERTEX_SHADER);var fs=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(vs,vertexShader);gl.shaderSource(fs,fragmentShader);gl.compileShader(vs);gl.compileShader(fs);if(!gl.getShaderParameter(vs,gl.COMPILE_STATUS)){throw new Error('Failed to compile Vertex Shader:\\n'+gl.getShaderInfoLog(vs));}if(!gl.getShaderParameter(fs,gl.COMPILE_STATUS)){throw new Error('Failed to compile Fragment Shader:\\n'+gl.getShaderInfoLog(fs));}gl.attachShader(program,vs);gl.attachShader(program,fs);gl.linkProgram(program);if(!gl.getProgramParameter(program,gl.LINK_STATUS)){throw new Error('Failed to link program:\\n'+gl.getProgramInfoLog(program));}return program;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createVertexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArrayBuffer} initialDataOrSize - [description]\r\n     * @param {integer} bufferUsage - [description]\r\n     *\r\n     * @return {WebGLBuffer} [description]\r\n     */createVertexBuffer:function createVertexBuffer(initialDataOrSize,bufferUsage){var gl=this.gl;var vertexBuffer=gl.createBuffer();this.setVertexBuffer(vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,initialDataOrSize,bufferUsage);this.setVertexBuffer(null);return vertexBuffer;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createIndexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArrayBuffer} initialDataOrSize - [description]\r\n     * @param {integer} bufferUsage - [description]\r\n     *\r\n     * @return {WebGLBuffer} [description]\r\n     */createIndexBuffer:function createIndexBuffer(initialDataOrSize,bufferUsage){var gl=this.gl;var indexBuffer=gl.createBuffer();this.setIndexBuffer(indexBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,initialDataOrSize,bufferUsage);this.setIndexBuffer(null);return indexBuffer;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLTexture} texture - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */deleteTexture:function deleteTexture(texture){this.gl.deleteTexture(texture);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */deleteFramebuffer:function deleteFramebuffer(framebuffer){this.gl.deleteFramebuffer(framebuffer);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */deleteProgram:function deleteProgram(program){this.gl.deleteProgram(program);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} vertexBuffer - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} This WebGL Renderer.\r\n     */deleteBuffer:function deleteBuffer(buffer){this.gl.deleteBuffer(buffer);return this;},/* Rendering Functions *//**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRenderCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */preRenderCamera:function preRenderCamera(camera){var resolution=this.config.resolution;var cx=Math.floor(camera.x*resolution);var cy=Math.floor(camera.y*resolution);var cw=Math.floor(camera.width*resolution);var ch=Math.floor(camera.height*resolution);this.pushScissor(cx,cy,cw,ch);if(camera.backgroundColor.alphaGL>0){var color=camera.backgroundColor;var FlatTintPipeline=this.pipelines.FlatTintPipeline;FlatTintPipeline.batchFillRect(0,0,1,1,0,camera.x,camera.y,camera.width,camera.height,Utils.getTintFromFloats(color.redGL,color.greenGL,color.blueGL,1.0),color.alphaGL,1,0,0,1,0,0,[1,0,0,1,0,0]);FlatTintPipeline.flush();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRenderCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */postRenderCamera:function postRenderCamera(camera){if(camera._fadeAlpha>0||camera._flashAlpha>0){var FlatTintPipeline=this.pipelines.FlatTintPipeline;// Fade\nFlatTintPipeline.batchFillRect(0,0,1,1,0,camera.x,camera.y,camera.width,camera.height,Utils.getTintFromFloats(camera._fadeRed,camera._fadeGreen,camera._fadeBlue,1.0),camera._fadeAlpha,1,0,0,1,0,0,[1,0,0,1,0,0]);// Flash\nFlatTintPipeline.batchFillRect(0,0,1,1,0,camera.x,camera.y,camera.width,camera.height,Utils.getTintFromFloats(camera._flashRed,camera._flashGreen,camera._flashBlue,1.0),camera._flashAlpha,1,0,0,1,0,0,[1,0,0,1,0,0]);FlatTintPipeline.flush();}this.popScissor();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRender\r\n     * @since 3.0.0\r\n     */preRender:function preRender(){if(this.contextLost){return;}var gl=this.gl;var color=this.config.backgroundColor;var pipelines=this.pipelines;// Bind custom framebuffer here\ngl.clearColor(color.redGL,color.greenGL,color.blueGL,color.alphaGL);if(this.config.clearBeforeRender){gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT|gl.STENCIL_BUFFER_BIT);}for(var key in pipelines){pipelines[key].onPreRender();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - [description]\r\n     * @param {Phaser.GameObjects.GameObject} children - [description]\r\n     * @param {number} interpolationPercentage - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */render:function render(scene,children,interpolationPercentage,camera){if(this.contextLost){return;}var list=children.list;var childCount=list.length;var pipelines=this.pipelines;for(var key in pipelines){pipelines[key].onRender(scene,camera);}this.preRenderCamera(camera);for(var index=0;index<childCount;++index){var child=list[index];if(!child.willRender()){continue;}if(child.blendMode!==this.currentBlendMode){this.setBlendMode(child.blendMode);}if(child.mask){child.mask.preRenderWebGL(this,child,camera);}child.renderWebGL(this,child,interpolationPercentage,camera);if(child.mask){child.mask.postRenderWebGL(this,child);}}this.flush();this.setBlendMode(CONST.BlendModes.NORMAL);this.postRenderCamera(camera);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRender\r\n     * @since 3.0.0\r\n     */postRender:function postRender(){if(this.contextLost){return;}// Unbind custom framebuffer here\nif(this.snapshotState.callback){this.snapshotState.callback(WebGLSnapshot(this.canvas,this.snapshotState.type,this.snapshotState.encoder));this.snapshotState.callback=null;}var pipelines=this.pipelines;for(var key in pipelines){pipelines[key].onPostRender();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {SnapshotCallback} callback - [description]\r\n     * @param {string} type - [description]\r\n     * @param {float} encoderOptions - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */snapshot:function snapshot(callback,type,encoderOptions){this.snapshotState.callback=callback;this.snapshotState.type=type;this.snapshotState.encoder=encoderOptions;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#canvasToTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {HTMLCanvasElement} srcCanvas - [description]\r\n     * @param {WebGLTexture} dstTexture - [description]\r\n     * @param {boolean} shouldReallocate - [description]\r\n     * @param {integer} scaleMode - [description]\r\n     *\r\n     * @return {WebGLTexture} [description]\r\n     */canvasToTexture:function canvasToTexture(srcCanvas,dstTexture){var gl=this.gl;if(!dstTexture){var wrapping=gl.CLAMP_TO_EDGE;if(IsSizePowerOfTwo(srcCanvas.width,srcCanvas.height)){wrapping=gl.REPEAT;}dstTexture=this.createTexture2D(0,gl.NEAREST,gl.NEAREST,wrapping,wrapping,gl.RGBA,srcCanvas,srcCanvas.width,srcCanvas.height,true);}else{this.setTexture2D(dstTexture,0);// if (!shouldReallocate && dstTexture.width >= srcCanvas.width || dstTexture.height >= srcCanvas.height)\n// {\n//    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, srcCanvas.width, srcCanvas.height, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);\n// }\n// else\n{gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,srcCanvas);dstTexture.width=srcCanvas.width;dstTexture.height=srcCanvas.height;}this.setTexture2D(null,0);}return dstTexture;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureFilter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} texture - [description]\r\n     * @param {integer} filter - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setTextureFilter:function setTextureFilter(texture,filter){var gl=this.gl;var glFilter=[gl.LINEAR,gl.NEAREST][filter];this.setTexture2D(texture,0);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,glFilter);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,glFilter);this.setTexture2D(null,0);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {float} x - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setFloat1:function setFloat1(program,name,x){this.setProgram(program);this.gl.uniform1f(this.gl.getUniformLocation(program,name),x);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {float} x - [description]\r\n     * @param {float} y - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setFloat2:function setFloat2(program,name,x,y){this.setProgram(program);this.gl.uniform2f(this.gl.getUniformLocation(program,name),x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {float} x - [description]\r\n     * @param {float} y - [description]\r\n     * @param {float} z - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setFloat3:function setFloat3(program,name,x,y,z){this.setProgram(program);this.gl.uniform3f(this.gl.getUniformLocation(program,name),x,y,z);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {float} x - [description]\r\n     * @param {float} y - [description]\r\n     * @param {float} z - [description]\r\n     * @param {float} w - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setFloat4:function setFloat4(program,name,x,y,z,w){this.setProgram(program);this.gl.uniform4f(this.gl.getUniformLocation(program,name),x,y,z,w);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt1\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {integer} x - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setInt1:function setInt1(program,name,x){this.setProgram(program);this.gl.uniform1i(this.gl.getUniformLocation(program,name),x);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {integer} x - [description]\r\n     * @param {integer} y - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setInt2:function setInt2(program,name,x,y){this.setProgram(program);this.gl.uniform2i(this.gl.getUniformLocation(program,name),x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {integer} x - [description]\r\n     * @param {integer} y - [description]\r\n     * @param {integer} z - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setInt3:function setInt3(program,name,x,y,z){this.setProgram(program);this.gl.uniform3i(this.gl.getUniformLocation(program,name),x,y,z);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {integer} x - [description]\r\n     * @param {integer} y - [description]\r\n     * @param {integer} z - [description]\r\n     * @param {integer} w - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setInt4:function setInt4(program,name,x,y,z,w){this.setProgram(program);this.gl.uniform4i(this.gl.getUniformLocation(program,name),x,y,z,w);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {boolean} transpose - [description]\r\n     * @param {Float32Array} matrix - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setMatrix2:function setMatrix2(program,name,transpose,matrix){this.setProgram(program);this.gl.uniformMatrix2fv(this.gl.getUniformLocation(program,name),transpose,matrix);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {boolean} transpose - [description]\r\n     * @param {Float32Array} matrix - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setMatrix3:function setMatrix3(program,name,transpose,matrix){this.setProgram(program);this.gl.uniformMatrix3fv(this.gl.getUniformLocation(program,name),transpose,matrix);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - [description]\r\n     * @param {string} name - [description]\r\n     * @param {boolean} transpose - [description]\r\n     * @param {Float32Array} matrix - [description]\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLRenderer} [description]\r\n     */setMatrix4:function setMatrix4(program,name,transpose,matrix){this.setProgram(program);this.gl.uniformMatrix4fv(this.gl.getUniformLocation(program,name),transpose,matrix);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){//  Clear-up anything that should be cleared :)\nfor(var key in this.pipelines){this.pipelines[key].destroy();delete this.pipelines[key];}for(var index=0;index<this.nativeTextures.length;++index){this.deleteTexture(this.nativeTextures[index]);delete this.nativeTextures[index];}if(this.hasExtension('WEBGL_lose_context')){this.getExtension('WEBGL_lose_context').loseContext();}delete this.gl;delete this.game;this.contextLost=true;this.extensions={};this.nativeTextures.length=0;}});module.exports=WebGLRenderer;/***/},/* 389 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var modes=__webpack_require__(64);var CanvasFeatures=__webpack_require__(314);/**\r\n * [description]\r\n *\r\n * @function Phaser.Renderer.Canvas.GetBlendModes\r\n * @since 3.0.0\r\n *\r\n * @return {array} [description]\r\n */var GetBlendModes=function GetBlendModes(){var output=[];var useNew=CanvasFeatures.supportNewBlendModes;output[modes.NORMAL]='source-over';output[modes.ADD]='lighter';output[modes.MULTIPLY]=useNew?'multiply':'source-over';output[modes.SCREEN]=useNew?'screen':'source-over';output[modes.OVERLAY]=useNew?'overlay':'source-over';output[modes.DARKEN]=useNew?'darken':'source-over';output[modes.LIGHTEN]=useNew?'lighten':'source-over';output[modes.COLOR_DODGE]=useNew?'color-dodge':'source-over';output[modes.COLOR_BURN]=useNew?'color-burn':'source-over';output[modes.HARD_LIGHT]=useNew?'hard-light':'source-over';output[modes.SOFT_LIGHT]=useNew?'soft-light':'source-over';output[modes.DIFFERENCE]=useNew?'difference':'source-over';output[modes.EXCLUSION]=useNew?'exclusion':'source-over';output[modes.HUE]=useNew?'hue':'source-over';output[modes.SATURATION]=useNew?'saturation':'source-over';output[modes.COLOR]=useNew?'color':'source-over';output[modes.LUMINOSITY]=useNew?'luminosity':'source-over';return output;};module.exports=GetBlendModes;/***/},/* 390 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var roundPixels=false;/**\r\n * [description]\r\n *\r\n * @function Phaser.Renderer.Canvas.DrawImage\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} src - [description]\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - [description]\r\n */var DrawImage=function DrawImage(src,camera,parentMatrix){var ctx=this.currentContext;var frame=src.frame;var cd=frame.canvasData;//  Blend Mode\nif(this.currentBlendMode!==src.blendMode){this.currentBlendMode=src.blendMode;ctx.globalCompositeOperation=this.blendModes[src.blendMode];}//  Alpha\nif(this.currentAlpha!==src.alpha){this.currentAlpha=src.alpha;ctx.globalAlpha=src.alpha;}//  Smoothing\nif(this.currentScaleMode!==src.scaleMode){this.currentScaleMode=src.scaleMode;// ctx[this.smoothProperty] = (source.scaleMode === ScaleModes.LINEAR);\n}var dx=frame.x;var dy=frame.y;var fx=1;var fy=1;if(src.flipX){fx=-1;dx-=cd.dWidth-src.displayOriginX;}else{dx-=src.displayOriginX;}if(src.flipY){fy=-1;dy-=cd.dHeight-src.displayOriginY;}else{dy-=src.displayOriginY;}var tx=src.x-camera.scrollX*src.scrollFactorX;var ty=src.y-camera.scrollY*src.scrollFactorY;if(roundPixels){tx|=0;ty|=0;dx|=0;dy|=0;}//  Perform Matrix ITRS\nctx.save();if(parentMatrix){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}ctx.translate(tx,ty);ctx.rotate(src.rotation);ctx.scale(src.scaleX,src.scaleY);ctx.scale(fx,fy);ctx.drawImage(frame.source.image,cd.sx,cd.sy,cd.sWidth,cd.sHeight,dx,dy,cd.dWidth,cd.dHeight);ctx.restore();};//  Special return so we can store the config value locally\nmodule.exports=function(configRoundPixels){roundPixels=configRoundPixels;return DrawImage;};/***/},/* 391 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Renderer.Snapshot.Canvas\r\n * @since 3.0.0\r\n *\r\n * @param {HTMLCanvasElement} canvas - [description]\r\n * @param {string} [type='image/png'] - [description]\r\n * @param {float} [encoderOptions=0.92] - [description]\r\n *\r\n * @return {HTMLImageElement} [description]\r\n */var CanvasSnapshot=function CanvasSnapshot(canvas,type,encoderOptions){if(type===undefined){type='image/png';}if(encoderOptions===undefined){encoderOptions=0.92;}var src=canvas.toDataURL(type,encoderOptions);var image=new Image();image.src=src;return image;};module.exports=CanvasSnapshot;/***/},/* 392 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var roundPixels=false;/**\r\n * No scaling, anchor, rotation or effects, literally draws the frame directly to the canvas.\r\n *\r\n * @function Phaser.Renderer.Canvas.BlitImage\r\n * @since 3.0.0\r\n *\r\n * @param {number} dx - The x coordinate to render the Frame to.\r\n * @param {number} dy - The y coordinate to render the Frame to.\r\n * @param {Phaser.Textures.Frame} frame - The Frame to render.\r\n */var BlitImage=function BlitImage(dx,dy,frame){var ctx=this.currentContext;var cd=frame.canvasData;if(roundPixels){dx|=0;dy|=0;}ctx.drawImage(frame.source.image,cd.sx,cd.sy,cd.sWidth,cd.sHeight,dx,dy,cd.dWidth,cd.dHeight);};//  Special return so we can store the config value locally\nmodule.exports=function(configRoundPixels){roundPixels=configRoundPixels;return BlitImage;};/***/},/* 393 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BlitImage=__webpack_require__(392);var CanvasSnapshot=__webpack_require__(391);var Class=__webpack_require__(0);var CONST=__webpack_require__(22);var DrawImage=__webpack_require__(390);var GetBlendModes=__webpack_require__(389);var ScaleModes=__webpack_require__(82);var Smoothing=__webpack_require__(158);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CanvasRenderer\r\n * @memberOf Phaser.Renderer.Canvas\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser Game instance that owns this renderer.\r\n */var CanvasRenderer=new Class({initialize:function CanvasRenderer(game){/**\r\n         * The Phaser Game instance that owns this renderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#type\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.type=CONST.CANVAS;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#drawCount\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.drawCount=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=game.config.width;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=game.config.height;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#config\r\n         * @type {RendererConfig}\r\n         * @since 3.0.0\r\n         */this.config={clearBeforeRender:game.config.clearBeforeRender,pixelArt:game.config.pixelArt,backgroundColor:game.config.backgroundColor,resolution:game.config.resolution,autoResize:game.config.autoResize,roundPixels:game.config.roundPixels};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#scaleMode\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.scaleMode=game.config.pixelArt?ScaleModes.NEAREST:ScaleModes.LINEAR;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */this.gameCanvas=game.canvas;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */this.gameContext=this.gameCanvas.getContext('2d');/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */this.currentContext=this.gameContext;/**\r\n         * Map to the required function.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#drawImage\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */this.drawImage=DrawImage(this.config.roundPixels);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#blitImage\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */this.blitImage=BlitImage(this.config.roundPixels);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#blendModes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.blendModes=GetBlendModes();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.currentAlpha=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentBlendMode\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.currentBlendMode=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentScaleMode\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.currentScaleMode=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotCallback\r\n         * @type {?SnapshotCallback}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.snapshotCallback=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotType\r\n         * @type {?string}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.snapshotType=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotEncoder\r\n         * @type {?number}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.snapshotEncoder=null;this.init();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#init\r\n     * @since 3.0.0\r\n     */init:function init(){this.resize(this.width,this.height);},/**\r\n     * Resize the main game canvas.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} width - [description]\r\n     * @param {integer} height - [description]\r\n     */resize:function resize(width,height){var resolution=this.config.resolution;this.width=width*resolution;this.height=height*resolution;this.gameCanvas.width=this.width;this.gameCanvas.height=this.height;if(this.config.autoResize){this.gameCanvas.style.width=this.width/resolution+'px';this.gameCanvas.style.height=this.height/resolution+'px';}//  Resizing a canvas will reset imageSmoothingEnabled (and probably other properties)\nif(this.scaleMode===ScaleModes.NEAREST){Smoothing.disable(this.gameContext);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#onContextLost\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - [description]\r\n     */onContextLost:function onContextLost(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#onContextRestored\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - [description]\r\n     */onContextRestored:function onContextRestored(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#resetTransform\r\n     * @since 3.0.0\r\n     */resetTransform:function resetTransform(){this.currentContext.setTransform(1,0,0,1,0,0);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} blendMode - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */setBlendMode:function setBlendMode(blendMode){if(this.currentBlendMode!==blendMode){this.currentContext.globalCompositeOperation=blendMode;this.currentBlendMode=blendMode;}return this.currentBlendMode;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} alpha - [description]\r\n     *\r\n     * @return {float} [description]\r\n     */setAlpha:function setAlpha(alpha){if(this.currentAlpha!==alpha){this.currentContext.globalAlpha=alpha;this.currentAlpha=alpha;}return this.currentAlpha;},/**\r\n     * Called at the start of the render loop.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#preRender\r\n     * @since 3.0.0\r\n     */preRender:function preRender(){var ctx=this.gameContext;var config=this.config;var width=this.width;var height=this.height;if(config.clearBeforeRender){ctx.clearRect(0,0,width,height);}if(!config.transparent){ctx.fillStyle=config.backgroundColor.rgba;ctx.fillRect(0,0,width,height);}this.drawCount=0;},/**\r\n     * Renders the Scene to the given Camera.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - [description]\r\n     * @param {Phaser.GameObjects.DisplayList} children - [description]\r\n     * @param {float} interpolationPercentage - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */render:function render(scene,children,interpolationPercentage,camera){var ctx=scene.sys.context;var scissor=camera.x!==0||camera.y!==0||camera.width!==ctx.canvas.width||camera.height!==ctx.canvas.height;var list=children.list;var resolution=this.config.resolution;this.currentContext=ctx;//  If the alpha or blend mode didn't change since the last render, then don't set them again (saves 2 ops)\nif(!camera.transparent){ctx.fillStyle=camera.backgroundColor.rgba;ctx.fillRect(camera.x,camera.y,camera.width,camera.height);}if(this.currentAlpha!==1){ctx.globalAlpha=1;this.currentAlpha=1;}if(this.currentBlendMode!==0){ctx.globalCompositeOperation='source-over';this.currentBlendMode=0;}this.currentScaleMode=0;this.drawCount+=list.length;if(scissor){ctx.save();ctx.beginPath();ctx.rect(camera.x*resolution,camera.y*resolution,camera.width*resolution,camera.height*resolution);ctx.clip();}var matrix=camera.matrix.matrix;ctx.setTransform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);for(var c=0;c<list.length;c++){var child=list[c];if(child.mask){child.mask.preRenderCanvas(this,child,camera);}child.renderCanvas(this,child,interpolationPercentage,camera);if(child.mask){child.mask.postRenderCanvas(this,child,camera);}}ctx.setTransform(1,0,0,1,0,0);ctx.globalCompositeOperation='source-over';if(camera._fadeAlpha>0){// fade rendering\nctx.fillStyle='rgba('+camera._fadeRed*255+','+camera._fadeGreen*255+','+camera._fadeBlue*255+','+camera._fadeAlpha+')';ctx.fillRect(camera.x,camera.y,camera.width,camera.height);}if(camera._flashAlpha>0){// flash rendering\nctx.fillStyle='rgba('+camera._flashRed*255+','+camera._flashGreen*255+','+camera._flashBlue*255+','+camera._flashAlpha+')';ctx.fillRect(camera.x,camera.y,camera.width,camera.height);}//  Reset the camera scissor\nif(scissor){ctx.restore();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#postRender\r\n     * @since 3.0.0\r\n     */postRender:function postRender(){var ctx=this.gameContext;ctx.globalAlpha=1;ctx.globalCompositeOperation='source-over';this.currentAlpha=1;this.currentBlendMode=0;if(this.snapshotCallback){this.snapshotCallback(CanvasSnapshot(this.gameCanvas,this.snapshotType,this.snapshotEncoder));this.snapshotCallback=null;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {SnapshotCallback} callback - [description]\r\n     * @param {string} type - [description]\r\n     * @param {number} encoderOptions - [description]\r\n     */snapshot:function snapshot(callback,type,encoderOptions){this.snapshotCallback=callback;this.snapshotType=type;this.snapshotEncoder=encoderOptions;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.gameCanvas=null;this.gameContext=null;this.game=null;}});module.exports=CanvasRenderer;/***/},/* 394 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * This event is dispatched when an animation starts playing.\r\n *\r\n * @event Phaser.GameObjects.Components.Animation#onStartEvent\r\n * @param {Phaser.Animations.Animation} animation - Reference to the currently playing animation.\r\n * @param {Phaser.Animations.AnimationFrame} frame - Reference to the current Animation Frame.\r\n *//**\r\n * This event is dispatched when an animation repeats.\r\n *\r\n * @event Phaser.GameObjects.Components.Animation#onRepeatEvent\r\n * @param {Phaser.Animations.Animation} animation - Reference to the currently playing animation.\r\n * @param {Phaser.Animations.AnimationFrame} frame - Reference to the current Animation Frame.\r\n * @param {integer} repeatCount - The number of times this animation has repeated.\r\n *//**\r\n * This event is dispatched when an animation updates. This happens when the animation frame changes,\r\n * based on the animation frame rate and other factors like timeScale and delay.\r\n *\r\n * @event Phaser.GameObjects.Components.Animation#onUpdateEvent\r\n * @param {Phaser.Animations.Animation} animation - Reference to the currently playing animation.\r\n * @param {Phaser.Animations.AnimationFrame} frame - Reference to the current Animation Frame.\r\n *//**\r\n * This event is dispatched when an animation completes playing, either naturally or via Animation.stop.\r\n *\r\n * @event Phaser.GameObjects.Components.Animation#onCompleteEvent\r\n * @param {Phaser.Animations.Animation} animation - Reference to the currently playing animation.\r\n * @param {Phaser.Animations.AnimationFrame} frame - Reference to the current Animation Frame.\r\n *//**\r\n * @classdesc\r\n * A Game Object Animation Controller.\r\n *\r\n * This controller lives as an instance within a Game Object, accessible as `sprite.anims`.\r\n *\r\n * @class Animation\r\n * @memberOf Phaser.GameObjects.Components\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} parent - The Game Object to which this animation controller belongs.\r\n */var Animation=new Class({initialize:function Animation(parent){/**\r\n         * The Game Object to which this animation controller belongs.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#parent\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */this.parent=parent;/**\r\n         * A reference to the global Animation Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#animationManager\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */this.animationManager=parent.scene.sys.anims;this.animationManager.once('remove',this.remove,this);/**\r\n         * Is an animation currently playing or not?\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#isPlaying\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.isPlaying=false;/**\r\n         * The current Animation loaded into this Animation Controller.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#currentAnim\r\n         * @type {?Phaser.Animations.Animation}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.currentAnim=null;/**\r\n         * The current AnimationFrame being displayed by this Animation Controller.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#currentFrame\r\n         * @type {?Phaser.Animations.AnimationFrame}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.currentFrame=null;/**\r\n         * Time scale factor.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_timeScale\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this._timeScale=1;/**\r\n         * The frame rate of playback in frames per second.\r\n         * The default is 24 if the `duration` property is `null`.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#frameRate\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.frameRate=0;/**\r\n         * How long the animation should play for, in milliseconds.\r\n         * If the `frameRate` property has been set then it overrides this value,\r\n         * otherwise the `frameRate` is derived from `duration`.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.duration=0;/**\r\n         * ms per frame, not including frame specific modifiers that may be present in the Animation data.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#msPerFrame\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.msPerFrame=0;/**\r\n         * Skip frames if the time lags, or always advanced anyway?\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#skipMissedFrames\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.skipMissedFrames=true;/**\r\n         * A delay before starting playback, in milliseconds.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_delay\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._delay=0;/**\r\n         * Number of times to repeat the animation (-1 for infinity)\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_repeat\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._repeat=0;/**\r\n         * Delay before the repeat starts, in milliseconds.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_repeatDelay\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._repeatDelay=0;/**\r\n         * Should the animation yoyo? (reverse back down to the start) before repeating?\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_yoyo\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this._yoyo=false;/**\r\n         * Will the playhead move forwards (`true`) or in reverse (`false`)\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#forward\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.forward=true;/**\r\n         * Internal time overflow accumulator.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#accumulator\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accumulator=0;/**\r\n         * The time point at which the next animation frame will change.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#nextTick\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.nextTick=0;/**\r\n         * An internal counter keeping track of how many repeats are left to play.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#repeatCounter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.repeatCounter=0;/**\r\n         * An internal flag keeping track of pending repeats.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#pendingRepeat\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.pendingRepeat=false;/**\r\n         * Is the Animation paused?\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_paused\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this._paused=false;/**\r\n         * Was the animation previously playing before being paused?\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_wasPlaying\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this._wasPlaying=false;/**\r\n         * Internal property tracking if this Animation is waiting to stop.\r\n         *\r\n         * 0 = No\r\n         * 1 = Waiting for ms to pass\r\n         * 2 = Waiting for repeat\r\n         * 3 = Waiting for specific frame\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_pendingStop\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.4.0\r\n         */this._pendingStop=0;/**\r\n         * Internal property used by _pendingStop.\r\n         *\r\n         * @name Phaser.GameObjects.Components.Animation#_pendingStopValue\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.4.0\r\n         */this._pendingStopValue;},/**\r\n     * Sets the amount of time, in milliseconds, that the animation will be delayed before starting playback.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#delay\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} [value=0] - The amount of time, in milliseconds, to wait before starting playback.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */setDelay:function setDelay(value){if(value===undefined){value=0;}this._delay=value;return this.parent;},/**\r\n     * Gets the amount of time, in milliseconds that the animation will be delayed before starting playback.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#delay\r\n     * @since 3.4.0\r\n     *\r\n     * @return {integer} The amount of time, in milliseconds, the Animation will wait before starting playback.\r\n     */getDelay:function getDelay(){return this._delay;},/**\r\n     * Waits for the specified delay, in milliseconds, then starts playback of the requested animation.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#delayedPlay\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} delay - The delay, in milliseconds, to wait before starting the animation playing.\r\n     * @param {string} key - The key of the animation to play.\r\n     * @param {integer} [startFrame=0] - The frame of the animation to start from.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */delayedPlay:function delayedPlay(delay,key,startFrame){this.play(key,true,startFrame);this.nextTick+=delay;return this.parent;},/**\r\n     * Returns the key of the animation currently loaded into this component.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#getCurrentKey\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string} The key of the Animation loaded into this component.\r\n     */getCurrentKey:function getCurrentKey(){if(this.currentAnim){return this.currentAnim.key;}},/**\r\n     * Internal method used to load an animation into this component.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#load\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - [description]\r\n     * @param {integer} [startFrame=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */load:function load(key,startFrame){if(startFrame===undefined){startFrame=0;}if(this.isPlaying){this.stop();}//  Load the new animation in\nthis.animationManager.load(this,key,startFrame);return this.parent;},/**\r\n     * Pause the current animation and set the `isPlaying` property to `false`.\r\n     * You can optionally pause it at a specific frame.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} [atFrame] - An optional frame to set after pausing the animation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */pause:function pause(atFrame){if(!this._paused){this._paused=true;this._wasPlaying=this.isPlaying;this.isPlaying=false;}if(atFrame!==undefined){this.updateFrame(atFrame);}return this.parent;},/**\r\n     * Resumes playback of a paused animation and sets the `isPlaying` property to `true`.\r\n     * You can optionally tell it to start playback from a specific frame.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} [fromFrame] - An optional frame to set before restarting playback.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */resume:function resume(fromFrame){if(this._paused){this._paused=false;this.isPlaying=this._wasPlaying;}if(fromFrame!==undefined){this.updateFrame(fromFrame);}return this.parent;},/**\r\n     * `true` if the current animation is paused, otherwise `false`.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Animation#isPaused\r\n     * @readOnly\r\n     * @type {boolean}\r\n     * @since 3.4.0\r\n     */isPaused:{get:function get(){return this._paused;}},/**\r\n     * Plays an Animation on the Game Object that owns this Animation Component.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#play\r\n     * @fires Phaser.GameObjects.Components.Animation#onStartEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The string-based key of the animation to play, as defined previously in the Animation Manager.\r\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\r\n     * @param {integer} [startFrame=0] - Optionally start the animation playing from this frame index.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */play:function play(key,ignoreIfPlaying,startFrame){if(ignoreIfPlaying===undefined){ignoreIfPlaying=false;}if(startFrame===undefined){startFrame=0;}if(ignoreIfPlaying&&this.isPlaying&&this.currentAnim.key===key){return this.parent;}this.load(key,startFrame);var anim=this.currentAnim;var gameObject=this.parent;//  Should give us 9,007,199,254,740,991 safe repeats\nthis.repeatCounter=this._repeat===-1?Number.MAX_VALUE:this._repeat;anim.getFirstTick(this);this.forward=true;this.isPlaying=true;this.pendingRepeat=false;if(anim.showOnStart){gameObject.visible=true;}gameObject.emit('animationstart',this.currentAnim,this.currentFrame);return gameObject;},/**\r\n     * Returns a value between 0 and 1 indicating how far this animation is through, ignoring repeats and yoyos.\r\n     * If the animation has a non-zero repeat defined, `getProgress` and `getTotalProgress` will be different\r\n     * because `getProgress` doesn't include any repeats or repeat delays, whereas `getTotalProgress` does.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#getProgress\r\n     * @since 3.4.0\r\n     *\r\n     * @return {float} The progress of the current animation, between 0 and 1.\r\n     */getProgress:function getProgress(){var p=this.currentFrame.progress;if(!this.forward){p=1-p;}return p;},/**\r\n     * Takes a value between 0 and 1 and uses it to set how far this animation is through playback.\r\n     * Does not factor in repeats or yoyos, but does handle playing forwards or backwards.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#setProgress\r\n     * @since 3.4.0\r\n     *\r\n     * @param {float} [value=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */setProgress:function setProgress(value){if(!this.forward){value=1-value;}this.setCurrentFrame(this.animationManager.getFrameByProgress(value));return this.parent;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Animations.Animation} [event] - [description]\r\n     */remove:function remove(event){if(event===undefined){event=this.currentAnim;}if(this.isPlaying&&event.key===this.currentAnim.key){this.stop();this.setCurrentFrame(this.currentAnim.frames[0]);}},/**\r\n     * Gets the number of times that the animation will repeat\r\n     * after its first iteration. For example, if returns 1, the animation will\r\n     * play a total of twice (the initial play plus 1 repeat).\r\n     * A value of -1 means the animation will repeat indefinitely.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#getRepeat\r\n     * @since 3.4.0\r\n     *\r\n     * @return {integer} The number of times that the animation will repeat.\r\n     */getRepeat:function getRepeat(){return this._repeat;},/**\r\n     * Sets the number of times that the animation should repeat\r\n     * after its first iteration. For example, if repeat is 1, the animation will\r\n     * play a total of twice (the initial play plus 1 repeat).\r\n     * To repeat indefinitely, use -1. repeat should always be an integer.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#setRepeat\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */setRepeat:function setRepeat(value){this._repeat=value;this.repeatCounter=0;return this.parent;},/**\r\n     * Gets the amount of delay between repeats, if any.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#getRepeatDelay\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The delay between repeats.\r\n     */getRepeatDelay:function getRepeatDelay(){return this._repeatDelay;},/**\r\n     * Sets the amount of time in seconds between repeats.\r\n     * For example, if `repeat` is 2 and `repeatDelay` is 10, the animation will play initially,\r\n     * then wait for 10 seconds before repeating, then play again, then wait another 10 seconds\r\n     * before doing its final repeat.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#setRepeatDelay\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} value - The delay to wait between repeats, in seconds.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */setRepeatDelay:function setRepeatDelay(value){this._repeatDelay=value;return this.parent;},/**\r\n     * Restarts the current animation from its beginning, optionally including its delay value.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#restart\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [includeDelay=false] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */restart:function restart(includeDelay){if(includeDelay===undefined){includeDelay=false;}this.currentAnim.getFirstTick(this,includeDelay);this.forward=true;this.isPlaying=true;this.pendingRepeat=false;this._paused=false;//  Set frame\nthis.updateFrame(this.currentAnim.frames[0]);return this.parent;},/**\r\n     * Immediately stops the current animation from playing and dispatches the `animationcomplete` event.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#stop\r\n     * @fires Phaser.GameObjects.Components.Animation#onCompleteEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */stop:function stop(){this._pendingStop=0;this.isPlaying=false;var gameObject=this.parent;gameObject.emit('animationcomplete',this.currentAnim,this.currentFrame);return gameObject;},/**\r\n     * Stops the current animation from playing after the specified time delay, given in milliseconds.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#stopAfterDelay\r\n     * @fires Phaser.GameObjects.Components.Animation#onCompleteEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {integer} delay - The number of miliseconds to wait before stopping this animation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */stopAfterDelay:function stopAfterDelay(delay){this._pendingStop=1;this._pendingStopValue=delay;return this.parent;},/**\r\n     * Stops the current animation from playing when it next repeats.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#stopOnRepeat\r\n     * @fires Phaser.GameObjects.Components.Animation#onCompleteEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */stopOnRepeat:function stopOnRepeat(){this._pendingStop=2;return this.parent;},/**\r\n     * Stops the current animation from playing when it next sets the given frame.\r\n     * If this frame doesn't exist within the animation it will not stop it from playing.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#stopOnFrame\r\n     * @fires Phaser.GameObjects.Components.Animation#onCompleteEvent\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} delay - The frame to check before stopping this animation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */stopOnFrame:function stopOnFrame(frame){this._pendingStop=3;this._pendingStopValue=frame;return this.parent;},/**\r\n     * Sets the Time Scale factor, allowing you to make the animation go go faster or slower than default.\r\n     * Where 1 = normal speed (the default), 0.5 = half speed, 2 = double speed, etc.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#setTimeScale\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [value=1] - The time scale factor, where 1 is no change, 0.5 is half speed, etc.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */setTimeScale:function setTimeScale(value){if(value===undefined){value=1;}this._timeScale=value;return this.parent;},/**\r\n     * Gets the Time Scale factor.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#getTimeScale\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The Time Scale value.\r\n     */getTimeScale:function getTimeScale(){return this._timeScale;},/**\r\n     * Returns the total number of frames in this animation.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#getTotalFrames\r\n     * @since 3.4.0\r\n     *\r\n     * @return {integer} The total number of frames in this animation.\r\n     */getTotalFrames:function getTotalFrames(){return this.currentAnim.frames.length;},/**\r\n     * The internal update loop for the Animation Component.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestamp - [description]\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */update:function update(timestamp,delta){if(this.currentAnim&&(this.isPlaying||!this.currentAnim.paused)){this.accumulator+=delta*this._timeScale;if(this._pendingStop===1){this._pendingStopValue-=delta;if(this._pendingStopValue<=0){return this.currentAnim.completeAnimation(this);}}if(this.accumulator>=this.nextTick){this.currentAnim.setFrame(this);}}},/**\r\n     * Sets the given Animation Frame as being the current frame\r\n     * and applies it to the parent Game Object, adjusting its size and origin as needed.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#setCurrentFrame\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} animationFrame - The Animation Frame to set as being current.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.\r\n     */setCurrentFrame:function setCurrentFrame(animationFrame){var gameObject=this.parent;this.currentFrame=animationFrame;gameObject.texture=animationFrame.frame.texture;gameObject.frame=animationFrame.frame;gameObject.setSizeToFrame();if(animationFrame.frame.customPivot){gameObject.setOrigin(animationFrame.frame.pivotX,animationFrame.frame.pivotY);}else{gameObject.updateDisplayOrigin();}return gameObject;},/**\r\n     * Internal frame change handler.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#updateFrame\r\n     * @fires Phaser.GameObjects.Components.Animation#onUpdateEvent\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} animationFrame - [description]\r\n     */updateFrame:function updateFrame(animationFrame){var gameObject=this.setCurrentFrame(animationFrame);if(this.isPlaying){if(animationFrame.setAlpha){gameObject.alpha=animationFrame.alpha;}var anim=this.currentAnim;gameObject.emit('animationupdate',anim,animationFrame);if(this._pendingStop===3&&this._pendingStopValue===animationFrame){this.currentAnim.completeAnimation(this);}}},/**\r\n     * Sets if the current Animation will yoyo when it reaches the end.\r\n     * A yoyo'ing animation will play through consecutively, and then reverse-play back to the start again.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#setYoyo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [value=false] - `true` if the animation should yoyo, `false` to not.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.\r\n     */setYoyo:function setYoyo(value){if(value===undefined){value=false;}this._yoyo=value;return this.parent;},/**\r\n     * Gets if the current Animation will yoyo when it reaches the end.\r\n     * A yoyo'ing animation will play through consecutively, and then reverse-play back to the start again.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#getYoyo\r\n     * @since 3.4.0\r\n     *\r\n     * @return {boolean} `true` if the animation is set to yoyo, `false` if not.\r\n     */getYoyo:function getYoyo(){return this._yoyo;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.Animation#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.animationManager.off('remove',this.remove,this);this.animationManager=null;this.parent=null;this.currentAnim=null;this.currentFrame=null;}});module.exports=Animation;/***/},/* 395 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Takes the given string and reverses it, returning the reversed string.\r\n * For example if given the string `Atari 520ST` it would return `TS025 iratA`.\r\n *\r\n * @function Phaser.Utils.String.ReverseString\r\n * @since 3.0.0\r\n *\r\n * @param {string} string - The string to be reversed.\r\n *\r\n * @return {string} The reversed string.\r\n */var ReverseString=function ReverseString(string){return string.split('').reverse().join('');};module.exports=ReverseString;/***/},/* 396 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Takes a string and replaces instances of markers with values in the given array.\r\n * The markers take the form of `%1`, `%2`, etc. I.e.:\r\n *\r\n * `Format(\"The %1 is worth %2 gold\", [ 'Sword', 500 ])`\r\n *\r\n * @function Phaser.Utils.String.Format\r\n * @since 3.0.0\r\n *\r\n * @param {string} string - The string containing the replacement markers.\r\n * @param {array} values - An array containing values that will replace the markers. If no value exists an empty string is inserted instead.\r\n *\r\n * @return {string} The string containing replaced values.\r\n */var Format=function Format(string,values){return string.replace(/%([0-9]+)/g,function(s,n){return values[Number(n)-1];});};module.exports=Format;/***/},/* 397 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Utils.String\r\n */module.exports={Format:__webpack_require__(396),Pad:__webpack_require__(165),Reverse:__webpack_require__(395),UppercaseFirst:__webpack_require__(297)};/***/},/* 398 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clone=__webpack_require__(57);/**\r\n * Creates a new Object using all values from obj1.\r\n * \r\n * Then scans obj2. If a property is found in obj2 that *also* exists in obj1, the value from obj2 is used, otherwise the property is skipped.\r\n *\r\n * @function Phaser.Utils.Object.MergeRight\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj1 - [description]\r\n * @param {object} obj2 - [description]\r\n *\r\n * @return {object} [description]\r\n */var MergeRight=function MergeRight(obj1,obj2){var clone=Clone(obj1);for(var key in obj2){if(clone.hasOwnProperty(key)){clone[key]=obj2[key];}}return clone;};module.exports=MergeRight;/***/},/* 399 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Verifies that an object contains all requested keys\r\n *\r\n * @function Phaser.Utils.Object.HasAll\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - an object on which to check for key existence\r\n * @param {string[]} keys - an array of keys to ensure the source object contains\r\n *\r\n * @return {boolean} true if the source object contains all keys, false otherwise.\r\n */var HasAll=function HasAll(source,keys){for(var i=0;i<keys.length;i++){if(!source.hasOwnProperty(keys[i])){return false;}}return true;};module.exports=HasAll;/***/},/* 400 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetValue=__webpack_require__(5);var Clamp=__webpack_require__(50);/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Object.GetMinMaxValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - [description]\r\n * @param {string} key - [description]\r\n * @param {number} min - [description]\r\n * @param {number} max - [description]\r\n * @param {number} defaultValue - [description]\r\n *\r\n * @return {number} [description]\r\n */var GetMinMaxValue=function GetMinMaxValue(source,key,min,max,defaultValue){if(defaultValue===undefined){defaultValue=min;}var value=GetValue(source,key,defaultValue);return Clamp(value,min,max);};module.exports=GetMinMaxValue;/***/},/* 401 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Utils.Object\r\n */module.exports={Clone:__webpack_require__(57),Extend:__webpack_require__(18),GetAdvancedValue:__webpack_require__(8),GetFastValue:__webpack_require__(2),GetMinMaxValue:__webpack_require__(400),GetValue:__webpack_require__(5),HasAll:__webpack_require__(399),HasAny:__webpack_require__(253),HasValue:__webpack_require__(71),IsPlainObject:__webpack_require__(381),Merge:__webpack_require__(84),MergeRight:__webpack_require__(398)};/***/},/* 402 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Utils\r\n */module.exports={Array:__webpack_require__(146),Objects:__webpack_require__(401),String:__webpack_require__(397)};/***/},/* 403 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var NumberTweenBuilder=__webpack_require__(185);var PluginManager=__webpack_require__(13);var TimelineBuilder=__webpack_require__(184);var TWEEN_CONST=__webpack_require__(69);var TweenBuilder=__webpack_require__(85);//  Phaser.Tweens.TweenManager\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TweenManager\r\n * @memberOf Phaser.Tweens\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var TweenManager=new Class({initialize:function TweenManager(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.TweenManager#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.TweenManager#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.TweenManager#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.timeScale=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.TweenManager#_add\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._add=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.TweenManager#_pending\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._pending=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.TweenManager#_active\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._active=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.TweenManager#_destroy\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._destroy=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Tweens.TweenManager#_toProcess\r\n         * @type {integer}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._toProcess=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('preupdate',this.preUpdate,this);eventEmitter.on('update',this.update,this);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);this.timeScale=1;},/**\r\n     * Create a Tween Timeline and return it, but do NOT add it to the active or pending Tween lists.\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#createTimeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} [description]\r\n     */createTimeline:function createTimeline(config){return TimelineBuilder(this,config);},/**\r\n     * Create a Tween Timeline and add it to the active Tween list/\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#timeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} [description]\r\n     */timeline:function timeline(config){var timeline=TimelineBuilder(this,config);if(!timeline.paused){this._add.push(timeline);this._toProcess++;}return timeline;},/**\r\n     * Create a Tween and return it, but do NOT add it to the active or pending Tween lists.\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Tween} [description]\r\n     */create:function create(config){return TweenBuilder(this,config);},/**\r\n     * Create a Tween and add it to the active Tween list.\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Tween} [description]\r\n     */add:function add(config){var tween=TweenBuilder(this,config);this._add.push(tween);this._toProcess++;return tween;},/**\r\n     * Add an existing tween into the active Tween list.\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#existing\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} This Tween Manager object.\r\n     */existing:function existing(tween){this._add.push(tween);this._toProcess++;return this;},/**\r\n     * Create a Tween and add it to the active Tween list.\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#addCounter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Tween} [description]\r\n     */addCounter:function addCounter(config){var tween=NumberTweenBuilder(this,config);this._add.push(tween);this._toProcess++;return tween;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#preUpdate\r\n     * @since 3.0.0\r\n     */preUpdate:function preUpdate(){if(this._toProcess===0){//  Quick bail\nreturn;}var list=this._destroy;var active=this._active;var i;var tween;//  Clear the 'destroy' list\nfor(i=0;i<list.length;i++){tween=list[i];//  Remove from the 'active' array\nvar idx=active.indexOf(tween);if(idx!==-1){tween.state=TWEEN_CONST.REMOVED;active.splice(idx,1);}}list.length=0;//  Process the addition list\n//  This stops callbacks and out of sync events from populating the active array mid-way during the update\nlist=this._add;for(i=0;i<list.length;i++){tween=list[i];if(tween.state===TWEEN_CONST.PENDING_ADD){//  Return true if the Tween should be started right away, otherwise false\nif(tween.init()){tween.play();this._active.push(tween);}else{this._pending.push(tween);}}}list.length=0;this._toProcess=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestamp - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(timestamp,delta){//  Process active tweens\nvar list=this._active;var tween;//  Scale the delta\ndelta*=this.timeScale;for(var i=0;i<list.length;i++){tween=list[i];//  If Tween.update returns 'true' then it means it has completed,\n//  so move it to the destroy list\nif(tween.update(timestamp,delta)){this._destroy.push(tween);this._toProcess++;}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#makeActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} This Tween Manager object.\r\n     */makeActive:function makeActive(tween){if(this._add.indexOf(tween)!==-1||this._active.indexOf(tween)!==-1){return;}var idx=this._pending.indexOf(tween);if(idx!==-1){this._pending.splice(idx,1);}this._add.push(tween);tween.state=TWEEN_CONST.PENDING_ADD;this._toProcess++;return this;},/**\r\n     * Passes all Tweens to the given callback.\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#each\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - [description]\r\n     * @param {object} [scope] - [description]\r\n     * @param {...*} [args] - [description]\r\n     */each:function each(callback,scope){var args=[null];for(var i=1;i<arguments.length;i++){args.push(arguments[i]);}for(var texture in this.list){args[0]=this.list[texture];callback.apply(scope,args);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#getAllTweens\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.Tween[]} [description]\r\n     */getAllTweens:function getAllTweens(){var list=this._active;var output=[];for(var i=0;i<list.length;i++){output.push(list[i]);}return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#getGlobalTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getGlobalTimeScale:function getGlobalTimeScale(){return this.timeScale;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#getTweensOf\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(object|array)} target - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Tween[]} [description]\r\n     */getTweensOf:function getTweensOf(target){var list=this._active;var tween;var output=[];var i;if(Array.isArray(target)){for(i=0;i<list.length;i++){tween=list[i];for(var t=0;t<target.length;i++){if(tween.hasTarget(target[t])){output.push(tween);}}}}else{for(i=0;i<list.length;i++){tween=list[i];if(tween.hasTarget(target)){output.push(tween);}}}return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#isTweening\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} target - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */isTweening:function isTweening(target){var list=this._active;var tween;for(var i=0;i<list.length;i++){tween=list[i];if(tween.hasTarget(target)&&tween.isPlaying()){return true;}}return false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#killAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} [description]\r\n     */killAll:function killAll(){var tweens=this.getAllTweens();for(var i=0;i<tweens.length;i++){tweens[i].stop();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#killTweensOf\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(object|array)} target - [description]\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} [description]\r\n     */killTweensOf:function killTweensOf(target){var tweens=this.getTweensOf(target);for(var i=0;i<tweens.length;i++){tweens[i].stop();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#pauseAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} [description]\r\n     */pauseAll:function pauseAll(){var list=this._active;for(var i=0;i<list.length;i++){list[i].pause();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#resumeAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} [description]\r\n     */resumeAll:function resumeAll(){var list=this._active;for(var i=0;i<list.length;i++){list[i].resume();}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#setGlobalTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} value - [description]\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} [description]\r\n     */setGlobalTimeScale:function setGlobalTimeScale(value){this.timeScale=value;return this;},/**\r\n     * Scene that owns this manager is shutting down.\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.killAll();this._add=[];this._pending=[];this._active=[];this._destroy=[];this._toProcess=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.TweenManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.shutdown();}});PluginManager.register('TweenManager',TweenManager,'tweens');module.exports=TweenManager;/***/},/* 404 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  RESERVED properties that a Tween config object uses\n//  completeDelay: The time the tween will wait before the onComplete event is dispatched once it has completed\n//  delay: The time the tween will wait before it first starts\n//  duration: The duration of the tween\n//  ease: The ease function used by the tween\n//  easeParams: The parameters to go with the ease function (if any)\n//  flipX: flip X the GameObject on tween end\n//  flipY: flip Y the GameObject on tween end//  hold: The time the tween will pause before running a yoyo\n//  hold: The time the tween will pause before running a yoyo\n//  loop: The time the tween will pause before starting either a yoyo or returning to the start for a repeat\n//  loopDelay: \n//  offset: Used when the Tween is part of a Timeline\n//  paused: Does the tween start in a paused state, or playing?\n//  props: The properties being tweened by the tween\n//  repeat: The number of times the tween will repeat itself (a value of 1 means the tween will play twice, as it repeated once)\n//  repeatDelay: The time the tween will pause for before starting a repeat. The tween holds in the start state.\n//  targets: The targets the tween is updating.\n//  useFrames: Use frames or milliseconds?\n//  yoyo: boolean - Does the tween reverse itself (yoyo) when it reaches the end?\nmodule.exports=['callbackScope','completeDelay','delay','duration','ease','easeParams','flipX','flipY','hold','loop','loopDelay','offset','onComplete','onCompleteParams','onCompleteScope','onLoop','onLoopParams','onLoopScope','onRepeat','onRepeatParams','onRepeatScope','onStart','onStartParams','onStartScope','onUpdate','onUpdateParams','onUpdateScope','onYoyo','onYoyoParams','onYoyoScope','paused','props','repeat','repeatDelay','targets','useFrames','yoyo'];/***/},/* 405 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Tweens.Builders\r\n */module.exports={GetBoolean:__webpack_require__(70),GetEaseFunction:__webpack_require__(72),GetNewValue:__webpack_require__(86),GetProps:__webpack_require__(187),GetTargets:__webpack_require__(116),GetTweens:__webpack_require__(186),GetValueOp:__webpack_require__(115),NumberTweenBuilder:__webpack_require__(185),TimelineBuilder:__webpack_require__(184),TweenBuilder:__webpack_require__(85)};/***/},/* 406 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(69);var Extend=__webpack_require__(18);/**\r\n * @namespace Phaser.Tweens\r\n */var Tweens={Builders:__webpack_require__(405),TweenManager:__webpack_require__(403),Tween:__webpack_require__(113),TweenData:__webpack_require__(112),Timeline:__webpack_require__(183)};//   Merge in the consts\nTweens=Extend(false,Tweens,CONST);module.exports=Tweens;/***/},/* 407 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var PluginManager=__webpack_require__(13);var TimerEvent=__webpack_require__(188);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Clock\r\n * @memberOf Phaser.Time\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var Clock=new Class({initialize:function Clock(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.Clock#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.Clock#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.Clock#now\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.now=Date.now();//  Scale the delta time coming into the Clock by this factor\n//  which then influences anything using this Clock for calculations, like TimerEvents\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.Clock#timeScale\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.timeScale=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.Clock#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.paused=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.Clock#_active\r\n         * @type {Phaser.Time.TimerEvent[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._active=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.Clock#_pendingInsertion\r\n         * @type {Phaser.Time.TimerEvent[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._pendingInsertion=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Time.Clock#_pendingRemoval\r\n         * @type {Phaser.Time.TimerEvent[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._pendingRemoval=[];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('preupdate',this.preUpdate,this);eventEmitter.on('update',this.update,this);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#addEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TimerEventConfig} config - [description]\r\n     *\r\n     * @return {Phaser.Time.TimerEvent} [description]\r\n     */addEvent:function addEvent(config){var event=new TimerEvent(config);this._pendingInsertion.push(event);return event;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#delayedCall\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delay - [description]\r\n     * @param {function} callback - [description]\r\n     * @param {Array.<*>} args - [description]\r\n     * @param {*} callbackScope - [description]\r\n     *\r\n     * @return {Phaser.Time.TimerEvent} [description]\r\n     */delayedCall:function delayedCall(delay,callback,args,callbackScope){return this.addEvent({delay:delay,callback:callback,args:args,callbackScope:callbackScope});},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#clearPendingEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Time.Clock} [description]\r\n     */clearPendingEvents:function clearPendingEvents(){this._pendingInsertion=[];return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#removeAllEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Time.Clock} [description]\r\n     */removeAllEvents:function removeAllEvents(){this._pendingRemoval=this._pendingRemoval.concat(this._active);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */preUpdate:function preUpdate(){var toRemove=this._pendingRemoval.length;var toInsert=this._pendingInsertion.length;if(toRemove===0&&toInsert===0){//  Quick bail\nreturn;}var i;var event;//  Delete old events\nfor(i=0;i<toRemove;i++){event=this._pendingRemoval[i];var index=this._active.indexOf(event);if(index>-1){this._active.splice(index,1);}//  Pool them?\nevent.destroy();}for(i=0;i<toInsert;i++){event=this._pendingInsertion[i];this._active.push(event);}//  Clear the lists\nthis._pendingRemoval.length=0;this._pendingInsertion.length=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(time,delta){this.now=time;if(this.paused){return;}delta*=this.timeScale;for(var i=0;i<this._active.length;i++){var event=this._active[i];if(event.paused){continue;}//  Use delta time to increase elapsed.\n//  Avoids needing to adjust for pause / resume.\n//  Automatically smoothed by TimeStep class.\n//  In testing accurate to +- 1ms!\nevent.elapsed+=delta*event.timeScale;if(event.elapsed>=event.delay){var remainder=event.elapsed-event.delay;//  Limit it, in case it's checked in the callback\nevent.elapsed=event.delay;//  Process the event\nif(!event.hasDispatched&&event.callback){event.hasDispatched=true;event.callback.apply(event.callbackScope,event.args);}if(event.repeatCount>0){event.repeatCount--;event.elapsed=remainder;event.hasDispatched=false;}else{this._pendingRemoval.push(event);}}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){var i;for(i=0;i<this._pendingInsertion.length;i++){this._pendingInsertion[i].destroy();}for(i=0;i<this._active.length;i++){this._active[i].destroy();}for(i=0;i<this._pendingRemoval.length;i++){this._pendingRemoval[i].destroy();}this._active.length=0;this._pendingRemoval.length=0;this._pendingInsertion.length=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Time.Clock#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.shutdown();this.scene=undefined;}});PluginManager.register('Clock',Clock,'time');module.exports=Clock;/***/},/* 408 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Time\r\n */module.exports={Clock:__webpack_require__(407),TimerEvent:__webpack_require__(188)};/***/},/* 409 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectFactory=__webpack_require__(9);var ParseToTilemap=__webpack_require__(117);/**\r\n * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.\r\n * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing\r\n * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map\r\n * data. For an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#tilemap\r\n * @since 3.0.0\r\n *\r\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n * @param {integer} [tileWidth=32] - The width of a tile in pixels. Pass in `null` to leave as the\r\n * default.\r\n * @param {integer} [tileHeight=32] - The height of a tile in pixels. Pass in `null` to leave as the\r\n * default.\r\n * @param {integer} [width=10] - The width of the map in tiles. Pass in `null` to leave as the\r\n * default.\r\n * @param {integer} [height=10] - The height of the map in tiles. Pass in `null` to leave as the\r\n * default.\r\n * @param {integer[][]} [data] - Instead of loading from the cache, you can also load directly from\r\n * a 2D array of tile indexes. Pass in `null` for no data.\r\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\r\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */GameObjectFactory.register('tilemap',function(key,tileWidth,tileHeight,width,height,data,insertNull){// Allow users to specify null to indicate that they want the default value, since null is\n// shorter & more legible than undefined. Convert null to undefined to allow ParseToTilemap\n// defaults to take effect.\nif(key===null){key=undefined;}if(tileWidth===null){tileWidth=undefined;}if(tileHeight===null){tileHeight=undefined;}if(width===null){width=undefined;}if(height===null){height=undefined;}return ParseToTilemap(this.scene,key,tileWidth,tileHeight,width,height,data,insertNull);});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 410 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectCreator=__webpack_require__(11);var ParseToTilemap=__webpack_require__(117);/**\r\n * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.\r\n * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing\r\n * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map\r\n * data. For an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tilemap\r\n * @since 3.0.0\r\n * \r\n * @param {object} [config] - The config options for the Tilemap.\r\n * @param {string} [config.key] - The key in the Phaser cache that corresponds to the loaded tilemap\r\n * data.\r\n * @param {integer[][]} [config.data] - Instead of loading from the cache, you can also load\r\n * directly from a 2D array of tile indexes.\r\n * @param {integer} [config.tileWidth=32] - The width of a tile in pixels.\r\n * @param {integer} [config.tileHeight=32] - The height of a tile in pixels.\r\n * @param {integer} [config.width=10] - The width of the map in tiles.\r\n * @param {integer} [config.height=10] - The height of the map in tiles.\r\n * @param {boolean} [config.insertNull=false] - Controls how empty tiles, tiles with an index of -1,\r\n * in the map data are handled. If `true`, empty locations will get a value of `null`. If `false`,\r\n * empty location will get a Tile object with an index of -1. If you've a large sparsely populated\r\n * map and the tile data doesn't need to change then setting this value to `true` will help with\r\n * memory consumption. However if your map is small or you need to update the tiles dynamically,\r\n * then leave the default value set.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */GameObjectCreator.register('tilemap',function(config){// Defaults are applied in ParseToTilemap\nvar c=config!==undefined?config:{};return ParseToTilemap(this.scene,c.key,c.tileWidth,c.tileHeight,c.width,c.height,c.data,c.insertNull);});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 411 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.StaticTilemapLayer#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.Tilemaps.StaticTilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */var StaticTilemapLayerCanvasRenderer=function StaticTilemapLayerCanvasRenderer(renderer,src,interpolationPercentage,camera){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}src.cull(camera);var renderTiles=src.culledTiles;var tileset=this.tileset;var ctx=renderer.gameContext;var tileCount=renderTiles.length;var image=tileset.image.getSourceImage();var tx=src.x-camera.scrollX*src.scrollFactorX;var ty=src.y-camera.scrollY*src.scrollFactorY;ctx.save();ctx.translate(tx,ty);ctx.rotate(src.rotation);ctx.scale(src.scaleX,src.scaleY);ctx.scale(src.flipX?-1:1,src.flipY?-1:1);ctx.globalAlpha=src.alpha;for(var index=0;index<tileCount;++index){var tile=renderTiles[index];var tileTexCoords=tileset.getTileTextureCoordinates(tile.index);if(tileTexCoords===null){continue;}ctx.drawImage(image,tileTexCoords.x,tileTexCoords.y,tile.width,tile.height,tile.pixelX,tile.pixelY,tile.width,tile.height);}ctx.restore();};module.exports=StaticTilemapLayerCanvasRenderer;/***/},/* 412 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.StaticTilemapLayer#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.Tilemaps.StaticTilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */var StaticTilemapLayerWebGLRenderer=function StaticTilemapLayerWebGLRenderer(renderer,src,interpolationPercentage,camera){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}src.upload(camera);this.pipeline.drawStaticTilemapLayer(src,camera);};module.exports=StaticTilemapLayerWebGLRenderer;/***/},/* 413 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(412);}if(true){renderCanvas=__webpack_require__(411);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 414 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.DynamicTilemapLayer#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.Tilemaps.DynamicTilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */var DynamicTilemapLayerCanvasRenderer=function DynamicTilemapLayerCanvasRenderer(renderer,src,interpolationPercentage,camera){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}src.cull(camera);var renderTiles=src.culledTiles;var length=renderTiles.length;var image=src.tileset.image.getSourceImage();var tileset=this.tileset;var tx=src.x-camera.scrollX*src.scrollFactorX;var ty=src.y-camera.scrollY*src.scrollFactorY;var ctx=renderer.gameContext;ctx.save();ctx.translate(tx,ty);ctx.rotate(src.rotation);ctx.scale(src.scaleX,src.scaleY);ctx.scale(src.flipX?-1:1,src.flipY?-1:1);for(var index=0;index<length;++index){var tile=renderTiles[index];var tileTexCoords=tileset.getTileTextureCoordinates(tile.index);if(tileTexCoords===null){continue;}var halfWidth=tile.width/2;var halfHeight=tile.height/2;ctx.save();ctx.translate(tile.pixelX+halfWidth,tile.pixelY+halfHeight);if(tile.rotation!==0){ctx.rotate(tile.rotation);}if(tile.flipX||tile.flipY){ctx.scale(tile.flipX?-1:1,tile.flipY?-1:1);}ctx.globalAlpha=src.alpha*tile.alpha;ctx.drawImage(image,tileTexCoords.x,tileTexCoords.y,tile.width,tile.height,-halfWidth,-halfHeight,tile.width,tile.height);ctx.restore();}ctx.restore();};module.exports=DynamicTilemapLayerCanvasRenderer;/***/},/* 415 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.DynamicTilemapLayer#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.Tilemaps.DynamicTilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */var DynamicTilemapLayerWebGLRenderer=function DynamicTilemapLayerWebGLRenderer(renderer,src,interpolationPercentage,camera){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}src.cull(camera);this.pipeline.batchDynamicTilemapLayer(src,camera);};module.exports=DynamicTilemapLayerWebGLRenderer;/***/},/* 416 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(415);}if(true){renderCanvas=__webpack_require__(414);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 417 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Tileset=__webpack_require__(87);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - [description]\r\n *\r\n * @return {array} [description]\r\n */var ParseTilesets=function ParseTilesets(json){var tilesets=[];var tilesetsNames=[];for(var i=0;i<json.layer.length;i++){var layer=json.layer[i];// A relative filepath to the source image (within Weltmeister) is used for the name\nvar tilesetName=layer.tilesetName;// Only add unique tilesets that have a valid name. Collision layers will have a blank name.\nif(tilesetName!==''&&tilesetsNames.indexOf(tilesetName)===-1){tilesetsNames.push(tilesetName);// Tiles are stored with an ID relative to the tileset, rather than a globally unique ID\n// across all tilesets. Also, tilesets in Weltmeister have no margin or padding.\ntilesets.push(new Tileset(tilesetName,0,layer.tilesize,layer.tilesize,0,0));}}return tilesets;};module.exports=ParseTilesets;/***/},/* 418 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var LayerData=__webpack_require__(67);var Tile=__webpack_require__(45);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - [description]\r\n * @param {boolean} insertNull - [description]\r\n *\r\n * @return {array} [description]\r\n */var ParseTileLayers=function ParseTileLayers(json,insertNull){var tileLayers=[];for(var i=0;i<json.layer.length;i++){var layer=json.layer[i];var layerData=new LayerData({name:layer.name,width:layer.width,height:layer.height,tileWidth:layer.tilesize,tileHeight:layer.tilesize,visible:layer.visible===1});var row=[];var tileGrid=[];//  Loop through the data field in the JSON. This is a 2D array containing the tile indexes,\n//  one after the other. The indexes are relative to the tileset that contains the tile.\nfor(var y=0;y<layer.data.length;y++){for(var x=0;x<layer.data[y].length;x++){// In Weltmeister, 0 = no tile, but the Tilemap API expects -1 = no tile.\nvar index=layer.data[y][x]-1;var tile;if(index>-1){tile=new Tile(layerData,index,x,y,layer.tilesize,layer.tilesize);}else{tile=insertNull?null:new Tile(layerData,-1,x,y,layer.tilesize,layer.tilesize);}row.push(tile);}tileGrid.push(row);row=[];}layerData.data=tileGrid;tileLayers.push(layerData);}return tileLayers;};module.exports=ParseTileLayers;/***/},/* 419 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Extend=__webpack_require__(18);/**\r\n * Copy properties from tileset to tiles.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.AssignTileProperties\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.MapData} mapData - [description]\r\n */var AssignTileProperties=function AssignTileProperties(mapData){var layerData;var tile;var sid;var set;var row;// go through each of the map data layers\nfor(var i=0;i<mapData.layers.length;i++){layerData=mapData.layers[i];set=null;// rows of tiles\nfor(var j=0;j<layerData.data.length;j++){row=layerData.data[j];// individual tiles\nfor(var k=0;k<row.length;k++){tile=row[k];if(tile===null||tile.index<0){continue;}// find the relevant tileset\nsid=mapData.tiles[tile.index][2];set=mapData.tilesets[sid];// Ensure that a tile's size matches its tileset\ntile.width=set.tileWidth;tile.height=set.tileHeight;// if that tile type has any properties, add them to the tile object\nif(set.tileProperties&&set.tileProperties[tile.index-set.firstgid]){tile.properties=Extend(tile.properties,set.tileProperties[tile.index-set.firstgid]);}}}}};module.exports=AssignTileProperties;/***/},/* 420 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Master list of tiles -> x, y, index in tileset.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.BuildTilesetIndex\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.MapData} mapData - [description]\r\n *\r\n * @return {array} [description]\r\n */var BuildTilesetIndex=function BuildTilesetIndex(mapData){var tiles=[];for(var i=0;i<mapData.tilesets.length;i++){var set=mapData.tilesets[i];var x=set.tileMargin;var y=set.tileMargin;var count=0;var countX=0;var countY=0;for(var t=set.firstgid;t<set.firstgid+set.total;t++){//  Can add extra properties here as needed\ntiles[t]=[x,y,i];x+=set.tileWidth+set.tileSpacing;count++;if(count===set.total){break;}countX++;if(countX===set.columns){x=set.tileMargin;y+=set.tileHeight+set.tileSpacing;countX=0;countY++;if(countY===set.rows){break;}}}}return tiles;};module.exports=BuildTilesetIndex;/***/},/* 421 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetFastValue=__webpack_require__(2);var ParseObject=__webpack_require__(194);var ObjectLayer=__webpack_require__(193);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseObjectLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - [description]\r\n *\r\n * @return {array} [description]\r\n */var ParseObjectLayers=function ParseObjectLayers(json){var objectLayers=[];for(var i=0;i<json.layers.length;i++){if(json.layers[i].type!=='objectgroup'){continue;}var curo=json.layers[i];var offsetX=GetFastValue(curo,'offsetx',0);var offsetY=GetFastValue(curo,'offsety',0);var objects=[];for(var j=0;j<curo.objects.length;j++){var parsedObject=ParseObject(curo.objects[j],offsetX,offsetY);objects.push(parsedObject);}var objectLayer=new ObjectLayer(curo);objectLayer.objects=objects;objectLayers.push(objectLayer);}return objectLayers;};module.exports=ParseObjectLayers;/***/},/* 422 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var HasValue=__webpack_require__(71);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.Pick\r\n * @since 3.0.0\r\n *\r\n * @param {object} object - [description]\r\n * @param {array} keys - [description]\r\n *\r\n * @return {object} [description]\r\n */var Pick=function Pick(object,keys){var obj={};for(var i=0;i<keys.length;i++){var key=keys[i];if(HasValue(object,key)){obj[key]=object[key];}}return obj;};module.exports=Pick;/***/},/* 423 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Tileset=__webpack_require__(87);var ImageCollection=__webpack_require__(195);var ParseObject=__webpack_require__(194);/**\r\n * Tilesets & Image Collections\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - [description]\r\n *\r\n * @return {object} [description]\r\n */var ParseTilesets=function ParseTilesets(json){var tilesets=[];var imageCollections=[];var lastSet=null;var stringID;for(var i=0;i<json.tilesets.length;i++){//  name, firstgid, width, height, margin, spacing, properties\nvar set=json.tilesets[i];if(set.source){console.warn('Phaser can\\'t load external tilesets. Use the Embed Tileset button and then export the map again.');}else if(set.image){var newSet=new Tileset(set.name,set.firstgid,set.tilewidth,set.tileheight,set.margin,set.spacing);// Properties stored per-tile in object with string indexes starting at \"0\"\nif(set.tileproperties){newSet.tileProperties=set.tileproperties;}// Object & terrain shapes stored per-tile in object with string indexes starting at \"0\"\nif(set.tiles){newSet.tileData=set.tiles;// Parse the objects into Phaser format to match handling of other Tiled objects\nfor(stringID in newSet.tileData){var objectGroup=newSet.tileData[stringID].objectgroup;if(objectGroup&&objectGroup.objects){var parsedObjects=objectGroup.objects.map(function(obj){return ParseObject(obj);});newSet.tileData[stringID].objectgroup.objects=parsedObjects;}}}// For a normal sliced tileset the row/count/size information is computed when updated.\n// This is done (again) after the image is set.\nnewSet.updateTileData(set.imagewidth,set.imageheight);tilesets.push(newSet);}else{var newCollection=new ImageCollection(set.name,set.firstgid,set.tilewidth,set.tileheight,set.margin,set.spacing,set.properties);for(stringID in set.tiles){var image=set.tiles[stringID].image;var gid=set.firstgid+parseInt(stringID,10);newCollection.addImage(gid,image);}imageCollections.push(newCollection);}//  We've got a new Tileset, so set the lastgid into the previous one\nif(lastSet){lastSet.lastgid=set.firstgid-1;}lastSet=set;}return{tilesets:tilesets,imageCollections:imageCollections};};module.exports=ParseTilesets;/***/},/* 424 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetFastValue=__webpack_require__(2);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseImageLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - [description]\r\n *\r\n * @return {array} [description]\r\n */var ParseImageLayers=function ParseImageLayers(json){var images=[];for(var i=0;i<json.layers.length;i++){if(json.layers[i].type!=='imagelayer'){continue;}var curi=json.layers[i];images.push({name:curi.name,image:curi.image,x:GetFastValue(curi,'offsetx',0)+curi.x,y:GetFastValue(curi,'offsety',0)+curi.y,alpha:curi.opacity,visible:curi.visible,properties:GetFastValue(curi,'properties',{})});}return images;};module.exports=ParseImageLayers;/***/},/* 425 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.Base64Decode\r\n * @since 3.0.0\r\n *\r\n * @param {object} data - [description]\r\n *\r\n * @return {array} [description]\r\n */var Base64Decode=function Base64Decode(data){var binaryString=window.atob(data);var len=binaryString.length;var bytes=new Array(len);// Interpret binaryString as an array of bytes representing little-endian encoded uint32 values.\nfor(var i=0;i<len;i+=4){bytes[i/4]=(binaryString.charCodeAt(i)|binaryString.charCodeAt(i+1)<<8|binaryString.charCodeAt(i+2)<<16|binaryString.charCodeAt(i+3)<<24)>>>0;}return bytes;};module.exports=Base64Decode;/***/},/* 426 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Base64Decode=__webpack_require__(425);var GetFastValue=__webpack_require__(2);var LayerData=__webpack_require__(67);var ParseGID=__webpack_require__(196);var Tile=__webpack_require__(45);/**\r\n * [description]\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - [description]\r\n * @param {boolean} insertNull - [description]\r\n *\r\n * @return {array} [description]\r\n */var ParseTileLayers=function ParseTileLayers(json,insertNull){var tileLayers=[];for(var i=0;i<json.layers.length;i++){if(json.layers[i].type!=='tilelayer'){continue;}var curl=json.layers[i];// Base64 decode data if necessary. NOTE: uncompressed base64 only.\nif(curl.compression){console.warn('TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \\''+curl.name+'\\'');continue;}else if(curl.encoding&&curl.encoding==='base64'){curl.data=Base64Decode(curl.data);delete curl.encoding;// Allow the same map to be parsed multiple times\n}var layerData=new LayerData({name:curl.name,x:GetFastValue(curl,'offsetx',0)+curl.x,y:GetFastValue(curl,'offsety',0)+curl.y,width:curl.width,height:curl.height,tileWidth:json.tilewidth,tileHeight:json.tileheight,alpha:curl.opacity,visible:curl.visible,properties:GetFastValue(curl,'properties',{})});var x=0;var row=[];var output=[];//  Loop through the data field in the JSON.\n//  This is an array containing the tile indexes, one after the other. -1 = no tile,\n//  everything else = the tile index (starting at 1 for Tiled, 0 for CSV) If the map\n//  contains multiple tilesets then the indexes are relative to that which the set starts\n//  from. Need to set which tileset in the cache = which tileset in the JSON, if you do this\n//  manually it means you can use the same map data but a new tileset.\nfor(var t=0,len=curl.data.length;t<len;t++){var gidInfo=ParseGID(curl.data[t]);//  index, x, y, width, height\nif(gidInfo.gid>0){var tile=new Tile(layerData,gidInfo.gid,x,output.length,json.tilewidth,json.tileheight);// Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\n// propeties into flipX, flipY and rotation\ntile.rotation=gidInfo.rotation;tile.flipX=gidInfo.flipped;row.push(tile);}else{var blankTile=insertNull?null:new Tile(layerData,-1,x,output.length,json.tilewidth,json.tileheight);row.push(blankTile);}x++;if(x===curl.width){output.push(row);x=0;row=[];}}layerData.data=output;tileLayers.push(layerData);}return tileLayers;};module.exports=ParseTileLayers;/***/},/* 427 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Tilemaps.Parsers\r\n */module.exports={Parse:__webpack_require__(199),Parse2DArray:__webpack_require__(118),ParseCSV:__webpack_require__(198),Impact:__webpack_require__(192),Tiled:__webpack_require__(197)};/***/},/* 428 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var WorldToTileX=__webpack_require__(40);var WorldToTileY=__webpack_require__(39);var Vector2=__webpack_require__(6);/**\r\n * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - [description]\r\n * @param {number} worldY - [description]\r\n * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the\r\n * nearest integer.\r\n * @param {Phaser.Math.Vector2} [point] - [description]\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */var WorldToTileXY=function WorldToTileXY(worldX,worldY,snapToFloor,point,camera,layer){if(point===undefined){point=new Vector2(0,0);}point.x=WorldToTileX(worldX,snapToFloor,camera,layer);point.y=WorldToTileY(worldY,snapToFloor,camera,layer);return point;};module.exports=WorldToTileXY;/***/},/* 429 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n * weightedIndexes array. An example weighted array:\r\n *\r\n * [\r\n *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n * ]\r\n *\r\n * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n * method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.WeightedRandomize\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {object[]} [weightedIndexes] - An array of objects to randomly draw from during\r\n * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var WeightedRandomize=function WeightedRandomize(tileX,tileY,width,height,weightedIndexes,layer){if(weightedIndexes===undefined){return;}var i;var tiles=GetTilesWithin(tileX,tileY,width,height,null,layer);var weightTotal=0;for(i=0;i<weightedIndexes.length;i++){weightTotal+=weightedIndexes[i].weight;}if(weightTotal<=0){return;}for(i=0;i<tiles.length;i++){var rand=Math.random()*weightTotal;var sum=0;var randomIndex=-1;for(var j=0;j<weightedIndexes.length;j++){sum+=weightedIndexes[j].weight;if(rand<=sum){var chosen=weightedIndexes[j].index;randomIndex=Array.isArray(chosen)?chosen[Math.floor(Math.random()*chosen.length)]:chosen;break;}}tiles[i].index=randomIndex;}};module.exports=WeightedRandomize;/***/},/* 430 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var TileToWorldX=__webpack_require__(89);var TileToWorldY=__webpack_require__(88);var Vector2=__webpack_require__(6);/**\r\n * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - [description]\r\n * @param {integer} tileY - [description]\r\n * @param {Phaser.Math.Vector2} [point] - [description]\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */var TileToWorldXY=function TileToWorldXY(tileX,tileY,point,camera,layer){if(point===undefined){point=new Vector2(0,0);}point.x=TileToWorldX(tileX,camera,layer);point.y=TileToWorldY(tileY,camera,layer);return point;};module.exports=TileToWorldXY;/***/},/* 431 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);/**\r\n * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n * information.\r\n *\r\n * @function Phaser.Tilemaps.Components.SwapByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileA - First tile index.\r\n * @param {integer} tileB - Second tile index.\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SwapByIndex=function SwapByIndex(indexA,indexB,tileX,tileY,width,height,layer){var tiles=GetTilesWithin(tileX,tileY,width,height,null,layer);for(var i=0;i<tiles.length;i++){if(tiles[i]){if(tiles[i].index===indexA){tiles[i].index=indexB;}else if(tiles[i].index===indexB){tiles[i].index=indexA;}}}};module.exports=SwapByIndex;/***/},/* 432 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);var ShuffleArray=__webpack_require__(106);/**\r\n * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n * appear to have changed! This method only modifies tile indexes and does not change collision\r\n * information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Shuffle\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var Shuffle=function Shuffle(tileX,tileY,width,height,layer){var tiles=GetTilesWithin(tileX,tileY,width,height,null,layer);var indexes=tiles.map(function(tile){return tile.index;});ShuffleArray(indexes);for(var i=0;i<tiles.length;i++){tiles[i].index=indexes[i];}};module.exports=Shuffle;/***/},/* 433 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);/**\r\n * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n * remove it.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileLocationCallback\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n * @param {object} callbackContext - The context under which the callback is called.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SetTileLocationCallback=function SetTileLocationCallback(tileX,tileY,width,height,callback,callbackContext,layer){var tiles=GetTilesWithin(tileX,tileY,width,height,null,layer);for(var i=0;i<tiles.length;i++){tiles[i].setCollisionCallback(callback,callbackContext);}};module.exports=SetTileLocationCallback;/***/},/* 434 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n * at a specific location on the map then see setTileLocationCallback.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileIndexCallback\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes to have a\r\n * collision callback set for.\r\n * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n * @param {object} callbackContext - The context under which the callback is called.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SetTileIndexCallback=function SetTileIndexCallback(indexes,callback,callbackContext,layer){if(typeof indexes==='number'){layer.callbacks[indexes]=callback!==null?{callback:callback,callbackContext:callbackContext}:undefined;}else{for(var i=0,len=indexes.length;i<len;i++){layer.callbacks[indexes[i]]=callback!==null?{callback:callback,callbackContext:callbackContext}:undefined;}}};module.exports=SetTileIndexCallback;/***/},/* 435 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SetTileCollision=__webpack_require__(46);var CalculateFacesWithin=__webpack_require__(26);/**\r\n * Sets collision on the tiles within a layer by checking each tile's collision group data\r\n * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n * a tile's collision group, the tile's colliding information will be set. The `collides` parameter\r\n * controls if collision will be enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionFromCollisionGroup\r\n * @since 3.0.0\r\n *\r\n * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n * collision.\r\n * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n * update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SetCollisionFromCollisionGroup=function SetCollisionFromCollisionGroup(collides,recalculateFaces,layer){if(collides===undefined){collides=true;}if(recalculateFaces===undefined){recalculateFaces=true;}for(var ty=0;ty<layer.height;ty++){for(var tx=0;tx<layer.width;tx++){var tile=layer.data[ty][tx];if(!tile){continue;}var collisionGroup=tile.getCollisionGroup();// It's possible in Tiled to have a collision group without any shapes, e.g. create a\n// shape and then delete the shape.\nif(collisionGroup&&collisionGroup.objects&&collisionGroup.objects.length>0){SetTileCollision(tile,collides);}}}if(recalculateFaces){CalculateFacesWithin(0,0,layer.width,layer.height,layer);}};module.exports=SetCollisionFromCollisionGroup;/***/},/* 436 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SetTileCollision=__webpack_require__(46);var CalculateFacesWithin=__webpack_require__(26);var HasValue=__webpack_require__(71);/**\r\n * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n * that matches the given properties object, its collision flag will be set. The `collides`\r\n * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n * \"types\" property that matches any of those values, its collision flag will be updated.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionByProperty\r\n * @since 3.0.0\r\n *\r\n * @param {object} properties - An object with tile properties and corresponding values that should\r\n * be checked.\r\n * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n * collision.\r\n * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n * update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SetCollisionByProperty=function SetCollisionByProperty(properties,collides,recalculateFaces,layer){if(collides===undefined){collides=true;}if(recalculateFaces===undefined){recalculateFaces=true;}for(var ty=0;ty<layer.height;ty++){for(var tx=0;tx<layer.width;tx++){var tile=layer.data[ty][tx];if(!tile){continue;}for(var property in properties){if(!HasValue(tile.properties,property)){continue;}var values=properties[property];if(!Array.isArray(values)){values=[values];}for(var i=0;i<values.length;i++){if(tile.properties[property]===values[i]){SetTileCollision(tile,collides);}}}}}if(recalculateFaces){CalculateFacesWithin(0,0,layer.width,layer.height,layer);}};module.exports=SetCollisionByProperty;/***/},/* 437 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SetTileCollision=__webpack_require__(46);var CalculateFacesWithin=__webpack_require__(26);var SetLayerCollisionIndex=__webpack_require__(119);/**\r\n * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n * disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionByExclusion\r\n * @since 3.0.0\r\n *\r\n * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.\r\n * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n * collision.\r\n * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n * update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SetCollisionByExclusion=function SetCollisionByExclusion(indexes,collides,recalculateFaces,layer){if(collides===undefined){collides=true;}if(recalculateFaces===undefined){recalculateFaces=true;}if(!Array.isArray(indexes)){indexes=[indexes];}// Note: this only updates layer.collideIndexes for tile indexes found currently in the layer\nfor(var ty=0;ty<layer.height;ty++){for(var tx=0;tx<layer.width;tx++){var tile=layer.data[ty][tx];if(tile&&indexes.indexOf(tile.index)===-1){SetTileCollision(tile,collides);SetLayerCollisionIndex(tile.index,collides,layer);}}}if(recalculateFaces){CalculateFacesWithin(0,0,layer.width,layer.height,layer);}};module.exports=SetCollisionByExclusion;/***/},/* 438 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SetTileCollision=__webpack_require__(46);var CalculateFacesWithin=__webpack_require__(26);var SetLayerCollisionIndex=__webpack_require__(119);/**\r\n * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n * enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionBetween\r\n * @since 3.0.0\r\n *\r\n * @param {integer} start - The first index of the tile to be set for collision.\r\n * @param {integer} stop - The last index of the tile to be set for collision.\r\n * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n * collision.\r\n * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n * update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SetCollisionBetween=function SetCollisionBetween(start,stop,collides,recalculateFaces,layer){if(collides===undefined){collides=true;}if(recalculateFaces===undefined){recalculateFaces=true;}if(start>stop){return;}// Update the array of colliding indexes\nfor(var index=start;index<=stop;index++){SetLayerCollisionIndex(index,collides,layer);}// Update the tiles\nfor(var ty=0;ty<layer.height;ty++){for(var tx=0;tx<layer.width;tx++){var tile=layer.data[ty][tx];if(tile){if(tile.index>=start&&tile.index<=stop){SetTileCollision(tile,collides);}}}}if(recalculateFaces){CalculateFacesWithin(0,0,layer.width,layer.height,layer);}};module.exports=SetCollisionBetween;/***/},/* 439 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SetTileCollision=__webpack_require__(46);var CalculateFacesWithin=__webpack_require__(26);var SetLayerCollisionIndex=__webpack_require__(119);/**\r\n * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n * collision will be enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollision\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear\r\n * collision.\r\n * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the\r\n * update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var SetCollision=function SetCollision(indexes,collides,recalculateFaces,layer){if(collides===undefined){collides=true;}if(recalculateFaces===undefined){recalculateFaces=true;}if(!Array.isArray(indexes)){indexes=[indexes];}// Update the array of colliding indexes\nfor(var i=0;i<indexes.length;i++){SetLayerCollisionIndex(indexes[i],collides,layer);}// Update the tiles\nfor(var ty=0;ty<layer.height;ty++){for(var tx=0;tx<layer.width;tx++){var tile=layer.data[ty][tx];if(tile&&indexes.indexOf(tile.index)!==-1){SetTileCollision(tile,collides);}}}if(recalculateFaces){CalculateFacesWithin(0,0,layer.width,layer.height,layer);}};module.exports=SetCollision;/***/},/* 440 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);var Color=__webpack_require__(324);/**\r\n * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n * wherever you want on the screen.\r\n *\r\n * @function Phaser.Tilemaps.Components.RenderDebug\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n * @param {object} styleConfig - An object specifying the colors to use for the debug drawing.\r\n * @param {?Phaser.Display.Color} [styleConfig.tileColor=blue] - Color to use for drawing a filled rectangle at\r\n * non-colliding tile locations. If set to null, non-colliding tiles will not be drawn.\r\n * @param {?Phaser.Display.Color} [styleConfig.collidingTileColor=orange] - Color to use for drawing a filled\r\n * rectangle at colliding tile locations. If set to null, colliding tiles will not be drawn.\r\n * @param {?Phaser.Display.Color} [styleConfig.faceColor=grey] - Color to use for drawing a line at interesting\r\n * tile faces. If set to null, interesting tile faces will not be drawn.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var RenderDebug=function RenderDebug(graphics,styleConfig,layer){if(styleConfig===undefined){styleConfig={};}// Default colors without needlessly creating Color objects\nvar tileColor=styleConfig.tileColor!==undefined?styleConfig.tileColor:new Color(105,210,231,150);var collidingTileColor=styleConfig.collidingTileColor!==undefined?styleConfig.collidingTileColor:new Color(243,134,48,200);var faceColor=styleConfig.faceColor!==undefined?styleConfig.faceColor:new Color(40,39,37,150);var tiles=GetTilesWithin(0,0,layer.width,layer.height,null,layer);for(var i=0;i<tiles.length;i++){var tile=tiles[i];var tw=tile.width;var th=tile.height;var x=tile.pixelX;var y=tile.pixelY;var color=tile.collides?collidingTileColor:tileColor;if(color!==null){graphics.fillStyle(color.color,color.alpha/255);graphics.fillRect(x,y,tw,th);}// Inset the face line to prevent neighboring tile's lines from overlapping\nx+=1;y+=1;tw-=2;th-=2;if(faceColor!==null){graphics.lineStyle(1,faceColor.color,faceColor.alpha/255);if(tile.faceTop){graphics.lineBetween(x,y,x+tw,y);}if(tile.faceRight){graphics.lineBetween(x+tw,y,x+tw,y+th);}if(tile.faceBottom){graphics.lineBetween(x,y+th,x+tw,y+th);}if(tile.faceLeft){graphics.lineBetween(x,y,x,y+th);}}}};module.exports=RenderDebug;/***/},/* 441 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RemoveTileAt=__webpack_require__(200);var WorldToTileX=__webpack_require__(40);var WorldToTileY=__webpack_require__(39);/**\r\n * Removes the tile at the given world coordinates in the specified layer and updates the layer's\r\n * collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.RemoveTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {number} worldX - [description]\r\n * @param {number} worldY - [description]\r\n * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified\r\n * location with null instead of a Tile with an index of -1.\r\n * @param {boolean} [recalculateFaces=true] - [description]\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was removed.\r\n */var RemoveTileAtWorldXY=function RemoveTileAtWorldXY(worldX,worldY,replaceWithNull,recalculateFaces,camera,layer){var tileX=WorldToTileX(worldX,true,camera,layer);var tileY=WorldToTileY(worldY,true,camera,layer);return RemoveTileAt(tileX,tileY,replaceWithNull,recalculateFaces,layer);};module.exports=RemoveTileAtWorldXY;/***/},/* 442 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);var GetRandom=__webpack_require__(144);/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n * indexes. This method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Randomize\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var Randomize=function Randomize(tileX,tileY,width,height,indexes,layer){var i;var tiles=GetTilesWithin(tileX,tileY,width,height,null,layer);// If no indicies are given, then find all the unique indexes within the specified region\nif(indexes===undefined){indexes=[];for(i=0;i<tiles.length;i++){if(indexes.indexOf(tiles[i].index)===-1){indexes.push(tiles[i].index);}}}for(i=0;i<tiles.length;i++){tiles[i].index=GetRandom(indexes);}};module.exports=Randomize;/***/},/* 443 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CalculateFacesWithin=__webpack_require__(26);var PutTileAt=__webpack_require__(120);/**\r\n * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n * index at the specified location will be changed. Collision information will be recalculated\r\n * within the region tiles were changed.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTilesAt\r\n * @since 3.0.0\r\n *\r\n * @param {(integer[]|integer[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles\r\n * or tile indexes to place.\r\n * @param {integer} tileX - [description]\r\n * @param {integer} tileY - [description]\r\n * @param {boolean} [recalculateFaces=true] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var PutTilesAt=function PutTilesAt(tilesArray,tileX,tileY,recalculateFaces,layer){if(!Array.isArray(tilesArray)){return null;}if(recalculateFaces===undefined){recalculateFaces=true;}// Force the input array to be a 2D array\nif(!Array.isArray(tilesArray[0])){tilesArray=[tilesArray];}var height=tilesArray.length;var width=tilesArray[0].length;for(var ty=0;ty<height;ty++){for(var tx=0;tx<width;tx++){var tile=tilesArray[ty][tx];PutTileAt(tile,tileX+tx,tileY+ty,false,layer);}}if(recalculateFaces){// Recalculate the faces within the destination area and neighboring tiles\nCalculateFacesWithin(tileX-1,tileY-1,width+2,height+2,layer);}};module.exports=PutTilesAt;/***/},/* 444 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PutTileAt=__webpack_require__(120);var WorldToTileX=__webpack_require__(40);var WorldToTileY=__webpack_require__(39);/**\r\n * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n * specified location. If you pass in an index, only the index at the specified location will be\r\n * changed. Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {integer} worldX - [description]\r\n * @param {integer} worldY - [description]\r\n * @param {boolean} [recalculateFaces=true] - [description]\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */var PutTileAtWorldXY=function PutTileAtWorldXY(tile,worldX,worldY,recalculateFaces,camera,layer){var tileX=WorldToTileX(worldX,true,camera,layer);var tileY=WorldToTileY(worldY,true,camera,layer);return PutTileAt(tile,tileX,tileY,recalculateFaces,layer);};module.exports=PutTileAtWorldXY;/***/},/* 445 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var HasTileAt=__webpack_require__(201);var WorldToTileX=__webpack_require__(40);var WorldToTileY=__webpack_require__(39);/**\r\n * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n * false if there is no tile or if the tile at that location has an index of -1.\r\n *\r\n * @function Phaser.Tilemaps.Components.HasTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - [description]\r\n * @param {number} worldY - [description]\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {boolean}\r\n */var HasTileAtWorldXY=function HasTileAtWorldXY(worldX,worldY,camera,layer){var tileX=WorldToTileX(worldX,true,camera,layer);var tileY=WorldToTileY(worldY,true,camera,layer);return HasTileAt(tileX,tileY,layer);};module.exports=HasTileAtWorldXY;/***/},/* 446 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);var WorldToTileX=__webpack_require__(40);var WorldToTileY=__webpack_require__(39);/**\r\n * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - [description]\r\n * @param {number} worldY - [description]\r\n * @param {number} width - [description]\r\n * @param {number} height - [description]\r\n * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n * -1 for an index.\r\n * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n * at least one side.\r\n * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n * have at least one interesting face.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */var GetTilesWithinWorldXY=function GetTilesWithinWorldXY(worldX,worldY,width,height,filteringOptions,camera,layer){// Top left corner of the rect, rounded down to include partial tiles\nvar xStart=WorldToTileX(worldX,true,camera,layer);var yStart=WorldToTileY(worldY,true,camera,layer);// Bottom right corner of the rect, rounded up to include partial tiles\nvar xEnd=Math.ceil(WorldToTileX(worldX+width,false,camera,layer));var yEnd=Math.ceil(WorldToTileY(worldY+height,false,camera,layer));return GetTilesWithin(xStart,yStart,xEnd-xStart,yEnd-yStart,filteringOptions,layer);};module.exports=GetTilesWithinWorldXY;/***/},/* 447 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Geom=__webpack_require__(247);var GetTilesWithin=__webpack_require__(15);var Intersects=__webpack_require__(246);var NOOP=__webpack_require__(3);var TileToWorldX=__webpack_require__(89);var TileToWorldY=__webpack_require__(88);var WorldToTileX=__webpack_require__(40);var WorldToTileY=__webpack_require__(39);var TriangleToRectangle=function TriangleToRectangle(triangle,rect){return Intersects.RectangleToTriangle(rect,triangle);};// Note: Could possibly be optimized by copying the shape and shifting it into tilemapLayer\n// coordinates instead of shifting the tiles.\n/**\r\n * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinShape\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n * -1 for an index.\r\n * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide on\r\n * at least one side.\r\n * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n * have at least one interesting face.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */var GetTilesWithinShape=function GetTilesWithinShape(shape,filteringOptions,camera,layer){if(shape===undefined){return[];}// intersectTest is a function with parameters: shape, rect\nvar intersectTest=NOOP;if(shape instanceof Geom.Circle){intersectTest=Intersects.CircleToRectangle;}else if(shape instanceof Geom.Rectangle){intersectTest=Intersects.RectangleToRectangle;}else if(shape instanceof Geom.Triangle){intersectTest=TriangleToRectangle;}else if(shape instanceof Geom.Line){intersectTest=Intersects.LineToRectangle;}// Top left corner of the shapes's bounding box, rounded down to include partial tiles\nvar xStart=WorldToTileX(shape.left,true,camera,layer);var yStart=WorldToTileY(shape.top,true,camera,layer);// Bottom right corner of the shapes's bounding box, rounded up to include partial tiles\nvar xEnd=Math.ceil(WorldToTileX(shape.right,false,camera,layer));var yEnd=Math.ceil(WorldToTileY(shape.bottom,false,camera,layer));// Tiles within bounding rectangle of shape. Bounds are forced to be at least 1 x 1 tile in size\n// to grab tiles for shapes that don't have a height or width (e.g. a horizontal line).\nvar width=Math.max(xEnd-xStart,1);var height=Math.max(yEnd-yStart,1);var tiles=GetTilesWithin(xStart,yStart,width,height,filteringOptions,layer);var tileWidth=layer.tileWidth;var tileHeight=layer.tileHeight;if(layer.tilemapLayer){tileWidth*=layer.tilemapLayer.scaleX;tileHeight*=layer.tilemapLayer.scaleY;}var results=[];var tileRect=new Geom.Rectangle(0,0,tileWidth,tileHeight);for(var i=0;i<tiles.length;i++){var tile=tiles[i];tileRect.x=TileToWorldX(tile.x,camera,layer);tileRect.y=TileToWorldY(tile.y,camera,layer);if(intersectTest(shape,tileRect)){results.push(tile);}}return results;};module.exports=GetTilesWithinShape;/***/},/* 448 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTileAt=__webpack_require__(90);var WorldToTileX=__webpack_require__(40);var WorldToTileY=__webpack_require__(39);/**\r\n * Gets a tile at the given world coordinates from the given layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - X position to get the tile from (given in pixels)\r\n * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile\r\n * object with an index of -1.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates\r\n * were invalid.\r\n */var GetTileAtWorldXY=function GetTileAtWorldXY(worldX,worldY,nonNull,camera,layer){var tileX=WorldToTileX(worldX,true,camera,layer);var tileY=WorldToTileY(worldY,true,camera,layer);return GetTileAt(tileX,tileY,nonNull,layer);};module.exports=GetTileAtWorldXY;/***/},/* 449 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);/**\r\n * @callback EachTileCallback\r\n *\r\n * @param {Phaser.Tilemaps.Tile} value - [description]\r\n * @param {number} index - [description]\r\n * @param {Phaser.Tilemaps.Tile[]} array - [description]\r\n *//**\r\n * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.ForEachTile\r\n * @since 3.0.0\r\n *\r\n * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this\r\n * callback as the first and only parameter.\r\n * @param {object} [context] - The context under which the callback should be run.\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n * -1 for an index.\r\n * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n * on at least one side.\r\n * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n * have at least one interesting face.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var ForEachTile=function ForEachTile(callback,context,tileX,tileY,width,height,filteringOptions,layer){var tiles=GetTilesWithin(tileX,tileY,width,height,filteringOptions,layer);tiles.forEach(callback,context);};module.exports=ForEachTile;/***/},/* 450 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);/**\r\n * @callback FindTileCallback\r\n *\r\n * @param {Phaser.Tilemaps.Tile} value - [description]\r\n * @param {number} index - [description]\r\n * @param {Phaser.Tilemaps.Tile[]} array - [description]\r\n *\r\n * @return {boolean} [description]\r\n *//**\r\n * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n * true. Similar to Array.prototype.find in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindTile\r\n * @since 3.0.0\r\n *\r\n * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this\r\n * callback as the first and only parameter.\r\n * @param {object} [context] - The context under which the callback should be run.\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n * -1 for an index.\r\n * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n * on at least one side.\r\n * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n * have at least one interesting face.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} A Tile that matches the search, or null if no Tile found\r\n */var FindTile=function FindTile(callback,context,tileX,tileY,width,height,filteringOptions,layer){var tiles=GetTilesWithin(tileX,tileY,width,height,filteringOptions,layer);return tiles.find(callback,context)||null;};module.exports=FindTile;/***/},/* 451 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n * the top-left.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {integer} index - The tile index value to search for.\r\n * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.\r\n * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the\r\n * bottom-right. Otherwise it scans from the top-left.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} The first (or n skipped) tile with the matching index.\r\n */var FindByIndex=function FindByIndex(findIndex,skip,reverse,layer){if(skip===undefined){skip=0;}if(reverse===undefined){reverse=false;}var count=0;var tx;var ty;var tile;if(reverse){for(ty=layer.height-1;ty>=0;ty--){for(tx=layer.width-1;tx>=0;tx--){tile=layer.data[ty][tx];if(tile&&tile.index===findIndex){if(count===skip){return tile;}else{count+=1;}}}}}else{for(ty=0;ty<layer.height;ty++){for(tx=0;tx<layer.width;tx++){tile=layer.data[ty][tx];if(tile&&tile.index===findIndex){if(count===skip){return tile;}else{count+=1;}}}}}return null;};module.exports=FindByIndex;/***/},/* 452 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);/**\r\n * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.FilterTiles\r\n * @since 3.0.0\r\n *\r\n * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n * filter.\r\n * @param {object} [context] - The context under which the callback should be run.\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {object} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n * @param {boolean} [filteringOptions.isNotEmpty=false] - If true, only return tiles that don't have\r\n * -1 for an index.\r\n * @param {boolean} [filteringOptions.isColliding=false] - If true, only return tiles that collide\r\n * on at least one side.\r\n * @param {boolean} [filteringOptions.hasInterestingFace=false] - If true, only return tiles that\r\n * have at least one interesting face.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile[]} The filtered array of Tiles.\r\n */var FilterTiles=function FilterTiles(callback,context,tileX,tileY,width,height,filteringOptions,layer){var tiles=GetTilesWithin(tileX,tileY,width,height,filteringOptions,layer);return tiles.filter(callback,context);};module.exports=FilterTiles;/***/},/* 453 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);var CalculateFacesWithin=__webpack_require__(26);var SetTileCollision=__webpack_require__(46);/**\r\n * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n * Collision information in the region will be recalculated.\r\n *\r\n * @function Phaser.Tilemaps.Components.Fill\r\n * @since 3.0.0\r\n *\r\n * @param {integer} index - [description]\r\n * @param {integer} [tileX=0] - [description]\r\n * @param {integer} [tileY=0] - [description]\r\n * @param {integer} [width=max width based on tileX] - [description]\r\n * @param {integer} [height=max height based on tileY] - [description]\r\n * @param {boolean} [recalculateFaces=true] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var Fill=function Fill(index,tileX,tileY,width,height,recalculateFaces,layer){if(recalculateFaces===undefined){recalculateFaces=true;}var doesIndexCollide=layer.collideIndexes.indexOf(index)!==-1;var tiles=GetTilesWithin(tileX,tileY,width,height,null,layer);for(var i=0;i<tiles.length;i++){tiles[i].index=index;SetTileCollision(tiles[i],doesIndexCollide);}if(recalculateFaces){// Recalculate the faces within the area and neighboring tiles\nCalculateFacesWithin(tileX-1,tileY-1,width+2,height+2,layer);}};module.exports=Fill;/***/},/* 454 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the tiles in the given layer that are within the camera's viewport. This is used\r\n * internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullTiles\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - [description]\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */var CullTiles=function CullTiles(layer,camera,outputArray){if(outputArray===undefined){outputArray=[];}outputArray.length=0;var tilemapLayer=layer.tilemapLayer;var mapData=layer.data;var mapWidth=layer.width;var mapHeight=layer.height;var left=camera.scrollX*camera.zoom*tilemapLayer.scrollFactorX-tilemapLayer.x;var top=camera.scrollY*camera.zoom*tilemapLayer.scrollFactorY-tilemapLayer.y;var sx=tilemapLayer.scaleX;var sy=tilemapLayer.scaleY;var tileWidth=layer.tileWidth*sx;var tileHeight=layer.tileHeight*sy;for(var row=0;row<mapHeight;++row){for(var col=0;col<mapWidth;++col){var tile=mapData[row][col];if(tile===null||tile.index===-1){continue;}var tileX=tile.pixelX*sx-left;var tileY=tile.pixelY*sy-top;var cullW=camera.width+tileWidth;var cullH=camera.height+tileHeight;if(tile.visible&&tileX>-tileWidth&&tileY>-tileHeight&&tileX<cullW&&tileY<cullH){outputArray.push(tile);}}}return outputArray;};module.exports=CullTiles;/***/},/* 455 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var TileToWorldX=__webpack_require__(89);var TileToWorldY=__webpack_require__(88);var GetTilesWithin=__webpack_require__(15);var ReplaceByIndex=__webpack_require__(202);/**\r\n * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n *\r\n * @function Phaser.Tilemaps.Components.CreateFromTiles\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted\r\n * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n * one-to-one mapping with the indexes array.\r\n * @param {object} spriteConfig - The config object to pass into the Sprite creator (i.e.\r\n * scene.make.sprite).\r\n * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n */var CreateFromTiles=function CreateFromTiles(indexes,replacements,spriteConfig,scene,camera,layer){if(spriteConfig===undefined){spriteConfig={};}if(!Array.isArray(indexes)){indexes=[indexes];}var tilemapLayer=layer.tilemapLayer;if(scene===undefined){scene=tilemapLayer.scene;}if(camera===undefined){camera=scene.cameras.main;}var tiles=GetTilesWithin(0,0,layer.width,layer.height,null,layer);var sprites=[];var i;for(i=0;i<tiles.length;i++){var tile=tiles[i];if(indexes.indexOf(tile.index)!==-1){spriteConfig.x=TileToWorldX(tile.x,camera,layer);spriteConfig.y=TileToWorldY(tile.y,camera,layer);var sprite=scene.make.sprite(spriteConfig);sprites.push(sprite);}}if(typeof replacements==='number'){//  Assume 1 replacement for all types of tile given\nfor(i=0;i<indexes.length;i++){ReplaceByIndex(indexes[i],replacements,0,0,layer.width,layer.height,layer);}}else if(Array.isArray(replacements)){//  Assume 1 to 1 mapping with indexes array\nfor(i=0;i<indexes.length;i++){ReplaceByIndex(indexes[i],replacements[i],0,0,layer.width,layer.height,layer);}}return sprites;};module.exports=CreateFromTiles;/***/},/* 456 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetTilesWithin=__webpack_require__(15);var CalculateFacesWithin=__webpack_require__(26);/**\r\n * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n * information in the destination region.\r\n *\r\n * @function Phaser.Tilemaps.Components.Copy\r\n * @since 3.0.0\r\n *\r\n * @param {integer} srcTileX - [description]\r\n * @param {integer} srcTileY - [description]\r\n * @param {integer} width - [description]\r\n * @param {integer} height - [description]\r\n * @param {integer} destTileX - [description]\r\n * @param {integer} destTileY - [description]\r\n * @param {boolean} [recalculateFaces=true] - [description]\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */var Copy=function Copy(srcTileX,srcTileY,width,height,destTileX,destTileY,recalculateFaces,layer){if(srcTileX<0){srcTileX=0;}if(srcTileY<0){srcTileY=0;}if(recalculateFaces===undefined){recalculateFaces=true;}var srcTiles=GetTilesWithin(srcTileX,srcTileY,width,height,null,layer);var offsetX=destTileX-srcTileX;var offsetY=destTileY-srcTileY;for(var i=0;i<srcTiles.length;i++){var tileX=srcTiles[i].x+offsetX;var tileY=srcTiles[i].y+offsetY;if(tileX>=0&&tileX<layer.width&&tileY>=0&&tileY<layer.height){if(layer.data[tileY][tileX]){layer.data[tileY][tileX].copy(srcTiles[i]);}}}if(recalculateFaces){// Recalculate the faces within the destination area and neighboring tiles\nCalculateFacesWithin(destTileX-1,destTileY-1,width+2,height+2,layer);}};module.exports=Copy;/***/},/* 457 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Tilemaps\r\n */module.exports={Components:__webpack_require__(91),Parsers:__webpack_require__(427),Formats:__webpack_require__(24),ImageCollection:__webpack_require__(195),ParseToTilemap:__webpack_require__(117),Tile:__webpack_require__(45),Tilemap:__webpack_require__(191),TilemapCreator:__webpack_require__(410),TilemapFactory:__webpack_require__(409),Tileset:__webpack_require__(87),LayerData:__webpack_require__(67),MapData:__webpack_require__(66),ObjectLayer:__webpack_require__(193),DynamicTilemapLayer:__webpack_require__(190),StaticTilemapLayer:__webpack_require__(189)};/***/},/* 458 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Filter Types.\r\n *\r\n * @name Phaser.Textures.FilterMode\r\n * @enum {integer}\r\n * @memberOf Phaser.Textures\r\n * @readOnly\r\n * @since 3.0.0\r\n */var CONST={/**\r\n     * Linear filter type.\r\n     * \r\n     * @name Phaser.Textures.FilterMode.LINEAR\r\n     */LINEAR:0,/**\r\n     * Nearest neighbor filter type.\r\n     * \r\n     * @name Phaser.Textures.FilterMode.NEAREST\r\n     */NEAREST:1};module.exports=CONST;/***/},/* 459 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Extend=__webpack_require__(18);var FilterMode=__webpack_require__(458);/**\r\n * @namespace Phaser.Textures\r\n *//**\r\n * Linear filter type.\r\n * \r\n * @name Phaser.Textures.LINEAR\r\n * @constant\r\n *//**\r\n * Nearest Neighbor filter type.\r\n * \r\n * @name Phaser.Textures.NEAREST\r\n * @constant\r\n */var Textures={FilterMode:FilterMode,Frame:__webpack_require__(147),Parsers:__webpack_require__(287),Texture:__webpack_require__(286),TextureManager:__webpack_require__(288),TextureSource:__webpack_require__(285)};Textures=Extend(false,Textures,FilterMode);module.exports=Textures;/***/},/* 460 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Structs\r\n */module.exports={List:__webpack_require__(101),Map:__webpack_require__(166),ProcessQueue:__webpack_require__(209),RTree:__webpack_require__(208),Set:__webpack_require__(65)};/***/},/* 461 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Sound\r\n *//**\r\n * Config object containing various sound settings.\r\n *\r\n * @typedef {object} SoundConfig\r\n *\r\n * @property {boolean} [mute=false] - Boolean indicating whether the sound should be muted or not.\r\n * @property {number} [volume=1] - A value between 0 (silence) and 1 (full volume).\r\n * @property {number} [rate=1] - Defines the speed at which the sound should be played.\r\n * @property {number} [detune=0] - Represents detuning of sound in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).\r\n * @property {number} [seek=0] - Position of playback for this sound, in seconds.\r\n * @property {boolean} [loop=false] - Whether or not the sound or current sound marker should loop.\r\n * @property {number} [delay=0] - Time, in seconds, that should elapse before the sound actually starts its playback.\r\n *//**\r\n * Marked section of a sound represented by name, and optionally start time, duration, and config object.\r\n *\r\n * @typedef {object} SoundMarker\r\n *\r\n * @property {string} name - Unique identifier of a sound marker.\r\n * @property {number} [start=0] - Sound position offset at witch playback should start.\r\n * @property {number} [duration] - Playback duration of this marker.\r\n * @property {SoundConfig} [config] - An optional config object containing default marker settings.\r\n */module.exports={SoundManagerCreator:__webpack_require__(295),BaseSound:__webpack_require__(102),BaseSoundManager:__webpack_require__(103),WebAudioSound:__webpack_require__(289),WebAudioSoundManager:__webpack_require__(290),HTML5AudioSound:__webpack_require__(293),HTML5AudioSoundManager:__webpack_require__(294),NoAudioSound:__webpack_require__(291),NoAudioSoundManager:__webpack_require__(292)};/***/},/* 462 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(76);var PluginManager=__webpack_require__(13);/**\r\n * @classdesc\r\n * A proxy class to the Global Scene Manager.\r\n *\r\n * @class ScenePlugin\r\n * @memberOf Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this ScenePlugin belongs to.\r\n */var ScenePlugin=new Class({initialize:function ScenePlugin(scene){/**\r\n         * The Scene that this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * The Scene Systems instance of the Scene that this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * The settings of the Scene this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#settings\r\n         * @type {SettingsObject}\r\n         * @since 3.0.0\r\n         */this.settings=scene.sys.settings;/**\r\n         * The key of the Scene this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.key=scene.sys.settings.key;/**\r\n         * The Game's SceneManager.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#manager\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @since 3.0.0\r\n         */this.manager=scene.sys.game.scene;},/**\r\n     * Boot the ScenePlugin.\r\n     *\r\n     * Registers event handlers.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * Shutdown this Scene and run the given one.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to start.\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */start:function start(key,data){if(key===undefined){key=this.key;}if(this.settings.status!==CONST.RUNNING){this.manager.queueOp('stop',this.key);this.manager.queueOp('start',key,data);}else{this.manager.stop(this.key);this.manager.start(key,data);}return this;},/**\r\n     * Restarts this Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#restart\r\n     * @since 3.4.0\r\n     * \r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */restart:function restart(data){var key=this.key;if(this.settings.status!==CONST.RUNNING){this.manager.queueOp('stop',key);this.manager.queueOp('start',key,data);}else{this.manager.stop(key);this.manager.start(key,data);}return this;},/**\r\n     * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene key.\r\n     * @param {(Phaser.Scene|SettingsConfig|function)} sceneConfig - The config for the Scene.\r\n     * @param {boolean} autoStart - Whether to start the Scene after it's added.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */add:function add(key,sceneConfig,autoStart){this.manager.add(key,sceneConfig,autoStart);return this;},/**\r\n     * Launch the given Scene and run it in parallel with this one.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#launch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to launch.\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */launch:function launch(key,data){if(key&&key!==this.key){if(this.settings.status!==CONST.RUNNING){this.manager.queueOp('start',key,data);}else{this.manager.start(key,data);}}return this;},/**\r\n     * Pause the Scene - this stops the update step from happening but it still renders.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to pause.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */pause:function pause(key){if(key===undefined){key=this.key;}this.manager.pause(key);return this;},/**\r\n     * Resume the Scene - starts the update loop again.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to resume.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */resume:function resume(key){if(key===undefined){key=this.key;}this.manager.resume(key);return this;},/**\r\n     * Makes the Scene sleep (no update, no render) but doesn't shutdown.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to put to sleep.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */sleep:function sleep(key){if(key===undefined){key=this.key;}this.manager.sleep(key);return this;},/**\r\n     * Makes the Scene wake-up (starts update and render)\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to wake up.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */wake:function wake(key){if(key===undefined){key=this.key;}this.manager.wake(key);return this;},/**\r\n     * Makes this Scene sleep then starts the Scene given.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to start.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */switch:function _switch(key){if(key!==this.key){if(this.settings.status!==CONST.RUNNING){this.manager.queueOp('switch',this.key,key);}else{this.manager.switch(this.key,key);}}return this;},/**\r\n     * Shutdown the Scene, clearing display list, timers, etc.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to stop.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */stop:function stop(key){if(key===undefined){key=this.key;}this.manager.stop(key);return this;},/**\r\n     * Sets the active state of the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The Scene to set the active state for.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */setActive:function setActive(value){this.settings.active=value;return this;},/**\r\n     * Sets the visible state of the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The Scene to set the visible state for.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */setVisible:function setVisible(value){this.settings.visible=value;return this;},/**\r\n     * Checks if the given Scene is sleeping or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping.\r\n     */isSleeping:function isSleeping(key){if(key===undefined){key=this.key;}return this.manager.isSleeping(key);},/**\r\n     * Checks if the given Scene is active or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is active.\r\n     */isActive:function isActive(key){if(key===undefined){key=this.key;}return this.manager.isActive(key);},/**\r\n     * Checks if the given Scene is visible or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible.\r\n     */isVisible:function isVisible(key){if(key===undefined){key=this.key;}return this.manager.isVisible(key);},/**\r\n     * Swaps the position of two scenes in the Scenes list.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#swapPosition\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The first Scene to swap.\r\n     * @param {string} [keyB] - The second Scene to swap. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */swapPosition:function swapPosition(keyA,keyB){if(keyB===undefined){keyB=this.key;}if(keyA!==keyB){this.manager.swapPosition(keyA,keyB);}return this;},/**\r\n     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The Scene that Scene B will be moved to be above.\r\n     * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */moveAbove:function moveAbove(keyA,keyB){if(keyB===undefined){keyB=this.key;}if(keyA!==keyB){this.manager.moveAbove(keyA,keyB);}return this;},/**\r\n     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The Scene that Scene B will be moved to be below.\r\n     * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */moveBelow:function moveBelow(keyA,keyB){if(keyB===undefined){keyB=this.key;}if(keyA!==keyB){this.manager.moveBelow(keyA,keyB);}return this;},/**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it wil\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to be removed.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */remove:function remove(key){if(key===undefined){key=this.key;}this.manager.remove(key);return this;},/**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */moveUp:function moveUp(key){if(key===undefined){key=this.key;}this.manager.moveUp(key);return this;},/**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */moveDown:function moveDown(key){if(key===undefined){key=this.key;}this.manager.moveDown(key);return this;},/**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */bringToTop:function bringToTop(key){if(key===undefined){key=this.key;}this.manager.bringToTop(key);return this;},/**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */sendToBack:function sendToBack(key){if(key===undefined){key=this.key;}this.manager.sendToBack(key);return this;},/**\r\n     * Retrieve a Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to retrieve.\r\n     *\r\n     * @return {Phaser.Scene} The Scene.\r\n     */get:function get(key){return this.manager.getScene(key);},/**\r\n     * Shut down the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){//  TODO\n},/**\r\n     * Destroy the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){//  TODO\n}});PluginManager.register('ScenePlugin',ScenePlugin,'scenePlugin');module.exports=ScenePlugin;/***/},/* 463 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(76);var Extend=__webpack_require__(18);/**\r\n * @namespace Phaser.Scenes\r\n */var Scene={SceneManager:__webpack_require__(299),ScenePlugin:__webpack_require__(462),Settings:__webpack_require__(296),Systems:__webpack_require__(148)};//   Merge in the consts\nScene=Extend(false,Scene,CONST);module.exports=Scene;/***/},/* 464 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.World` module contains methods for creating and manipulating the world composite.\r\n* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.\r\n* A `Matter.World` has a few additional properties including `gravity` and `bounds`.\r\n* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.\r\n* There are also a few methods here that alias those in `Matter.Composite` for easier readability.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class World\r\n* @extends Composite\r\n*/var World={};module.exports=World;var Composite=__webpack_require__(122);var Constraint=__webpack_require__(177);var Common=__webpack_require__(37);(function(){/**\r\n     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @constructor\r\n     * @param {} options\r\n     * @return {world} A new world\r\n     */World.create=function(options){var composite=Composite.create();var defaults={label:'World',gravity:{x:0,y:1,scale:0.001},bounds:{min:{x:-Infinity,y:-Infinity},max:{x:Infinity,y:Infinity}}};return Common.extend(composite,defaults,options);};/*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    *//**\r\n     * The gravity to apply on the world.\r\n     *\r\n     * @property gravity\r\n     * @type object\r\n     *//**\r\n     * The gravity x component.\r\n     *\r\n     * @property gravity.x\r\n     * @type object\r\n     * @default 0\r\n     *//**\r\n     * The gravity y component.\r\n     *\r\n     * @property gravity.y\r\n     * @type object\r\n     * @default 1\r\n     *//**\r\n     * The gravity scale factor.\r\n     *\r\n     * @property gravity.scale\r\n     * @type object\r\n     * @default 0.001\r\n     *//**\r\n     * A `Bounds` object that defines the world bounds for collision detection.\r\n     *\r\n     * @property bounds\r\n     * @type bounds\r\n     * @default { min: { x: -Infinity, y: -Infinity }, max: { x: Infinity, y: Infinity } }\r\n     */// World is a Composite body\n// see src/module/Outro.js for these aliases:\n/**\r\n     * An alias for Composite.clear\r\n     * @method clear\r\n     * @param {world} world\r\n     * @param {boolean} keepStatic\r\n     *//**\r\n     * An alias for Composite.add\r\n     * @method addComposite\r\n     * @param {world} world\r\n     * @param {composite} composite\r\n     * @return {world} The original world with the objects from composite added\r\n     *//**\r\n      * An alias for Composite.addBody\r\n      * @method addBody\r\n      * @param {world} world\r\n      * @param {body} body\r\n      * @return {world} The original world with the body added\r\n      *//**\r\n      * An alias for Composite.addConstraint\r\n      * @method addConstraint\r\n      * @param {world} world\r\n      * @param {constraint} constraint\r\n      * @return {world} The original world with the constraint added\r\n      */})();/***/},/* 465 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\r\n*\r\n* @class Plugin\r\n*/var Plugin={};module.exports=Plugin;var Common=__webpack_require__(37);(function(){Plugin._registry={};/**\r\n     * Registers a plugin object so it can be resolved later by name.\r\n     * @method register\r\n     * @param plugin {} The plugin to register.\r\n     * @return {object} The plugin.\r\n     */Plugin.register=function(plugin){if(!Plugin.isPlugin(plugin)){Common.warn('Plugin.register:',Plugin.toString(plugin),'does not implement all required fields.');}if(plugin.name in Plugin._registry){var registered=Plugin._registry[plugin.name],pluginVersion=Plugin.versionParse(plugin.version).number,registeredVersion=Plugin.versionParse(registered.version).number;if(pluginVersion>registeredVersion){Common.warn('Plugin.register:',Plugin.toString(registered),'was upgraded to',Plugin.toString(plugin));Plugin._registry[plugin.name]=plugin;}else if(pluginVersion<registeredVersion){Common.warn('Plugin.register:',Plugin.toString(registered),'can not be downgraded to',Plugin.toString(plugin));}else if(plugin!==registered){Common.warn('Plugin.register:',Plugin.toString(plugin),'is already registered to different plugin object');}}else{Plugin._registry[plugin.name]=plugin;}return plugin;};/**\r\n     * Resolves a dependency to a plugin object from the registry if it exists. \r\n     * The `dependency` may contain a version, but only the name matters when resolving.\r\n     * @method resolve\r\n     * @param dependency {string} The dependency.\r\n     * @return {object} The plugin if resolved, otherwise `undefined`.\r\n     */Plugin.resolve=function(dependency){return Plugin._registry[Plugin.dependencyParse(dependency).name];};/**\r\n     * Returns a pretty printed plugin name and version.\r\n     * @method toString\r\n     * @param plugin {} The plugin.\r\n     * @return {string} Pretty printed plugin name and version.\r\n     */Plugin.toString=function(plugin){return typeof plugin==='string'?plugin:(plugin.name||'anonymous')+'@'+(plugin.version||plugin.range||'0.0.0');};/**\r\n     * Returns `true` if the object meets the minimum standard to be considered a plugin.\r\n     * This means it must define the following properties:\r\n     * - `name`\r\n     * - `version`\r\n     * - `install`\r\n     * @method isPlugin\r\n     * @param obj {} The obj to test.\r\n     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\r\n     */Plugin.isPlugin=function(obj){return obj&&obj.name&&obj.version&&obj.install;};/**\r\n     * Returns `true` if a plugin with the given `name` been installed on `module`.\r\n     * @method isUsed\r\n     * @param module {} The module.\r\n     * @param name {string} The plugin name.\r\n     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\r\n     */Plugin.isUsed=function(module,name){return module.used.indexOf(name)>-1;};/**\r\n     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\r\n     * If `plugin.for` is not specified then it is assumed to be applicable.\r\n     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\r\n     * @method isFor\r\n     * @param plugin {} The plugin.\r\n     * @param module {} The module.\r\n     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\r\n     */Plugin.isFor=function(plugin,module){var parsed=plugin.for&&Plugin.dependencyParse(plugin.for);return!plugin.for||module.name===parsed.name&&Plugin.versionSatisfies(module.version,parsed.range);};/**\r\n     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\r\n     * For installing plugins on `Matter` see the convenience function `Matter.use`.\r\n     * Plugins may be specified either by their name or a reference to the plugin object.\r\n     * Plugins themselves may specify further dependencies, but each plugin is installed only once.\r\n     * Order is important, a topological sort is performed to find the best resulting order of installation.\r\n     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\r\n     * This function logs the resulting status of each dependency in the console, along with any warnings.\r\n     * - A green tick ✅ indicates a dependency was resolved and installed.\r\n     * - An orange diamond 🔶 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\r\n     * - A red cross ❌ indicates a dependency could not be resolved.\r\n     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param module {} The module install plugins on.\r\n     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\r\n     */Plugin.use=function(module,plugins){module.uses=(module.uses||[]).concat(plugins||[]);if(module.uses.length===0){Common.warn('Plugin.use:',Plugin.toString(module),'does not specify any dependencies to install.');return;}var dependencies=Plugin.dependencies(module),sortedDependencies=Common.topologicalSort(dependencies),status=[];for(var i=0;i<sortedDependencies.length;i+=1){if(sortedDependencies[i]===module.name){continue;}var plugin=Plugin.resolve(sortedDependencies[i]);if(!plugin){status.push('❌ '+sortedDependencies[i]);continue;}if(Plugin.isUsed(module,plugin.name)){continue;}if(!Plugin.isFor(plugin,module)){Common.warn('Plugin.use:',Plugin.toString(plugin),'is for',plugin.for,'but installed on',Plugin.toString(module)+'.');plugin._warned=true;}if(plugin.install){plugin.install(module);}else{Common.warn('Plugin.use:',Plugin.toString(plugin),'does not specify an install function.');plugin._warned=true;}if(plugin._warned){status.push('🔶 '+Plugin.toString(plugin));delete plugin._warned;}else{status.push('✅ '+Plugin.toString(plugin));}module.used.push(plugin.name);}if(status.length>0&&!plugin.silent){Common.info(status.join('  '));}};/**\r\n     * Recursively finds all of a module's dependencies and returns a flat dependency graph.\r\n     * @method dependencies\r\n     * @param module {} The module.\r\n     * @return {object} A dependency graph.\r\n     */Plugin.dependencies=function(module,tracked){var parsedBase=Plugin.dependencyParse(module),name=parsedBase.name;tracked=tracked||{};if(name in tracked){return;}module=Plugin.resolve(module)||module;tracked[name]=Common.map(module.uses||[],function(dependency){if(Plugin.isPlugin(dependency)){Plugin.register(dependency);}var parsed=Plugin.dependencyParse(dependency),resolved=Plugin.resolve(dependency);if(resolved&&!Plugin.versionSatisfies(resolved.version,parsed.range)){Common.warn('Plugin.dependencies:',Plugin.toString(resolved),'does not satisfy',Plugin.toString(parsed),'used by',Plugin.toString(parsedBase)+'.');resolved._warned=true;module._warned=true;}else if(!resolved){Common.warn('Plugin.dependencies:',Plugin.toString(dependency),'used by',Plugin.toString(parsedBase),'could not be resolved.');module._warned=true;}return parsed.name;});for(var i=0;i<tracked[name].length;i+=1){Plugin.dependencies(tracked[name][i],tracked);}return tracked;};/**\r\n     * Parses a dependency string into its components.\r\n     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\r\n     * See documentation for `Plugin.versionParse` for a description of the format.\r\n     * This function can also handle dependencies that are already resolved (e.g. a module object).\r\n     * @method dependencyParse\r\n     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\r\n     * @return {object} The dependency parsed into its components.\r\n     */Plugin.dependencyParse=function(dependency){if(Common.isString(dependency)){var pattern=/^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?))?$/;if(!pattern.test(dependency)){Common.warn('Plugin.dependencyParse:',dependency,'is not a valid dependency string.');}return{name:dependency.split('@')[0],range:dependency.split('@')[1]||'*'};}return{name:dependency.name,range:dependency.range||dependency.version};};/**\r\n     * Parses a version string into its components.  \r\n     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\r\n     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\r\n     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\r\n     * Only the following range types are supported:\r\n     * - Tilde ranges e.g. `~1.2.3`\r\n     * - Caret ranges e.g. `^1.2.3`\r\n     * - Exact version e.g. `1.2.3`\r\n     * - Any version `*`\r\n     * @method versionParse\r\n     * @param range {string} The version string.\r\n     * @return {object} The version range parsed into its components.\r\n     */Plugin.versionParse=function(range){var pattern=/^\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?$/;if(!pattern.test(range)){Common.warn('Plugin.versionParse:',range,'is not a valid version or range.');}var identifiers=range.split('-');range=identifiers[0];var isRange=isNaN(Number(range[0])),version=isRange?range.substr(1):range,parts=Common.map(version.split('.'),function(part){return Number(part);});return{isRange:isRange,version:version,range:range,operator:isRange?range[0]:'',parts:parts,prerelease:identifiers[1],number:parts[0]*1e8+parts[1]*1e4+parts[2]};};/**\r\n     * Returns `true` if `version` satisfies the given `range`.\r\n     * See documentation for `Plugin.versionParse` for a description of the format.\r\n     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\r\n     * @method versionSatisfies\r\n     * @param version {string} The version string.\r\n     * @param range {string} The range string.\r\n     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\r\n     */Plugin.versionSatisfies=function(version,range){range=range||'*';var rangeParsed=Plugin.versionParse(range),rangeParts=rangeParsed.parts,versionParsed=Plugin.versionParse(version),versionParts=versionParsed.parts;if(rangeParsed.isRange){if(rangeParsed.operator==='*'||version==='*'){return true;}if(rangeParsed.operator==='~'){return versionParts[0]===rangeParts[0]&&versionParts[1]===rangeParts[1]&&versionParts[2]>=rangeParts[2];}if(rangeParsed.operator==='^'){if(rangeParts[0]>0){return versionParts[0]===rangeParts[0]&&versionParsed.number>=rangeParsed.number;}if(rangeParts[1]>0){return versionParts[1]===rangeParts[1]&&versionParts[2]>=rangeParts[2];}return versionParts[2]===rangeParts[2];}}return version===range||version==='*';};})();/***/},/* 466 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Matter=__webpack_require__(984);Matter.Body=__webpack_require__(51);Matter.Composite=__webpack_require__(122);Matter.World=__webpack_require__(464);Matter.Detector=__webpack_require__(468);Matter.Grid=__webpack_require__(983);Matter.Pairs=__webpack_require__(982);Matter.Pair=__webpack_require__(383);Matter.Query=__webpack_require__(1008);Matter.Resolver=__webpack_require__(981);Matter.SAT=__webpack_require__(467);Matter.Constraint=__webpack_require__(177);Matter.Common=__webpack_require__(37);Matter.Engine=__webpack_require__(980);Matter.Events=__webpack_require__(178);Matter.Sleeping=__webpack_require__(203);Matter.Plugin=__webpack_require__(465);Matter.Bodies=__webpack_require__(123);Matter.Composites=__webpack_require__(987);Matter.Axes=__webpack_require__(470);Matter.Bounds=__webpack_require__(92);Matter.Svg=__webpack_require__(1006);Matter.Vector=__webpack_require__(83);Matter.Vertices=__webpack_require__(93);// aliases\nMatter.World.add=Matter.Composite.add;Matter.World.remove=Matter.Composite.remove;Matter.World.addComposite=Matter.Composite.addComposite;Matter.World.addBody=Matter.Composite.addBody;Matter.World.addConstraint=Matter.Composite.addConstraint;Matter.World.clear=Matter.Composite.clear;module.exports=Matter;/***/},/* 467 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\r\n*\r\n* @class SAT\r\n*/// TODO: true circles and curves\nvar SAT={};module.exports=SAT;var Vertices=__webpack_require__(93);var Vector=__webpack_require__(83);(function(){/**\r\n     * Detect collision between two bodies using the Separating Axis Theorem.\r\n     * @method collides\r\n     * @param {body} bodyA\r\n     * @param {body} bodyB\r\n     * @param {collision} previousCollision\r\n     * @return {collision} collision\r\n     */SAT.collides=function(bodyA,bodyB,previousCollision){var overlapAB,overlapBA,minOverlap,collision,canReusePrevCol=false;if(previousCollision){// estimate total motion\nvar parentA=bodyA.parent,parentB=bodyB.parent,motion=parentA.speed*parentA.speed+parentA.angularSpeed*parentA.angularSpeed+parentB.speed*parentB.speed+parentB.angularSpeed*parentB.angularSpeed;// we may be able to (partially) reuse collision result \n// but only safe if collision was resting\ncanReusePrevCol=previousCollision&&previousCollision.collided&&motion<0.2;// reuse collision object\ncollision=previousCollision;}else{collision={collided:false,bodyA:bodyA,bodyB:bodyB};}if(previousCollision&&canReusePrevCol){// if we can reuse the collision result\n// we only need to test the previously found axis\nvar axisBodyA=collision.axisBody,axisBodyB=axisBodyA===bodyA?bodyB:bodyA,axes=[axisBodyA.axes[previousCollision.axisNumber]];minOverlap=_overlapAxes(axisBodyA.vertices,axisBodyB.vertices,axes);collision.reused=true;if(minOverlap.overlap<=0){collision.collided=false;return collision;}}else{// if we can't reuse a result, perform a full SAT test\noverlapAB=_overlapAxes(bodyA.vertices,bodyB.vertices,bodyA.axes);if(overlapAB.overlap<=0){collision.collided=false;return collision;}overlapBA=_overlapAxes(bodyB.vertices,bodyA.vertices,bodyB.axes);if(overlapBA.overlap<=0){collision.collided=false;return collision;}if(overlapAB.overlap<overlapBA.overlap){minOverlap=overlapAB;collision.axisBody=bodyA;}else{minOverlap=overlapBA;collision.axisBody=bodyB;}// important for reuse later\ncollision.axisNumber=minOverlap.axisNumber;}collision.bodyA=bodyA.id<bodyB.id?bodyA:bodyB;collision.bodyB=bodyA.id<bodyB.id?bodyB:bodyA;collision.collided=true;collision.depth=minOverlap.overlap;collision.parentA=collision.bodyA.parent;collision.parentB=collision.bodyB.parent;bodyA=collision.bodyA;bodyB=collision.bodyB;// ensure normal is facing away from bodyA\nif(Vector.dot(minOverlap.axis,Vector.sub(bodyB.position,bodyA.position))<0){collision.normal={x:minOverlap.axis.x,y:minOverlap.axis.y};}else{collision.normal={x:-minOverlap.axis.x,y:-minOverlap.axis.y};}collision.tangent=Vector.perp(collision.normal);collision.penetration=collision.penetration||{};collision.penetration.x=collision.normal.x*collision.depth;collision.penetration.y=collision.normal.y*collision.depth;// find support points, there is always either exactly one or two\nvar verticesB=_findSupports(bodyA,bodyB,collision.normal),supports=[];// find the supports from bodyB that are inside bodyA\nif(Vertices.contains(bodyA.vertices,verticesB[0]))supports.push(verticesB[0]);if(Vertices.contains(bodyA.vertices,verticesB[1]))supports.push(verticesB[1]);// find the supports from bodyA that are inside bodyB\nif(supports.length<2){var verticesA=_findSupports(bodyB,bodyA,Vector.neg(collision.normal));if(Vertices.contains(bodyB.vertices,verticesA[0]))supports.push(verticesA[0]);if(supports.length<2&&Vertices.contains(bodyB.vertices,verticesA[1]))supports.push(verticesA[1]);}// account for the edge case of overlapping but no vertex containment\nif(supports.length<1)supports=[verticesB[0]];collision.supports=supports;return collision;};/**\r\n     * Find the overlap between two sets of vertices.\r\n     * @method _overlapAxes\r\n     * @private\r\n     * @param {} verticesA\r\n     * @param {} verticesB\r\n     * @param {} axes\r\n     * @return result\r\n     */var _overlapAxes=function _overlapAxes(verticesA,verticesB,axes){var projectionA=Vector._temp[0],projectionB=Vector._temp[1],result={overlap:Number.MAX_VALUE},overlap,axis;for(var i=0;i<axes.length;i++){axis=axes[i];_projectToAxis(projectionA,verticesA,axis);_projectToAxis(projectionB,verticesB,axis);overlap=Math.min(projectionA.max-projectionB.min,projectionB.max-projectionA.min);if(overlap<=0){result.overlap=overlap;return result;}if(overlap<result.overlap){result.overlap=overlap;result.axis=axis;result.axisNumber=i;}}return result;};/**\r\n     * Projects vertices on an axis and returns an interval.\r\n     * @method _projectToAxis\r\n     * @private\r\n     * @param {} projection\r\n     * @param {} vertices\r\n     * @param {} axis\r\n     */var _projectToAxis=function _projectToAxis(projection,vertices,axis){var min=Vector.dot(vertices[0],axis),max=min;for(var i=1;i<vertices.length;i+=1){var dot=Vector.dot(vertices[i],axis);if(dot>max){max=dot;}else if(dot<min){min=dot;}}projection.min=min;projection.max=max;};/**\r\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\r\n     * @method _findSupports\r\n     * @private\r\n     * @param {} bodyA\r\n     * @param {} bodyB\r\n     * @param {} normal\r\n     * @return [vector]\r\n     */var _findSupports=function _findSupports(bodyA,bodyB,normal){var nearestDistance=Number.MAX_VALUE,vertexToBody=Vector._temp[0],vertices=bodyB.vertices,bodyAPosition=bodyA.position,distance,vertex,vertexA,vertexB;// find closest vertex on bodyB\nfor(var i=0;i<vertices.length;i++){vertex=vertices[i];vertexToBody.x=vertex.x-bodyAPosition.x;vertexToBody.y=vertex.y-bodyAPosition.y;distance=-Vector.dot(normal,vertexToBody);if(distance<nearestDistance){nearestDistance=distance;vertexA=vertex;}}// find next closest vertex using the two connected to it\nvar prevIndex=vertexA.index-1>=0?vertexA.index-1:vertices.length-1;vertex=vertices[prevIndex];vertexToBody.x=vertex.x-bodyAPosition.x;vertexToBody.y=vertex.y-bodyAPosition.y;nearestDistance=-Vector.dot(normal,vertexToBody);vertexB=vertex;var nextIndex=(vertexA.index+1)%vertices.length;vertex=vertices[nextIndex];vertexToBody.x=vertex.x-bodyAPosition.x;vertexToBody.y=vertex.y-bodyAPosition.y;distance=-Vector.dot(normal,vertexToBody);if(distance<nearestDistance){vertexB=vertex;}return[vertexA,vertexB];};})();/***/},/* 468 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\r\n*\r\n* @class Detector\r\n*/// TODO: speculative contacts\nvar Detector={};module.exports=Detector;var SAT=__webpack_require__(467);var Pair=__webpack_require__(383);var Bounds=__webpack_require__(92);(function(){/**\r\n     * Finds all collisions given a list of pairs.\r\n     * @method collisions\r\n     * @param {pair[]} broadphasePairs\r\n     * @param {engine} engine\r\n     * @return {array} collisions\r\n     */Detector.collisions=function(broadphasePairs,engine){var collisions=[],pairsTable=engine.pairs.table;// @if DEBUG\nvar metrics=engine.metrics;// @endif\nfor(var i=0;i<broadphasePairs.length;i++){var bodyA=broadphasePairs[i][0],bodyB=broadphasePairs[i][1];if((bodyA.isStatic||bodyA.isSleeping)&&(bodyB.isStatic||bodyB.isSleeping))continue;if(!Detector.canCollide(bodyA.collisionFilter,bodyB.collisionFilter))continue;// @if DEBUG\nmetrics.midphaseTests+=1;// @endif\n// mid phase\nif(Bounds.overlaps(bodyA.bounds,bodyB.bounds)){for(var j=bodyA.parts.length>1?1:0;j<bodyA.parts.length;j++){var partA=bodyA.parts[j];for(var k=bodyB.parts.length>1?1:0;k<bodyB.parts.length;k++){var partB=bodyB.parts[k];if(partA===bodyA&&partB===bodyB||Bounds.overlaps(partA.bounds,partB.bounds)){// find a previous collision we could reuse\nvar pairId=Pair.id(partA,partB),pair=pairsTable[pairId],previousCollision;if(pair&&pair.isActive){previousCollision=pair.collision;}else{previousCollision=null;}// narrow phase\nvar collision=SAT.collides(partA,partB,previousCollision);// @if DEBUG\nmetrics.narrowphaseTests+=1;if(collision.reused)metrics.narrowReuseCount+=1;// @endif\nif(collision.collided){collisions.push(collision);// @if DEBUG\nmetrics.narrowDetections+=1;// @endif\n}}}}}}return collisions;};/**\r\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\r\n     * See `body.collisionFilter` for more information.\r\n     * @method canCollide\r\n     * @param {} filterA\r\n     * @param {} filterB\r\n     * @return {bool} `true` if collision can occur\r\n     */Detector.canCollide=function(filterA,filterB){if(filterA.group===filterB.group&&filterA.group!==0)return filterA.group>0;return(filterA.mask&filterB.category)!==0&&(filterB.mask&filterA.category)!==0;};})();/***/},/* 469 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Bodies=__webpack_require__(123);var Body=__webpack_require__(51);var Class=__webpack_require__(0);var Components=__webpack_require__(384);var GetFastValue=__webpack_require__(2);var HasValue=__webpack_require__(71);var Vertices=__webpack_require__(93);/**\r\n * @classdesc\r\n * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only\r\n * have one Matter body associated with it. You can either pass in an existing Matter body for\r\n * the tile or allow the constructor to create the corresponding body for you. If the Tile has a\r\n * collision group (defined in Tiled), those shapes will be used to create the body. If not, the\r\n * tile's rectangle bounding box will be used.\r\n *\r\n * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.\r\n *\r\n * Note: not all Tiled collision shapes are supported. See\r\n * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.\r\n *\r\n * @class TileBody\r\n * @memberOf Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.\r\n * @param {object} [options] - Options to be used when creating the Matter body. See\r\n * Phaser.Physics.Matter.Matter.Body for a list of what Matter accepts.\r\n * @param {Phaser.Physics.Matter.Matter.Body} [options.body=null] - An existing Matter body to\r\n * be used instead of creating a new one.\r\n * @param {boolean} [options.isStatic=true] - Whether or not the newly created body should be\r\n * made static. This defaults to true since typically tiles should not be moved.\r\n * @param {boolean} [options.addToWorld=true] - Whether or not to add the newly created body (or\r\n * existing body if options.body is used) to the Matter world.\r\n */var MatterTileBody=new Class({Mixins:[Components.Bounce,Components.Collision,Components.Friction,Components.Gravity,Components.Mass,Components.Sensor,Components.Sleep,Components.Static],initialize:function MatterTileBody(world,tile,options){/**\r\n         * The tile object the body is associated with.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#tile\r\n         * @type {Phaser.Tilemaps.Tile}\r\n         * @since 3.0.0\r\n         */this.tile=tile;/**\r\n         * The Matter world the body exists within.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */this.world=world;// Install a reference to 'this' on the tile and ensure there can only be one matter body\n// associated with the tile\nif(tile.physics.matterBody){tile.physics.matterBody.destroy();}tile.physics.matterBody=this;// Set the body either from an existing body (if provided), the shapes in the tileset\n// collision layer (if it exists) or a rectangle matching the tile.\nvar body=GetFastValue(options,'body',null);var addToWorld=GetFastValue(options,'addToWorld',true);if(!body){var collisionGroup=tile.getCollisionGroup();var collisionObjects=GetFastValue(collisionGroup,'objects',[]);if(collisionObjects.length>0){this.setFromTileCollision(options);}else{this.setFromTileRectangle(options);}}else{this.setBody(body,addToWorld);}},/**\r\n     * Sets the current body to a rectangle that matches the bounds of the tile.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * @param {boolean} [options.isStatic=true] - Whether or not the newly created body should be\r\n     * made static. This defaults to true since typically tiles should not be moved.\r\n     * @param {boolean} [options.addToWorld=true] - Whether or not to add the newly created body (or\r\n     * existing body if options.body is used) to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */setFromTileRectangle:function setFromTileRectangle(options){if(options===undefined){options={};}if(!HasValue(options,'isStatic')){options.isStatic=true;}if(!HasValue(options,'addToWorld')){options.addToWorld=true;}var bounds=this.tile.getBounds();var cx=bounds.x+bounds.width/2;var cy=bounds.y+bounds.height/2;var body=Bodies.rectangle(cx,cy,bounds.width,bounds.height,options);this.setBody(body,options.addToWorld);return this;},/**\r\n     * Sets the current body from the collision group associated with the Tile. This is typically\r\n     * set up in Tiled's collision editor.\r\n     *\r\n     * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly\r\n     * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are\r\n     * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave\r\n     * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to\r\n     * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave\r\n     * polygon into multiple convex polygons yourself.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * @param {boolean} [options.isStatic=true] - Whether or not the newly created body should be\r\n     * made static. This defaults to true since typically tiles should not be moved.\r\n     * @param {boolean} [options.addToWorld=true] - Whether or not to add the newly created body (or\r\n     * existing body if options.body is used) to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */setFromTileCollision:function setFromTileCollision(options){if(options===undefined){options={};}if(!HasValue(options,'isStatic')){options.isStatic=true;}if(!HasValue(options,'addToWorld')){options.addToWorld=true;}var sx=this.tile.tilemapLayer.scaleX;var sy=this.tile.tilemapLayer.scaleY;var tileX=this.tile.getLeft();var tileY=this.tile.getTop();var collisionGroup=this.tile.getCollisionGroup();var collisionObjects=GetFastValue(collisionGroup,'objects',[]);var parts=[];for(var i=0;i<collisionObjects.length;i++){var object=collisionObjects[i];var ox=tileX+object.x*sx;var oy=tileY+object.y*sy;var ow=object.width*sx;var oh=object.height*sy;var body=null;if(object.rectangle){body=Bodies.rectangle(ox+ow/2,oy+oh/2,ow,oh,options);}else if(object.ellipse){body=Bodies.circle(ox+ow/2,oy+oh/2,ow/2,options);}else if(object.polygon||object.polyline){// Polygons and polylines are both treated as closed polygons\nvar originalPoints=object.polygon?object.polygon:object.polyline;var points=originalPoints.map(function(p){return{x:p.x*sx,y:p.y*sy};});var vertices=Vertices.create(points);// Points are relative to the object's origin (first point placed in Tiled), but\n// matter expects points to be relative to the center of mass. This only applies to\n// convex shapes. When a concave shape is decomposed, multiple parts are created and\n// the individual parts are positioned relative to (ox, oy).\nif(Vertices.isConvex(points)){var center=Vertices.centre(vertices);ox+=center.x;oy+=center.y;}body=Bodies.fromVertices(ox,oy,vertices,options);}if(body){parts.push(body);}}if(parts.length===1){this.setBody(parts[0],options.addToWorld);}else if(parts.length>1){options.parts=parts;this.setBody(Body.create(options),options.addToWorld);}return this;},/**\r\n     * Sets the current body to the given body. This will remove the previous body, if one already\r\n     * exists.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} body - The new Matter body to use.\r\n     * @param {boolean} [addToWorld=true] - Whether or not to add the body to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */setBody:function setBody(body,addToWorld){if(addToWorld===undefined){addToWorld=true;}if(this.body){this.removeBody();}this.body=body;this.body.gameObject=this;if(addToWorld){this.world.add(this.body);}return this;},/**\r\n     * Removes the current body from the TileBody and from the Matter world\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#removeBody\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */removeBody:function removeBody(){if(this.body){this.world.remove(this.body);this.body.gameObject=undefined;this.body=undefined;}return this;},/**\r\n     * Removes the current body from the tile and the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */destroy:function destroy(){this.removeBody();this.tile.physics.matterBody=undefined;}});module.exports=MatterTileBody;/***/},/* 470 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\r\n*\r\n* @class Axes\r\n*/var Axes={};module.exports=Axes;var Vector=__webpack_require__(83);var Common=__webpack_require__(37);(function(){/**\r\n     * Creates a new set of axes from the given vertices.\r\n     * @method fromVertices\r\n     * @param {vertices} vertices\r\n     * @return {axes} A new axes from the given vertices\r\n     */Axes.fromVertices=function(vertices){var axes={};// find the unique axes, using edge normal gradients\nfor(var i=0;i<vertices.length;i++){var j=(i+1)%vertices.length,normal=Vector.normalise({x:vertices[j].y-vertices[i].y,y:vertices[i].x-vertices[j].x}),gradient=normal.y===0?Infinity:normal.x/normal.y;// limit precision\ngradient=gradient.toFixed(3).toString();axes[gradient]=normal;}return Common.values(axes);};/**\r\n     * Rotates a set of axes by the given angle.\r\n     * @method rotate\r\n     * @param {axes} axes\r\n     * @param {number} angle\r\n     */Axes.rotate=function(axes,angle){if(angle===0)return;var cos=Math.cos(angle),sin=Math.sin(angle);for(var i=0;i<axes.length;i++){var axis=axes[i],xx;xx=axis.x*cos-axis.y*sin;axis.y=axis.x*sin+axis.y*cos;axis.x=xx;}};})();/***/},/* 471 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Physics.Impact.Body.Components\r\n */module.exports={Acceleration:__webpack_require__(1039),BodyScale:__webpack_require__(1038),BodyType:__webpack_require__(1037),Bounce:__webpack_require__(1036),CheckAgainst:__webpack_require__(1035),Collides:__webpack_require__(1034),Debug:__webpack_require__(1033),Friction:__webpack_require__(1032),Gravity:__webpack_require__(1031),Offset:__webpack_require__(1030),SetGameObject:__webpack_require__(1029),Velocity:__webpack_require__(1028)};/***/},/* 472 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetOverlapY=__webpack_require__(210);/**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Arcade.SeparateY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - [description]\r\n * @param {Phaser.Physics.Arcade.Body} body2 - [description]\r\n * @param {boolean} overlapOnly - [description]\r\n * @param {number} bias - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var SeparateY=function SeparateY(body1,body2,overlapOnly,bias){var overlap=GetOverlapY(body1,body2,overlapOnly,bias);//  Can't separate two immovable bodies, or a body with its own custom separation logic\nif(overlapOnly||overlap===0||body1.immovable&&body2.immovable||body1.customSeparateY||body2.customSeparateY){//  return true if there was some overlap, otherwise false\nreturn overlap!==0||body1.embedded&&body2.embedded;}//  Adjust their positions and velocities accordingly (if there was any overlap)\nvar v1=body1.velocity.y;var v2=body2.velocity.y;if(!body1.immovable&&!body2.immovable){overlap*=0.5;body1.y-=overlap;body2.y+=overlap;var nv1=Math.sqrt(v2*v2*body2.mass/body1.mass)*(v2>0?1:-1);var nv2=Math.sqrt(v1*v1*body1.mass/body2.mass)*(v1>0?1:-1);var avg=(nv1+nv2)*0.5;nv1-=avg;nv2-=avg;body1.velocity.y=avg+nv1*body1.bounce.y;body2.velocity.y=avg+nv2*body2.bounce.y;}else if(!body1.immovable){body1.y-=overlap;body1.velocity.y=v2-v1*body1.bounce.y;//  This is special case code that handles things like horizontal moving platforms you can ride\nif(body2.moves){body1.x+=(body2.x-body2.prev.x)*body2.friction.x;}}else{body2.y+=overlap;body2.velocity.y=v1-v2*body2.bounce.y;//  This is special case code that handles things like horizontal moving platforms you can ride\nif(body1.moves){body2.x+=(body1.x-body1.prev.x)*body1.friction.x;}}//  If we got this far then there WAS overlap, and separation is complete, so return true\nreturn true;};module.exports=SeparateY;/***/},/* 473 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetOverlapX=__webpack_require__(211);/**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Arcade.SeparateX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - [description]\r\n * @param {Phaser.Physics.Arcade.Body} body2 - [description]\r\n * @param {boolean} overlapOnly - [description]\r\n * @param {number} bias - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var SeparateX=function SeparateX(body1,body2,overlapOnly,bias){var overlap=GetOverlapX(body1,body2,overlapOnly,bias);//  Can't separate two immovable bodies, or a body with its own custom separation logic\nif(overlapOnly||overlap===0||body1.immovable&&body2.immovable||body1.customSeparateX||body2.customSeparateX){//  return true if there was some overlap, otherwise false\nreturn overlap!==0||body1.embedded&&body2.embedded;}//  Adjust their positions and velocities accordingly (if there was any overlap)\nvar v1=body1.velocity.x;var v2=body2.velocity.x;if(!body1.immovable&&!body2.immovable){overlap*=0.5;body1.x-=overlap;body2.x+=overlap;var nv1=Math.sqrt(v2*v2*body2.mass/body1.mass)*(v2>0?1:-1);var nv2=Math.sqrt(v1*v1*body1.mass/body2.mass)*(v1>0?1:-1);var avg=(nv1+nv2)*0.5;nv1-=avg;nv2-=avg;body1.velocity.x=avg+nv1*body1.bounce.x;body2.velocity.x=avg+nv2*body2.bounce.x;}else if(!body1.immovable){body1.x-=overlap;body1.velocity.x=v2-v1*body1.bounce.x;//  This is special case code that handles things like vertically moving platforms you can ride\nif(body2.moves){body1.y+=(body2.y-body2.prev.y)*body2.friction.y;}}else{body2.x+=overlap;body2.velocity.x=v1-v2*body2.bounce.x;//  This is special case code that handles things like vertically moving platforms you can ride\nif(body1.moves){body2.y+=(body1.y-body1.prev.y)*body1.friction.y;}}//  If we got this far then there WAS overlap, and separation is complete, so return true\nreturn true;};module.exports=SeparateX;/***/},/* 474 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Internal function to process the separation of a physics body from a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.ProcessTileSeparationY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {number} y - The y separation amount.\r\n */var ProcessTileSeparationY=function ProcessTileSeparationY(body,y){if(y<0){body.blocked.up=true;}else if(y>0){body.blocked.down=true;}body.position.y-=y;if(body.bounce.y===0){body.velocity.y=0;}else{body.velocity.y=-body.velocity.y*body.bounce.y;}};module.exports=ProcessTileSeparationY;/***/},/* 475 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ProcessTileSeparationY=__webpack_require__(474);/**\r\n * Check the body against the given tile on the Y axis.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.TileCheckY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to check.\r\n * @param {number} tileTop - [description]\r\n * @param {number} tileBottom - [description]\r\n * @param {number} tileBias - [description]\r\n *\r\n * @return {number} The amount of separation that occurred.\r\n */var TileCheckY=function TileCheckY(body,tile,tileTop,tileBottom,tileBias){var oy=0;if(body.deltaY()<0&&!body.blocked.up&&tile.collideDown&&body.checkCollision.up){//  Body is moving UP\nif(tile.faceBottom&&body.y<tileBottom){oy=body.y-tileBottom;if(oy<-tileBias){oy=0;}}}else if(body.deltaY()>0&&!body.blocked.down&&tile.collideUp&&body.checkCollision.down){//  Body is moving DOWN\nif(tile.faceTop&&body.bottom>tileTop){oy=body.bottom-tileTop;if(oy>tileBias){oy=0;}}}if(oy!==0){if(body.customSeparateY){body.overlapY=oy;}else{ProcessTileSeparationY(body,oy);}}return oy;};module.exports=TileCheckY;/***/},/* 476 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Internal function to process the separation of a physics body from a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.ProcessTileSeparationX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {number} x - The x separation amount.\r\n */var ProcessTileSeparationX=function ProcessTileSeparationX(body,x){if(x<0){body.blocked.left=true;}else if(x>0){body.blocked.right=true;}body.position.x-=x;if(body.bounce.x===0){body.velocity.x=0;}else{body.velocity.x=-body.velocity.x*body.bounce.x;}};module.exports=ProcessTileSeparationX;/***/},/* 477 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ProcessTileSeparationX=__webpack_require__(476);/**\r\n * Check the body against the given tile on the X axis.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.TileCheckX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to check.\r\n * @param {number} tileLeft - [description]\r\n * @param {number} tileRight - [description]\r\n * @param {number} tileBias - [description]\r\n *\r\n * @return {number} The amount of separation that occurred.\r\n */var TileCheckX=function TileCheckX(body,tile,tileLeft,tileRight,tileBias){var ox=0;if(body.deltaX()<0&&!body.blocked.left&&tile.collideRight&&body.checkCollision.left){//  Body is moving LEFT\nif(tile.faceRight&&body.x<tileRight){ox=body.x-tileRight;if(ox<-tileBias){ox=0;}}}else if(body.deltaX()>0&&!body.blocked.right&&tile.collideLeft&&body.checkCollision.right){//  Body is moving RIGHT\nif(tile.faceLeft&&body.right>tileLeft){ox=body.right-tileLeft;if(ox>tileBias){ox=0;}}}if(ox!==0){if(body.customSeparateX){body.overlapX=ox;}else{ProcessTileSeparationX(body,ox);}}return ox;};module.exports=TileCheckX;/***/},/* 478 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var TileCheckX=__webpack_require__(477);var TileCheckY=__webpack_require__(475);var TileIntersectsBody=__webpack_require__(207);/**\r\n * The core separation function to separate a physics body and a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.SeparateTile\r\n * @since 3.0.0\r\n *\r\n * @param {number} i - [description]\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to collide against.\r\n * @param {Phaser.Geom.Rectangle} tileWorldRect - [description]\r\n * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemapLayer to collide against.\r\n * @param {number} tileBias - [description]\r\n *\r\n * @return {boolean} Returns true if the body was separated, otherwise false.\r\n */var SeparateTile=function SeparateTile(i,body,tile,tileWorldRect,tilemapLayer,tileBias){var tileLeft=tileWorldRect.left;var tileTop=tileWorldRect.top;var tileRight=tileWorldRect.right;var tileBottom=tileWorldRect.bottom;var faceHorizontal=tile.faceLeft||tile.faceRight;var faceVertical=tile.faceTop||tile.faceBottom;//  We don't need to go any further if this tile doesn't actually have any colliding faces. This\n//  could happen if the tile was meant to be collided with re: a callback, but otherwise isn't\n//  needed for separation.\nif(!faceHorizontal&&!faceVertical){return false;}var ox=0;var oy=0;var minX=0;var minY=1;if(body.deltaAbsX()>body.deltaAbsY()){//  Moving faster horizontally, check X axis first\nminX=-1;}else if(body.deltaAbsX()<body.deltaAbsY()){//  Moving faster vertically, check Y axis first\nminY=-1;}if(body.deltaX()!==0&&body.deltaY()!==0&&faceHorizontal&&faceVertical){//  We only need do this if both axes have colliding faces AND we're moving in both\n//  directions\nminX=Math.min(Math.abs(body.position.x-tileRight),Math.abs(body.right-tileLeft));minY=Math.min(Math.abs(body.position.y-tileBottom),Math.abs(body.bottom-tileTop));}if(minX<minY){if(faceHorizontal){ox=TileCheckX(body,tile,tileLeft,tileRight,tileBias);//  That's horizontal done, check if we still intersects? If not then we can return now\nif(ox!==0&&!TileIntersectsBody(tileWorldRect,body)){return true;}}if(faceVertical){oy=TileCheckY(body,tile,tileTop,tileBottom,tileBias);}}else{if(faceVertical){oy=TileCheckY(body,tile,tileTop,tileBottom,tileBias);//  That's vertical done, check if we still intersects? If not then we can return now\nif(oy!==0&&!TileIntersectsBody(tileWorldRect,body)){return true;}}if(faceHorizontal){ox=TileCheckX(body,tile,tileLeft,tileRight,tileBias);}}return ox!==0||oy!==0;};module.exports=SeparateTile;/***/},/* 479 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.ProcessTileCallbacks\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.Tilemap} tile - [description]\r\n * @param {Phaser.GameObjects.Sprite} sprite - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var ProcessTileCallbacks=function ProcessTileCallbacks(tile,sprite){// Tile callbacks take priority over layer level callbacks\nif(tile.collisionCallback){return!tile.collisionCallback.call(tile.collisionCallbackContext,sprite,tile);}else if(tile.layer.callbacks[tile.index]){return!tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext,sprite,tile);}return true;};module.exports=ProcessTileCallbacks;/***/},/* 480 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Velocity\r\n * @since 3.0.0\r\n */var Velocity={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocity:function setVelocity(x,y){this.body.velocity.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocityX:function setVelocityX(x){this.body.velocity.x=x;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocityY:function setVelocityY(y){this.body.velocity.y=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Velocity#setMaxVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setMaxVelocity:function setMaxVelocity(x,y){this.body.maxVelocity.set(x,y);return this;}};module.exports=Velocity;/***/},/* 481 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Size\r\n * @since 3.0.0\r\n */var Size={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Size#setOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setOffset:function setOffset(x,y){this.body.setOffset(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Size#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {boolean} [center=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setSize:function setSize(width,height,center){this.body.setSize(width,height,center);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Size#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - [description]\r\n     * @param {number} [offsetX] - [description]\r\n     * @param {number} [offsetY] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCircle:function setCircle(radius,offsetX,offsetY){this.body.setCircle(radius,offsetX,offsetY);return this;}};module.exports=Size;/***/},/* 482 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Mass\r\n * @since 3.0.0\r\n */var Mass={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Mass#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setMass:function setMass(value){this.body.mass=value;return this;}};module.exports=Mass;/***/},/* 483 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Immovable\r\n * @since 3.0.0\r\n */var Immovable={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Immovable#setImmovable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setImmovable:function setImmovable(value){if(value===undefined){value=true;}this.body.immovable=value;return this;}};module.exports=Immovable;/***/},/* 484 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Gravity\r\n * @since 3.0.0\r\n */var Gravity={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Gravity#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setGravity:function setGravity(x,y){this.body.gravity.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Gravity#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setGravityX:function setGravityX(x){this.body.gravity.x=x;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Gravity#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setGravityY:function setGravityY(y){this.body.gravity.y=y;return this;}};module.exports=Gravity;/***/},/* 485 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Friction\r\n * @since 3.0.0\r\n */var Friction={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Friction#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFriction:function setFriction(x,y){this.body.friction.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Friction#setFrictionX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFrictionX:function setFrictionX(x){this.body.friction.x=x;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Friction#setFrictionY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFrictionY:function setFrictionY(y){this.body.friction.y=y;return this;}};module.exports=Friction;/***/},/* 486 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Enable\r\n * @since 3.0.0\r\n */var Enable={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Enable#enableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} reset - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {boolean} enableGameObject - [description]\r\n     * @param {boolean} showGameObject - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */enableBody:function enableBody(reset,x,y,enableGameObject,showGameObject){if(reset){this.body.reset(x,y);}if(enableGameObject){this.body.gameObject.active=true;}if(showGameObject){this.body.gameObject.visible=true;}this.body.enable=true;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Enable#disableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [disableGameObject=false] - [description]\r\n     * @param {boolean} [hideGameObject=false] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */disableBody:function disableBody(disableGameObject,hideGameObject){if(disableGameObject===undefined){disableGameObject=false;}if(hideGameObject===undefined){hideGameObject=false;}this.body.stop();this.body.enable=false;if(disableGameObject){this.body.gameObject.active=false;}if(hideGameObject){this.body.gameObject.visible=false;}return this;},/**\r\n     * Syncs the Bodies position and size with its parent Game Object.\r\n     * You don't need to call this for Dynamic Bodies, as it happens automatically.\r\n     * But for Static bodies it's a useful way of modifying the position of a Static Body\r\n     * in the Physics World, based on its Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Enable#refreshBody\r\n     * @since 3.1.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */refreshBody:function refreshBody(){this.body.updateFromGameObject();return this;}};module.exports=Enable;/***/},/* 487 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Drag\r\n * @since 3.0.0\r\n */var Drag={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Drag#setDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setDrag:function setDrag(x,y){this.body.drag.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Drag#setDragX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setDragX:function setDragX(value){this.body.drag.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Drag#setDragY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setDragY:function setDragY(value){this.body.drag.y=value;return this;}};module.exports=Drag;/***/},/* 488 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Debug\r\n * @since 3.0.0\r\n */var Debug={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Debug#setDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} showBody - [description]\r\n     * @param {boolean} showVelocity - [description]\r\n     * @param {number} bodyColor - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setDebug:function setDebug(showBody,showVelocity,bodyColor){this.debugShowBody=showBody;this.debugShowVelocity=showVelocity;this.debugBodyColor=bodyColor;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Debug#setDebugBodyColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setDebugBodyColor:function setDebugBodyColor(value){this.body.debugBodyColor=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Components.Debug#debugShowBody\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */debugShowBody:{get:function get(){return this.body.debugShowBody;},set:function set(value){this.body.debugShowBody=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Components.Debug#debugShowVelocity\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */debugShowVelocity:{get:function get(){return this.body.debugShowVelocity;},set:function set(value){this.body.debugShowVelocity=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Arcade.Components.Debug#debugBodyColor\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */debugBodyColor:{get:function get(){return this.body.debugBodyColor;},set:function set(value){this.body.debugBodyColor=value;}}};module.exports=Debug;/***/},/* 489 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Bounce\r\n * @since 3.0.0\r\n */var Bounce={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Bounce#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBounce:function setBounce(x,y){this.body.bounce.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Bounce#setBounceX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBounceX:function setBounceX(value){this.body.bounce.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Bounce#setBounceY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBounceY:function setBounceY(value){this.body.bounce.y=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Bounce#setCollideWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCollideWorldBounds:function setCollideWorldBounds(value){this.body.collideWorldBounds=value;return this;}};module.exports=Bounce;/***/},/* 490 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Angular\r\n * @since 3.0.0\r\n */var Angular={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Angular#setAngularVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAngularVelocity:function setAngularVelocity(value){this.body.angularVelocity=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Angular#setAngularAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAngularAcceleration:function setAngularAcceleration(value){this.body.angularAcceleration=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Angular#setAngularDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAngularDrag:function setAngularDrag(value){this.body.angularDrag=value;return this;}};module.exports=Angular;/***/},/* 491 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Arcade.Components.Acceleration\r\n * @since 3.0.0\r\n */var Acceleration={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Acceleration#setAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal acceleration\r\n     * @param {number} [y=x] - The vertical acceleration\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAcceleration:function setAcceleration(x,y){this.body.acceleration.set(x,y);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Acceleration#setAccelerationX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The horizontal acceleration\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAccelerationX:function setAccelerationX(value){this.body.acceleration.x=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Acceleration#setAccelerationY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The vertical acceleration\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAccelerationY:function setAccelerationY(value){this.body.acceleration.y=value;return this;}};module.exports=Acceleration;/***/},/* 492 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var DegToRad=__webpack_require__(43);var DistanceBetween=__webpack_require__(49);var Factory=__webpack_require__(219);var GetFastValue=__webpack_require__(2);var Merge=__webpack_require__(84);var PluginManager=__webpack_require__(13);var Vector2=__webpack_require__(6);var World=__webpack_require__(214);//  All methods in this class are available under `this.physics` in a Scene.\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ArcadePhysics\r\n * @memberOf Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var ArcadePhysics=new Class({initialize:function ArcadePhysics(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.config=this.getConfig();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */this.world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#add\r\n         * @type {Phaser.Physics.Arcade.Factory}\r\n         * @since 3.0.0\r\n         */this.add;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */getConfig:function getConfig(){var gameConfig=this.systems.game.config.physics;var sceneConfig=this.systems.settings.physics;var config=Merge(GetFastValue(sceneConfig,'arcade',{}),GetFastValue(gameConfig,'arcade',{}));return config;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){this.world=new World(this.scene,this.config);this.add=new Factory(this.world);var eventEmitter=this.systems.events;eventEmitter.on('update',this.world.update,this.world);eventEmitter.on('postupdate',this.world.postUpdate,this.world);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * Checks for overlaps between two Game Objects. The objects can be any Game Object that have an Arcade Physics Body.\r\n     *\r\n     * Unlike {@link #collide} the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.\r\n     *\r\n     * Both the first and second parameter can be arrays of objects, of differing types.\r\n     * If two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.\r\n     *\r\n     * ##### Tilemaps\r\n     *\r\n     * Any overlapping tiles, including blank/null tiles, will give a positive result. Tiles marked via {@link Phaser.Tilemap#setCollision} (and similar methods) have no special status, and callbacks added via {@link Phaser.Tilemap#setTileIndexCallback} or {@link Phaser.Tilemap#setTileLocationCallback} are not invoked. So calling this method without any callbacks isn't very useful.\r\n     *\r\n     * If you're interested only in whether an object overlaps a certain tile or class of tiles, filter the tiles with `processCallback` and then use the result returned by this method. Blank/null tiles can be excluded by their {@link Phaser.Tile#index index} (-1).\r\n     *\r\n     * If you want to take action on certain overlaps, examine the tiles in `collideCallback` and then handle as you like.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|array)} object1 - The first object or array of objects to check. Can be any Game Object that has an Arcade Physics Body.\r\n     * @param {(Phaser.GameObjects.GameObject|array)} object2 - The second object or array of objects to check. Can be any Game Object that has an Arcade Physics Body.\r\n     * @param {ArcadePhysicsCallback} [overlapCallback=null] - An optional callback function that is called if the objects overlap. The two objects will be passed to this function in the same order in which you specified them, unless you are checking Group vs. Sprite, in which case Sprite will always be the first parameter.\r\n     * @param {ArcadePhysicsCallback} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if an overlap occurred otherwise false.\r\n     */overlap:function overlap(object1,object2,overlapCallback,processCallback,callbackContext){if(overlapCallback===undefined){overlapCallback=null;}if(processCallback===undefined){processCallback=null;}if(callbackContext===undefined){callbackContext=overlapCallback;}return this.world.collideObjects(object1,object2,overlapCallback,processCallback,callbackContext,true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|array)} object1 - The first object or array of objects to check. Can be any Game Object that has an Arcade Physics Body.\r\n     * @param {(Phaser.GameObjects.GameObject|array)} object2 - The second object or array of objects to check. Can be any Game Object that has an Arcade Physics Body.\r\n     * @param {ArcadePhysicsCallback} [collideCallback=null] - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them, unless you are checking Group vs. Sprite, in which case Sprite will always be the first parameter.\r\n     * @param {ArcadePhysicsCallback} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if a collision occurred otherwise false.\r\n     */collide:function collide(object1,object2,collideCallback,processCallback,callbackContext){if(collideCallback===undefined){collideCallback=null;}if(processCallback===undefined){processCallback=null;}if(callbackContext===undefined){callbackContext=collideCallback;}return this.world.collideObjects(object1,object2,collideCallback,processCallback,callbackContext,false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} [description]\r\n     */pause:function pause(){return this.world.pause();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} [description]\r\n     */resume:function resume(){return this.world.resume();},/**\r\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)\r\n     *\r\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n     *\r\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {number} x - The x coordinate to accelerate towards.\r\n     * @param {number} y - The y coordinate to accelerate towards.\r\n     * @param {number} [speed=60] - The speed it will accelerate in pixels per second.\r\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */accelerateTo:function accelerateTo(gameObject,x,y,speed,xSpeedMax,ySpeedMax){if(speed===undefined){speed=60;}var angle=Math.atan2(y-gameObject.y,x-gameObject.x);gameObject.body.acceleration.setToPolar(angle,speed);if(xSpeedMax!==undefined&&ySpeedMax!==undefined){gameObject.body.maxVelocity.set(xSpeedMax,ySpeedMax);}return angle;},/**\r\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)\r\n     *\r\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n     *\r\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\r\n     * @param {number} [speed=60] - The speed it will accelerate in pixels per second.\r\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */accelerateToObject:function accelerateToObject(gameObject,destination,speed,xSpeedMax,ySpeedMax){return this.accelerateTo(gameObject,destination.x,destination.y,speed,xSpeedMax,ySpeedMax);},/**\r\n     * From a set of points or display objects, find the one closest to a source point or object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#closest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} The closest Body to the given source point.\r\n     */closest:function closest(source){var bodies=this.tree.all();var min=Number.MAX_VALUE;var closest=null;var x=source.x;var y=source.y;for(var i=bodies.length-1;i>=0;i--){var target=bodies[i];var distance=DistanceBetween(x,y,target.x,target.y);if(distance<min){closest=target;min=distance;}}return closest;},/**\r\n     * From a set of points or display objects, find the one farthest from a source point or object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} The Body furthest from the given source point.\r\n     */furthest:function furthest(source){var bodies=this.tree.all();var max=-1;var farthest=null;var x=source.x;var y=source.y;for(var i=bodies.length-1;i>=0;i--){var target=bodies[i];var distance=DistanceBetween(x,y,target.x,target.y);if(distance>max){farthest=target;max=distance;}}return farthest;},/**\r\n     * Move the given display object towards the x/y coordinates at a steady velocity.\r\n     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\r\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {number} x - The x coordinate to move towards.\r\n     * @param {number} y - The y coordinate to move towards.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */moveTo:function moveTo(gameObject,x,y,speed,maxTime){if(speed===undefined){speed=60;}if(maxTime===undefined){maxTime=0;}var angle=Math.atan2(y-gameObject.y,x-gameObject.x);if(maxTime>0){//  We know how many pixels we need to move, but how fast?\nspeed=DistanceBetween(gameObject.x,gameObject.y,x,y)/(maxTime/1000);}gameObject.body.velocity.setToPolar(angle,speed);return angle;},/**\r\n     * Move the given display object towards the destination object at a steady velocity.\r\n     * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\r\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */moveToObject:function moveToObject(gameObject,destination,speed,maxTime){return this.moveTo(gameObject,destination.x,destination.y,speed,maxTime);},/**\r\n     * Given the angle (in degrees) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\r\n     * One way to use this is: velocityFromAngle(angle, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second sq.\r\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n     */velocityFromAngle:function velocityFromAngle(angle,speed,vec2){if(speed===undefined){speed=60;}if(vec2===undefined){vec2=new Vector2();}return vec2.setToPolar(DegToRad(angle),speed);},/**\r\n     * Given the rotation (in radians) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\r\n     * One way to use this is: velocityFromRotation(rotation, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rotation - The angle in radians.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second sq.\r\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n     */velocityFromRotation:function velocityFromRotation(rotation,speed,vec2){if(speed===undefined){speed=60;}if(vec2===undefined){vec2=new Vector2();}return vec2.setToPolar(rotation,speed);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.world.shutdown();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.world.destroy();}});PluginManager.register('ArcadePhysics',ArcadePhysics,'arcadePhysics');module.exports=ArcadePhysics;/***/},/* 493 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(47);var Extend=__webpack_require__(18);/**\r\n * @callback ArcadePhysicsCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} object1 - [description]\r\n * @param {Phaser.GameObjects.GameObject} object2 - [description]\r\n *//**\r\n * @namespace Phaser.Physics.Arcade\r\n */var Arcade={ArcadePhysics:__webpack_require__(492),Body:__webpack_require__(213),Collider:__webpack_require__(212),Factory:__webpack_require__(219),Group:__webpack_require__(216),Image:__webpack_require__(218),Sprite:__webpack_require__(94),StaticBody:__webpack_require__(206),StaticGroup:__webpack_require__(215),World:__webpack_require__(214)};//   Merge in the consts\nArcade=Extend(false,Arcade,CONST);module.exports=Arcade;/***/},/* 494 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Checks if the two values are within the given `tolerance` of each other.\r\n *\r\n * @function Phaser.Math.Within\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - [description]\r\n * @param {number} b - [description]\r\n * @param {number} tolerance - The tolerance. Anything equal to or less than this value is considered as being within range.\r\n *\r\n * @return {boolean} Returns `true` if `a` is less than or equal to the tolerance of `b`.\r\n */var Within=function Within(a,b,tolerance){return Math.abs(a-b)<=tolerance;};module.exports=Within;/***/},/* 495 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} SinCosTable\r\n *\r\n * @property {number} sin - [description]\r\n * @property {number} cos - [description]\r\n * @property {number} length - [description]\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.SinCosTableGenerator\r\n * @since 3.0.0\r\n *\r\n * @param {number} length - [description]\r\n * @param {number} sinAmp - [description]\r\n * @param {number} cosAmp - [description]\r\n * @param {number} frequency - [description]\r\n *\r\n * @return {SinCosTable} [description]\r\n */var SinCosTableGenerator=function SinCosTableGenerator(length,sinAmp,cosAmp,frequency){if(sinAmp===undefined){sinAmp=1;}if(cosAmp===undefined){cosAmp=1;}if(frequency===undefined){frequency=1;}frequency*=Math.PI/length;var cos=[];var sin=[];for(var c=0;c<length;c++){cosAmp-=sinAmp*frequency;sinAmp+=cosAmp*frequency;cos[c]=cosAmp;sin[c]=sinAmp;}return{sin:sin,cos:cos,length:length};};module.exports=SinCosTableGenerator;/***/},/* 496 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.RoundTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {integer} [place=0] - [description]\r\n * @param {integer} [base=10] - [description]\r\n *\r\n * @return {number} [description]\r\n */var RoundTo=function RoundTo(value,place,base){if(place===undefined){place=0;}if(base===undefined){base=10;}var p=Math.pow(base,-place);return Math.round(value*p)/p;};module.exports=RoundTo;/***/},/* 497 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.RandomXY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector2} vector - [description]\r\n * @param {float} scale - [description]\r\n *\r\n * @return {Phaser.Math.Vector2} [description]\r\n */var RandomXY=function RandomXY(vector,scale){if(scale===undefined){scale=1;}var r=Math.random()*2*Math.PI;vector.x=Math.cos(r)*scale;vector.y=Math.sin(r)*scale;return vector;};module.exports=RandomXY;/***/},/* 498 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Work out what percentage `value` is of the range between `min` and `max`.\r\n * If `max` isn't given then it will return the percentage of `value` to `min`.\r\n *\r\n * You can optionally specify an `upperMax` value, which is a mid-way point in the range that represents 100%, after which the % starts to go down to zero again.\r\n *\r\n * @function Phaser.Math.Percent\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {number} min - [description]\r\n * @param {number} [max] - [description]\r\n * @param {number} [upperMax] - [description]\r\n *\r\n * @return {float} A value between 0 and 1 representing the percentage.\r\n */var Percent=function Percent(value,min,max,upperMax){if(max===undefined){max=min+1;}var percentage=(value-min)/(max-min);if(percentage>1){if(upperMax!==undefined){percentage=(upperMax-value)/(upperMax-max);if(percentage<0){percentage=0;}}else{percentage=1;}}else if(percentage<0){percentage=0;}return percentage;};module.exports=Percent;/***/},/* 499 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.MinSub\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {number} amount - [description]\r\n * @param {number} min - [description]\r\n *\r\n * @return {number} [description]\r\n */var MinSub=function MinSub(value,amount,min){return Math.max(value-amount,min);};module.exports=MinSub;/***/},/* 500 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.MaxAdd\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {number} amount - [description]\r\n * @param {number} max - [description]\r\n *\r\n * @return {number} [description]\r\n */var MaxAdd=function MaxAdd(value,amount,max){return Math.min(value+amount,max);};module.exports=MaxAdd;/***/},/* 501 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.IsEvenStrict\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var IsEvenStrict=function IsEvenStrict(value){// Use strict equality === for \"is number\" test\nreturn value===parseFloat(value)?!(value%2):void 0;};module.exports=IsEvenStrict;/***/},/* 502 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.IsEven\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var IsEven=function IsEven(value){// Use abstract equality == for \"is number\" test\n// eslint-disable-next-line eqeqeq\nreturn value==parseFloat(value)?!(value%2):void 0;};module.exports=IsEven;/***/},/* 503 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.GetSpeed\r\n * @since 3.0.0\r\n *\r\n * @param {number} distance - The distance to travel in pixels.\r\n * @param {integer} time - The time, in ms, to cover the distance in.\r\n *\r\n * @return {number} The amount you will need to increment the position by each step in order to cover the distance in the time given.\r\n */var GetSpeed=function GetSpeed(distance,time){return distance/time/1000;};module.exports=GetSpeed;/***/},/* 504 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.FloorTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {integer} [place=0 - [description]\r\n * @param {integer} [base=10] - [description]\r\n *\r\n * @return {number} [description]\r\n */var FloorTo=function FloorTo(value,place,base){if(place===undefined){place=0;}if(base===undefined){base=10;}var p=Math.pow(base,-place);return Math.floor(value*p)/p;};module.exports=FloorTo;/***/},/* 505 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Difference\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - [description]\r\n * @param {number} b - [description]\r\n *\r\n * @return {number} [description]\r\n */var Difference=function Difference(a,b){return Math.abs(a-b);};module.exports=Difference;/***/},/* 506 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.CeilTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {number} [place=0] - [description]\r\n * @param {integer} [base=10] - [description]\r\n *\r\n * @return {number} [description]\r\n */var CeilTo=function CeilTo(value,place,base){if(place===undefined){place=0;}if(base===undefined){base=10;}var p=Math.pow(base,-place);return Math.ceil(value*p)/p;};module.exports=CeilTo;/***/},/* 507 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Average\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} values - [description]\r\n *\r\n * @return {number} [description]\r\n */var Average=function Average(values){var sum=0;for(var i=0;i<values.length;i++){sum+=+values[i];}return sum/values.length;};module.exports=Average;/***/},/* 508 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Snap.To\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {number} gap - [description]\r\n * @param {number} [start=0] - [description]\r\n *\r\n * @return {number} [description]\r\n */var SnapTo=function SnapTo(value,gap,start){if(start===undefined){start=0;}if(gap===0){return value;}value-=start;value=gap*Math.round(value/gap);return start+value;};module.exports=SnapTo;/***/},/* 509 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Snap.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {number} gap - [description]\r\n * @param {number} [start=0] - [description]\r\n *\r\n * @return {number} [description]\r\n */var SnapFloor=function SnapFloor(value,gap,start){if(start===undefined){start=0;}if(gap===0){return value;}value-=start;value=gap*Math.floor(value/gap);return start+value;};module.exports=SnapFloor;/***/},/* 510 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Snap.Ceil\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {number} gap - [description]\r\n * @param {number} [start=0] - [description]\r\n *\r\n * @return {number} [description]\r\n */var SnapCeil=function SnapCeil(value,gap,start){if(start===undefined){start=0;}if(gap===0){return value;}value-=start;value=gap*Math.ceil(value/gap);return start+value;};module.exports=SnapCeil;/***/},/* 511 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Math.Snap\r\n */module.exports={Ceil:__webpack_require__(510),Floor:__webpack_require__(509),To:__webpack_require__(508)};/***/},/* 512 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Tests the value and returns `true` if it is a power of two.\r\n *\r\n * @function Phaser.Math.Pow2.IsValuePowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to check if it's a power of two.\r\n *\r\n * @return {boolean} Returns `true` if `value` is a power of two, otherwise `false`.\r\n */var IsValuePowerOfTwo=function IsValuePowerOfTwo(value){return value>0&&(value&value-1)===0;};module.exports=IsValuePowerOfTwo;/***/},/* 513 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Math.Pow2\r\n */module.exports={GetNext:__webpack_require__(250),IsSize:__webpack_require__(151),IsValue:__webpack_require__(512)};/***/},/* 514 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Linear=__webpack_require__(154);/**\r\n * A Linear Interpolation Method.\r\n *\r\n * @function Phaser.Math.Interpolation.Linear\r\n * @since 3.0.0\r\n * @see https://en.wikipedia.org/wiki/Linear_interpolation\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {!number} k - The percentage of interploation, between 0 and 1.\r\n *\r\n * @return {!number} The interpolated value.\r\n */var LinearInterpolation=function LinearInterpolation(v,k){var m=v.length-1;var f=m*k;var i=Math.floor(f);if(k<0){return Linear(v[0],v[1],f);}if(k>1){return Linear(v[m],v[m-1],m-f);}return Linear(v[i],v[i+1>m?m:i+1],f-i);};module.exports=LinearInterpolation;/***/},/* 515 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CatmullRom=__webpack_require__(155);/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Interpolation.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {number} k - [description]\r\n *\r\n * @return {number} [description]\r\n */var CatmullRomInterpolation=function CatmullRomInterpolation(v,k){var m=v.length-1;var f=m*k;var i=Math.floor(f);if(v[0]===v[m]){if(k<0){i=Math.floor(f=m*(1+k));}return CatmullRom(f-i,v[(i-1+m)%m],v[i],v[(i+1)%m],v[(i+2)%m]);}else{if(k<0){return v[0]-(CatmullRom(-f,v[0],v[0],v[1],v[1])-v[0]);}if(k>1){return v[m]-(CatmullRom(f-m,v[m],v[m],v[m-1],v[m-1])-v[m]);}return CatmullRom(f-i,v[i?i-1:0],v[i],v[m<i+1?m:i+1],v[m<i+2?m:i+2]);}};module.exports=CatmullRomInterpolation;/***/},/* 516 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Bernstein=__webpack_require__(222);/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Interpolation.Bezier\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {number} k - [description]\r\n *\r\n * @return {number} [description]\r\n */var BezierInterpolation=function BezierInterpolation(v,k){var b=0;var n=v.length-1;for(var i=0;i<=n;i++){b+=Math.pow(1-k,n-i)*Math.pow(k,i)*v[i]*Bernstein(n,i);}return b;};module.exports=BezierInterpolation;/***/},/* 517 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Math.Interpolation\r\n */module.exports={Bezier:__webpack_require__(516),CatmullRom:__webpack_require__(515),CubicBezier:__webpack_require__(331),Linear:__webpack_require__(514),QuadraticBezier:__webpack_require__(327)};/***/},/* 518 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Fuzzy.LessThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - [description]\r\n * @param {number} b - [description]\r\n * @param {float} [epsilon=0.0001] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var LessThan=function LessThan(a,b,epsilon){if(epsilon===undefined){epsilon=0.0001;}return a<b+epsilon;};module.exports=LessThan;/***/},/* 519 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Fuzzy.GreaterThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - [description]\r\n * @param {number} b - [description]\r\n * @param {float} [epsilon=0.0001] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var GreaterThan=function GreaterThan(a,b,epsilon){if(epsilon===undefined){epsilon=0.0001;}return a>b-epsilon;};module.exports=GreaterThan;/***/},/* 520 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Fuzzy.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {float} [epsilon=0.0001] - [description]\r\n *\r\n * @return {number} [description]\r\n */var Floor=function Floor(value,epsilon){if(epsilon===undefined){epsilon=0.0001;}return Math.floor(value+epsilon);};module.exports=Floor;/***/},/* 521 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Fuzzy.Equal\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - [description]\r\n * @param {number} b - [description]\r\n * @param {float} [epsilon=0.0001] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Equal=function Equal(a,b,epsilon){if(epsilon===undefined){epsilon=0.0001;}return Math.abs(a-b)<epsilon;};module.exports=Equal;/***/},/* 522 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Fuzzy.Ceil\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - [description]\r\n * @param {float} [epsilon=0.0001] - [description]\r\n *\r\n * @return {number} [description]\r\n */var Ceil=function Ceil(value,epsilon){if(epsilon===undefined){epsilon=0.0001;}return Math.ceil(value-epsilon);};module.exports=Ceil;/***/},/* 523 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Math.Fuzzy\r\n */module.exports={Ceil:__webpack_require__(522),Equal:__webpack_require__(521),Floor:__webpack_require__(520),GreaterThan:__webpack_require__(519),LessThan:__webpack_require__(518)};/***/},/* 524 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Math.Easing\r\n */module.exports={Back:__webpack_require__(265),Bounce:__webpack_require__(264),Circular:__webpack_require__(263),Cubic:__webpack_require__(262),Elastic:__webpack_require__(261),Expo:__webpack_require__(260),Linear:__webpack_require__(259),Quadratic:__webpack_require__(258),Quartic:__webpack_require__(257),Quintic:__webpack_require__(256),Sine:__webpack_require__(255),Stepped:__webpack_require__(254)};/***/},/* 525 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Distance.Squared\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - [description]\r\n * @param {number} y1 - [description]\r\n * @param {number} x2 - [description]\r\n * @param {number} y2 - [description]\r\n *\r\n * @return {number} [description]\r\n */var DistanceSquared=function DistanceSquared(x1,y1,x2,y2){var dx=x1-x2;var dy=y1-y2;return dx*dx+dy*dy;};module.exports=DistanceSquared;/***/},/* 526 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Distance.Power\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - [description]\r\n * @param {number} y1 - [description]\r\n * @param {number} x2 - [description]\r\n * @param {number} y2 - [description]\r\n * @param {number} pow - [description]\r\n *\r\n * @return {number} [description]\r\n */var DistancePower=function DistancePower(x1,y1,x2,y2,pow){if(pow===undefined){pow=2;}return Math.sqrt(Math.pow(x2-x1,pow)+Math.pow(y2-y1,pow));};module.exports=DistancePower;/***/},/* 527 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Math.Distance\r\n */module.exports={Between:__webpack_require__(49),Power:__webpack_require__(526),Squared:__webpack_require__(525)};/***/},/* 528 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Gets the shortest angle between `angle1` and `angle2`.\r\n * Both angles must be in the range -180 to 180, which is the same clamped\r\n * range that `sprite.angle` uses, so you can pass in two sprite angles to\r\n * this method and get the shortest angle back between the two of them.\r\n *\r\n * The angle returned will be in the same range. If the returned angle is\r\n * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's\r\n * a clockwise rotation.\r\n *\r\n * @function Phaser.Math.Angle.ShortestBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle1 - The first angle in the range -180 to 180.\r\n * @param {number} angle2 - The second angle in the range -180 to 180.\r\n *\r\n * @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.\r\n */var ShortestBetween=function ShortestBetween(angle1,angle2){var difference=angle2-angle1;if(difference===0){return 0;}var times=Math.floor((difference- -180)/360);return difference-times*360;};module.exports=ShortestBetween;/***/},/* 529 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MATH_CONST=__webpack_require__(16);/**\r\n * Rotates `currentAngle` towards `targetAngle`, taking the shortest rotation distance. The `lerp` argument is the amount to rotate by in this call.\r\n *\r\n * @function Phaser.Math.Angle.RotateTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} currentAngle - The current angle, in radians.\r\n * @param {number} targetAngle - The target angle to rotate to, in radians.\r\n * @param {number} [lerp=0.05] - The lerp value to add to the current angle.\r\n *\r\n * @return {number} The adjusted angle.\r\n */var RotateTo=function RotateTo(currentAngle,targetAngle,lerp){if(lerp===undefined){lerp=0.05;}if(currentAngle===targetAngle){return currentAngle;}if(Math.abs(targetAngle-currentAngle)<=lerp||Math.abs(targetAngle-currentAngle)>=MATH_CONST.PI2-lerp){currentAngle=targetAngle;}else{if(Math.abs(targetAngle-currentAngle)>Math.PI){if(targetAngle<currentAngle){targetAngle+=MATH_CONST.PI2;}else{targetAngle-=MATH_CONST.PI2;}}if(targetAngle>currentAngle){currentAngle+=lerp;}else if(targetAngle<currentAngle){currentAngle-=lerp;}}return currentAngle;};module.exports=RotateTo;/***/},/* 530 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Normalize=__webpack_require__(223);/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Angle.Reverse\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - [description]\r\n *\r\n * @return {number} [description]\r\n */var Reverse=function Reverse(angle){return Normalize(angle+Math.PI);};module.exports=Reverse;/***/},/* 531 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Angle.BetweenPointsY\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point1 - [description]\r\n * @param {(Phaser.Geom.Point|object)} point2 - [description]\r\n *\r\n * @return {number} [description]\r\n */var BetweenPointsY=function BetweenPointsY(point1,point2){return Math.atan2(point2.x-point1.x,point2.y-point1.y);};module.exports=BetweenPointsY;/***/},/* 532 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Angle.BetweenPoints\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point1 - [description]\r\n * @param {(Phaser.Geom.Point|object)} point2 - [description]\r\n *\r\n * @return {number} [description]\r\n */var BetweenPoints=function BetweenPoints(point1,point2){return Math.atan2(point2.y-point1.y,point2.x-point1.x);};module.exports=BetweenPoints;/***/},/* 533 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Angle.BetweenY\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - [description]\r\n * @param {number} y1 - [description]\r\n * @param {number} x2 - [description]\r\n * @param {number} y2 - [description]\r\n *\r\n * @return {number} [description]\r\n */var BetweenY=function BetweenY(x1,y1,x2,y2){return Math.atan2(x2-x1,y2-y1);};module.exports=BetweenY;/***/},/* 534 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Angle.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - [description]\r\n * @param {number} y1 - [description]\r\n * @param {number} x2 - [description]\r\n * @param {number} y2 - [description]\r\n *\r\n * @return {number} [description]\r\n */var Between=function Between(x1,y1,x2,y2){return Math.atan2(y2-y1,x2-x1);};module.exports=Between;/***/},/* 535 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Math.Angle\r\n */module.exports={Between:__webpack_require__(534),BetweenY:__webpack_require__(533),BetweenPoints:__webpack_require__(532),BetweenPointsY:__webpack_require__(531),Reverse:__webpack_require__(530),RotateTo:__webpack_require__(529),ShortestBetween:__webpack_require__(528),Normalize:__webpack_require__(223),Wrap:__webpack_require__(182),WrapDegrees:__webpack_require__(181)};/***/},/* 536 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(16);var Extend=__webpack_require__(18);/**\r\n * @namespace Phaser.Math\r\n */var PhaserMath={//  Collections of functions\nAngle:__webpack_require__(535),Distance:__webpack_require__(527),Easing:__webpack_require__(524),Fuzzy:__webpack_require__(523),Interpolation:__webpack_require__(517),Pow2:__webpack_require__(513),Snap:__webpack_require__(511),//  Single functions\nAverage:__webpack_require__(507),Bernstein:__webpack_require__(222),Between:__webpack_require__(320),CatmullRom:__webpack_require__(155),CeilTo:__webpack_require__(506),Clamp:__webpack_require__(50),DegToRad:__webpack_require__(43),Difference:__webpack_require__(505),Factorial:__webpack_require__(221),FloatBetween:__webpack_require__(266),FloorTo:__webpack_require__(504),FromPercent:__webpack_require__(80),GetSpeed:__webpack_require__(503),IsEven:__webpack_require__(502),IsEvenStrict:__webpack_require__(501),Linear:__webpack_require__(154),MaxAdd:__webpack_require__(500),MinSub:__webpack_require__(499),Percent:__webpack_require__(498),RadToDeg:__webpack_require__(156),RandomXY:__webpack_require__(497),RandomXYZ:__webpack_require__(341),RandomXYZW:__webpack_require__(340),Rotate:__webpack_require__(220),RotateAround:__webpack_require__(363),RotateAroundDistance:__webpack_require__(167),RoundAwayFromZero:__webpack_require__(282),RoundTo:__webpack_require__(496),SinCosTableGenerator:__webpack_require__(495),SmootherStep:__webpack_require__(357),SmoothStep:__webpack_require__(356),TransformXY:__webpack_require__(300),Within:__webpack_require__(494),Wrap:__webpack_require__(44),//  Vector classes\nVector2:__webpack_require__(6),Vector3:__webpack_require__(59),Vector4:__webpack_require__(159),Matrix3:__webpack_require__(337),Matrix4:__webpack_require__(160),Quaternion:__webpack_require__(338),RotateVec3:__webpack_require__(339)};//   Merge in the consts\nPhaserMath=Extend(false,PhaserMath,CONST);//  Export it\nmodule.exports=PhaserMath;/***/},/* 537 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var CustomSet=__webpack_require__(65);var EventEmitter=__webpack_require__(14);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);var ParseXMLBitmapFont=__webpack_require__(278);var PluginManager=__webpack_require__(13);var XHRSettings=__webpack_require__(95);/**\r\n * @typedef {object} LinkFileObject\r\n *\r\n * @property {string} type - [description]\r\n * @property {Phaser.Loader.File} fileA - [description]\r\n * @property {Phaser.Loader.File} fileB - [description]\r\n *//**\r\n * @typedef {object} LoaderFileObject\r\n *\r\n * @property {string} key - [description]\r\n * @property {string} type - [description]\r\n * @property {string} [url] - [description]\r\n * @property {string[]} [urls] - [description]\r\n * @property {string} [textureURL] - [description]\r\n * @property {string} [atlasURL] - [description]\r\n * @property {string} [xmlURL] - [description]\r\n * @property {string[]} [textureURLs] - [description]\r\n * @property {string[]} [atlasURLs] - [description]\r\n * @property {object} [config] - [description]\r\n * @property {object} [json] - [description]\r\n * @property {XHRSettingsObject} [xhrSettings] - [description]\r\n * @property {XHRSettingsObject} [textureXhrSettings] - [description]\r\n * @property {XHRSettingsObject} [atlasXhrSettings] - [description]\r\n * @property {XHRSettingsObject} [xmlXhrSettings] - [description]\r\n * @property {XHRSettingsObject} [audioXhrSettings] - [description]\r\n * @property {XHRSettingsObject} [jsonXhrSettings] - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class LoaderPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var LoaderPlugin=new Class({Extends:EventEmitter,initialize:function LoaderPlugin(scene){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#_multilist\r\n         * @type {object}\r\n         * @private\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */this._multilist={};//  Inject the available filetypes into the Loader\nFileTypesManager.install(this);var gameConfig=this.systems.game.config;var sceneConfig=this.systems.settings.loader;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#path\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.path='';/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#baseURL\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.baseURL='';this.setBaseURL(GetFastValue(sceneConfig,'baseURL',gameConfig.loaderBaseURL));this.setPath(GetFastValue(sceneConfig,'path',gameConfig.loaderPath));/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#enableParallel\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.enableParallel=GetFastValue(sceneConfig,'enableParallel',gameConfig.loaderEnableParallel);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#maxParallelDownloads\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.maxParallelDownloads=GetFastValue(sceneConfig,'maxParallelDownloads',gameConfig.loaderMaxParallelDownloads);/**\r\n         * xhr specific global settings (can be overridden on a per-file basis)\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#xhr\r\n         * @type {XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */this.xhr=XHRSettings(GetFastValue(sceneConfig,'responseType',gameConfig.loaderResponseType),GetFastValue(sceneConfig,'async',gameConfig.loaderAsync),GetFastValue(sceneConfig,'user',gameConfig.loaderUser),GetFastValue(sceneConfig,'password',gameConfig.loaderPassword),GetFastValue(sceneConfig,'timeout',gameConfig.loaderTimeout));/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#crossOrigin\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.crossOrigin=GetFastValue(sceneConfig,'crossOrigin',gameConfig.loaderCrossOrigin);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalToLoad\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.totalToLoad=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.progress=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#list\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */this.list=new CustomSet();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#inflight\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */this.inflight=new CustomSet();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#failed\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */this.failed=new CustomSet();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#queue\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */this.queue=new CustomSet();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#storage\r\n         * @type {Phaser.Structs.Set.<(Phaser.Loader.File|LinkFileObject)>}\r\n         * @since 3.0.0\r\n         */this.storage=new CustomSet();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.state=CONST.LOADER_IDLE;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setBaseURL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} url - [description]\r\n     *\r\n     * @return {Phaser.Loader.LoaderPlugin} This Loader object.\r\n     */setBaseURL:function setBaseURL(url){if(url!==''&&url.substr(-1)!=='/'){url=url.concat('/');}this.baseURL=url;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} path - [description]\r\n     *\r\n     * @return {Phaser.Loader.LoaderPlugin} This Loader object.\r\n     */setPath:function setPath(path){if(path!==''&&path.substr(-1)!=='/'){path=path.concat('/');}this.path=path;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setCORS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} crossOrigin - [description]\r\n     *\r\n     * @return {Phaser.Loader.LoaderPlugin} This Loader object.\r\n     */setCORS:function setCORS(crossOrigin){this.crossOrigin=crossOrigin;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#addFile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - [description]\r\n     *\r\n     * @return {Phaser.Loader.File} [description]\r\n     */addFile:function addFile(file){if(!this.isReady()){return-1;}file.path=this.path;this.list.set(file);return file;},/**\r\n     * Is the Loader actively loading (or processing loaded files)\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#isLoading\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isLoading:function isLoading(){return this.state===CONST.LOADER_LOADING||this.state===CONST.LOADER_PROCESSING;},/**\r\n     * Is the Loader ready to start a new load?\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#isReady\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isReady:function isReady(){return this.state===CONST.LOADER_IDLE||this.state===CONST.LOADER_COMPLETE;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#start\r\n     * @since 3.0.0\r\n     */start:function start(){if(!this.isReady()){return;}this.progress=0;this.totalToLoad=this.list.size;this.emit('start',this);if(this.list.size===0){this.finishedLoading();}else{this.state=CONST.LOADER_LOADING;this.failed.clear();this.inflight.clear();this.queue.clear();this.queue.debug=true;this.updateProgress();this.processLoadQueue();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#updateProgress\r\n     * @since 3.0.0\r\n     */updateProgress:function updateProgress(){this.progress=1-(this.list.size+this.inflight.size)/this.totalToLoad;this.emit('progress',this.progress);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#processLoadQueue\r\n     * @since 3.0.0\r\n     */processLoadQueue:function processLoadQueue(){this.list.each(function(file){if(file.state===CONST.FILE_POPULATED||file.state===CONST.FILE_PENDING&&this.inflight.size<this.maxParallelDownloads){this.inflight.set(file);this.list.delete(file);this.loadFile(file);}if(this.inflight.size===this.maxParallelDownloads){//  Tells the Set iterator to abort\nreturn false;}},this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#loadFile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - [description]\r\n     */loadFile:function loadFile(file){//  If the file doesn't have its own crossOrigin set,\n//  we'll use the Loaders (which is undefined by default)\nif(!file.crossOrigin){file.crossOrigin=this.crossOrigin;}file.load(this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#nextFile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} previousFile - [description]\r\n     * @param {boolean} success - [description]\r\n     */nextFile:function nextFile(previousFile,success){//  Move the file that just loaded from the inflight list to the queue or failed Set\nif(success){this.emit('load',previousFile);this.queue.set(previousFile);}else{this.emit('loaderror',previousFile);this.failed.set(previousFile);}this.inflight.delete(previousFile);this.updateProgress();if(this.list.size>0){this.processLoadQueue();}else if(this.inflight.size===0){this.finishedLoading();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#finishedLoading\r\n     * @since 3.0.0\r\n     */finishedLoading:function finishedLoading(){if(this.state===CONST.LOADER_PROCESSING){return;}this.progress=1;this.state=CONST.LOADER_PROCESSING;this.storage.clear();if(this.queue.size===0){//  Everything failed, so nothing to process\nthis.processComplete();}else{this.queue.each(function(file){file.onProcess(this.processUpdate.bind(this));},this);}},/**\r\n     * Called automatically by the File when it has finished processing.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#processUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - [description]\r\n     */processUpdate:function processUpdate(file){//  This file has failed to load, so move it to the failed Set\nif(file.state===CONST.FILE_ERRORED){this.failed.set(file);if(file.linkFile){this.queue.delete(file.linkFile);}return this.removeFromQueue(file);}//  If we got here, then the file loaded\n//  Special handling for multi-part files\nif(file.linkFile){if(file.state===CONST.FILE_COMPLETE&&file.linkFile.state===CONST.FILE_COMPLETE){//  Partner has loaded, so add them both to Storage\nthis.storage.set({type:file.linkType,fileA:file,fileB:file.linkFile});this.queue.delete(file.linkFile);this.removeFromQueue(file);}}else{this.storage.set(file);this.removeFromQueue(file);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#removeFromQueue\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - [description]\r\n     */removeFromQueue:function removeFromQueue(file){this.queue.delete(file);if(this.queue.size===0&&this.state===CONST.LOADER_PROCESSING){//  We've processed all the files we loaded\nthis.processComplete();}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#processComplete\r\n     * @since 3.0.0\r\n     */processComplete:function processComplete(){this.list.clear();this.inflight.clear();this.queue.clear();this.processCallback();this.state=CONST.LOADER_COMPLETE;this.emit('complete',this,this.storage.size,this.failed.size);//  Move to a User setting:\n// this.removeAllListeners();\n},/**\r\n     * The Loader has finished.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#processCallback\r\n     * @since 3.0.0\r\n     */processCallback:function processCallback(){if(this.storage.size===0){return;}//  The global Texture Manager\nvar cache=this.scene.sys.cache;var textures=this.scene.sys.textures;var anims=this.scene.sys.anims;//  Process multiatlas groups first\nvar file;var fileA;var fileB;for(var key in this._multilist){var data=[];var images=[];var keys=this._multilist[key];for(var i=0;i<keys.length;i++){file=this.storage.get('key',keys[i]);if(file){if(file.type==='image'){images.push(file.data);}else if(file.type==='json'){data.push(file.data);}this.storage.delete(file);}}//  Do we have everything needed?\nif(images.length+data.length===keys.length){//  Yup, add them to the Texture Manager\n//  Is the data JSON Hash or JSON Array?\nif(Array.isArray(data[0].textures)||Array.isArray(data[0].frames)){textures.addAtlasJSONArray(key,images,data);}else{textures.addAtlasJSONHash(key,images,data);}}}//  Process all of the files\n//  Because AnimationJSON may require images to be loaded first, we process them last\nvar animJSON=[];this.storage.each(function(file){switch(file.type){case'animationJSON':animJSON.push(file);break;case'image':case'svg':case'html':textures.addImage(file.key,file.data);break;case'atlasjson':fileA=file.fileA;fileB=file.fileB;if(fileA.type==='image'){textures.addAtlas(fileA.key,fileA.data,fileB.data);}else{textures.addAtlas(fileB.key,fileB.data,fileA.data);}break;case'dataimage':fileA=file.fileA;fileB=file.fileB;if(fileA.linkParent){textures.addImage(fileA.key,fileA.data,fileB.data);}else{textures.addImage(fileB.key,fileB.data,fileA.data);}break;case'unityatlas':fileA=file.fileA;fileB=file.fileB;if(fileA.type==='image'){textures.addUnityAtlas(fileA.key,fileA.data,fileB.data);}else{textures.addUnityAtlas(fileB.key,fileB.data,fileA.data);}break;case'bitmapfont':fileA=file.fileA;fileB=file.fileB;if(fileA.type==='image'){cache.bitmapFont.add(fileB.key,{data:ParseXMLBitmapFont(fileB.data),texture:fileA.key,frame:null});textures.addImage(fileA.key,fileA.data);}else{cache.bitmapFont.add(fileA.key,{data:ParseXMLBitmapFont(fileA.data),texture:fileB.key,frame:null});textures.addImage(fileB.key,fileB.data);}break;case'spritesheet':textures.addSpriteSheet(file.key,file.data,file.config);break;case'json':cache.json.add(file.key,file.data);break;case'xml':cache.xml.add(file.key,file.data);break;case'text':cache.text.add(file.key,file.data);break;case'obj':cache.obj.add(file.key,file.data);break;case'binary':cache.binary.add(file.key,file.data);break;case'audio':cache.audio.add(file.key,file.data);break;case'audioSprite':var files=[file.fileA,file.fileB];files.forEach(function(file){cache[file.type].add(file.key,file.data);});break;case'glsl':cache.shader.add(file.key,file.data);break;case'tilemapCSV':case'tilemapJSON':cache.tilemap.add(file.key,{format:file.tilemapFormat,data:file.data});break;}});animJSON.forEach(function(file){anims.fromJSON(file.data);});this.storage.clear();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#saveJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} data - [description]\r\n     * @param {string} [filename=file.json] - [description]\r\n     *\r\n     * @return {Phaser.Loader.LoaderPlugin} This Loader plugin.\r\n     */saveJSON:function saveJSON(data,filename){return this.save(JSON.stringify(data),filename);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#save\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} data - [description]\r\n     * @param {string} [filename=file.json] - [description]\r\n     * @param {string} [filetype=application/json] - [description]\r\n     *\r\n     * @return {Phaser.Loader.LoaderPlugin} This Loader plugin.\r\n     */save:function save(data,filename,filetype){if(filename===undefined){filename='file.json';}if(filetype===undefined){filetype='application/json';}var blob=new Blob([data],{type:filetype});var url=URL.createObjectURL(blob);var a=document.createElement('a');a.download=filename;a.textContent='Download '+filename;a.href=url;a.click();return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#reset\r\n     * @since 3.0.0\r\n     */reset:function reset(){this.list.clear();this.inflight.clear();this.failed.clear();this.queue.clear();this.storage.clear();var gameConfig=this.systems.game.config;var sceneConfig=this.systems.settings.loader;this.setBaseURL(GetFastValue(sceneConfig,'baseURL',gameConfig.loaderBaseURL));this.setPath(GetFastValue(sceneConfig,'path',gameConfig.loaderPath));this.state=CONST.LOADER_IDLE;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#loadArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {LoaderFileObject[]} files - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */loadArray:function loadArray(files){if(Array.isArray(files)){for(var i=0;i<files.length;i++){this.file(files[i]);}}return this.list.size>0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#file\r\n     * @since 3.0.0\r\n     *\r\n     * @param {LoaderFileObject} file - [description]\r\n     *\r\n     * @return {Phaser.Loader.File} [description]\r\n     */file:function file(_file){var entry;var key=_file.key;switch(_file.type){case'spritesheet':entry=this.spritesheet(key,_file.url,_file.config,_file.xhrSettings);break;case'atlas':entry=this.atlas(key,_file.textureURL,_file.atlasURL,_file.textureXhrSettings,_file.atlasXhrSettings);break;case'bitmapFont':entry=this.bitmapFont(key,_file.textureURL,_file.xmlURL,_file.textureXhrSettings,_file.xmlXhrSettings);break;case'multiatlas':entry=this.multiatlas(key,_file.textureURLs,_file.atlasURLs,_file.textureXhrSettings,_file.atlasXhrSettings);break;case'audioSprite':entry=this.audioSprite(key,_file.urls,_file.json,_file.config,_file.audioXhrSettings,_file.jsonXhrSettings);break;//  image, json, xml, binary, text, glsl, svg, obj\ndefault:entry=this[_file.type](key,_file.url,_file.xhrSettings);break;}return entry;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.reset();this.state=CONST.LOADER_SHUTDOWN;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.reset();this.state=CONST.LOADER_DESTROYED;}});PluginManager.register('Loader',LoaderPlugin,'load');module.exports=LoaderPlugin;/***/},/* 538 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FileTypesManager=__webpack_require__(7);var ImageFile=__webpack_require__(52);var TextFile=__webpack_require__(224);/**\r\n * An Atlas JSON File.\r\n *\r\n * @function Phaser.Loader.FileTypes.UnityAtlasFile\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {string} textureURL - The url to load the texture file from.\r\n * @param {string} atlasURL - The url to load the atlas file from.\r\n * @param {string} path - The path of the file.\r\n * @param {XHRSettingsObject} textureXhrSettings - Optional texture file specific XHR settings.\r\n * @param {XHRSettingsObject} atlasXhrSettings - Optional atlas file specific XHR settings.\r\n *\r\n * @return {object} An object containing two File objects to be added to the loader.\r\n */var UnityAtlasFile=function UnityAtlasFile(key,textureURL,atlasURL,path,textureXhrSettings,atlasXhrSettings){var image=new ImageFile(key,textureURL,path,textureXhrSettings);var data=new TextFile(key,atlasURL,path,atlasXhrSettings);//  Link them together\nimage.linkFile=data;data.linkFile=image;//  Set the type\nimage.linkType='unityatlas';data.linkType='unityatlas';return{texture:image,data:data};};/**\r\n * Adds a Unity Texture Atlas file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Unity Atlas File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#unityAtlas\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {string} textureURL - The url to load the texture file from.\r\n * @param {string} atlasURL - The url to load the atlas file from.\r\n * @param {XHRSettingsObject} textureXhrSettings - Optional texture file specific XHR settings.\r\n * @param {XHRSettingsObject} atlasXhrSettings - Optional atlas file specific XHR settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('unityAtlas',function(key,textureURL,atlasURL,textureXhrSettings,atlasXhrSettings){//  Returns an object with two properties: 'texture' and 'data'\nvar files=new UnityAtlasFile(key,textureURL,atlasURL,this.path,textureXhrSettings,atlasXhrSettings);this.addFile(files.texture);this.addFile(files.data);return this;});module.exports=UnityAtlasFile;/***/},/* 539 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FileTypesManager=__webpack_require__(7);var JSONFile=__webpack_require__(53);var TILEMAP_FORMATS=__webpack_require__(24);/**\r\n * A Tilemap File.\r\n *\r\n * @function Phaser.Loader.FileTypes.TilemapJSONFile\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {string} format - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {object} An object containing two File objects to be added to the loader.\r\n */var TilemapJSONFile=function TilemapJSONFile(key,url,path,format,xhrSettings){var json=new JSONFile(key,url,path,xhrSettings);//  Override the File type\njson.type='tilemapJSON';json.tilemapFormat=format;return json;};/**\r\n * Adds a Tilemap (Tiled JSON Format) file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Tilemap File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapTiledJSON\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('tilemapTiledJSON',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(TilemapJSONFile(key[i],url,this.path,TILEMAP_FORMATS.TILED_JSON,xhrSettings));}}else{this.addFile(TilemapJSONFile(key,url,this.path,TILEMAP_FORMATS.TILED_JSON,xhrSettings));}//  For method chaining\nreturn this;});/**\r\n * Adds a Tilemap (Weltmeister Format) file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Tilemap File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapWeltmeister\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('tilemapWeltmeister',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(TilemapJSONFile(key[i],url,this.path,TILEMAP_FORMATS.WELTMEISTER,xhrSettings));}}else{this.addFile(TilemapJSONFile(key,url,this.path,TILEMAP_FORMATS.WELTMEISTER,xhrSettings));}//  For method chaining\nreturn this;});module.exports=TilemapJSONFile;/***/},/* 540 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var TILEMAP_FORMATS=__webpack_require__(24);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TilemapCSVFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {string} format - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var TilemapCSVFile=new Class({Extends:File,initialize:function TilemapCSVFile(key,url,path,format,xhrSettings){var fileConfig={type:'tilemapCSV',extension:'.csv',responseType:'text',key:key,url:url,path:path,xhrSettings:xhrSettings};File.call(this,fileConfig);this.tilemapFormat=format;},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=this.xhrLoader.responseText;this.onComplete();callback(this);}});/**\r\n * Adds a Tilemap CSV file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Tilemap CSV File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapCSV\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('tilemapCSV',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new TilemapCSVFile(key[i],url,this.path,TILEMAP_FORMATS.CSV,xhrSettings));}}else{this.addFile(new TilemapCSVFile(key,url,this.path,TILEMAP_FORMATS.CSV,xhrSettings));}//  For method chaining\nreturn this;});module.exports=TilemapCSVFile;/***/},/* 541 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class SVGFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var SVGFile=new Class({Extends:File,initialize:function SVGFile(key,url,path,xhrSettings){var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'svg',extension:GetFastValue(key,'extension','svg'),responseType:'text',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings)};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;var svg=[this.xhrLoader.responseText];var _this=this;try{var blob=new window.Blob(svg,{type:'image/svg+xml;charset=utf-8'});}catch(e){_this.state=CONST.FILE_ERRORED;callback(_this);return;}this.data=new Image();this.data.crossOrigin=this.crossOrigin;var retry=false;this.data.onload=function(){if(!retry){File.revokeObjectURL(_this.data);}_this.onComplete();callback(_this);};this.data.onerror=function(){//  Safari 8 re-try\nif(!retry){retry=true;File.revokeObjectURL(_this.data);_this.data.src='data:image/svg+xml,'+encodeURIComponent(svg.join(''));}else{_this.state=CONST.FILE_ERRORED;callback(_this);}};File.createObjectURL(this.data,blob,'image/svg+xml');}});/**\r\n * Adds an SVG file to the current load queue.\r\n *\r\n * Note: This method will only be available if the SVG File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#svg\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('svg',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new SVGFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new SVGFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=SVGFile;/***/},/* 542 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FileTypesManager=__webpack_require__(7);var ImageFile=__webpack_require__(52);/**\r\n * A Sprite Sheet File.\r\n *\r\n * @function Phaser.Loader.FileTypes.SpriteSheetFile\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {string} url - The url to load the texture file from.\r\n * @param {object} config - Optional texture file specific XHR settings.\r\n * @param {string} path - Optional texture file specific XHR settings.\r\n * @param {XHRSettingsObject} xhrSettings - Optional atlas file specific XHR settings.\r\n *\r\n * @return {object} An object containing two File objects to be added to the loader.\r\n */var SpriteSheetFile=function SpriteSheetFile(key,url,config,path,xhrSettings){var image=new ImageFile(key,url,path,xhrSettings,config);//  Override the File type\nimage.type='spritesheet';return image;};/**\r\n * Adds a Sprite Sheet file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Sprite Sheet File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#spritesheet\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {object} config - config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing.\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('spritesheet',function(key,url,config,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new SpriteSheetFile(key[i],url,null,this.path,xhrSettings));}}else{this.addFile(new SpriteSheetFile(key,url,config,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=SpriteSheetFile;/***/},/* 543 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ScriptFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var ScriptFile=new Class({Extends:File,initialize:function ScriptFile(key,url,path,xhrSettings){var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'script',extension:GetFastValue(key,'extension','js'),responseType:'text',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings)};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=document.createElement('script');this.data.language='javascript';this.data.type='text/javascript';this.data.defer=false;this.data.text=this.xhrLoader.responseText;document.head.appendChild(this.data);this.onComplete();callback(this);}});/**\r\n * Adds a JavaScript file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Script File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#script\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('script',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new ScriptFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new ScriptFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=ScriptFile;/***/},/* 544 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);var PluginManager=__webpack_require__(13);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class PluginFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var PluginFile=new Class({Extends:File,initialize:function PluginFile(key,url,path,xhrSettings){// If the url variable refers to a class, add the plugin directly\nif(typeof url==='function'){this.key=key;window[key]=url;window[key].register(PluginManager);}var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'script',extension:GetFastValue(key,'extension','js'),responseType:'text',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings)};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=document.createElement('script');this.data.language='javascript';this.data.type='text/javascript';this.data.defer=false;this.data.text=this.xhrLoader.responseText;document.head.appendChild(this.data);//  Need to wait for onload?\nwindow[this.key].register(PluginManager);this.onComplete();callback(this);}});/**\r\n * Adds a Plugin file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Plugin File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#plugin\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('plugin',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new PluginFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new PluginFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=PluginFile;/***/},/* 545 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FileTypesManager=__webpack_require__(7);var ImageFile=__webpack_require__(52);var JSONFile=__webpack_require__(53);var NumberArray=__webpack_require__(283);/**\r\n * Adds a Multi File Texture Atlas to the current load queue.\r\n *\r\n * Note: This method will only be available if the Multi Atlas File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#multiatlas\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string[]} textureURLs - [description]\r\n * @param {string[]} atlasURLs - [description]\r\n * @param {XHRSettingsObject} textureXhrSettings - [description]\r\n * @param {XHRSettingsObject} atlasXhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('multiatlas',function(key,textureURLs,atlasURLs,textureXhrSettings,atlasXhrSettings){if(typeof textureURLs==='number'){var total=textureURLs;var suffix=atlasURLs===undefined?'':atlasURLs;textureURLs=NumberArray(0,total,key+suffix,'.png');atlasURLs=NumberArray(0,total,key+suffix,'.json');}else{if(!Array.isArray(textureURLs)){textureURLs=[textureURLs];}if(!Array.isArray(atlasURLs)){atlasURLs=[atlasURLs];}}var file;var i=0;var multiKey;this._multilist[key]=[];for(i=0;i<textureURLs.length;i++){multiKey='_MA_IMG_'+key+'_'+i.toString();file=new ImageFile(multiKey,textureURLs[i],this.path,textureXhrSettings);this.addFile(file);this._multilist[key].push(multiKey);}for(i=0;i<atlasURLs.length;i++){multiKey='_MA_JSON_'+key+'_'+i.toString();file=new JSONFile(multiKey,atlasURLs[i],this.path,atlasXhrSettings);this.addFile(file);this._multilist[key].push(multiKey);}return this;});/***/},/* 546 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class HTMLFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {number} width - [description]\r\n * @param {number} height - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var HTMLFile=new Class({Extends:File,initialize:function HTMLFile(key,url,width,height,path,xhrSettings){if(width===undefined){width=512;}if(height===undefined){height=512;}var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'html',extension:GetFastValue(key,'extension','html'),responseType:'text',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings),config:{width:width,height:height}};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;var w=this.config.width;var h=this.config.height;var data=[];data.push('<svg width=\"'+w+'px\" height=\"'+h+'px\" viewBox=\"0 0 '+w+' '+h+'\" xmlns=\"http://www.w3.org/2000/svg\">');data.push('<foreignObject width=\"100%\" height=\"100%\">');data.push('<body xmlns=\"http://www.w3.org/1999/xhtml\">');data.push(this.xhrLoader.responseText);data.push('</body>');data.push('</foreignObject>');data.push('</svg>');var svg=[data.join('\\n')];var _this=this;try{var blob=new window.Blob(svg,{type:'image/svg+xml;charset=utf-8'});}catch(e){_this.state=CONST.FILE_ERRORED;callback(_this);return;}this.data=new Image();this.data.crossOrigin=this.crossOrigin;this.data.onload=function(){File.revokeObjectURL(_this.data);_this.onComplete();callback(_this);};this.data.onerror=function(){File.revokeObjectURL(_this.data);_this.state=CONST.FILE_ERRORED;callback(_this);};File.createObjectURL(this.data,blob,'image/svg+xml');}});/**\r\n * Adds an HTML file to the current load queue.\r\n *\r\n * Note: This method will only be available if the HTML File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#html\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {number} width - [description]\r\n * @param {number} height - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('html',function(key,url,width,height,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new HTMLFile(key[i],url,width,height,this.path,xhrSettings));}}else{this.addFile(new HTMLFile(key,url,width,height,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=HTMLFile;/***/},/* 547 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class GLSLFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var GLSLFile=new Class({Extends:File,initialize:function GLSLFile(key,url,path,xhrSettings){var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'glsl',extension:GetFastValue(key,'extension','glsl'),responseType:'text',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings)};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=this.xhrLoader.responseText;this.onComplete();callback(this);}});/**\r\n * Adds a GLSL file to the current load queue.\r\n *\r\n * Note: This method will only be available if the GLSL File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#glsl\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('glsl',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new GLSLFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new GLSLFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=GLSLFile;/***/},/* 548 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FileTypesManager=__webpack_require__(7);var ImageFile=__webpack_require__(52);var XMLFile=__webpack_require__(225);/**\r\n * An Bitmap Font File.\r\n *\r\n * @function Phaser.Loader.FileTypes.BitmapFontFile\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {string} textureURL - The url to load the texture file from.\r\n * @param {string} xmlURL - The url to load the atlas file from.\r\n * @param {string} path - The path of the file.\r\n * @param {XHRSettingsObject} textureXhrSettings - Optional texture file specific XHR settings.\r\n * @param {XHRSettingsObject} xmlXhrSettings - Optional atlas file specific XHR settings.\r\n *\r\n * @return {object} An object containing two File objects to be added to the loader.\r\n */var BitmapFontFile=function BitmapFontFile(key,textureURL,xmlURL,path,textureXhrSettings,xmlXhrSettings){var image=new ImageFile(key,textureURL,path,textureXhrSettings);var data=new XMLFile(key,xmlURL,path,xmlXhrSettings);//  Link them together\nimage.linkFile=data;data.linkFile=image;//  Set the type\nimage.linkType='bitmapfont';data.linkType='bitmapfont';return{texture:image,data:data};};/**\r\n * Adds a Bitmap Font file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Bitmap Font File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#bitmapFont\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} textureURL - [description]\r\n * @param {string} xmlURL - [description]\r\n * @param {XHRSettingsObject} textureXhrSettings - [description]\r\n * @param {XHRSettingsObject} xmlXhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('bitmapFont',function(key,textureURL,xmlURL,textureXhrSettings,xmlXhrSettings){//  Returns an object with two properties: 'texture' and 'data'\nvar files=new BitmapFontFile(key,textureURL,xmlURL,this.path,textureXhrSettings,xmlXhrSettings);this.addFile(files.texture);this.addFile(files.data);return this;});module.exports=BitmapFontFile;/***/},/* 549 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(17);var File=__webpack_require__(19);var FileTypesManager=__webpack_require__(7);var GetFastValue=__webpack_require__(2);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class BinaryFile\r\n * @extends Phaser.Loader.File\r\n * @memberOf Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {string} path - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n */var BinaryFile=new Class({Extends:File,initialize:function BinaryFile(key,url,path,xhrSettings){var fileKey=typeof key==='string'?key:GetFastValue(key,'key','');var fileConfig={type:'binary',extension:GetFastValue(key,'extension','bin'),responseType:'arraybuffer',key:fileKey,url:GetFastValue(key,'file',url),path:path,xhrSettings:GetFastValue(key,'xhr',xhrSettings)};File.call(this,fileConfig);},onProcess:function onProcess(callback){this.state=CONST.FILE_PROCESSING;this.data=this.xhrLoader.response;this.onComplete();callback(this);}});/**\r\n * Adds Binary file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Binary File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#binary\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {string} url - [description]\r\n * @param {XHRSettingsObject} xhrSettings - [description]\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('binary',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new BinaryFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new BinaryFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});module.exports=BinaryFile;/***/},/* 550 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var AudioFile=__webpack_require__(227);var CONST=__webpack_require__(17);var FileTypesManager=__webpack_require__(7);var JSONFile=__webpack_require__(53);/**\r\n * Adds an Audio Sprite file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Audio Sprite File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#audioSprite\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - [description]\r\n * @param {(string|string[])} urls - [description]\r\n * @param {object} json - [description]\r\n * @param {object} config - [description]\r\n * @param {XHRSettingsObject} audioXhrSettings - Optional file specific XHR settings.\r\n * @param {XHRSettingsObject} jsonXhrSettings - Optional file specific XHR settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('audioSprite',function(key,urls,json,config,audioXhrSettings,jsonXhrSettings){var audioFile=AudioFile.create(this,key,urls,config,audioXhrSettings);if(audioFile){var jsonFile;if(typeof json==='string'){jsonFile=new JSONFile(key,json,this.path,jsonXhrSettings);this.addFile(jsonFile);}else{jsonFile={type:'json',key:key,data:json,state:CONST.FILE_WAITING_LINKFILE};}//  Link them together\naudioFile.linkFile=jsonFile;jsonFile.linkFile=audioFile;//  Set the type\naudioFile.linkType='audioSprite';jsonFile.linkType='audioSprite';this.addFile(audioFile);}return this;});/***/},/* 551 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FileTypesManager=__webpack_require__(7);var ImageFile=__webpack_require__(52);var JSONFile=__webpack_require__(53);/**\r\n * An Atlas JSON File.\r\n *\r\n * @function Phaser.Loader.FileTypes.AtlasJSONFile\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {string} textureURL - The url to load the texture file from.\r\n * @param {string} atlasURL - The url to load the atlas file from.\r\n * @param {string} path - The path of the file.\r\n * @param {XHRSettingsObject} textureXhrSettings - Optional texture file specific XHR settings.\r\n * @param {XHRSettingsObject} atlasXhrSettings - Optional atlas file specific XHR settings.\r\n *\r\n * @return {object} An object containing two File objects to be added to the loader.\r\n */var AtlasJSONFile=function AtlasJSONFile(key,textureURL,atlasURL,path,textureXhrSettings,atlasXhrSettings){var image=new ImageFile(key,textureURL,path,textureXhrSettings);var data=new JSONFile(key,atlasURL,path,atlasXhrSettings);//  Link them together\nimage.linkFile=data;data.linkFile=image;//  Set the type\nimage.linkType='atlasjson';data.linkType='atlasjson';return{texture:image,data:data};};/**\r\n * Adds a Texture Atlas file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Atlas JSON File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#atlas\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {string} textureURL - The url to load the texture file from.\r\n * @param {string} atlasURL - The url to load the atlas file from.\r\n * @param {XHRSettingsObject} textureXhrSettings - Optional texture file specific XHR settings.\r\n * @param {XHRSettingsObject} atlasXhrSettings - Optional atlas file specific XHR settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('atlas',function(key,textureURL,atlasURL,textureXhrSettings,atlasXhrSettings){var files;// If param key is an object, use object based loading method\nif((typeof key==='undefined'?'undefined':_typeof(key))==='object'&&key!==null){files=new AtlasJSONFile(key.key,key.texture,key.data,this.path,textureXhrSettings,atlasXhrSettings);}// Else just use the parameters like normal\nelse{//  Returns an object with two properties: 'texture' and 'data'\nfiles=new AtlasJSONFile(key,textureURL,atlasURL,this.path,textureXhrSettings,atlasXhrSettings);}this.addFile(files.texture);this.addFile(files.data);return this;});module.exports=AtlasJSONFile;/***/},/* 552 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var FileTypesManager=__webpack_require__(7);var JSONFile=__webpack_require__(53);/**\r\n * An Animation JSON File.\r\n *\r\n * @function Phaser.Loader.FileTypes.AnimationJSONFile\r\n * @since 3.0.0\r\n *\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {string} url - The url to load the file from.\r\n * @param {string} path - The path of the file.\r\n * @param {XHRSettingsObject} xhrSettings - Optional file specific XHR settings.\r\n *\r\n * @return {Phaser.Loader.FileTypes.AnimationJSONFile} A File instance to be added to the Loader.\r\n */var AnimationJSONFile=function AnimationJSONFile(key,url,path,xhrSettings){var json=new JSONFile(key,url,path,xhrSettings);//  Override the File type\njson.type='animationJSON';return json;};/**\r\n * Adds an Animation JSON file to the current load queue.\r\n *\r\n * Note: This method will only be available if the Animation JSON File type has been built into Phaser.\r\n *\r\n * The file is **not** loaded immediately after calling this method.\r\n * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#animation\r\n * @since 3.0.0\r\n *\r\n * @param {(string|array|object)} key - A unique string to be used as the key to reference this file from the Cache. Must be unique within this file type.\r\n * @param {string} [url] - URL of the file. If `undefined` or `null` the url will be set to `<key>.json`,\r\n * i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {XHRSettingsObject} [xhrSettings] - File specific XHR settings to be used during the load. These settings are merged with the global Loader XHR settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader.\r\n */FileTypesManager.register('animation',function(key,url,xhrSettings){if(Array.isArray(key)){for(var i=0;i<key.length;i++){//  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\nthis.addFile(new AnimationJSONFile(key[i],url,this.path,xhrSettings));}}else{this.addFile(new AnimationJSONFile(key,url,this.path,xhrSettings));}//  For method chaining\nreturn this;});//  When registering a factory function 'this' refers to the Loader context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\nmodule.exports=AnimationJSONFile;/***/},/* 553 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Loader.FileTypes\r\n *//**\r\n * @typedef {object} XHRConfig\r\n *\r\n * @property {string} key - [description]\r\n * @property {string} texture - [description]\r\n * @property {string} [data] - [description]\r\n * @property {XHRConfig} [xhr] - [description]\r\n *//**\r\n * @typedef {object} FileTypeConfig\r\n *\r\n * @property {string} key - [description]\r\n * @property {string} texture - [description]\r\n * @property {string} [data] - [description]\r\n * @property {string} [url] - [description]\r\n * @property {string} [path] - [description]\r\n * @property {string} [extension] - [description]\r\n * @property {string} [responseType] - [description]\r\n * @property {object} [config] - [description]\r\n * @property {XHRConfig} [xhr] - [description]\r\n */module.exports={AnimationJSONFile:__webpack_require__(552),AtlasJSONFile:__webpack_require__(551),AudioFile:__webpack_require__(227),AudioSprite:__webpack_require__(550),BinaryFile:__webpack_require__(549),BitmapFontFile:__webpack_require__(548),GLSLFile:__webpack_require__(547),HTML5AudioFile:__webpack_require__(226),HTMLFile:__webpack_require__(546),ImageFile:__webpack_require__(52),JSONFile:__webpack_require__(53),MultiAtlas:__webpack_require__(545),PluginFile:__webpack_require__(544),ScriptFile:__webpack_require__(543),SpriteSheetFile:__webpack_require__(542),SVGFile:__webpack_require__(541),TextFile:__webpack_require__(224),TilemapCSVFile:__webpack_require__(540),TilemapJSONFile:__webpack_require__(539),UnityAtlasFile:__webpack_require__(538),XMLFile:__webpack_require__(225)};/***/},/* 554 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(17);var Extend=__webpack_require__(18);/**\r\n * @namespace Phaser.Loader\r\n */var Loader={FileTypes:__webpack_require__(553),File:__webpack_require__(19),FileTypesManager:__webpack_require__(7),GetURL:__webpack_require__(125),LoaderPlugin:__webpack_require__(537),MergeXHRSettings:__webpack_require__(124),XHRLoader:__webpack_require__(228),XHRSettings:__webpack_require__(95)};//   Merge in the consts\nLoader=Extend(false,Loader,CONST);module.exports=Loader;/***/},/* 555 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Input.Touch\r\n *//* eslint-disable */module.exports={TouchManager:__webpack_require__(301)};/* eslint-enable *//***/},/* 556 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Input.Mouse\r\n *//* eslint-disable */module.exports={MouseManager:__webpack_require__(303)};/* eslint-enable *//***/},/* 557 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns `true` if the Key was released within the `duration` value given, or `false` if it either isn't up,\r\n * or was released longer ago than then given duration.\r\n *\r\n * @function Phaser.Input.Keyboard.UpDuration\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - [description]\r\n * @param {integer} [duration=50] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var UpDuration=function UpDuration(key,duration){if(duration===undefined){duration=50;}return key.isUp&&key.duration<duration;};module.exports=UpDuration;/***/},/* 558 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,\r\n * or was pressed down longer ago than then given duration.\r\n *\r\n * @function Phaser.Input.Keyboard.DownDuration\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - [description]\r\n * @param {integer} [duration=50] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var DownDuration=function DownDuration(key,duration){if(duration===undefined){duration=50;}return key.isDown&&key.duration<duration;};module.exports=DownDuration;/***/},/* 559 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * The justUp value allows you to test if this Key has just been released or not.\r\n * When you check this value it will return `true` if the Key is up, otherwise `false`.\r\n * You can only call justUp once per key release. It will only return `true` once, until the Key is pressed down and released again.\r\n * This allows you to use it in situations where you want to check if this key is up without using a Signal, such as in a core game loop.\r\n *\r\n * @function Phaser.Input.Keyboard.JustUp\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var JustUp=function JustUp(key){if(key._justUp){key._justUp=false;return true;}else{return false;}};module.exports=JustUp;/***/},/* 560 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * The justDown value allows you to test if this Key has just been pressed down or not.\r\n * When you check this value it will return `true` if the Key is down, otherwise `false`.\r\n * You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.\r\n * This allows you to use it in situations where you want to check if this key is down without using a Signal, such as in a core game loop.\r\n *\r\n * @function Phaser.Input.Keyboard.JustDown\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var JustDown=function JustDown(key){if(key._justDown){key._justDown=false;return true;}else{return false;}};module.exports=JustDown;/***/},/* 561 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Input.Keyboard\r\n */module.exports={KeyboardManager:__webpack_require__(306),Key:__webpack_require__(305),KeyCodes:__webpack_require__(149),KeyCombo:__webpack_require__(304),JustDown:__webpack_require__(560),JustUp:__webpack_require__(559),DownDuration:__webpack_require__(558),UpDuration:__webpack_require__(557)};/***/},/* 562 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Circle=__webpack_require__(81);var CircleContains=__webpack_require__(28);var Class=__webpack_require__(0);var DistanceBetween=__webpack_require__(49);var Ellipse=__webpack_require__(137);var EllipseContains=__webpack_require__(75);var EventEmitter=__webpack_require__(14);var CreateInteractiveObject=__webpack_require__(229);var PluginManager=__webpack_require__(13);var Rectangle=__webpack_require__(10);var RectangleContains=__webpack_require__(27);var Triangle=__webpack_require__(54);var TriangleContains=__webpack_require__(56);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class InputPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that owns this plugin.\r\n */var InputPlugin=new Class({Extends:EventEmitter,initialize:function InputPlugin(scene){EventEmitter.call(this);/**\r\n         * The Scene that owns this plugin.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputPlugin#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */this.manager=scene.sys.game.input;/**\r\n         * A reference to this.scene.sys.displayList (set in boot)\r\n         *\r\n         * @name Phaser.Input.InputPlugin#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */this.displayList;/**\r\n         * A reference to the this.scene.sys.cameras (set in boot)\r\n         *\r\n         * @name Phaser.Input.InputPlugin#cameras\r\n         * @type {null}\r\n         * @since 3.0.0\r\n         */this.cameras;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputPlugin#keyboard\r\n         * @type {Phaser.Input.Keyboard.KeyboardManager}\r\n         * @since 3.0.0\r\n         */this.keyboard=this.manager.keyboard;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputPlugin#mouse\r\n         * @type {Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */this.mouse=this.manager.mouse;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputPlugin#gamepad\r\n         * @type {Phaser.Input.Gamepad.GamepadManager}\r\n         * @since 3.0.0\r\n         */this.gamepad=this.manager.gamepad;/**\r\n         * Only fire callbacks and events on the top-most Game Object in the display list (emulating DOM behavior)\r\n         * and ignore any GOs below it, or call them all?\r\n         *\r\n         * @name Phaser.Input.InputPlugin#topOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.topOnly=true;/**\r\n         * How often should the pointer input be checked?\r\n         * Time given in ms\r\n         * Pointer will *always* be checked if it has been moved by the user.\r\n         * This controls how often it will be polled if it hasn't been moved.\r\n         * Set to 0 to poll constantly. Set to -1 to only poll on user movement.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pollRate\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */this.pollRate=-1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pollTimer\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._pollTimer=0;/**\r\n         * The distance, in pixels, the pointer has to move while being held down, before it thinks it is being dragged.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragDistanceThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.dragDistanceThreshold=0;/**\r\n         * The amount of time, in ms, the pointer has to be held down before it thinks it is dragging.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragTimeThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.dragTimeThreshold=0;/**\r\n         * Used to temporarily store the results of the Hit Test\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_temp\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._temp=[];/**\r\n         * Used to temporarily store the results of the Hit Test dropZones\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_tempZones\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._tempZones=[];/**\r\n         * A list of all Game Objects that have been set to be interactive.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._list=[];/**\r\n         * Objects waiting to be inserted to the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingInsertion\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._pendingInsertion=[];/**\r\n         * Objects waiting to be removed from the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingRemoval\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._pendingRemoval=[];/**\r\n         * A list of all Game Objects that have been enabled for dragging.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_draggable\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._draggable=[];/**\r\n         * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_drag\r\n         * @type {{0:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._drag={0:[],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[]};/**\r\n         * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_over\r\n         * @type {{0:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._over={0:[],1:[],2:[],3:[],4:[],5:[],6:[],7:[],8:[],9:[]};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_validTypes\r\n         * @type {string[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._validTypes=['onDown','onUp','onOver','onOut','onMove','onDragStart','onDrag','onDragEnd','onDragEnter','onDragLeave','onDragOver','onDrop'];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('preupdate',this.preUpdate,this);eventEmitter.on('update',this.update,this);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);this.cameras=this.systems.cameras;this.displayList=this.systems.displayList;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#preUpdate\r\n     * @since 3.0.0\r\n     */preUpdate:function preUpdate(){var removeList=this._pendingRemoval;var insertList=this._pendingInsertion;var toRemove=removeList.length;var toInsert=insertList.length;if(toRemove===0&&toInsert===0){//  Quick bail\nreturn;}var current=this._list;//  Delete old gameObjects\nfor(var i=0;i<toRemove;i++){var gameObject=removeList[i];var index=current.indexOf(gameObject);if(index>-1){current.splice(index,1);this.clear(gameObject);}}//  Clear the removal list\nremoveList.length=0;//  Move pendingInsertion to list (also clears pendingInsertion at the same time)\nthis._list=current.concat(insertList.splice(0));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */clear:function clear(gameObject){var input=gameObject.input;input.gameObject=undefined;input.target=undefined;input.hitArea=undefined;input.hitAreaCallback=undefined;input.callbackContext=undefined;gameObject.input=null;//  Clear from _draggable, _drag and _over\nvar index=this._draggable.indexOf(gameObject);if(index>-1){this._draggable.splice(index,1);}index=this._drag[0].indexOf(gameObject);if(index>-1){this._drag[0].splice(index,1);}index=this._over[0].indexOf(gameObject);if(index>-1){this._over[0].splice(index,1);}return gameObject;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     */disable:function disable(gameObject){gameObject.input.enabled=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     * @param {object} shape - [description]\r\n     * @param {HitAreaCallback} callback - [description]\r\n     * @param {boolean} [dropZone=false] - [description]\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n     */enable:function enable(gameObject,shape,callback,dropZone){if(dropZone===undefined){dropZone=false;}if(gameObject.input){//  If it is already has an InteractiveObject then just enable it and return\ngameObject.input.enabled=true;}else{//  Create an InteractiveObject and enable it\nthis.setHitArea(gameObject,shape,callback);}if(gameObject.input){gameObject.input.dropZone=dropZone;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#hitTestPointer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - [description]\r\n     *\r\n     * @return {array} [description]\r\n     */hitTestPointer:function hitTestPointer(pointer){var camera=this.cameras.getCameraBelowPointer(pointer);if(camera){pointer.camera=camera;//  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'output' array.\n//  All objects in this array are input enabled, as checked by the hitTest method, so we don't need to check later on as well.\nvar over=this.manager.hitTest(pointer.x,pointer.y,this._list,camera);//  Filter out the drop zones\nfor(var i=0;i<over.length;i++){var obj=over[i];if(obj.input.dropZone){this._tempZones.push(obj);}}return over;}else{return[];}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDownEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */processDownEvents:function processDownEvents(pointer){var currentlyOver=this._temp;//  Contains ALL Game Objects currently over in the array\nthis.emit('pointerdown',pointer,currentlyOver);var total=0;//  Go through all objects the pointer was over and fire their events / callbacks\nfor(var i=0;i<currentlyOver.length;i++){var gameObject=currentlyOver[i];if(!gameObject.input){continue;}total++;gameObject.emit('pointerdown',pointer,gameObject.input.localX,gameObject.input.localY,pointer.camera);this.emit('gameobjectdown',pointer,gameObject);}return total;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} pointer - [description]\r\n     * @param {number} time - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */processDragEvents:function processDragEvents(pointer,time){if(this._draggable.length===0){//  There are no draggable items, so let's not even bother going further\nreturn 0;}var i;var gameObject;var list;var input;var currentlyOver=this._temp;//  0 = Not dragging anything\n//  1 = Primary button down and objects below, so collect a draglist\n//  2 = Pointer being checked if meets drag criteria\n//  3 = Pointer meets criteria, notify the draglist\n//  4 = Pointer actively dragging the draglist and has moved\n//  5 = Pointer actively dragging but has been released, notify draglist\nif(pointer.dragState===0&&pointer.primaryDown&&pointer.justDown&&currentlyOver.length>0){pointer.dragState=1;}else if(pointer.dragState>0&&!pointer.primaryDown&&pointer.justUp){pointer.dragState=5;}//  Process the various drag states\n//  1 = Primary button down and objects below, so collect a draglist\nif(pointer.dragState===1){//  Get draggable objects, sort them, pick the top (or all) and store them somewhere\nvar draglist=[];for(i=0;i<currentlyOver.length;i++){gameObject=currentlyOver[i];if(gameObject.input.draggable){draglist.push(gameObject);}}if(draglist.length===0){pointer.dragState=0;return 0;}else if(draglist.length>1){this.sortGameObjects(draglist);if(this.topOnly){draglist.splice(1);}}//  draglist now contains all potential candidates for dragging\nthis._drag[pointer.id]=draglist;if(this.dragDistanceThreshold===0&&this.dragTimeThreshold===0){//  No drag criteria, so snap immediately to mode 3\npointer.dragState=3;}else{//  Check the distance / time\npointer.dragState=2;}}//  2 = Pointer being checked if meets drag criteria\nif(pointer.dragState===2){//  Has it moved far enough to be considered a drag?\nif(this.dragDistanceThreshold>0&&DistanceBetween(pointer.x,pointer.y,pointer.downX,pointer.downY)>=this.dragDistanceThreshold){//  Alrighty, we've got a drag going on ...\npointer.dragState=3;}//  Held down long enough to be considered a drag?\nif(this.dragTimeThreshold>0&&time>=pointer.downTime+this.dragTimeThreshold){//  Alrighty, we've got a drag going on ...\npointer.dragState=3;}}//  3 = Pointer meets criteria and is freshly down, notify the draglist\nif(pointer.dragState===3){list=this._drag[pointer.id];for(i=0;i<list.length;i++){gameObject=list[i];input=gameObject.input;input.dragState=2;input.dragX=pointer.x-gameObject.x;input.dragY=pointer.y-gameObject.y;input.dragStartX=gameObject.x;input.dragStartY=gameObject.y;gameObject.emit('dragstart',pointer,input.dragX,input.dragY);this.emit('dragstart',pointer,gameObject);}pointer.dragState=4;return list.length;}//  4 = Pointer actively dragging the draglist and has moved\nif(pointer.dragState===4&&pointer.justMoved){var dropZones=this._tempZones;list=this._drag[pointer.id];for(i=0;i<list.length;i++){gameObject=list[i];input=gameObject.input;//  If this GO has a target then let's check it\nif(input.target){var index=dropZones.indexOf(input.target);//  Got a target, are we still over it?\nif(index===0){//  We're still over it, and it's still the top of the display list, phew ...\ngameObject.emit('dragover',pointer,input.target);this.emit('dragover',pointer,gameObject,input.target);}else if(index>0){//  Still over it but it's no longer top of the display list (targets must always be at the top)\ngameObject.emit('dragleave',pointer,input.target);this.emit('dragleave',pointer,gameObject,input.target);input.target=dropZones[0];gameObject.emit('dragenter',pointer,input.target);this.emit('dragenter',pointer,gameObject,input.target);}else{//  Nope, we've moved on (or the target has!), leave the old target\ngameObject.emit('dragleave',pointer,input.target);this.emit('dragleave',pointer,gameObject,input.target);//  Anything new to replace it?\n//  Yup!\nif(dropZones[0]){input.target=dropZones[0];gameObject.emit('dragenter',pointer,input.target);this.emit('dragenter',pointer,gameObject,input.target);}else{//  Nope\ninput.target=null;}}}else if(!input.target&&dropZones[0]){input.target=dropZones[0];gameObject.emit('dragenter',pointer,input.target);this.emit('dragenter',pointer,gameObject,input.target);}var dragX=pointer.x-gameObject.input.dragX;var dragY=pointer.y-gameObject.input.dragY;gameObject.emit('drag',pointer,dragX,dragY);this.emit('drag',pointer,gameObject,dragX,dragY);}return list.length;}//  5 = Pointer was actively dragging but has been released, notify draglist\nif(pointer.dragState===5){list=this._drag[pointer.id];for(i=0;i<list.length;i++){gameObject=list[i];input=gameObject.input;input.dragState=0;input.dragX=input.localX-gameObject.displayOriginX;input.dragY=input.localY-gameObject.displayOriginY;var dropped=false;if(input.target){gameObject.emit('drop',pointer,input.target);this.emit('drop',pointer,gameObject,input.target);input.target=null;dropped=true;}//  And finally the dragend event\ngameObject.emit('dragend',pointer,input.dragX,input.dragY,dropped);this.emit('dragend',pointer,gameObject,dropped);}pointer.dragState=0;list.splice(0);}return 0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processMoveEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */processMoveEvents:function processMoveEvents(pointer){var currentlyOver=this._temp;this.emit('pointermove',pointer,currentlyOver);var total=0;//  Go through all objects the pointer was over and fire their events / callbacks\nfor(var i=0;i<currentlyOver.length;i++){var gameObject=currentlyOver[i];if(!gameObject.input){continue;}total++;gameObject.emit('pointermove',pointer,gameObject.input.localX,gameObject.input.localY);this.emit('gameobjectmove',pointer,gameObject);if(this.topOnly){break;}}return total;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverOutEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - [description]\r\n     *\r\n     * @return {integer} The number of objects interacted with.\r\n     */processOverOutEvents:function processOverOutEvents(pointer){var currentlyOver=this._temp;var i;var gameObject;var justOut=[];var justOver=[];var stillOver=[];var previouslyOver=this._over[pointer.id];var currentlyDragging=this._drag[pointer.id];//  Go through all objects the pointer was previously over, and see if it still is.\n//  Splits the previouslyOver array into two parts: justOut and stillOver\nfor(i=0;i<previouslyOver.length;i++){gameObject=previouslyOver[i];if(currentlyOver.indexOf(gameObject)===-1&&currentlyDragging.indexOf(gameObject)===-1){//  Not in the currentlyOver array, so must be outside of this object now\njustOut.push(gameObject);}else{//  In the currentlyOver array\nstillOver.push(gameObject);}}//  Go through all objects the pointer is currently over (the hit test results)\n//  and if not in the previouslyOver array we know it's a new entry, so add to justOver\nfor(i=0;i<currentlyOver.length;i++){gameObject=currentlyOver[i];//  Is this newly over?\nif(previouslyOver.indexOf(gameObject)===-1){justOver.push(gameObject);}}//  By this point the arrays are filled, so now we can process what happened...\n//  Process the Just Out objects\nvar total=justOut.length;var totalInteracted=0;if(total>0){this.sortGameObjects(justOut);this.emit('pointerout',pointer,justOut);//  Call onOut for everything in the justOut array\nfor(i=0;i<total;i++){gameObject=justOut[i];if(!gameObject.input){continue;}this.emit('gameobjectout',pointer,gameObject);gameObject.emit('pointerout',pointer);totalInteracted++;}}//  Process the Just Over objects\ntotal=justOver.length;if(total>0){this.sortGameObjects(justOver);this.emit('pointerover',pointer,justOver);//  Call onOver for everything in the justOver array\nfor(i=0;i<total;i++){gameObject=justOver[i];if(!gameObject.input){continue;}this.emit('gameobjectover',pointer,gameObject);gameObject.emit('pointerover',pointer,gameObject.input.localX,gameObject.input.localY);totalInteracted++;}}//  Add the contents of justOver to the previously over array\npreviouslyOver=stillOver.concat(justOver);//  Then sort it into display list order\nthis._over[pointer.id]=this.sortGameObjects(previouslyOver);return totalInteracted;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processUpEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - [description]\r\n     */processUpEvents:function processUpEvents(pointer){var currentlyOver=this._temp;//  Contains ALL Game Objects currently up in the array\nthis.emit('pointerup',pointer,currentlyOver);//  Go through all objects the pointer was over and fire their events / callbacks\nfor(var i=0;i<currentlyOver.length;i++){var gameObject=currentlyOver[i];if(!gameObject.input){continue;}//  pointerupoutside\ngameObject.emit('pointerup',pointer,gameObject.input.localX,gameObject.input.localY);this.emit('gameobjectup',pointer,gameObject);}return currentlyOver.length;},/**\r\n     * Queues a Game Object for insertion into this Input Manager on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForInsertion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */queueForInsertion:function queueForInsertion(child){if(this._pendingInsertion.indexOf(child)===-1&&this._list.indexOf(child)===-1){this._pendingInsertion.push(child);}return this;},/**\r\n     * Queues a Game Object for removal from this Input Manager on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForRemoval\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */queueForRemoval:function queueForRemoval(child){this._pendingRemoval.push(child);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDraggable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.\r\n     * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setDraggable:function setDraggable(gameObjects,value){if(value===undefined){value=true;}if(!Array.isArray(gameObjects)){gameObjects=[gameObjects];}for(var i=0;i<gameObjects.length;i++){var gameObject=gameObjects[i];gameObject.input.draggable=value;var index=this._draggable.indexOf(gameObject);if(value&&index===-1){this._draggable.push(gameObject);}else if(!value&&index>-1){this._draggable.splice(index,1);}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.\r\n     * @param {object} [shape] - The shape or object to check if the pointer is within for hit area checks.\r\n     * @param {HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setHitArea:function setHitArea(gameObjects,shape,callback){if(shape===undefined){return this.setHitAreaFromTexture(gameObjects);}if(!Array.isArray(gameObjects)){gameObjects=[gameObjects];}for(var i=0;i<gameObjects.length;i++){var gameObject=gameObjects[i];gameObject.input=CreateInteractiveObject(gameObject,shape,callback);this.queueForInsertion(gameObject);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.\r\n     * @param {number} x - The center of the circle.\r\n     * @param {number} y - The center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setHitAreaCircle:function setHitAreaCircle(gameObjects,x,y,radius,callback){if(callback===undefined){callback=CircleContains;}var shape=new Circle(x,y,radius);return this.setHitArea(gameObjects,shape,callback);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {number} x - The center of the ellipse.\r\n     * @param {number} y - The center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setHitAreaEllipse:function setHitAreaEllipse(gameObjects,x,y,width,height,callback){if(callback===undefined){callback=EllipseContains;}var shape=new Ellipse(x,y,width,height);return this.setHitArea(gameObjects,shape,callback);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaFromTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setHitAreaFromTexture:function setHitAreaFromTexture(gameObjects,callback){if(callback===undefined){callback=RectangleContains;}if(!Array.isArray(gameObjects)){gameObjects=[gameObjects];}for(var i=0;i<gameObjects.length;i++){var gameObject=gameObjects[i];if(gameObject.type==='Container'){console.warn('Container.setInteractive() must specify a Shape');continue;}var frame=gameObject.frame;var width=0;var height=0;if(frame){width=frame.realWidth;height=frame.realHeight;}else if(gameObject.width){width=gameObject.width;height=gameObject.height;}if(width!==0&&height!==0){gameObject.input=CreateInteractiveObject(gameObject,new Rectangle(0,0,width,height),callback);this.queueForInsertion(gameObject);}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.\r\n     * @param {number} x - The top-left of the rectangle.\r\n     * @param {number} y - The top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setHitAreaRectangle:function setHitAreaRectangle(gameObjects,x,y,width,height,callback){if(callback===undefined){callback=RectangleContains;}var shape=new Rectangle(x,y,width,height);return this.setHitArea(gameObjects,shape,callback);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.\r\n     * @param {number} x1 - The x coordinate of the first point of the triangle.\r\n     * @param {number} y1 - The y coordinate of the first point of the triangle.\r\n     * @param {number} x2 - The x coordinate of the second point of the triangle.\r\n     * @param {number} y2 - The y coordinate of the second point of the triangle.\r\n     * @param {number} x3 - The x coordinate of the third point of the triangle.\r\n     * @param {number} y3 - The y coordinate of the third point of the triangle.\r\n     * @param {HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setHitAreaTriangle:function setHitAreaTriangle(gameObjects,x1,y1,x2,y2,x3,y3,callback){if(callback===undefined){callback=TriangleContains;}var shape=new Triangle(x1,y1,x2,y2,x3,y3);return this.setHitArea(gameObjects,shape,callback);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollAlways\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setPollAlways:function setPollAlways(){this.pollRate=0;this._pollTimer=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollOnMove\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setPollOnMove:function setPollOnMove(){this.pollRate=-1;this._pollTimer=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollRate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setPollRate:function setPollRate(value){this.pollRate=value;this._pollTimer=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setGlobalTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setGlobalTopOnly:function setGlobalTopOnly(value){this.manager.globalTopOnly=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */setTopOnly:function setTopOnly(value){this.topOnly=value;return this;},/**\r\n     * Given an array of Game Objects, sort the array and return it,\r\n     * so that the objects are in index order with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortGameObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} [description]\r\n     */sortGameObjects:function sortGameObjects(gameObjects){if(gameObjects.length<2){return gameObjects;}this.scene.sys.depthSort();return gameObjects.sort(this.sortHandlerGO.bind(this));},/**\r\n     * Return the child lowest down the display list (with the smallest index)\r\n     * Will iterate through all parent containers, if present.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortHandlerGO\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.\r\n     *\r\n     * @return {integer} Returns either a negative or positive integer, or zero if they match.\r\n     */sortHandlerGO:function sortHandlerGO(childA,childB){if(!childA.parentContainer&&!childB.parentContainer){//  Quick bail out when neither child has a container\nreturn this.displayList.getIndex(childB)-this.displayList.getIndex(childA);}else if(childA.parentContainer===childB.parentContainer){//  Quick bail out when both children have the same container\nreturn childB.parentContainer.getIndex(childB)-childA.parentContainer.getIndex(childA);}else{//  Container index check\nvar listA=childA.getIndexList();var listB=childB.getIndexList();var len=Math.min(listA.length,listB.length);for(var i=0;i<len;i++){// var indexA = listA[i][0];\n// var indexB = listB[i][0];\nvar indexA=listA[i];var indexB=listB[i];if(indexA===indexB){//  Go to the next level down\ncontinue;}else{//  Non-matching parents, so return\nreturn indexB-indexA;}}}//  Technically this shouldn't happen, but ...\nreturn 0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#stopPropagation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */stopPropagation:function stopPropagation(){if(this.manager.globalTopOnly){this.manager.ignoreEvents=true;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(time,delta){var manager=this.manager;//  Another Scene above this one has already consumed the input events\nif(manager.globalTopOnly&&manager.ignoreEvents){return;}var pointer=manager.activePointer;var runUpdate=pointer.dirty||this.pollRate===0;if(this.pollRate>-1){this._pollTimer-=delta;if(this._pollTimer<0){runUpdate=true;//  Discard timer diff\nthis._pollTimer=this.pollRate;}}if(!runUpdate){return;}//  Always reset this array\nthis._tempZones=[];//  _temp contains a hit tested and camera culled list of IO objects\nthis._temp=this.hitTestPointer(pointer);this.sortGameObjects(this._temp);this.sortGameObjects(this._tempZones);if(this.topOnly){//  Only the top-most one counts now, so safely ignore the rest\nif(this._temp.length){this._temp.splice(1);}if(this._tempZones.length){this._tempZones.splice(1);}}var total=this.processDragEvents(pointer,time);if(!pointer.wasTouch){total+=this.processOverOutEvents(pointer);}if(pointer.justDown){total+=this.processDownEvents(pointer);}if(pointer.justUp){total+=this.processUpEvents(pointer);}if(pointer.justMoved){total+=this.processMoveEvents(pointer);}if(total>0&&manager.globalTopOnly){//  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\nmanager.ignoreEvents=true;}},/**\r\n     * The Scene that owns this plugin is shutting down.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this._temp.length=0;this._list.length=0;this._draggable.length=0;this._pendingRemoval.length=0;this._pendingInsertion.length=0;for(var i=0;i<10;i++){this._drag[i]=[];this._over[i]=[];}this.removeAllListeners();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Input.InputPlugin#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.shutdown();this.scene=undefined;this.cameras=undefined;this.manager=undefined;this.events=undefined;this.keyboard=undefined;this.mouse=undefined;this.gamepad=undefined;},/**\r\n     * The current active input Pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#activePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */activePointer:{get:function get(){return this.manager.activePointer;}},/**\r\n     * The x coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#x\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */x:{get:function get(){return this.manager.activePointer.x;}},/**\r\n     * The y coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#y\r\n     * @type {number}\r\n     * @readOnly\r\n     * @since 3.0.0\r\n     */y:{get:function get(){return this.manager.activePointer.y;}}});PluginManager.register('InputPlugin',InputPlugin,'input');module.exports=InputPlugin;/***/},/* 563 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * XBox 360 Gamepad Configuration.\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.XBOX_360\r\n * @type {object}\r\n * @since 3.0.0\r\n */module.exports={UP:12,DOWN:13,LEFT:14,RIGHT:15,MENU:16,A:0,B:1,X:2,Y:3,LB:4,RB:5,LT:6,RT:7,BACK:8,START:9,LS:10,RS:11,LEFT_STICK_H:0,LEFT_STICK_V:1,RIGHT_STICK_H:2,RIGHT_STICK_V:3};/***/},/* 564 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Tatar SNES USB Controller Gamepad Configuration.\r\n * USB Gamepad  (STANDARD GAMEPAD Vendor: 0079 Product: 0011)\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.SNES_USB\r\n * @type {object}\r\n * @since 3.0.0\r\n */module.exports={UP:12,DOWN:13,LEFT:14,RIGHT:15,SELECT:8,START:9,B:0,A:1,Y:2,X:3,LEFT_SHOULDER:4,RIGHT_SHOULDER:5};/***/},/* 565 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * PlayStation DualShock 4 Gamepad Configuration.\r\n * Sony PlayStation DualShock 4 (v2) wireless controller\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.DUALSHOCK_4\r\n * @type {object}\r\n * @since 3.0.0\r\n */module.exports={UP:12,DOWN:13,LEFT:14,RIGHT:15,SHARE:8,OPTIONS:9,PS:16,TOUCHBAR:17,X:0,CIRCLE:1,SQUARE:2,TRIANGLE:3,L1:4,R1:5,L2:6,R2:7,L3:10,R3:11,LEFT_STICK_H:0,LEFT_STICK_V:1,RIGHT_STICK_H:2,RIGHT_STICK_V:3};/***/},/* 566 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Input.Gamepad.Configs\r\n */module.exports={DUALSHOCK_4:__webpack_require__(565),SNES_USB:__webpack_require__(564),XBOX_360:__webpack_require__(563)};/***/},/* 567 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Input.Gamepad\r\n */module.exports={Axis:__webpack_require__(308),Button:__webpack_require__(307),Gamepad:__webpack_require__(309),GamepadManager:__webpack_require__(310),Configs:__webpack_require__(566)};/***/},/* 568 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Input\r\n */module.exports={CreateInteractiveObject:__webpack_require__(229),Gamepad:__webpack_require__(567),InputManager:__webpack_require__(311),InputPlugin:__webpack_require__(562),Keyboard:__webpack_require__(561),Mouse:__webpack_require__(556),Pointer:__webpack_require__(302),Touch:__webpack_require__(555)};/***/},/* 569 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RotateAroundXY=__webpack_require__(126);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.RotateAroundPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Point} point - [description]\r\n * @param {number} angle - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var RotateAroundPoint=function RotateAroundPoint(triangle,point,angle){return RotateAroundXY(triangle,point.x,point.y,angle);};module.exports=RotateAroundPoint;/***/},/* 570 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RotateAroundXY=__webpack_require__(126);var InCenter=__webpack_require__(230);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Rotate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {number} angle - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var Rotate=function Rotate(triangle,angle){var point=InCenter(triangle);return RotateAroundXY(triangle,point.x,point.y,angle);};module.exports=Rotate;/***/},/* 571 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Length=__webpack_require__(79);// The 2D area of a triangle. The area value is always non-negative.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Perimeter\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n *\r\n * @return {number} [description]\r\n */var Perimeter=function Perimeter(triangle){var line1=triangle.getLineA();var line2=triangle.getLineB();var line3=triangle.getLineC();return Length(line1)+Length(line2)+Length(line3);};module.exports=Perimeter;/***/},/* 572 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Triangle} toCompare - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Equals=function Equals(triangle,toCompare){return triangle.x1===toCompare.x1&&triangle.y1===toCompare.y1&&triangle.x2===toCompare.x2&&triangle.y2===toCompare.y2&&triangle.x3===toCompare.x3&&triangle.y3===toCompare.y3;};module.exports=Equals;/***/},/* 573 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} source - [description]\r\n * @param {Phaser.Geom.Triangle} dest - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var CopyFrom=function CopyFrom(source,dest){return dest.setTo(source.x1,source.y1,source.x2,source.y2,source.x3,source.y3);};module.exports=CopyFrom;/***/},/* 574 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Contains=__webpack_require__(56);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var ContainsPoint=function ContainsPoint(triangle,point){return Contains(triangle,point.x,point.y);};module.exports=ContainsPoint;/***/},/* 575 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Triangle=__webpack_require__(54);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} source - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var Clone=function Clone(source){return new Triangle(source.x1,source.y1,source.x2,source.y2,source.x3,source.y3);};module.exports=Clone;/***/},/* 576 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Circle=__webpack_require__(81);//  Adapted from https://gist.github.com/mutoo/5617691\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.CircumCircle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Circle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Circle} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Circle} [description]\r\n */var CircumCircle=function CircumCircle(triangle,out){if(out===undefined){out=new Circle();}//  A\nvar x1=triangle.x1;var y1=triangle.y1;//  B\nvar x2=triangle.x2;var y2=triangle.y2;//  C\nvar x3=triangle.x3;var y3=triangle.y3;var A=x2-x1;var B=y2-y1;var C=x3-x1;var D=y3-y1;var E=A*(x1+x2)+B*(y1+y2);var F=C*(x1+x3)+D*(y1+y3);var G=2*(A*(y3-y2)-B*(x3-x2));var dx;var dy;//  If the points of the triangle are collinear, then just find the\n//  extremes and use the midpoint as the center of the circumcircle.\nif(Math.abs(G)<0.000001){var minX=Math.min(x1,x2,x3);var minY=Math.min(y1,y2,y3);dx=(Math.max(x1,x2,x3)-minX)*0.5;dy=(Math.max(y1,y2,y3)-minY)*0.5;out.x=minX+dx;out.y=minY+dy;out.radius=Math.sqrt(dx*dx+dy*dy);}else{out.x=(D*E-B*F)/G;out.y=(A*F-C*E)/G;dx=out.x-x1;dy=out.y-y1;out.radius=Math.sqrt(dx*dx+dy*dy);}return out;};module.exports=CircumCircle;/***/},/* 577 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Vector2=__webpack_require__(6);//  Adapted from http://bjornharrtell.github.io/jsts/doc/api/jsts_geom_Triangle.js.html\n/**\r\n * Computes the determinant of a 2x2 matrix. Uses standard double-precision arithmetic, so is susceptible to round-off error.\r\n *\r\n * @function det\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {number} m00 - The [0,0] entry of the matrix.\r\n * @param {number} m01 - The [0,1] entry of the matrix.\r\n * @param {number} m10 - The [1,0] entry of the matrix.\r\n * @param {number} m11 - The [1,1] entry of the matrix.\r\n *\r\n * @return {number} the determinant.\r\n */function det(m00,m01,m10,m11){return m00*m11-m01*m10;}/**\r\n * Computes the circumcentre of a triangle. The circumcentre is the centre of\r\n * the circumcircle, the smallest circle which encloses the triangle. It is also\r\n * the common intersection point of the perpendicular bisectors of the sides of\r\n * the triangle, and is the only point which has equal distance to all three\r\n * vertices of the triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.CircumCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Math.Vector2} [out] - [description]\r\n *\r\n * @return {Phaser.Math.Vector2} [description]\r\n */var CircumCenter=function CircumCenter(triangle,out){if(out===undefined){out=new Vector2();}var cx=triangle.x3;var cy=triangle.y3;var ax=triangle.x1-cx;var ay=triangle.y1-cy;var bx=triangle.x2-cx;var by=triangle.y2-cy;var denom=2*det(ax,ay,bx,by);var numx=det(ay,ax*ax+ay*ay,by,bx*bx+by*by);var numy=det(ax,ax*ax+ay*ay,bx,bx*bx+by*by);out.x=cx-numx/denom;out.y=cy+numy/denom;return out;};module.exports=CircumCenter;/***/},/* 578 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Centroid=__webpack_require__(232);var Offset=__webpack_require__(231);/**\r\n * @callback CenterFunction\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n *\r\n * @return {Phaser.Math.Vector2} [description]\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.CenterOn\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {CenterFunction} [centerFunc] - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var CenterOn=function CenterOn(triangle,x,y,centerFunc){if(centerFunc===undefined){centerFunc=Centroid;}//  Get the center of the triangle\nvar center=centerFunc(triangle);//  Difference\nvar diffX=x-center.x;var diffY=y-center.y;return Offset(triangle,diffX,diffY);};module.exports=CenterOn;/***/},/* 579 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Triangle=__webpack_require__(54);//  Builds a right triangle, with one 90 degree angle and two acute angles\n//  The x/y is the coordinate of the 90 degree angle (and will map to x1/y1 in the resulting Triangle)\n//  w/h can be positive or negative and represent the length of each side\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.BuildRight\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {number} width - [description]\r\n * @param {number} height - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var BuildRight=function BuildRight(x,y,width,height){if(height===undefined){height=width;}//  90 degree angle\nvar x1=x;var y1=y;var x2=x;var y2=y-height;var x3=x+width;var y3=y;return new Triangle(x1,y1,x2,y2,x3,y3);};module.exports=BuildRight;/***/},/* 580 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var EarCut=__webpack_require__(313);var Triangle=__webpack_require__(54);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.BuildFromPolygon\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle[]} O - [out,$return]\r\n *\r\n * @param {array} data - A flat array of vertice coordinates like [x0,y0, x1,y1, x2,y2, ...]\r\n * @param {array} [holes=null] - An array of hole indices if any (e.g. [5, 8] for a 12-vertice input would mean one hole with vertices 5–7 and another with 8–11).\r\n * @param {float} [scaleX=1] - [description]\r\n * @param {float} [scaleY=1] - [description]\r\n * @param {(array|Phaser.Geom.Triangle[])} [out] - [description]\r\n *\r\n * @return {(array|Phaser.Geom.Triangle[])} [description]\r\n */var BuildFromPolygon=function BuildFromPolygon(data,holes,scaleX,scaleY,out){if(holes===undefined){holes=null;}if(scaleX===undefined){scaleX=1;}if(scaleY===undefined){scaleY=1;}if(out===undefined){out=[];}var tris=EarCut(data,holes);var a;var b;var c;var x1;var y1;var x2;var y2;var x3;var y3;for(var i=0;i<tris.length;i+=3){a=tris[i];b=tris[i+1];c=tris[i+2];x1=data[a*2]*scaleX;y1=data[a*2+1]*scaleY;x2=data[b*2]*scaleX;y2=data[b*2+1]*scaleY;x3=data[c*2]*scaleX;y3=data[c*2+1]*scaleY;out.push(new Triangle(x1,y1,x2,y2,x3,y3));}return out;};module.exports=BuildFromPolygon;/***/},/* 581 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Triangle=__webpack_require__(54);// Builds an equilateral triangle.\n// In the equilateral triangle, all the sides are the same length (congruent)\n// and all the angles are the same size (congruent).\n//  The x/y specifies the top-middle of the triangle (x1/y1) and length\n//  is the length of each side\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.BuildEquilateral\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {number} length - [description]\r\n *\r\n * @return {Phaser.Geom.Triangle} [description]\r\n */var BuildEquilateral=function BuildEquilateral(x,y,length){var height=length*(Math.sqrt(3)/2);var x1=x;var y1=y;var x2=x+length/2;var y2=y+height;var x3=x-length/2;var y3=y+height;return new Triangle(x1,y1,x2,y2,x3,y3);};module.exports=BuildEquilateral;/***/},/* 582 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */// The 2D area of a triangle. The area value is always non-negative.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Triangle.Area\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n *\r\n * @return {number} [description]\r\n */var Area=function Area(triangle){var x1=triangle.x1;var y1=triangle.y1;var x2=triangle.x2;var y2=triangle.y2;var x3=triangle.x3;var y3=triangle.y3;return Math.abs(((x3-x1)*(y2-y1)-(x2-x1)*(y3-y1))/2);};module.exports=Area;/***/},/* 583 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Triangle=__webpack_require__(54);Triangle.Area=__webpack_require__(582);Triangle.BuildEquilateral=__webpack_require__(581);Triangle.BuildFromPolygon=__webpack_require__(580);Triangle.BuildRight=__webpack_require__(579);Triangle.CenterOn=__webpack_require__(578);Triangle.Centroid=__webpack_require__(232);Triangle.CircumCenter=__webpack_require__(577);Triangle.CircumCircle=__webpack_require__(576);Triangle.Clone=__webpack_require__(575);Triangle.Contains=__webpack_require__(56);Triangle.ContainsArray=__webpack_require__(130);Triangle.ContainsPoint=__webpack_require__(574);Triangle.CopyFrom=__webpack_require__(573);Triangle.Decompose=__webpack_require__(241);Triangle.Equals=__webpack_require__(572);Triangle.GetPoint=__webpack_require__(234);Triangle.GetPoints=__webpack_require__(233);Triangle.InCenter=__webpack_require__(230);Triangle.Perimeter=__webpack_require__(571);Triangle.Offset=__webpack_require__(231);Triangle.Random=__webpack_require__(168);Triangle.Rotate=__webpack_require__(570);Triangle.RotateAroundPoint=__webpack_require__(569);Triangle.RotateAroundXY=__webpack_require__(126);module.exports=Triangle;/***/},/* 584 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */// Scales the width and height of this Rectangle by the given amounts.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Scale\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var Scale=function Scale(rect,x,y){if(y===undefined){y=x;}rect.width*=x;rect.height*=y;return rect;};module.exports=Scale;/***/},/* 585 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);var DegToRad=__webpack_require__(43);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.PerimeterPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectangle - [description]\r\n * @param {integer} angle - [description]\r\n * @param {Phaser.Geom.Point} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var PerimeterPoint=function PerimeterPoint(rectangle,angle,out){if(out===undefined){out=new Point();}angle=DegToRad(angle);var s=Math.sin(angle);var c=Math.cos(angle);var dx=c>0?rectangle.width/2:rectangle.width/-2;var dy=s>0?rectangle.height/2:rectangle.height/-2;if(Math.abs(dx*s)<Math.abs(dy*c)){dy=dx*s/c;}else{dx=dy*c/s;}out.x=dx+rectangle.centerX;out.y=dy+rectangle.centerY;return out;};module.exports=PerimeterPoint;/***/},/* 586 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Overlaps\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - [description]\r\n * @param {Phaser.Geom.Rectangle} rectB - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Overlaps=function Overlaps(rectA,rectB){return rectA.x<rectB.right&&rectA.right>rectB.x&&rectA.y<rectB.bottom&&rectA.bottom>rectB.y;};module.exports=Overlaps;/***/},/* 587 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.OffsetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var OffsetPoint=function OffsetPoint(rect,point){rect.x+=point.x;rect.y+=point.y;return rect;};module.exports=OffsetPoint;/***/},/* 588 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var Offset=function Offset(rect,x,y){rect.x+=x;rect.y+=y;return rect;};module.exports=Offset;/***/},/* 589 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.MergeXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var MergeXY=function MergeXY(target,x,y){var minX=Math.min(target.x,x);var maxX=Math.max(target.right,x);target.x=minX;target.width=maxX-minX;var minY=Math.min(target.y,y);var maxY=Math.max(target.bottom,y);target.y=minY;target.height=maxY-minY;return target;};module.exports=MergeXY;/***/},/* 590 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Merges source rectangle into target rectangle and returns target\n//  Neither rect should have negative widths or heights\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.MergeRect\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - [description]\r\n * @param {Phaser.Geom.Rectangle} source - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var MergeRect=function MergeRect(target,source){var minX=Math.min(target.x,source.x);var maxX=Math.max(target.right,source.right);target.x=minX;target.width=maxX-minX;var minY=Math.min(target.y,source.y);var maxY=Math.max(target.bottom,source.bottom);target.y=minY;target.height=maxY-minY;return target;};module.exports=MergeRect;/***/},/* 591 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Merges the target Rectangle with a list of points.\n//  The points is an array of objects with public x/y properties.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.MergePoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - [description]\r\n * @param {Phaser.Geom.Point[]} points - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var MergePoints=function MergePoints(target,points){var minX=target.x;var maxX=target.right;var minY=target.y;var maxY=target.bottom;for(var i=0;i<points.length;i++){minX=Math.min(minX,points[i].x);maxX=Math.max(maxX,points[i].x);minY=Math.min(minY,points[i].y);maxY=Math.max(maxY,points[i].y);}target.x=minX;target.y=minY;target.width=maxX-minX;target.height=maxY-minY;return target;};module.exports=MergePoints;/***/},/* 592 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CenterOn=__webpack_require__(235);//  Increases the size of the Rectangle object by the specified amounts.\n//  The center point of the Rectangle object stays the same, and its size increases\n//  to the left and right by the x value, and to the top and the bottom by the y value.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Inflate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var Inflate=function Inflate(rect,x,y){var cx=rect.centerX;var cy=rect.centerY;rect.setSize(rect.width+x*2,rect.height+y*2);return CenterOn(rect,cx,cy);};module.exports=Inflate;/***/},/* 593 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);//  The size of the Rectangle object, expressed as a Point object\n//  with the values of the width and height properties.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.GetSize\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var GetSize=function GetSize(rect,out){if(out===undefined){out=new Point();}out.x=rect.width;out.y=rect.height;return out;};module.exports=GetSize;/***/},/* 594 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);//  The center of the Rectangle object, expressed as a Point object\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.GetCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var GetCenter=function GetCenter(rect,out){if(out===undefined){out=new Point();}out.x=rect.centerX;out.y=rect.centerY;return out;};module.exports=GetCenter;/***/},/* 595 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.FloorAll\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var FloorAll=function FloorAll(rect){rect.x=Math.floor(rect.x);rect.y=Math.floor(rect.y);rect.width=Math.floor(rect.width);rect.height=Math.floor(rect.height);return rect;};module.exports=FloorAll;/***/},/* 596 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Floor\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var Floor=function Floor(rect){rect.x=Math.floor(rect.x);rect.y=Math.floor(rect.y);return rect;};module.exports=Floor;/***/},/* 597 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetAspectRatio=__webpack_require__(127);//  Fits the target rectangle around the source rectangle.\n//  Preserves aspect ration.\n//  Scales and centers the target rectangle to the source rectangle\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.FitOutside\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - [description]\r\n * @param {Phaser.Geom.Rectangle} source - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var FitOutside=function FitOutside(target,source){var ratio=GetAspectRatio(target);if(ratio>GetAspectRatio(source)){//  Wider than Tall\ntarget.setSize(source.height*ratio,source.height);}else{//  Taller than Wide\ntarget.setSize(source.width,source.width/ratio);}return target.setPosition(source.centerX-target.width/2,source.centerY-target.height/2);};module.exports=FitOutside;/***/},/* 598 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetAspectRatio=__webpack_require__(127);//  Fits the target rectangle into the source rectangle.\n//  Preserves aspect ratio.\n//  Scales and centers the target rectangle to the source rectangle\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.FitInside\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - [description]\r\n * @param {Phaser.Geom.Rectangle} source - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var FitInside=function FitInside(target,source){var ratio=GetAspectRatio(target);if(ratio<GetAspectRatio(source)){//  Taller than Wide\ntarget.setSize(source.height*ratio,source.height);}else{//  Wider than Tall\ntarget.setSize(source.width,source.width/ratio);}return target.setPosition(source.centerX-target.width/2,source.centerY-target.height/2);};module.exports=FitInside;/***/},/* 599 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {Phaser.Geom.Rectangle} toCompare - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Equals=function Equals(rect,toCompare){return rect.x===toCompare.x&&rect.y===toCompare.y&&rect.width===toCompare.width&&rect.height===toCompare.height;};module.exports=Equals;/***/},/* 600 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} source - [description]\r\n * @param {Phaser.Geom.Rectangle} dest - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var CopyFrom=function CopyFrom(source,dest){return dest.setTo(source.x,source.y,source.width,source.height);};module.exports=CopyFrom;/***/},/* 601 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Checks if rectB is fully contained within rectA\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.ContainsRect\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - [description]\r\n * @param {Phaser.Geom.Rectangle} rectB - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var ContainsRect=function ContainsRect(rectA,rectB){//  Volume check (if rectB volume > rectA then rectA cannot contain it)\nif(rectB.width*rectB.height>rectA.width*rectA.height){return false;}return rectB.x>rectA.x&&rectB.x<rectA.right&&rectB.right>rectA.x&&rectB.right<rectA.right&&rectB.y>rectA.y&&rectB.y<rectA.bottom&&rectB.bottom>rectA.y&&rectB.bottom<rectA.bottom;};module.exports=ContainsRect;/***/},/* 602 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Contains=__webpack_require__(27);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var ContainsPoint=function ContainsPoint(rect,point){return Contains(rect,point.x,point.y);};module.exports=ContainsPoint;/***/},/* 603 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} source - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var Clone=function Clone(source){return new Rectangle(source.x,source.y,source.width,source.height);};module.exports=Clone;/***/},/* 604 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.CeilAll\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var CeilAll=function CeilAll(rect){rect.x=Math.ceil(rect.x);rect.y=Math.ceil(rect.y);rect.width=Math.ceil(rect.width);rect.height=Math.ceil(rect.height);return rect;};module.exports=CeilAll;/***/},/* 605 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Ceil\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var Ceil=function Ceil(rect){rect.x=Math.ceil(rect.x);rect.y=Math.ceil(rect.y);return rect;};module.exports=Ceil;/***/},/* 606 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Rectangle.Area\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {number} [description]\r\n */var Area=function Area(rect){return rect.width*rect.height;};module.exports=Area;/***/},/* 607 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */// Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Polygon.GetNumberArray\r\n * @since 3.0.0\r\n *\r\n * @generic {number[]} O - [output,$return]\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - [description]\r\n * @param {(array|number[])} [output] - [description]\r\n *\r\n * @return {(array|number[])} [description]\r\n */var GetNumberArray=function GetNumberArray(polygon,output){if(output===undefined){output=[];}for(var i=0;i<polygon.points.length;i++){output.push(polygon.points[i].x);output.push(polygon.points[i].y);}return output;};module.exports=GetNumberArray;/***/},/* 608 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Polygon.GetAABB\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - [description]\r\n * @param {(Phaser.Geom.Rectangle|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Rectangle|object)} [description]\r\n */var GetAABB=function GetAABB(polygon,out){if(out===undefined){out=new Rectangle();}var minX=Infinity;var minY=Infinity;var maxX=-minX;var maxY=-minY;var p;for(var i=0;i<polygon.points.length;i++){p=polygon.points[i];minX=Math.min(minX,p.x);minY=Math.min(minY,p.y);maxX=Math.max(maxX,p.x);maxY=Math.max(maxY,p.y);}out.x=minX;out.y=minY;out.width=maxX-minX;out.height=maxY-minY;return out;};module.exports=GetAABB;/***/},/* 609 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Contains=__webpack_require__(128);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Polygon.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - [description]\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var ContainsPoint=function ContainsPoint(polygon,point){return Contains(polygon,point.x,point.y);};module.exports=ContainsPoint;/***/},/* 610 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Polygon=__webpack_require__(237);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Polygon.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - [description]\r\n *\r\n * @return {Phaser.Geom.Polygon} [description]\r\n */var Clone=function Clone(polygon){return new Polygon(polygon.points);};module.exports=Clone;/***/},/* 611 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Polygon=__webpack_require__(237);Polygon.Clone=__webpack_require__(610);Polygon.Contains=__webpack_require__(128);Polygon.ContainsPoint=__webpack_require__(609);Polygon.GetAABB=__webpack_require__(608);Polygon.GetNumberArray=__webpack_require__(607);module.exports=Polygon;/***/},/* 612 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetMagnitude=__webpack_require__(239);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.SetMagnitude\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [point,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n * @param {number} magnitude - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var SetMagnitude=function SetMagnitude(point,magnitude){if(point.x!==0||point.y!==0){var m=GetMagnitude(point);point.x/=m;point.y/=m;}point.x*=magnitude;point.y*=magnitude;return point;};module.exports=SetMagnitude;/***/},/* 613 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.ProjectUnit\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point} pointA - [description]\r\n * @param {Phaser.Geom.Point} pointB - [description]\r\n * @param {Phaser.Geom.Point} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var ProjectUnit=function ProjectUnit(pointA,pointB,out){if(out===undefined){out=new Point();}var amt=pointA.x*pointB.x+pointA.y*pointB.y;if(amt!==0){out.x=amt*pointB.x;out.y=amt*pointB.y;}return out;};module.exports=ProjectUnit;/***/},/* 614 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);var GetMagnitudeSq=__webpack_require__(238);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.Project\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point} pointA - [description]\r\n * @param {Phaser.Geom.Point} pointB - [description]\r\n * @param {Phaser.Geom.Point} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Project=function Project(pointA,pointB,out){if(out===undefined){out=new Point();}var dot=pointA.x*pointB.x+pointA.y*pointB.y;var amt=dot/GetMagnitudeSq(pointB);if(amt!==0){out.x=amt*pointB.x;out.y=amt*pointB.y;}return out;};module.exports=Project;/***/},/* 615 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.Negative\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n * @param {Phaser.Geom.Point} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Negative=function Negative(point,out){if(out===undefined){out=new Point();}return out.setTo(-point.x,-point.y);};module.exports=Negative;/***/},/* 616 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.Invert\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [point,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Invert=function Invert(point){return point.setTo(point.y,point.x);};module.exports=Invert;/***/},/* 617 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.Interpolate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point} pointA - [description]\r\n * @param {Phaser.Geom.Point} pointB - [description]\r\n * @param {float} [t=0] - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var Interpolate=function Interpolate(pointA,pointB,t,out){if(t===undefined){t=0;}if(out===undefined){out=new Point();}out.x=pointA.x+(pointB.x-pointA.x)*t;out.y=pointA.y+(pointB.y-pointA.y)*t;return out;};module.exports=Interpolate;/***/},/* 618 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);/**\r\n * Calculates the Axis Aligned Bounding Box (or aabb) from an array of points.\r\n *\r\n * @function Phaser.Geom.Point.GetRectangleFromPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point[]} points - [description]\r\n * @param {Phaser.Geom.Rectangle} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var GetRectangleFromPoints=function GetRectangleFromPoints(points,out){if(out===undefined){out=new Rectangle();}var xMax=Number.NEGATIVE_INFINITY;var xMin=Number.POSITIVE_INFINITY;var yMax=Number.NEGATIVE_INFINITY;var yMin=Number.POSITIVE_INFINITY;for(var i=0;i<points.length;i++){var point=points[i];if(point.x>xMax){xMax=point.x;}if(point.x<xMin){xMin=point.x;}if(point.y>yMax){yMax=point.y;}if(point.y<yMin){yMin=point.y;}}out.x=xMin;out.y=yMin;out.width=xMax-xMin;out.height=yMax-yMin;return out;};module.exports=GetRectangleFromPoints;/***/},/* 619 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.GetCentroid\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point[]} points - [description]\r\n * @param {Phaser.Geom.Point} [out] - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var GetCentroid=function GetCentroid(points,out){if(out===undefined){out=new Point();}if(!Array.isArray(points)){throw new Error('GetCentroid points argument must be an array');}var len=points.length;if(len<1){throw new Error('GetCentroid points array must not be empty');}else if(len===1){out.x=points[0].x;out.y=points[0].y;}else{for(var i=0;i<len;i++){out.x+=points[i].x;out.y+=points[i].y;}out.x/=len;out.y/=len;}return out;};module.exports=GetCentroid;/***/},/* 620 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.Floor\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [point,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Floor=function Floor(point){return point.setTo(Math.floor(point.x),Math.floor(point.y));};module.exports=Floor;/***/},/* 621 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n * @param {Phaser.Geom.Point} toCompare - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Equals=function Equals(point,toCompare){return point.x===toCompare.x&&point.y===toCompare.y;};module.exports=Equals;/***/},/* 622 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Point} source - [description]\r\n * @param {Phaser.Geom.Point} dest - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var CopyFrom=function CopyFrom(source,dest){return dest.setTo(source.x,source.y);};module.exports=CopyFrom;/***/},/* 623 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} source - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Clone=function Clone(source){return new Point(source.x,source.y);};module.exports=Clone;/***/},/* 624 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Point.Ceil\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [point,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n *\r\n * @return {Phaser.Geom.Point} [description]\r\n */var Ceil=function Ceil(point){return point.setTo(Math.ceil(point.x),Math.ceil(point.y));};module.exports=Ceil;/***/},/* 625 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);Point.Ceil=__webpack_require__(624);Point.Clone=__webpack_require__(623);Point.CopyFrom=__webpack_require__(622);Point.Equals=__webpack_require__(621);Point.Floor=__webpack_require__(620);Point.GetCentroid=__webpack_require__(619);Point.GetMagnitude=__webpack_require__(239);Point.GetMagnitudeSq=__webpack_require__(238);Point.GetRectangleFromPoints=__webpack_require__(618);Point.Interpolate=__webpack_require__(617);Point.Invert=__webpack_require__(616);Point.Negative=__webpack_require__(615);Point.Project=__webpack_require__(614);Point.ProjectUnit=__webpack_require__(613);Point.SetMagnitude=__webpack_require__(612);module.exports=Point;/***/},/* 626 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Width\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var Width=function Width(line){return Math.abs(line.x1-line.x2);};module.exports=Width;/***/},/* 627 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Slope\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var Slope=function Slope(line){return(line.y2-line.y1)/(line.x2-line.x1);};module.exports=Slope;/***/},/* 628 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.SetToAngle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {number} angle - [description]\r\n * @param {number} length - [description]\r\n *\r\n * @return {Phaser.Geom.Line} [description]\r\n */var SetToAngle=function SetToAngle(line,x,y,angle,length){line.x1=x;line.y1=y;line.x2=x+Math.cos(angle)*length;line.y2=y+Math.sin(angle)*length;return line;};module.exports=SetToAngle;/***/},/* 629 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RotateAroundXY=__webpack_require__(129);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.RotateAroundPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {(Phaser.Geom.Point|object)} point - [description]\r\n * @param {number} angle - [description]\r\n *\r\n * @return {Phaser.Geom.Line} [description]\r\n */var RotateAroundPoint=function RotateAroundPoint(line,point,angle){return RotateAroundXY(line,point.x,point.y,angle);};module.exports=RotateAroundPoint;/***/},/* 630 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RotateAroundXY=__webpack_require__(129);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Rotate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {number} angle - [description]\r\n *\r\n * @return {Phaser.Geom.Line} [description]\r\n */var Rotate=function Rotate(line,angle){var x=(line.x1+line.x2)/2;var y=(line.y1+line.y2)/2;return RotateAroundXY(line,x,y,angle);};module.exports=Rotate;/***/},/* 631 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Angle=__webpack_require__(55);var NormalAngle=__webpack_require__(240);/**\r\n* Returns the reflected angle between two lines.\r\n* This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.\r\n*//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.ReflectAngle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} lineA - [description]\r\n * @param {Phaser.Geom.Line} lineB - [description]\r\n *\r\n * @return {number} [description]\r\n */var ReflectAngle=function ReflectAngle(lineA,lineB){return 2*NormalAngle(lineB)-Math.PI-Angle(lineA);};module.exports=ReflectAngle;/***/},/* 632 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.PerpSlope\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var PerpSlope=function PerpSlope(line){return-((line.x2-line.x1)/(line.y2-line.y1));};module.exports=PerpSlope;/***/},/* 633 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {Phaser.Geom.Line} [description]\r\n */var Offset=function Offset(line,x,y){line.x1+=x;line.y1+=y;line.x2+=x;line.y2+=y;return line;};module.exports=Offset;/***/},/* 634 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MATH_CONST=__webpack_require__(16);var Angle=__webpack_require__(55);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.NormalY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var NormalY=function NormalY(line){return Math.sin(Angle(line)-MATH_CONST.TAU);};module.exports=NormalY;/***/},/* 635 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MATH_CONST=__webpack_require__(16);var Angle=__webpack_require__(55);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.NormalX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var NormalX=function NormalX(line){return Math.cos(Angle(line)-MATH_CONST.TAU);};module.exports=NormalX;/***/},/* 636 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Height\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {number} [description]\r\n */var Height=function Height(line){return Math.abs(line.y1-line.y2);};module.exports=Height;/***/},/* 637 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MATH_CONST=__webpack_require__(16);var Angle=__webpack_require__(55);var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.GetNormal\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var GetNormal=function GetNormal(line,out){if(out===undefined){out=new Point();}var a=Angle(line)-MATH_CONST.TAU;out.x=Math.cos(a);out.y=Math.sin(a);return out;};module.exports=GetNormal;/***/},/* 638 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Point=__webpack_require__(4);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.GetMidPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {(Phaser.Geom.Point|object)} [out] - [description]\r\n *\r\n * @return {(Phaser.Geom.Point|object)} [description]\r\n */var GetMidPoint=function GetMidPoint(line,out){if(out===undefined){out=new Point();}out.x=(line.x1+line.x2)/2;out.y=(line.y1+line.y2)/2;return out;};module.exports=GetMidPoint;/***/},/* 639 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {Phaser.Geom.Line} toCompare - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var Equals=function Equals(line,toCompare){return line.x1===toCompare.x1&&line.y1===toCompare.y1&&line.x2===toCompare.x2&&line.y2===toCompare.y2;};module.exports=Equals;/***/},/* 640 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Line} source - [description]\r\n * @param {Phaser.Geom.Line} dest - [description]\r\n *\r\n * @return {Phaser.Geom.Line} [description]\r\n */var CopyFrom=function CopyFrom(source,dest){return dest.setTo(source.x1,source.y1,source.x2,source.y2);};module.exports=CopyFrom;/***/},/* 641 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Line=__webpack_require__(108);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} source - [description]\r\n *\r\n * @return {Phaser.Geom.Line} [description]\r\n */var Clone=function Clone(source){return new Line(source.x1,source.y1,source.x2,source.y2);};module.exports=Clone;/***/},/* 642 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Line.CenterOn\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n *\r\n * @return {Phaser.Geom.Line} [description]\r\n */var CenterOn=function CenterOn(line,x,y){var tx=x-(line.x1+line.x2)/2;var ty=y-(line.y1+line.y2)/2;line.x1+=tx;line.y1+=ty;line.x2+=tx;line.y2+=ty;return line;};module.exports=CenterOn;/***/},/* 643 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Line=__webpack_require__(108);Line.Angle=__webpack_require__(55);Line.BresenhamPoints=__webpack_require__(358);Line.CenterOn=__webpack_require__(642);Line.Clone=__webpack_require__(641);Line.CopyFrom=__webpack_require__(640);Line.Equals=__webpack_require__(639);Line.GetMidPoint=__webpack_require__(638);Line.GetNormal=__webpack_require__(637);Line.GetPoint=__webpack_require__(364);Line.GetPoints=__webpack_require__(172);Line.Height=__webpack_require__(636);Line.Length=__webpack_require__(79);Line.NormalAngle=__webpack_require__(240);Line.NormalX=__webpack_require__(635);Line.NormalY=__webpack_require__(634);Line.Offset=__webpack_require__(633);Line.PerpSlope=__webpack_require__(632);Line.Random=__webpack_require__(171);Line.ReflectAngle=__webpack_require__(631);Line.Rotate=__webpack_require__(630);Line.RotateAroundPoint=__webpack_require__(629);Line.RotateAroundXY=__webpack_require__(129);Line.SetToAngle=__webpack_require__(628);Line.Slope=__webpack_require__(627);Line.Width=__webpack_require__(626);module.exports=Line;/***/},/* 644 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ContainsArray=__webpack_require__(130);var Decompose=__webpack_require__(241);var LineToLine=__webpack_require__(96);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.TriangleToTriangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangleA - [description]\r\n * @param {Phaser.Geom.Triangle} triangleB - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var TriangleToTriangle=function TriangleToTriangle(triangleA,triangleB){//  First the cheapest ones:\nif(triangleA.left>triangleB.right||triangleA.right<triangleB.left||triangleA.top>triangleB.bottom||triangleA.bottom<triangleB.top){return false;}var lineAA=triangleA.getLineA();var lineAB=triangleA.getLineB();var lineAC=triangleA.getLineC();var lineBA=triangleB.getLineA();var lineBB=triangleB.getLineB();var lineBC=triangleB.getLineC();//  Now check the lines against each line of TriangleB\nif(LineToLine(lineAA,lineBA)||LineToLine(lineAA,lineBB)||LineToLine(lineAA,lineBC)){return true;}if(LineToLine(lineAB,lineBA)||LineToLine(lineAB,lineBB)||LineToLine(lineAB,lineBC)){return true;}if(LineToLine(lineAC,lineBA)||LineToLine(lineAC,lineBB)||LineToLine(lineAC,lineBC)){return true;}//  Nope, so check to see if any of the points of triangleA are within triangleB\nvar points=Decompose(triangleA);var within=ContainsArray(triangleB,points,true);if(within.length>0){return true;}//  Finally check to see if any of the points of triangleB are within triangleA\npoints=Decompose(triangleB);within=ContainsArray(triangleA,points,true);if(within.length>0){return true;}return false;};module.exports=TriangleToTriangle;/***/},/* 645 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Contains=__webpack_require__(56);var LineToLine=__webpack_require__(96);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.TriangleToLine\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var TriangleToLine=function TriangleToLine(triangle,line){//  If the Triangle contains either the start or end point of the line, it intersects\nif(Contains(triangle,line.getPointA())||Contains(triangle,line.getPointB())){return true;}//  Now check the line against each line of the Triangle\nif(LineToLine(triangle.getLineA(),line)){return true;}if(LineToLine(triangle.getLineB(),line)){return true;}if(LineToLine(triangle.getLineC(),line)){return true;}return false;};module.exports=TriangleToLine;/***/},/* 646 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var LineToCircle=__webpack_require__(244);var Contains=__webpack_require__(56);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.TriangleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {Phaser.Geom.Circle} circle - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var TriangleToCircle=function TriangleToCircle(triangle,circle){//  First the cheapest ones:\nif(triangle.left>circle.right||triangle.right<circle.left||triangle.top>circle.bottom||triangle.bottom<circle.top){return false;}if(Contains(triangle,circle.x,circle.y)){return true;}if(LineToCircle(triangle.getLineA(),circle)){return true;}if(LineToCircle(triangle.getLineB(),circle)){return true;}if(LineToCircle(triangle.getLineC(),circle)){return true;}return false;};module.exports=TriangleToCircle;/***/},/* 647 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.RectangleToValues\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} left - [description]\r\n * @param {number} right - [description]\r\n * @param {number} top - [description]\r\n * @param {number} bottom - [description]\r\n * @param {float} [tolerance=0] - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var RectangleToValues=function RectangleToValues(rect,left,right,top,bottom,tolerance){if(tolerance===undefined){tolerance=0;}return!(left>rect.right+tolerance||right<rect.left-tolerance||top>rect.bottom+tolerance||bottom<rect.top-tolerance);};module.exports=RectangleToValues;/***/},/* 648 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var LineToLine=__webpack_require__(96);var Contains=__webpack_require__(27);var ContainsArray=__webpack_require__(130);var Decompose=__webpack_require__(242);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.RectangleToTriangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var RectangleToTriangle=function RectangleToTriangle(rect,triangle){//  First the cheapest ones:\nif(triangle.left>rect.right||triangle.right<rect.left||triangle.top>rect.bottom||triangle.bottom<rect.top){return false;}var triA=triangle.getLineA();var triB=triangle.getLineB();var triC=triangle.getLineC();//  Are any of the triangle points within the rectangle?\nif(Contains(rect,triA.x1,triA.y1)||Contains(rect,triA.x2,triA.y2)){return true;}if(Contains(rect,triB.x1,triB.y1)||Contains(rect,triB.x2,triB.y2)){return true;}if(Contains(rect,triC.x1,triC.y1)||Contains(rect,triC.x2,triC.y2)){return true;}//  Cheap tests over, now to see if any of the lines intersect ...\nvar rectA=rect.getLineA();var rectB=rect.getLineB();var rectC=rect.getLineC();var rectD=rect.getLineD();if(LineToLine(triA,rectA)||LineToLine(triA,rectB)||LineToLine(triA,rectC)||LineToLine(triA,rectD)){return true;}if(LineToLine(triB,rectA)||LineToLine(triB,rectB)||LineToLine(triB,rectC)||LineToLine(triB,rectD)){return true;}if(LineToLine(triC,rectA)||LineToLine(triC,rectB)||LineToLine(triC,rectC)||LineToLine(triC,rectD)){return true;}//  None of the lines intersect, so are any rectangle points within the triangle?\nvar points=Decompose(rect);var within=ContainsArray(triangle,points,true);return within.length>0;};module.exports=RectangleToTriangle;/***/},/* 649 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PointToLine=__webpack_require__(243);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.PointToLineSegment\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - [description]\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var PointToLineSegment=function PointToLineSegment(point,line){if(!PointToLine(point,line)){return false;}var xMin=Math.min(line.x1,line.x2);var xMax=Math.max(line.x1,line.x2);var yMin=Math.min(line.y1,line.y2);var yMax=Math.max(line.y1,line.y2);return point.x>=xMin&&point.x<=xMax&&point.y>=yMin&&point.y<=yMax;};module.exports=PointToLineSegment;/***/},/* 650 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Checks for intersection between the Line and a Rectangle shape, or a rectangle-like\r\n * object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.\r\n *\r\n * An intersection is considered valid if:\r\n *\r\n * The line starts within, or ends within, the Rectangle.\r\n * The line segment intersects one of the 4 rectangle edges.\r\n *\r\n * The for the purposes of this function rectangles are considered 'solid'.\r\n *\r\n * @function Phaser.Geom.Intersects.LineToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - [description]\r\n * @param {(Phaser.Geom.Rectangle|object)} rect - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var LineToRectangle=function LineToRectangle(line,rect){var x1=line.x1;var y1=line.y1;var x2=line.x2;var y2=line.y2;var bx1=rect.x;var by1=rect.y;var bx2=rect.right;var by2=rect.bottom;var t=0;//  If the start or end of the line is inside the rect then we assume\n//  collision, as rects are solid for our use-case.\nif(x1>=bx1&&x1<=bx2&&y1>=by1&&y1<=by2||x2>=bx1&&x2<=bx2&&y2>=by1&&y2<=by2){return true;}if(x1<bx1&&x2>=bx1){//  Left edge\nt=y1+(y2-y1)*(bx1-x1)/(x2-x1);if(t>by1&&t<=by2){return true;}}else if(x1>bx2&&x2<=bx2){//  Right edge\nt=y1+(y2-y1)*(bx2-x1)/(x2-x1);if(t>=by1&&t<=by2){return true;}}if(y1<by1&&y2>=by1){//  Top edge\nt=x1+(x2-x1)*(by1-y1)/(y2-y1);if(t>=bx1&&t<=bx2){return true;}}else if(y1>by2&&y2<=by2){//  Bottom edge\nt=x1+(x2-x1)*(by2-y1)/(y2-y1);if(t>=bx1&&t<=bx2){return true;}}return false;};module.exports=LineToRectangle;/***/},/* 651 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);var RectangleToRectangle=__webpack_require__(245);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.GetRectangleIntersection\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [output,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - [description]\r\n * @param {Phaser.Geom.Rectangle} rectB - [description]\r\n * @param {Phaser.Geom.Rectangle} [output] - [description]\r\n *\r\n * @return {Phaser.Geom.Rectangle} [description]\r\n */var GetRectangleIntersection=function GetRectangleIntersection(rectA,rectB,output){if(output===undefined){output=new Rectangle();}if(RectangleToRectangle(rectA,rectB)){output.x=Math.max(rectA.x,rectB.x);output.y=Math.max(rectA.y,rectB.y);output.width=Math.min(rectA.right,rectB.right)-output.x;output.height=Math.min(rectA.bottom,rectB.bottom)-output.y;}return output;};module.exports=GetRectangleIntersection;/***/},/* 652 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.CircleToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - [description]\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var CircleToRectangle=function CircleToRectangle(circle,rect){var halfWidth=rect.width/2;var halfHeight=rect.height/2;var cx=Math.abs(circle.x-rect.x-halfWidth);var cy=Math.abs(circle.y-rect.y-halfHeight);var xDist=halfWidth+circle.radius;var yDist=halfHeight+circle.radius;if(cx>xDist||cy>yDist){return false;}else if(cx<=halfWidth||cy<=halfHeight){return true;}else{var xCornerDist=cx-halfWidth;var yCornerDist=cy-halfHeight;var xCornerDistSq=xCornerDist*xCornerDist;var yCornerDistSq=yCornerDist*yCornerDist;var maxCornerDistSq=circle.radius*circle.radius;return xCornerDistSq+yCornerDistSq<=maxCornerDistSq;}};module.exports=CircleToRectangle;/***/},/* 653 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var DistanceBetween=__webpack_require__(49);/**\r\n * [description]\r\n *\r\n * @function Phaser.Geom.Intersects.CircleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circleA - [description]\r\n * @param {Phaser.Geom.Circle} circleB - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var CircleToCircle=function CircleToCircle(circleA,circleB){return DistanceBetween(circleA.x,circleA.y,circleB.x,circleB.y)<=circleA.radius+circleB.radius;};module.exports=CircleToCircle;/***/},/* 654 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Offsets the Circle by the values given in the `x` and `y` properties of the Point object.\r\n *\r\n * @function Phaser.Geom.Circle.OffsetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Circle} O - [circle,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to be offset (translated.)\r\n * @param {(Phaser.Geom.Point|object)} point - The Point object containing the values to offset the Circle by.\r\n *\r\n * @return {Phaser.Geom.Circle} The Circle that was offset.\r\n */var OffsetPoint=function OffsetPoint(circle,point){circle.x+=point.x;circle.y+=point.y;return circle;};module.exports=OffsetPoint;/***/},/* 655 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Offsets the Circle by the values given.\r\n *\r\n * @function Phaser.Geom.Circle.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Circle} O - [circle,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to be offset (translated.)\r\n * @param {number} x - The amount to horizontally offset the Circle by.\r\n * @param {number} y - The amount to vertically offset the Circle by.\r\n *\r\n * @return {Phaser.Geom.Circle} The Circle that was offset.\r\n */var Offset=function Offset(circle,x,y){circle.x+=x;circle.y+=y;return circle;};module.exports=Offset;/***/},/* 656 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);/**\r\n * Returns the bounds of the Circle object.\r\n *\r\n * @function Phaser.Geom.Circle.GetBounds\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the bounds from.\r\n * @param {(Phaser.Geom.Rectangle|object)} [out] - A Rectangle, or rectangle-like object, to store the circle bounds in. If not given a new Rectangle will be created.\r\n *\r\n * @return {(Phaser.Geom.Rectangle|object)} The Rectangle object containing the Circles bounds.\r\n */var GetBounds=function GetBounds(circle,out){if(out===undefined){out=new Rectangle();}out.x=circle.left;out.y=circle.top;out.width=circle.diameter;out.height=circle.diameter;return out;};module.exports=GetBounds;/***/},/* 657 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Compares the `x`, `y` and `radius` properties of the two given Circles.\r\n * Returns `true` if they all match, otherwise returns `false`.\r\n *\r\n * @function Phaser.Geom.Circle.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The first Circle to compare.\r\n * @param {Phaser.Geom.Circle} toCompare - The second Circle to compare.\r\n *\r\n * @return {boolean} `true` if the two Circles equal each other, otherwise `false`.\r\n */var Equals=function Equals(circle,toCompare){return circle.x===toCompare.x&&circle.y===toCompare.y&&circle.radius===toCompare.radius;};module.exports=Equals;/***/},/* 658 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Copies the `x`, `y` and `radius` properties from the `source` Circle\r\n * into the given `dest` Circle, then returns the `dest` Circle.\r\n *\r\n * @function Phaser.Geom.Circle.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Circle} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} source - The source Circle to copy the values from.\r\n * @param {Phaser.Geom.Circle} dest - The destination Circle to copy the values to.\r\n *\r\n * @return {Phaser.Geom.Circle} The dest Circle.\r\n */var CopyFrom=function CopyFrom(source,dest){return dest.setTo(source.x,source.y,source.radius);};module.exports=CopyFrom;/***/},/* 659 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Contains=__webpack_require__(28);/**\r\n * Check to see if the Circle contains all four points of the given Rectangle object.\r\n *\r\n * @function Phaser.Geom.Circle.ContainsRect\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to check.\r\n * @param {(Phaser.Geom.Rectangle|object)} rect - The Rectangle object to check if it's within the Circle or not.\r\n *\r\n * @return {boolean} True if all of the Rectangle coordinates are within the circle, otherwise false.\r\n */var ContainsRect=function ContainsRect(circle,rect){return Contains(circle,rect.x,rect.y)&&Contains(circle,rect.right,rect.y)&&Contains(circle,rect.x,rect.bottom)&&Contains(circle,rect.right,rect.bottom);};module.exports=ContainsRect;/***/},/* 660 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Contains=__webpack_require__(28);/**\r\n * Check to see if the Circle contains the given Point object.\r\n *\r\n * @function Phaser.Geom.Circle.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to check.\r\n * @param {(Phaser.Geom.Point|object)} point - The Point object to check if it's within the Circle or not.\r\n *\r\n * @return {boolean} True if the Point coordinates are within the circle, otherwise false.\r\n */var ContainsPoint=function ContainsPoint(circle,point){return Contains(circle,point.x,point.y);};module.exports=ContainsPoint;/***/},/* 661 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Circle=__webpack_require__(81);/**\r\n * Creates a new Circle instance based on the values contained in the given source.\r\n *\r\n * @function Phaser.Geom.Circle.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Circle|object)} source - The Circle to be cloned. Can be an instance of a Circle or a circle-like object, with x, y and radius properties.\r\n *\r\n * @return {Phaser.Geom.Circle} A clone of the source Circle.\r\n */var Clone=function Clone(source){return new Circle(source.x,source.y,source.radius);};module.exports=Clone;/***/},/* 662 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Calculates the area of the circle.\r\n *\r\n * @function Phaser.Geom.Circle.Area\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the area of.\r\n *\r\n * @return {number} The area of the Circle.\r\n */var Area=function Area(circle){return circle.radius>0?Math.PI*circle.radius*circle.radius:0;};module.exports=Area;/***/},/* 663 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Circle=__webpack_require__(81);Circle.Area=__webpack_require__(662);Circle.Circumference=__webpack_require__(366);Circle.CircumferencePoint=__webpack_require__(175);Circle.Clone=__webpack_require__(661);Circle.Contains=__webpack_require__(28);Circle.ContainsPoint=__webpack_require__(660);Circle.ContainsRect=__webpack_require__(659);Circle.CopyFrom=__webpack_require__(658);Circle.Equals=__webpack_require__(657);Circle.GetBounds=__webpack_require__(656);Circle.GetPoint=__webpack_require__(368);Circle.GetPoints=__webpack_require__(367);Circle.Offset=__webpack_require__(655);Circle.OffsetPoint=__webpack_require__(654);Circle.Random=__webpack_require__(174);module.exports=Circle;/***/},/* 664 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var LightsManager=__webpack_require__(248);var PluginManager=__webpack_require__(13);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class LightsPlugin\r\n * @extends Phaser.GameObjects.LightsManager\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var LightsPlugin=new Class({Extends:LightsManager,initialize:function LightsPlugin(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.LightsPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.LightsPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}LightsManager.call(this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsPlugin#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.LightsPlugin#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.shutdown();this.scene=undefined;this.systems=undefined;}});PluginManager.register('LightsPlugin',LightsPlugin,'lights');module.exports=LightsPlugin;/***/},/* 665 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var Quad=__webpack_require__(131);/**\r\n * Creates a new Quad Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Quad Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#quad\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Quad} The Game Object that was created.\r\n */GameObjectCreator.register('quad',function(config){var x=GetAdvancedValue(config,'x',0);var y=GetAdvancedValue(config,'y',0);var key=GetAdvancedValue(config,'key',null);var frame=GetAdvancedValue(config,'frame',null);var quad=new Quad(this.scene,x,y,key,frame);BuildGameObject(this.scene,quad,config);return quad;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 666 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var GetValue=__webpack_require__(5);var Mesh=__webpack_require__(97);/**\r\n * Creates a new Mesh Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#mesh\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Mesh} The Game Object that was created.\r\n */GameObjectCreator.register('mesh',function(config){var key=GetAdvancedValue(config,'key',null);var frame=GetAdvancedValue(config,'frame',null);var vertices=GetValue(config,'vertices',[]);var colors=GetValue(config,'colors',[]);var alphas=GetValue(config,'alphas',[]);var uv=GetValue(config,'uv',[]);var mesh=new Mesh(this.scene,0,0,vertices,uv,colors,alphas,key,frame);BuildGameObject(this.scene,mesh,config);return mesh;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 667 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Quad=__webpack_require__(131);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Quad Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Quad Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#quad\r\n * @webglOnly\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * \r\n * @return {Phaser.GameObjects.Quad} The Game Object that was created.\r\n */if(true){GameObjectFactory.register('quad',function(x,y,key,frame){return this.displayList.add(new Quad(this.scene,x,y,key,frame));});}//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//  \n//  There are several properties available to use:\n//  \n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 668 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Mesh=__webpack_require__(97);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Mesh Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#mesh\r\n * @webglOnly\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {float[]} vertices - An array containing the vertices data for this Mesh.\r\n * @param {float[]} uv - An array containing the uv data for this Mesh.\r\n * @param {float[]} colors - An array containing the color data for this Mesh.\r\n * @param {float[]} alphas - An array containing the alpha data for this Mesh.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.Mesh} The Game Object that was created.\r\n */if(true){GameObjectFactory.register('mesh',function(x,y,vertices,uv,colors,alphas,texture,frame){return this.displayList.add(new Mesh(this.scene,x,y,vertices,uv,colors,alphas,texture,frame));});}//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 669 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * This is a stub function for Mesh.Render. There is no Canvas renderer for Mesh objects.\r\n *\r\n * @method Phaser.GameObjects.Mesh#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Mesh} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */var MeshCanvasRenderer=function MeshCanvasRenderer(){};module.exports=MeshCanvasRenderer;/***/},/* 670 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Mesh#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Mesh} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var MeshWebGLRenderer=function MeshWebGLRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}this.pipeline.batchMesh(src,camera,parentMatrix);};module.exports=MeshWebGLRenderer;/***/},/* 671 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(670);}if(true){renderCanvas=__webpack_require__(669);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 672 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var Zone=__webpack_require__(110);/**\r\n * Creates a new Zone Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Zone Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#zone\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Zone} The Game Object that was created.\r\n */GameObjectCreator.register('zone',function(config){var x=GetAdvancedValue(config,'x',0);var y=GetAdvancedValue(config,'y',0);var width=GetAdvancedValue(config,'width',1);var height=GetAdvancedValue(config,'height',width);return new Zone(this.scene,x,y,width,height);});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 673 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var TileSprite=__webpack_require__(132);/**\r\n * @typedef {object} TileSprite\r\n * @extends GameObjectConfig\r\n *\r\n * @property {number} [x=0] - [description]\r\n * @property {number} [y=0] - [description]\r\n * @property {number} [width=512] - [description]\r\n * @property {number} [height=512] - [description]\r\n * @property {string} [key=''] - [description]\r\n * @property {string} [frame=''] - [description]\r\n *//**\r\n * Creates a new TileSprite Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tileSprite\r\n * @since 3.0.0\r\n *\r\n * @param {TileSprite} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.TileSprite} The Game Object that was created.\r\n */GameObjectCreator.register('tileSprite',function(config){var x=GetAdvancedValue(config,'x',0);var y=GetAdvancedValue(config,'y',0);var width=GetAdvancedValue(config,'width',512);var height=GetAdvancedValue(config,'height',512);var key=GetAdvancedValue(config,'key','');var frame=GetAdvancedValue(config,'frame','');var tile=new TileSprite(this.scene,x,y,width,height,key,frame);BuildGameObject(this.scene,tile,config);return tile;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 674 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var Text=__webpack_require__(133);/**\r\n * Creates a new Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#text\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Text} The Game Object that was created.\r\n */GameObjectCreator.register('text',function(config){// style Object = {\n//     font: [ 'font', '16px Courier' ],\n//     backgroundColor: [ 'backgroundColor', null ],\n//     fill: [ 'fill', '#fff' ],\n//     stroke: [ 'stroke', '#fff' ],\n//     strokeThickness: [ 'strokeThickness', 0 ],\n//     shadowOffsetX: [ 'shadow.offsetX', 0 ],\n//     shadowOffsetY: [ 'shadow.offsetY', 0 ],\n//     shadowColor: [ 'shadow.color', '#000' ],\n//     shadowBlur: [ 'shadow.blur', 0 ],\n//     shadowStroke: [ 'shadow.stroke', false ],\n//     shadowFill: [ 'shadow.fill', false ],\n//     align: [ 'align', 'left' ],\n//     maxLines: [ 'maxLines', 0 ],\n//     fixedWidth: [ 'fixedWidth', false ],\n//     fixedHeight: [ 'fixedHeight', false ],\n//     rtl: [ 'rtl', false ]\n// }\nvar content=GetAdvancedValue(config,'text','');var style=GetAdvancedValue(config,'style',null);//  Padding\n//      { padding: 2 }\n//      { padding: { x: , y: }}\n//      { padding: { left: , top: }}\n//      { padding: { left: , right: , top: , bottom: }}\nvar padding=GetAdvancedValue(config,'padding',null);if(padding!==null){style.padding=padding;}var text=new Text(this.scene,0,0,content,style);BuildGameObject(this.scene,text,config);//  Text specific config options:\ntext.autoRound=GetAdvancedValue(config,'autoRound',true);text.resolution=GetAdvancedValue(config,'resolution',1);return text;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 675 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BitmapText=__webpack_require__(142);var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var GetValue=__webpack_require__(5);/**\r\n * Creates a new Bitmap Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#bitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {BitmapTextConfig} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.BitmapText} The Game Object that was created.\r\n */GameObjectCreator.register('bitmapText',function(config){var font=GetValue(config,'font','');var text=GetAdvancedValue(config,'text','');var size=GetAdvancedValue(config,'size',false);// var align = GetValue(config, 'align', 'left');\nvar bitmapText=new BitmapText(this.scene,0,0,font,text,size);BuildGameObject(this.scene,bitmapText,config);return bitmapText;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 676 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var BuildGameObjectAnimation=__webpack_require__(143);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var Sprite=__webpack_require__(41);/**\r\n * Creates a new Sprite Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Sprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#sprite\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Sprite} The Game Object that was created.\r\n */GameObjectCreator.register('sprite',function(config){var key=GetAdvancedValue(config,'key',null);var frame=GetAdvancedValue(config,'frame',null);var sprite=new Sprite(this.scene,0,0,key,frame);BuildGameObject(this.scene,sprite,config);//  Sprite specific config options:\nBuildGameObjectAnimation(sprite,config);//  Physics, Input, etc to follow ...\nreturn sprite;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 677 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var BuildGameObjectAnimation=__webpack_require__(143);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var Sprite3D=__webpack_require__(105);/**\r\n * Creates a new Sprite3D Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Sprite3D Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#sprite3D\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Sprite3D} The Game Object that was created.\r\n */GameObjectCreator.register('sprite3D',function(config){var key=GetAdvancedValue(config,'key',null);var frame=GetAdvancedValue(config,'frame',null);var sprite=new Sprite3D(this.scene,0,0,key,frame);BuildGameObject(this.scene,sprite,config);//  Sprite specific config options:\nBuildGameObjectAnimation(sprite,config);//  Physics, Input, etc to follow ...\nreturn sprite;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 678 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var RenderTexture=__webpack_require__(134);/**\r\n * @typedef {object} RenderTextureConfig\r\n *\r\n * @property {number} [x=0] - [description]\r\n * @property {number} [y=0] - [description]\r\n * @property {number} [width=32] - [description]\r\n * @property {number} [height=32] - [description]\r\n *//**\r\n * Creates a new Render Texture Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#renderTexture\r\n * @since 3.2.0\r\n *\r\n * @param {RenderTextureConfig} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.RenderTexture} The Game Object that was created.\r\n */GameObjectCreator.register('renderTexture',function(config){var x=GetAdvancedValue(config,'x',0);var y=GetAdvancedValue(config,'y',0);var width=GetAdvancedValue(config,'width',32);var height=GetAdvancedValue(config,'height',32);var renderTexture=new RenderTexture(this.scene,x,y,width,height);BuildGameObject(this.scene,renderTexture,config);return renderTexture;});/***/},/* 679 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var GetFastValue=__webpack_require__(2);var ParticleEmitterManager=__webpack_require__(135);/**\r\n * Creates a new Particle Emitter Manager Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Particles Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#particles\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} The Game Object that was created.\r\n */GameObjectCreator.register('particles',function(config){var key=GetAdvancedValue(config,'key',null);var frame=GetAdvancedValue(config,'frame',null);var emitters=GetFastValue(config,'emitters',null);//  frame is optional and can contain the emitters array or object if skipped\nvar manager=new ParticleEmitterManager(this.scene,key,frame,emitters);var add=GetFastValue(config,'add',false);if(add){this.displayList.add(manager);}this.updateList.add(manager);return manager;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n//  \n//  There are several properties available to use:\n//  \n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 680 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);var Image=__webpack_require__(73);/**\r\n * Creates a new Image Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Image Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#image\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Image} The Game Object that was created.\r\n */GameObjectCreator.register('image',function(config){var key=GetAdvancedValue(config,'key',null);var frame=GetAdvancedValue(config,'frame',null);var image=new Image(this.scene,0,0,key,frame);BuildGameObject(this.scene,image,config);return image;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 681 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectCreator=__webpack_require__(11);var Group=__webpack_require__(74);/**\r\n * Creates a new Group Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Group Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#group\r\n * @since 3.0.0\r\n *\r\n * @param {GroupConfig} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Group} The Game Object that was created.\r\n */GameObjectCreator.register('group',function(config){return new Group(this.scene,null,config);});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 682 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetAdvancedValue=__webpack_require__(8);var GameObjectCreator=__webpack_require__(11);var Graphics=__webpack_require__(138);/**\r\n * Creates a new Graphics Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Graphics Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#graphics\r\n * @since 3.0.0\r\n *\r\n * @param {object} [config] - [description]\r\n *\r\n * @return {Phaser.GameObjects.Graphics} The Game Object that was created.\r\n */GameObjectCreator.register('graphics',function(config){var add=GetAdvancedValue(config,'add',true);var graphics=new Graphics(this.scene,config);if(add){this.scene.sys.displayList.add(graphics);}return graphics;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 683 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BitmapText=__webpack_require__(139);var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);/**\r\n * @typedef {object} BitmapTextConfig\r\n * @extends GameObjectConfig\r\n *\r\n * @property {string} [font=''] - [description]\r\n * @property {string} [text=''] - [description]\r\n * @property {(number|false)} [size=false] - [description]\r\n * @property {string} [align='left'] - [description]\r\n *//**\r\n * Creates a new Dynamic Bitmap Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#dynamicBitmapText\r\n * @since 3.0.0\r\n *²\r\n * @param {BitmapTextConfig} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.DynamicBitmapText} The Game Object that was created.\r\n */GameObjectCreator.register('dynamicBitmapText',function(config){var font=GetAdvancedValue(config,'font','');var text=GetAdvancedValue(config,'text','');var size=GetAdvancedValue(config,'size',false);var align=GetAdvancedValue(config,'align','left');var bitmapText=new BitmapText(this.scene,0,0,font,text,size,align);BuildGameObject(this.scene,bitmapText,config);return bitmapText;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 684 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BuildGameObject=__webpack_require__(20);var Container=__webpack_require__(140);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);/**\r\n * Creates a new Container Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Container Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#container\r\n * @since 3.4.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Container} The Game Object that was created.\r\n */GameObjectCreator.register('container',function(config){var x=GetAdvancedValue(config,'x',0);var y=GetAdvancedValue(config,'y',0);var container=new Container(this.scene,x,y);BuildGameObject(this.scene,container,config);return container;});/***/},/* 685 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Blitter=__webpack_require__(141);var BuildGameObject=__webpack_require__(20);var GameObjectCreator=__webpack_require__(11);var GetAdvancedValue=__webpack_require__(8);/**\r\n * Creates a new Blitter Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Blitter Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#blitter\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n *\r\n * @return {Phaser.GameObjects.Blitter} The Game Object that was created.\r\n */GameObjectCreator.register('blitter',function(config){var key=GetAdvancedValue(config,'key',null);var frame=GetAdvancedValue(config,'frame',null);var blitter=new Blitter(this.scene,0,0,key,frame);BuildGameObject(this.scene,blitter,config);return blitter;});//  When registering a factory function 'this' refers to the GameObjectCreator context.\n/***/},/* 686 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Zone=__webpack_require__(110);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Zone Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Zone Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#zone\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} width - The width of the Game Object.\r\n * @param {number} height - The height of the Game Object.\r\n * \r\n * @return {Phaser.GameObjects.Zone} The Game Object that was created.\r\n */GameObjectFactory.register('zone',function(x,y,width,height){return this.displayList.add(new Zone(this.scene,x,y,width,height));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//  \n//  There are several properties available to use:\n//  \n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 687 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var TileSprite=__webpack_require__(132);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new TileSprite Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#tileSprite\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} width - The width of the Game Object.\r\n * @param {number} height - The height of the Game Object.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.TileSprite} The Game Object that was created.\r\n */GameObjectFactory.register('tileSprite',function(x,y,width,height,key,frame){return this.displayList.add(new TileSprite(this.scene,x,y,width,height,key,frame));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 688 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Text=__webpack_require__(133);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Text Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#text\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {object} [style] - The Text style configuration object.\r\n *\r\n * @return {Phaser.GameObjects.Text} The Game Object that was created.\r\n */GameObjectFactory.register('text',function(x,y,text,style){return this.displayList.add(new Text(this.scene,x,y,text,style));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 689 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BitmapText=__webpack_require__(142);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Bitmap Text Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#bitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} font - [description]\r\n * @param {(string|string[])} [text] - [description]\r\n * @param {number} [size] - [description]\r\n *\r\n * @return {Phaser.GameObjects.BitmapText} The Game Object that was created.\r\n */GameObjectFactory.register('bitmapText',function(x,y,font,text,size){return this.displayList.add(new BitmapText(this.scene,x,y,font,text,size));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 690 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectFactory=__webpack_require__(9);var Sprite=__webpack_require__(41);/**\r\n * Creates a new Sprite Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Sprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#sprite\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.Sprite} The Game Object that was created.\r\n */GameObjectFactory.register('sprite',function(x,y,key,frame){var sprite=new Sprite(this.scene,x,y,key,frame);this.displayList.add(sprite);this.updateList.add(sprite);return sprite;});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 691 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Sprite3D=__webpack_require__(105);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Sprite3D Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Sprite3D Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#sprite3D\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object.\r\n * @param {number} y - The vertical position of this Game Object.\r\n * @param {number} z - The z position of this Game Object.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.Sprite3D} The Game Object that was created.\r\n */GameObjectFactory.register('sprite3D',function(x,y,z,key,frame){var sprite=new Sprite3D(this.scene,x,y,z,key,frame);this.displayList.add(sprite.gameObject);this.updateList.add(sprite.gameObject);return sprite;});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 692 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectFactory=__webpack_require__(9);var RenderTexture=__webpack_require__(134);/**\r\n * Creates a new Render Texture Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#renderTexture\r\n * @since 3.2.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {integer} [width=32] - The width of the Render Texture.\r\n * @param {integer} [height=32] - The height of the Render Texture.\r\n * \r\n * @return {Phaser.GameObjects.RenderTexture} The Game Object that was created.\r\n */GameObjectFactory.register('renderTexture',function(x,y,width,height){return this.displayList.add(new RenderTexture(this.scene,x,y,width,height));});/***/},/* 693 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectFactory=__webpack_require__(9);var PathFollower=__webpack_require__(251);/**\r\n * Creates a new PathFollower Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the PathFollower Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#follower\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Curves.Path} path - The Path this PathFollower is connected to.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.PathFollower} The Game Object that was created.\r\n */GameObjectFactory.register('follower',function(path,x,y,key,frame){var sprite=new PathFollower(this.scene,path,x,y,key,frame);this.displayList.add(sprite);this.updateList.add(sprite);return sprite;});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 694 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObjectFactory=__webpack_require__(9);var ParticleEmitterManager=__webpack_require__(135);/**\r\n * Creates a new Particle Emitter Manager Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Particles Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#particles\r\n * @since 3.0.0\r\n *\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer|object)} [frame] - [description]\r\n * @param {object} [emitters] - [description]\r\n *\r\n * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} The Game Object that was created.\r\n */GameObjectFactory.register('particles',function(key,frame,emitters){var manager=new ParticleEmitterManager(this.scene,key,frame,emitters);this.displayList.add(manager);this.updateList.add(manager);return manager;});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 695 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Image=__webpack_require__(73);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Image Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Image Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#image\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.Image} The Game Object that was created.\r\n */GameObjectFactory.register('image',function(x,y,key,frame){return this.displayList.add(new Image(this.scene,x,y,key,frame));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 696 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Group=__webpack_require__(74);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Group Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Group Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#group\r\n * @since 3.0.0\r\n *\r\n * @param {?(Phaser.GameObjects.GameObject[]|GroupConfig)} children - [description]\r\n * @param {GroupConfig} [config] - [description]\r\n *\r\n * @return {Phaser.GameObjects.Group} The Game Object that was created.\r\n */GameObjectFactory.register('group',function(children,config){if((typeof children==='undefined'?'undefined':_typeof(children))==='object'&&config===undefined){config=children;children=[];}return this.updateList.add(new Group(this.scene,children,config));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 697 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Graphics=__webpack_require__(138);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Graphics Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Graphics Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#graphics\r\n * @since 3.0.0\r\n *\r\n * @param {object} [config] - [description]\r\n * \r\n * @return {Phaser.GameObjects.Graphics} The Game Object that was created.\r\n */GameObjectFactory.register('graphics',function(config){return this.displayList.add(new Graphics(this.scene,config));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//  \n//  There are several properties available to use:\n//  \n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 698 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var DynamicBitmapText=__webpack_require__(139);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Dynamic Bitmap Text Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#dynamicBitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} font - [description]\r\n * @param {(string|string[])} [text] - [description]\r\n * @param {number} [size] - [description]\r\n *\r\n * @return {Phaser.GameObjects.DynamicBitmapText} The Game Object that was created.\r\n */GameObjectFactory.register('dynamicBitmapText',function(x,y,font,text,size){return this.displayList.add(new DynamicBitmapText(this.scene,x,y,font,text,size));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 699 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Container=__webpack_require__(140);var GameObjectFactory=__webpack_require__(9);var hasWarned=false;/**\r\n * Creates a new Container Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Container Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#container\r\n * @since 3.4.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.\r\n *\r\n * @return {Phaser.GameObjects.Container} The Game Object that was created.\r\n */GameObjectFactory.register('container',function(x,y,children){if(!hasWarned){console.warn('Use of a beta feature: Containers');hasWarned=true;}return this.displayList.add(new Container(this.scene,x,y,children));});/***/},/* 700 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Blitter=__webpack_require__(141);var GameObjectFactory=__webpack_require__(9);/**\r\n * Creates a new Blitter Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Blitter Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#blitter\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} key - The key of the Texture the Blitter object will use.\r\n * @param {(string|integer)} [frame] - The default Frame children of the Blitter will use.\r\n * \r\n * @return {Phaser.GameObjects.Blitter} The Game Object that was created.\r\n */GameObjectFactory.register('blitter',function(x,y,key,frame){return this.displayList.add(new Blitter(this.scene,x,y,key,frame));});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//  \n//  There are several properties available to use:\n//  \n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n/***/},/* 701 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.TileSprite#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.TileSprite} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var TileSpriteCanvasRenderer=function TileSpriteCanvasRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}var ctx=renderer.currentContext;var frame=src.frame;src.updateTileTexture();//  Blend Mode\nif(renderer.currentBlendMode!==src.blendMode){renderer.currentBlendMode=src.blendMode;ctx.globalCompositeOperation=renderer.blendModes[src.blendMode];}//  Alpha\nif(renderer.currentAlpha!==src.alpha){renderer.currentAlpha=src.alpha;ctx.globalAlpha=src.alpha;}//  Smoothing\nif(renderer.currentScaleMode!==src.scaleMode){renderer.currentScaleMode=src.scaleMode;}var dx=frame.x-src.originX*src.width;var dy=frame.y-src.originY*src.height;var tx=src.x-camera.scrollX*src.scrollFactorX;var ty=src.y-camera.scrollY*src.scrollFactorY;var fx=1;var fy=1;// Flipping\nif(src.flipX){fx=-1;dx+=src.width;}if(src.flipY){fy=-1;dy+=src.height;}if(renderer.config.roundPixels){dx|=0;dy|=0;tx|=0;ty|=0;}ctx.save();if(parentMatrix!==undefined){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}ctx.translate(dx,dy);ctx.translate(tx,ty);// Flip\nctx.scale(fx,fy);// Rotate and scale around center\nctx.translate(src.originX*src.width,src.originY*src.height);ctx.rotate(fx*fy*src.rotation);ctx.scale(this.scaleX,this.scaleY);ctx.translate(-(src.originX*src.width),-(src.originY*src.height));// Draw\nctx.translate(-this.tilePositionX,-this.tilePositionY);ctx.fillStyle=src.canvasPattern;ctx.fillRect(this.tilePositionX,this.tilePositionY,src.width,src.height);ctx.restore();};module.exports=TileSpriteCanvasRenderer;/***/},/* 702 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.TileSprite#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.TileSprite} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var TileSpriteWebGLRenderer=function TileSpriteWebGLRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}src.updateTileTexture();this.pipeline.batchTileSprite(this,camera,parentMatrix);};module.exports=TileSpriteWebGLRenderer;/***/},/* 703 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(702);}if(true){renderCanvas=__webpack_require__(701);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 704 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CanvasPool=__webpack_require__(23);/**\r\n * Calculates the ascent, descent and fontSize of a given font style.\r\n *\r\n * @function Phaser.GameObjects.Text.MeasureText\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Text.TextStyle} textStyle - The TextStyle object to measure.\r\n *\r\n * @return {object} An object containing the ascent, descent and fontSize of the TextStyle.\r\n */var MeasureText=function MeasureText(textStyle){// @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.\nvar canvas=CanvasPool.create(this);// @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.\nvar context=canvas.getContext('2d');textStyle.syncFont(canvas,context);var width=Math.ceil(context.measureText(textStyle.testString).width*textStyle.baselineX);var baseline=width;var height=2*baseline;baseline=baseline*textStyle.baselineY|0;canvas.width=width;canvas.height=height;context.fillStyle='#f00';context.fillRect(0,0,width,height);context.font=textStyle._font;context.textBaseline='alphabetic';context.fillStyle='#000';context.fillText(textStyle.testString,0,baseline);var output={ascent:0,descent:0,fontSize:0};if(!context.getImageData(0,0,width,height)){output.ascent=baseline;output.descent=baseline+6;output.fontSize=output.ascent+output.descent;CanvasPool.remove(canvas);return output;}var imagedata=context.getImageData(0,0,width,height).data;var pixels=imagedata.length;var line=width*4;var i;var j;var idx=0;var stop=false;// ascent. scan from top to bottom until we find a non red pixel\nfor(i=0;i<baseline;i++){for(j=0;j<line;j+=4){if(imagedata[idx+j]!==255){stop=true;break;}}if(!stop){idx+=line;}else{break;}}output.ascent=baseline-i;idx=pixels-line;stop=false;// descent. scan from bottom to top until we find a non red pixel\nfor(i=height;i>baseline;i--){for(j=0;j<line;j+=4){if(imagedata[idx+j]!==255){stop=true;break;}}if(!stop){idx-=line;}else{break;}}output.descent=i-baseline;output.fontSize=output.ascent+output.descent;CanvasPool.remove(canvas);return output;};module.exports=MeasureText;/***/},/* 705 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetAdvancedValue=__webpack_require__(8);var GetValue=__webpack_require__(5);var MeasureText=__webpack_require__(704);//  Key: [ Object Key, Default Value ]\n/**\r\n * A custom function that will be responsible for wrapping the text.\r\n * @callback TextStyleWordWrapCallback\r\n *\r\n * @param {string} text - The string to wrap.\r\n * @param {Phaser.GameObjects.Text} textObject - The Text instance.\r\n *\r\n * @return {(string|string[])} Should return the wrapped lines either as an array of lines or as a string with\r\n * newline characters in place to indicate where breaks should happen.\r\n */var propertyMap={fontFamily:['fontFamily','Courier'],fontSize:['fontSize','16px'],fontStyle:['fontStyle',''],backgroundColor:['backgroundColor',null],color:['color','#fff'],stroke:['stroke','#fff'],strokeThickness:['strokeThickness',0],shadowOffsetX:['shadow.offsetX',0],shadowOffsetY:['shadow.offsetY',0],shadowColor:['shadow.color','#000'],shadowBlur:['shadow.blur',0],shadowStroke:['shadow.stroke',false],shadowFill:['shadow.fill',false],align:['align','left'],maxLines:['maxLines',0],fixedWidth:['fixedWidth',0],fixedHeight:['fixedHeight',0],rtl:['rtl',false],testString:['testString','|MÃ‰qgy'],baselineX:['baselineX',1.2],baselineY:['baselineY',1.4],wordWrapWidth:['wordWrap.width',null],wordWrapCallback:['wordWrap.callback',null],wordWrapCallbackScope:['wordWrap.callbackScope',null],wordWrapUseAdvanced:['wordWrap.useAdvancedWrap',false]};/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TextStyle\r\n * @memberOf Phaser.GameObjects.Text\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Text} text - The Text object that this TextStyle is styling.\r\n * @param {object} style - [description]\r\n */var TextStyle=new Class({initialize:function TextStyle(text,style){/**\r\n         * The Text object that this TextStyle is styling.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#parent\r\n         * @type {Phaser.GameObjects.Text}\r\n         * @since 3.0.0\r\n         */this.parent=text;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#fontFamily\r\n         * @type {string}\r\n         * @default 'Courier'\r\n         * @since 3.0.0\r\n         */this.fontFamily;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#fontSize\r\n         * @type {string}\r\n         * @default '16px'\r\n         * @since 3.0.0\r\n         */this.fontSize;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#fontStyle\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.fontStyle;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#backgroundColor\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.backgroundColor;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#color\r\n         * @type {string}\r\n         * @default '#fff'\r\n         * @since 3.0.0\r\n         */this.color;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#stroke\r\n         * @type {string}\r\n         * @default '#fff'\r\n         * @since 3.0.0\r\n         */this.stroke;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#strokeThickness\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.strokeThickness;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#shadowOffsetX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.shadowOffsetX;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#shadowOffsetY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.shadowOffsetY;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#shadowColor\r\n         * @type {string}\r\n         * @default '#000'\r\n         * @since 3.0.0\r\n         */this.shadowColor;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#shadowBlur\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.shadowBlur;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#shadowStroke\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.shadowStroke;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#shadowFill\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.shadowFill;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#align\r\n         * @type {string}\r\n         * @default 'left'\r\n         * @since 3.0.0\r\n         */this.align;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#maxLines\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.maxLines;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#fixedWidth\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.fixedWidth;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#fixedHeight\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.fixedHeight;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#rtl\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.rtl;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#testString\r\n         * @type {string}\r\n         * @default '|MÉqgy'\r\n         * @since 3.0.0\r\n         */this.testString;/**\r\n         * The amount of horizontal padding adding to the width of the text when calculating the font metrics.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#baselineX\r\n         * @type {number}\r\n         * @default 1.2\r\n         * @since 3.3.0\r\n         */this.baselineX;/**\r\n         * The amount of vertical padding adding to the width of the text when calculating the font metrics.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#baselineY\r\n         * @type {number}\r\n         * @default 1.4\r\n         * @since 3.3.0\r\n         */this.baselineY;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Components.TextStyle#_font\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._font;//  Set to defaults + user style\nthis.setStyle(style,false);var metrics=GetValue(style,'metrics',false);//  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning\n//  Doing this is reset if you then change the font of this TextStyle after creation\nif(metrics){this.metrics={ascent:GetValue(metrics,'ascent',0),descent:GetValue(metrics,'descent',0),fontSize:GetValue(metrics,'fontSize',0)};}else{this.metrics=MeasureText(this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {CSSStyleRule} style - [description]\r\n     * @param {boolean} [updateText=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setStyle:function setStyle(style,updateText){if(updateText===undefined){updateText=true;}//  Avoid type mutation\nif(style&&style.hasOwnProperty('fontSize')&&typeof style.fontSize==='number'){style.fontSize=style.fontSize.toString()+'px';}for(var key in propertyMap){if(key==='wordWrapCallback'||key==='wordWrapCallbackScope'){// Callback & scope should be set without processing the values\nthis[key]=GetValue(style,propertyMap[key][0],propertyMap[key][1]);}else{this[key]=GetAdvancedValue(style,propertyMap[key][0],propertyMap[key][1]);}}//  Allow for 'font' override\nvar font=GetValue(style,'font',null);if(font===null){this._font=[this.fontStyle,this.fontSize,this.fontFamily].join(' ');}else{this._font=font;}//  Allow for 'fill' to be used in place of 'color'\nvar fill=GetValue(style,'fill',null);if(fill!==null){this.color=fill;}if(updateText){return this.update(true);}else{return this.parent;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#syncFont\r\n     * @since 3.0.0\r\n     *\r\n     * @param {HTMLCanvasElement} canvas - [description]\r\n     * @param {CanvasRenderingContext2D} context - [description]\r\n     */syncFont:function syncFont(canvas,context){context.font=this._font;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#syncStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {HTMLCanvasElement} canvas - [description]\r\n     * @param {CanvasRenderingContext2D} context - [description]\r\n     */syncStyle:function syncStyle(canvas,context){context.textBaseline='alphabetic';context.fillStyle=this.color;context.strokeStyle=this.stroke;context.lineWidth=this.strokeThickness;context.lineCap='round';context.lineJoin='round';},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#syncShadow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {CanvasRenderingContext2D} context - [description]\r\n     * @param {boolean} enabled - [description]\r\n     */syncShadow:function syncShadow(context,enabled){if(enabled){context.shadowOffsetX=this.shadowOffsetX;context.shadowOffsetY=this.shadowOffsetY;context.shadowColor=this.shadowColor;context.shadowBlur=this.shadowBlur;}else{context.shadowOffsetX=0;context.shadowOffsetY=0;context.shadowColor=0;context.shadowBlur=0;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} recalculateMetrics - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */update:function update(recalculateMetrics){if(recalculateMetrics){this._font=[this.fontStyle,this.fontSize,this.fontFamily].join(' ');this.metrics=MeasureText(this);}return this.parent.updateText();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setFont\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} font - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setFont:function setFont(font){if(typeof font==='string'){this.fontFamily=font;this.fontSize='';this.fontStyle='';}else{this.fontFamily=GetValue(font,'fontFamily','Courier');this.fontSize=GetValue(font,'fontSize','16px');this.fontStyle=GetValue(font,'fontStyle','');}return this.update(true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setFontFamily\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} family - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setFontFamily:function setFontFamily(family){this.fontFamily=family;return this.update(true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setFontStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} style - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setFontStyle:function setFontStyle(style){this.fontStyle=style;return this.update(true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|string)} size - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setFontSize:function setFontSize(size){if(typeof size==='number'){size=size.toString()+'px';}this.fontSize=size;return this.update(true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setTestString\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} string - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setTestString:function setTestString(string){this.testString=string;return this.update(true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setFixedSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setFixedSize:function setFixedSize(width,height){this.fixedWidth=width;this.fixedHeight=height;if(width){this.parent.width=width;}if(height){this.parent.height=height;}return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setBackgroundColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setBackgroundColor:function setBackgroundColor(color){this.backgroundColor=color;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setFill:function setFill(color){this.color=color;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setColor:function setColor(color){this.color=color;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - [description]\r\n     * @param {number} thickness - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setStroke:function setStroke(color,thickness){if(color===undefined){//  Reset the stroke to zero (disabling it)\nthis.strokeThickness=0;}else{if(thickness===undefined){thickness=this.strokeThickness;}this.stroke=color;this.strokeThickness=thickness;}return this.update(true);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setShadow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - [description]\r\n     * @param {number} [y=0] - [description]\r\n     * @param {string} [color='#000'] - [description]\r\n     * @param {number} [blur=0] - [description]\r\n     * @param {boolean} [shadowStroke=false] - [description]\r\n     * @param {boolean} [shadowFill=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setShadow:function setShadow(x,y,color,blur,shadowStroke,shadowFill){if(x===undefined){x=0;}if(y===undefined){y=0;}if(color===undefined){color='#000';}if(blur===undefined){blur=0;}if(shadowStroke===undefined){shadowStroke=false;}if(shadowFill===undefined){shadowFill=true;}this.shadowOffsetX=x;this.shadowOffsetY=y;this.shadowColor=color;this.shadowBlur=blur;this.shadowStroke=shadowStroke;this.shadowFill=shadowFill;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setShadowOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - [description]\r\n     * @param {number} [y=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setShadowOffset:function setShadowOffset(x,y){if(x===undefined){x=0;}if(y===undefined){y=x;}this.shadowOffsetX=x;this.shadowOffsetY=y;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setShadowColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [color='#000'] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setShadowColor:function setShadowColor(color){if(color===undefined){color='#000';}this.shadowColor=color;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setShadowBlur\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [blur=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setShadowBlur:function setShadowBlur(blur){if(blur===undefined){blur=0;}this.shadowBlur=blur;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setShadowStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setShadowStroke:function setShadowStroke(enabled){this.shadowStroke=enabled;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setShadowFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setShadowFill:function setShadowFill(enabled){this.shadowFill=enabled;return this.update(false);},/**\r\n     * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setWordWrapWidth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\r\n     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\r\n     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\r\n     * spaces and whitespace are left as is.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setWordWrapWidth:function setWordWrapWidth(width,useAdvancedWrap){if(useAdvancedWrap===undefined){useAdvancedWrap=false;}this.wordWrapWidth=width;this.wordWrapUseAdvanced=useAdvancedWrap;return this.update(false);},/**\r\n     * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setWordWrapCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\r\n     * text. It will receive two arguments: text (the string to wrap), textObject (this Text\r\n     * instance). It should return the wrapped lines either as an array of lines or as a string with\r\n     * newline characters in place to indicate where breaks should happen.\r\n     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setWordWrapCallback:function setWordWrapCallback(callback,scope){if(scope===undefined){scope=null;}this.wordWrapCallback=callback;this.wordWrapCallbackScope=scope;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setAlign\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} align - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setAlign:function setAlign(align){if(align===undefined){align='left';}this.align=align;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#setMaxLines\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [max=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Text} The parent Text object.\r\n     */setMaxLines:function setMaxLines(max){if(max===undefined){max=0;}this.maxLines=max;return this.update(false);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#getTextMetrics\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */getTextMetrics:function getTextMetrics(){var metrics=this.metrics;return{ascent:metrics.ascent,descent:metrics.descent,fontSize:metrics.fontSize};},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */toJSON:function toJSON(){var output={};for(var key in propertyMap){output[key]=this[key];}output.metrics=this.getTextMetrics();return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextStyle#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.parent=undefined;}});module.exports=TextStyle;/***/},/* 706 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Text#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var TextCanvasRenderer=function TextCanvasRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id||src.text===''){return;}var ctx=renderer.currentContext;// var resolution = src.resolution;\n//  Blend Mode\nif(renderer.currentBlendMode!==src.blendMode){renderer.currentBlendMode=src.blendMode;ctx.globalCompositeOperation=renderer.blendModes[src.blendMode];}//  Alpha\nif(renderer.currentAlpha!==src.alpha){renderer.currentAlpha=src.alpha;ctx.globalAlpha=src.alpha;}//  Smoothing\nif(renderer.currentScaleMode!==src.scaleMode){renderer.currentScaleMode=src.scaleMode;}var canvas=src.canvas;ctx.save();if(parentMatrix!==undefined){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}var tx=src.x-camera.scrollX*src.scrollFactorX;var ty=src.y-camera.scrollY*src.scrollFactorY;if(renderer.config.roundPixels){tx|=0;ty|=0;}ctx.translate(tx,ty);ctx.rotate(src.rotation);ctx.scale(src.scaleX,src.scaleY);ctx.translate(canvas.width*(src.flipX?1:0),canvas.height*(src.flipY?1:0));ctx.scale(src.flipX?-1:1,src.flipY?-1:1);ctx.drawImage(canvas,0,0,canvas.width,canvas.height,-src.displayOriginX,-src.displayOriginY,canvas.width,canvas.height);ctx.restore();};module.exports=TextCanvasRenderer;/***/},/* 707 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Text#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var TextWebGLRenderer=function TextWebGLRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id||src.text===''){return;}if(src.dirty){src.canvasTexture=renderer.canvasToTexture(src.canvas,src.canvasTexture,true,src.scaleMode);src.dirty=false;}this.pipeline.batchText(this,camera,parentMatrix);};module.exports=TextWebGLRenderer;/***/},/* 708 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(707);}if(true){renderCanvas=__webpack_require__(706);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 709 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns an object containing dimensions of the Text object.\r\n *\r\n * @function Phaser.GameObjects.Text.GetTextSize\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Text} text - The Text object to get the size from.\r\n * @param {number} size - [description]\r\n * @param {array} lines - [description]\r\n *\r\n * @return {object} An object containing dimensions of the Text object.\r\n */var GetTextSize=function GetTextSize(text,size,lines){var canvas=text.canvas;var context=text.context;var style=text.style;var lineWidths=[];var maxLineWidth=0;var drawnLines=lines.length;if(style.maxLines>0&&style.maxLines<lines.length){drawnLines=style.maxLines;}style.syncFont(canvas,context);//  Text Width\nfor(var i=0;i<drawnLines;i++){var lineWidth=style.strokeThickness;lineWidth+=context.measureText(lines[i]).width;// Adjust for wrapped text\nif(style.wordWrap){lineWidth-=context.measureText(' ').width;}lineWidths[i]=Math.ceil(lineWidth);maxLineWidth=Math.max(maxLineWidth,lineWidths[i]);}//  Text Height\nvar lineHeight=size.fontSize+style.strokeThickness;var height=lineHeight*drawnLines;var lineSpacing=text._lineSpacing||0;if(lineSpacing<0&&Math.abs(lineSpacing)>lineHeight){lineSpacing=-lineHeight;}//  Adjust for line spacing\nif(lineSpacing!==0){height+=lineSpacing>0?lineSpacing*lines.length:lineSpacing*(lines.length-1);}return{width:maxLineWidth,height:height,lines:drawnLines,lineWidths:lineWidths,lineSpacing:lineSpacing,lineHeight:lineHeight};};module.exports=GetTextSize;/***/},/* 710 *//***/function(module,exports){var RenderTextureWebGL={fill:function fill(rgb){var ur=(rgb>>16|0)&0xff;var ug=(rgb>>8|0)&0xff;var ub=(rgb|0)&0xff;this.renderer.setFramebuffer(this.framebuffer);var gl=this.gl;gl.clearColor(ur/255.0,ug/255.0,ub/255.0,1);gl.clear(gl.COLOR_BUFFER_BIT);this.renderer.setFramebuffer(null);return this;},clear:function clear(){this.renderer.setFramebuffer(this.framebuffer);var gl=this.gl;gl.clearColor(0,0,0,0);gl.clear(gl.COLOR_BUFFER_BIT);this.renderer.setFramebuffer(null);return this;},draw:function draw(texture,frame,x,y){var glTexture=texture.source[frame.sourceIndex].glTexture;var tint=(this.globalTint>>16)+(this.globalTint&0xff00)+((this.globalTint&0xff)<<16);this.renderer.setFramebuffer(this.framebuffer);this.renderer.pipelines.TextureTintPipeline.drawTexture(glTexture,x,y,tint,this.globalAlpha,frame.cutX,frame.cutY,frame.cutWidth,frame.cutHeight,this.currentMatrix);this.renderer.setFramebuffer(null);return this;}};module.exports=RenderTextureWebGL;/***/},/* 711 *//***/function(module,exports){var RenderTextureCanvas={fill:function fill(rgb){var ur=(rgb>>16|0)&0xff;var ug=(rgb>>8|0)&0xff;var ub=(rgb|0)&0xff;this.context.fillStyle='rgb('+ur+','+ug+','+ub+')';this.context.fillRect(0,0,this.canvas.width,this.canvas.height);return this;},clear:function clear(){this.context.save();this.context.setTransform(1,0,0,1,0,0);this.context.clearRect(0,0,this.canvas.width,this.canvas.height);this.context.restore();return this;},draw:function draw(texture,frame,x,y){var matrix=this.currentMatrix;this.context.globalAlpha=this.globalAlpha;this.context.setTransform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);this.context.drawImage(texture.source[frame.sourceIndex].image,frame.cutX,frame.cutY,frame.cutWidth,frame.cutHeight,x,y,frame.cutWidth,frame.cutWidth);return this;}};module.exports=RenderTextureCanvas;/***/},/* 712 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.RenderTexture#renderCanvas\r\n * @since 3.2.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.RenderTexture} renderTexture - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var RenderTextureCanvasRenderer=function RenderTextureCanvasRenderer(renderer,renderTexture,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==renderTexture.renderFlags||renderTexture.cameraFilter>0&&renderTexture.cameraFilter&camera._id){return;}var ctx=renderer.currentContext;if(renderer.currentBlendMode!==renderTexture.blendMode){renderer.currentBlendMode=renderTexture.blendMode;ctx.globalCompositeOperation=renderer.blendModes[renderTexture.blendMode];}if(renderer.currentAlpha!==renderTexture.alpha){renderer.currentAlpha=renderTexture.alpha;ctx.globalAlpha=renderTexture.alpha;}if(renderer.currentScaleMode!==renderTexture.scaleMode){renderer.currentScaleMode=renderTexture.scaleMode;}var dx=0;var dy=0;var fx=1;var fy=1;if(renderTexture.flipX){fx=-1;dx-=renderTexture.canvas.width-renderTexture.displayOriginX;}else{dx-=renderTexture.displayOriginX;}if(renderTexture.flipY){fy=-1;dy-=renderTexture.canvas.height-renderTexture.displayOriginY;}else{dy-=renderTexture.displayOriginY;}ctx.save();if(parentMatrix!==undefined){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}ctx.translate(renderTexture.x-camera.scrollX*renderTexture.scrollFactorX,renderTexture.y-camera.scrollY*renderTexture.scrollFactorY);ctx.rotate(renderTexture.rotation);ctx.scale(renderTexture.scaleX,renderTexture.scaleY);ctx.scale(fx,fy);ctx.drawImage(renderTexture.canvas,dx,dy);ctx.restore();};module.exports=RenderTextureCanvasRenderer;/***/},/* 713 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);var Utils=__webpack_require__(38);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.RenderTexture#renderWebgl\r\n * @since 3.2.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.RenderTexture} renderTexture - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var RenderTextureWebGLRenderer=function RenderTextureWebGLRenderer(renderer,renderTexture,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==renderTexture.renderFlags||renderTexture.cameraFilter>0&&renderTexture.cameraFilter&camera._id){return;}this.pipeline.batchTexture(renderTexture,renderTexture.texture,renderTexture.texture.width,renderTexture.texture.height,renderTexture.x,renderTexture.y,renderTexture.width,renderTexture.height,renderTexture.scaleX,renderTexture.scaleY,renderTexture.rotation,renderTexture.flipX,renderTexture.flipY,renderTexture.scrollFactorX,renderTexture.scrollFactorY,renderTexture.displayOriginX,renderTexture.displayOriginY,0,0,renderTexture.texture.width,renderTexture.texture.height,Utils.getTintAppendFloatAlpha(renderTexture.tintTopLeft,renderTexture.alphaTopLeft),Utils.getTintAppendFloatAlpha(renderTexture.tintTopRight,renderTexture.alphaTopRight),Utils.getTintAppendFloatAlpha(renderTexture.tintBottomLeft,renderTexture.alphaBottomLeft),Utils.getTintAppendFloatAlpha(renderTexture.tintBottomRight,renderTexture.alphaBottomRight),0,0,camera,parentMatrix);};module.exports=RenderTextureWebGLRenderer;/***/},/* 714 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(713);}if(true){renderCanvas=__webpack_require__(712);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 715 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var ParticleManagerCanvasRenderer=function ParticleManagerCanvasRenderer(renderer,emitterManager,interpolationPercentage,camera,parentMatrix){var emitters=emitterManager.emitters.list;if(emitters.length===0||GameObject.RENDER_MASK!==emitterManager.renderFlags||emitterManager.cameraFilter>0&&emitterManager.cameraFilter&camera._id){return;}var ctx=renderer.currentContext;ctx.save();if(parentMatrix!==undefined){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}for(var i=0;i<emitters.length;i++){var emitter=emitters[i];var particles=emitter.alive;var length=particles.length;if(!emitter.visible||length===0){continue;}var lastAlpha=ctx.globalAlpha;var cameraScrollX=camera.scrollX*emitter.scrollFactorX;var cameraScrollY=camera.scrollY*emitter.scrollFactorY;if(renderer.currentBlendMode!==emitter.blendMode){renderer.currentBlendMode=emitter.blendMode;ctx.globalCompositeOperation=renderer.blendModes[emitter.blendMode];}var roundPixels=renderer.config.roundPixels;for(var index=0;index<length;++index){var particle=particles[index];var alpha=(particle.color>>24&0xFF)/255.0;if(alpha<=0){continue;}var frame=particle.frame;var width=frame.width;var height=frame.height;var ox=width*0.5;var oy=height*0.5;var cd=frame.canvasData;var x=-ox;var y=-oy;var tx=particle.x-cameraScrollX*particle.scrollFactorX;var ty=particle.y-cameraScrollY*particle.scrollFactorY;if(roundPixels){tx|=0;ty|=0;}ctx.globalAlpha=alpha;ctx.save();ctx.translate(tx,ty);ctx.rotate(particle.rotation);ctx.scale(particle.scaleX,particle.scaleY);ctx.drawImage(frame.source.image,cd.sx,cd.sy,cd.sWidth,cd.sHeight,x,y,cd.dWidth,cd.dHeight);ctx.restore();}ctx.globalAlpha=lastAlpha;}ctx.restore();};module.exports=ParticleManagerCanvasRenderer;/***/},/* 716 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var ParticleManagerWebGLRenderer=function ParticleManagerWebGLRenderer(renderer,emitterManager,interpolationPercentage,camera,parentMatrix){var emitters=emitterManager.emitters;if(emitters.length===0||GameObject.RENDER_MASK!==emitterManager.renderFlags||emitterManager.cameraFilter>0&&emitterManager.cameraFilter&camera._id){return;}this.pipeline.drawEmitterManager(emitterManager,camera,parentMatrix);};module.exports=ParticleManagerWebGLRenderer;/***/},/* 717 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(716);}if(true){renderCanvas=__webpack_require__(715);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 718 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Stepped\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {float} [steps=1] - [description]\r\n *\r\n * @return {number} [description]\r\n */var Stepped=function Stepped(v,steps){if(steps===undefined){steps=1;}if(v<=0){return 0;}else if(v>=1){return 1;}else{return((steps*v|0)+1)*(1/steps);}};module.exports=Stepped;/***/},/* 719 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Sine.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v){if(v===0){return 0;}else if(v===1){return 1;}else{return 0.5*(1-Math.cos(Math.PI*v));}};module.exports=InOut;/***/},/* 720 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Sine.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v){if(v===0){return 0;}else if(v===1){return 1;}else{return Math.sin(v*Math.PI/2);}};module.exports=Out;/***/},/* 721 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Sine.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v){if(v===0){return 0;}else if(v===1){return 1;}else{return 1-Math.cos(v*Math.PI/2);}};module.exports=In;/***/},/* 722 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quintic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v){if((v*=2)<1){return 0.5*v*v*v*v*v;}else{return 0.5*((v-=2)*v*v*v*v+2);}};module.exports=InOut;/***/},/* 723 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quintic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v){return--v*v*v*v*v+1;};module.exports=Out;/***/},/* 724 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quintic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v){return v*v*v*v*v;};module.exports=In;/***/},/* 725 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quartic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v){if((v*=2)<1){return 0.5*v*v*v*v;}else{return-0.5*((v-=2)*v*v*v-2);}};module.exports=InOut;/***/},/* 726 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quartic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v){return 1- --v*v*v*v;};module.exports=Out;/***/},/* 727 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quartic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v){return v*v*v*v;};module.exports=In;/***/},/* 728 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v){if((v*=2)<1){return 0.5*v*v;}else{return-0.5*(--v*(v-2)-1);}};module.exports=InOut;/***/},/* 729 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v){return v*(2-v);};module.exports=Out;/***/},/* 730 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v){return v*v;};module.exports=In;/***/},/* 731 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Linear\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Linear=function Linear(v){return v;};module.exports=Linear;/***/},/* 732 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Expo.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v){if((v*=2)<1){return 0.5*Math.pow(2,10*(v-1));}else{return 0.5*(2-Math.pow(2,-10*(v-1)));}};module.exports=InOut;/***/},/* 733 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Expo.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v){return 1-Math.pow(2,-10*v);};module.exports=Out;/***/},/* 734 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Expo.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v){return Math.pow(2,10*(v-1))-0.001;};module.exports=In;/***/},/* 735 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Elastic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {float} [amplitude=0.1] - [description]\r\n * @param {float} [period=0.1] - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v,amplitude,period){if(amplitude===undefined){amplitude=0.1;}if(period===undefined){period=0.1;}if(v===0){return 0;}else if(v===1){return 1;}else{var s=period/4;if(amplitude<1){amplitude=1;}else{s=period*Math.asin(1/amplitude)/(2*Math.PI);}if((v*=2)<1){return-0.5*(amplitude*Math.pow(2,10*(v-=1))*Math.sin((v-s)*(2*Math.PI)/period));}else{return amplitude*Math.pow(2,-10*(v-=1))*Math.sin((v-s)*(2*Math.PI)/period)*0.5+1;}}};module.exports=InOut;/***/},/* 736 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Elastic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {float} [amplitude=0.1] - [description]\r\n * @param {float} [period=0.1] - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v,amplitude,period){if(amplitude===undefined){amplitude=0.1;}if(period===undefined){period=0.1;}if(v===0){return 0;}else if(v===1){return 1;}else{var s=period/4;if(amplitude<1){amplitude=1;}else{s=period*Math.asin(1/amplitude)/(2*Math.PI);}return amplitude*Math.pow(2,-10*v)*Math.sin((v-s)*(2*Math.PI)/period)+1;}};module.exports=Out;/***/},/* 737 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Elastic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {float} [amplitude=0.1] - [description]\r\n * @param {float} [period=0.1] - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v,amplitude,period){if(amplitude===undefined){amplitude=0.1;}if(period===undefined){period=0.1;}if(v===0){return 0;}else if(v===1){return 1;}else{var s=period/4;if(amplitude<1){amplitude=1;}else{s=period*Math.asin(1/amplitude)/(2*Math.PI);}return-(amplitude*Math.pow(2,10*(v-=1))*Math.sin((v-s)*(2*Math.PI)/period));}};module.exports=In;/***/},/* 738 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Cubic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v){if((v*=2)<1){return 0.5*v*v*v;}else{return 0.5*((v-=2)*v*v+2);}};module.exports=InOut;/***/},/* 739 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Cubic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v){return--v*v*v+1;};module.exports=Out;/***/},/* 740 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Cubic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v){return v*v*v;};module.exports=In;/***/},/* 741 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Circular.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v){if((v*=2)<1){return-0.5*(Math.sqrt(1-v*v)-1);}else{return 0.5*(Math.sqrt(1-(v-=2)*v)+1);}};module.exports=InOut;/***/},/* 742 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Circular.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v){return Math.sqrt(1- --v*v);};module.exports=Out;/***/},/* 743 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Circular.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v){return 1-Math.sqrt(1-v*v);};module.exports=In;/***/},/* 744 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Bounce.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v){var reverse=false;if(v<0.5){v=1-v*2;reverse=true;}else{v=v*2-1;}if(v<1/2.75){v=7.5625*v*v;}else if(v<2/2.75){v=7.5625*(v-=1.5/2.75)*v+0.75;}else if(v<2.5/2.75){v=7.5625*(v-=2.25/2.75)*v+0.9375;}else{v=7.5625*(v-=2.625/2.75)*v+0.984375;}if(reverse){return(1-v)*0.5;}else{return v*0.5+0.5;}};module.exports=InOut;/***/},/* 745 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Bounce.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v){if(v<1/2.75){return 7.5625*v*v;}else if(v<2/2.75){return 7.5625*(v-=1.5/2.75)*v+0.75;}else if(v<2.5/2.75){return 7.5625*(v-=2.25/2.75)*v+0.9375;}else{return 7.5625*(v-=2.625/2.75)*v+0.984375;}};module.exports=Out;/***/},/* 746 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Bounce.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v){v=1-v;if(v<1/2.75){return 1-7.5625*v*v;}else if(v<2/2.75){return 1-(7.5625*(v-=1.5/2.75)*v+0.75);}else if(v<2.5/2.75){return 1-(7.5625*(v-=2.25/2.75)*v+0.9375);}else{return 1-(7.5625*(v-=2.625/2.75)*v+0.984375);}};module.exports=In;/***/},/* 747 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Back.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {number} [overshoot=1.70158] - [description]\r\n *\r\n * @return {number} [description]\r\n */var InOut=function InOut(v,overshoot){if(overshoot===undefined){overshoot=1.70158;}var s=overshoot*1.525;if((v*=2)<1){return 0.5*(v*v*((s+1)*v-s));}else{return 0.5*((v-=2)*v*((s+1)*v+s)+2);}};module.exports=InOut;/***/},/* 748 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Back.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {number} [overshoot=1.70158] - [description]\r\n *\r\n * @return {number} [description]\r\n */var Out=function Out(v,overshoot){if(overshoot===undefined){overshoot=1.70158;}return--v*v*((overshoot+1)*v+overshoot)+1;};module.exports=Out;/***/},/* 749 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Easing.Back.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - [description]\r\n * @param {number} [overshoot=1.70158] - [description]\r\n *\r\n * @return {number} [description]\r\n */var In=function In(v,overshoot){if(overshoot===undefined){overshoot=1.70158;}return v*v*((overshoot+1)*v-overshoot);};module.exports=In;/***/},/* 750 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Back=__webpack_require__(265);var Bounce=__webpack_require__(264);var Circular=__webpack_require__(263);var Cubic=__webpack_require__(262);var Elastic=__webpack_require__(261);var Expo=__webpack_require__(260);var Linear=__webpack_require__(259);var Quadratic=__webpack_require__(258);var Quartic=__webpack_require__(257);var Quintic=__webpack_require__(256);var Sine=__webpack_require__(255);var Stepped=__webpack_require__(254);//  EaseMap\nmodule.exports={Power0:Linear,Power1:Quadratic.Out,Power2:Cubic.Out,Power3:Quartic.Out,Power4:Quintic.Out,Linear:Linear,Quad:Quadratic.Out,Cubic:Cubic.Out,Quart:Quartic.Out,Quint:Quintic.Out,Sine:Sine.Out,Expo:Expo.Out,Circ:Circular.Out,Elastic:Elastic.Out,Back:Back.Out,Bounce:Bounce.Out,Stepped:Stepped,'Quad.easeIn':Quadratic.In,'Cubic.easeIn':Cubic.In,'Quart.easeIn':Quartic.In,'Quint.easeIn':Quintic.In,'Sine.easeIn':Sine.In,'Expo.easeIn':Expo.In,'Circ.easeIn':Circular.In,'Elastic.easeIn':Elastic.In,'Back.easeIn':Back.In,'Bounce.easeIn':Bounce.In,'Quad.easeOut':Quadratic.Out,'Cubic.easeOut':Cubic.Out,'Quart.easeOut':Quartic.Out,'Quint.easeOut':Quintic.Out,'Sine.easeOut':Sine.Out,'Expo.easeOut':Expo.Out,'Circ.easeOut':Circular.Out,'Elastic.easeOut':Elastic.Out,'Back.easeOut':Back.Out,'Bounce.easeOut':Bounce.Out,'Quad.easeInOut':Quadratic.InOut,'Cubic.easeInOut':Cubic.InOut,'Quart.easeInOut':Quartic.InOut,'Quint.easeInOut':Quintic.InOut,'Sine.easeInOut':Sine.InOut,'Expo.easeInOut':Expo.InOut,'Circ.easeInOut':Circular.InOut,'Elastic.easeInOut':Elastic.InOut,'Back.easeInOut':Back.InOut,'Bounce.easeInOut':Bounce.InOut};/***/},/* 751 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var FloatBetween=__webpack_require__(266);var GetEaseFunction=__webpack_require__(72);var GetFastValue=__webpack_require__(2);var Wrap=__webpack_require__(44);/**\r\n * The returned value sets what the property will be at the START of the particles life, on emit.\r\n * @callback EmitterOpOnEmitCallback\r\n *\r\n * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n * @param {string} key - [description]\r\n * @param {number} value - [description]\r\n *\r\n * @return {number} [description]\r\n *//**\r\n * The returned value updates the property for the duration of the particles life.\r\n * @callback EmitterOpOnUpdateCallback\r\n *\r\n * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n * @param {string} key - [description]\r\n * @param {float} t - The T value (between 0 and 1)\r\n * @param {number} value - [description]\r\n *\r\n * @return {number} [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class EmitterOp\r\n * @memberOf Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - [description]\r\n * @param {string} key - [description]\r\n * @param {number} defaultValue - [description]\r\n * @param {boolean} [emitOnly=false] - [description]\r\n */var EmitterOp=new Class({initialize:function EmitterOp(config,key,defaultValue,emitOnly){if(emitOnly===undefined){emitOnly=false;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#propertyKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */this.propertyKey=key;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#propertyValue\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.propertyValue=defaultValue;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#defaultValue\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.defaultValue=defaultValue;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#steps\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.steps=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#counter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.counter=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#start\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.start=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#end\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.end=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#ease\r\n         * @type {?function}\r\n         * @since 3.0.0\r\n         */this.ease;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#emitOnly\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.emitOnly=emitOnly;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#onEmit\r\n         * @type {EmitterOpOnEmitCallback}\r\n         * @since 3.0.0\r\n         */this.onEmit=this.defaultEmit;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#onUpdate\r\n         * @type {EmitterOpOnUpdateCallback}\r\n         * @since 3.0.0\r\n         */this.onUpdate=this.defaultUpdate;this.loadConfig(config);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#loadConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [config] - [description]\r\n     * @param {string} [newKey] - [description]\r\n     */loadConfig:function loadConfig(config,newKey){if(config===undefined){config={};}if(newKey){this.propertyKey=newKey;}this.propertyValue=GetFastValue(config,this.propertyKey,this.defaultValue);this.setMethods();if(this.emitOnly){//  Reset it back again\nthis.onUpdate=this.defaultUpdate;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */toJSON:function toJSON(){return JSON.stringify(this.propertyValue);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#onChange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.EmitterOp} This Emitter Op object.\r\n     */onChange:function onChange(value){this.propertyValue=value;return this.setMethods();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#setMethods\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.EmitterOp} This Emitter Op object.\r\n     */setMethods:function setMethods(){var value=this.propertyValue;var t=typeof value==='undefined'?'undefined':_typeof(value);if(t==='number'){//  Explicit static value:\n//  x: 400\nthis.onEmit=this.staticValueEmit;this.onUpdate=this.staticValueUpdate;}else if(Array.isArray(value)){//  Picks a random element from the array:\n//  x: [ 100, 200, 300, 400 ]\nthis.onEmit=this.randomStaticValueEmit;}else if(t==='function'){//  The same as setting just the onUpdate function and no onEmit (unless this op is an emitOnly one)\n//  Custom callback, must return a value:\n/*\r\n            x: function (particle, key, t, value)\r\n               {\r\n                   return value + 50;\r\n               }\r\n            */if(this.emitOnly){this.onEmit=value;}else{this.onUpdate=value;}}else if(t==='object'&&(this.has(value,'random')||this.hasBoth(value,'start','end')||this.hasBoth(value,'min','max'))){this.start=this.has(value,'start')?value.start:value.min;this.end=this.has(value,'end')?value.end:value.max;var isRandom=this.hasBoth(value,'min','max')||this.has(value,'random');//  A random starting value (using 'min | max' instead of 'start | end' automatically implies a random value)\n//  x: { start: 100, end: 400, random: true } OR { min: 100, max: 400 } OR { random: [ 100, 400 ] }\nif(isRandom){var rnd=value.random;//  x: { random: [ 100, 400 ] } = the same as doing: x: { start: 100, end: 400, random: true }\nif(Array.isArray(rnd)){this.start=rnd[0];this.end=rnd[1];}this.onEmit=this.randomRangedValueEmit;}if(this.has(value,'steps')){//  A stepped (per emit) range\n//  x: { start: 100, end: 400, steps: 64 }\n//  Increments a value stored in the emitter\nthis.steps=value.steps;this.counter=this.start;this.onEmit=this.steppedEmit;}else{//  An eased range (defaults to Linear if not specified)\n//  x: { start: 100, end: 400, [ ease: 'Linear' ] }\nvar easeType=this.has(value,'ease')?value.ease:'Linear';this.ease=GetEaseFunction(easeType);if(!isRandom){this.onEmit=this.easedValueEmit;}this.onUpdate=this.easeValueUpdate;}}else if(t==='object'&&this.hasEither(value,'onEmit','onUpdate')){//  Custom onEmit and onUpdate callbacks\n/*\r\n            x: {\r\n                //  Called at the start of the particles life, when it is being created\r\n                onEmit: function (particle, key, t, value)\r\n                {\r\n                    return value;\r\n                },\r\n\r\n                //  Called during the particles life on each update\r\n                onUpdate: function (particle, key, t, value)\r\n                {\r\n                    return value;\r\n                }\r\n            }\r\n            */if(this.has(value,'onEmit')){this.onEmit=value.onEmit;}if(this.has(value,'onUpdate')){this.onUpdate=value.onUpdate;}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - [description]\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */has:function has(object,key){return object.hasOwnProperty(key);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#hasBoth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - [description]\r\n     * @param {string} key1 - [description]\r\n     * @param {string} key2 - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hasBoth:function hasBoth(object,key1,key2){return object.hasOwnProperty(key1)&&object.hasOwnProperty(key2);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#hasEither\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - [description]\r\n     * @param {string} key1 - [description]\r\n     * @param {string} key2 - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */hasEither:function hasEither(object,key1,key2){return object.hasOwnProperty(key1)||object.hasOwnProperty(key2);},/**\r\n     * The returned value sets what the property will be at the START of the particles life, on emit.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#defaultEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n     * @param {string} key - [description]\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */defaultEmit:function defaultEmit(particle,key,value){return value;},/**\r\n     * The returned value updates the property for the duration of the particles life.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#defaultUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n     * @param {string} key - [description]\r\n     * @param {float} t - The T value (between 0 and 1)\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */defaultUpdate:function defaultUpdate(particle,key,t,value){return value;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */staticValueEmit:function staticValueEmit(){return this.propertyValue;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */staticValueUpdate:function staticValueUpdate(){return this.propertyValue;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#randomStaticValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */randomStaticValueEmit:function randomStaticValueEmit(){var randomIndex=Math.floor(Math.random()*this.propertyValue.length);return this.propertyValue[randomIndex];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#randomRangedValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */randomRangedValueEmit:function randomRangedValueEmit(particle,key){var value=FloatBetween(this.start,this.end);if(particle&&particle.data[key]){particle.data[key].min=value;}return value;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#steppedEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */steppedEmit:function steppedEmit(){var current=this.counter;var next=this.counter+(this.end-this.start)/this.steps;this.counter=Wrap(next,this.start,this.end);return current;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#easedValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n     * @param {string} key - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */easedValueEmit:function easedValueEmit(particle,key){if(particle&&particle.data[key]){var data=particle.data[key];data.min=this.start;data.max=this.end;}return this.start;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - [description]\r\n     * @param {string} key - [description]\r\n     * @param {float} t - The T value (between 0 and 1)\r\n     *\r\n     * @return {number} [description]\r\n     */easeValueUpdate:function easeValueUpdate(particle,key,t){var data=particle.data[key];return(data.max-data.min)*this.ease(t)+data.min;}});module.exports=EmitterOp;/***/},/* 752 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.GameObjects.Particles\r\n */module.exports={GravityWell:__webpack_require__(271),Particle:__webpack_require__(270),ParticleEmitter:__webpack_require__(269),ParticleEmitterManager:__webpack_require__(135),Zones:{DeathZone:__webpack_require__(268),EdgeZone:__webpack_require__(267),RandomZone:__webpack_require__(252)}};/***/},/* 753 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Image#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Image} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var ImageCanvasRenderer=function ImageCanvasRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}renderer.drawImage(src,camera,parentMatrix);};module.exports=ImageCanvasRenderer;/***/},/* 754 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Image#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Image} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var ImageWebGLRenderer=function ImageWebGLRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}this.pipeline.batchSprite(src,camera,parentMatrix);};module.exports=ImageWebGLRenderer;/***/},/* 755 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(754);}if(true){renderCanvas=__webpack_require__(753);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 756 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Graphics} graphics - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var GraphicsWebGLRenderer=function GraphicsWebGLRenderer(renderer,graphics,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==graphics.renderFlags||graphics.cameraFilter>0&&graphics.cameraFilter&camera._id){return;}this.pipeline.batchGraphics(this,camera,parentMatrix);};module.exports=GraphicsWebGLRenderer;/***/},/* 757 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(756);//  Needed for Graphics.generateTexture\nrenderCanvas=__webpack_require__(272);}if(true){renderCanvas=__webpack_require__(272);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 758 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Offsets the Ellipse by the values given in the `x` and `y` properties of the Point object.\r\n *\r\n * @function Phaser.Geom.Ellipse.OffsetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Ellipse} O - [ellipse,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to be offset (translated.)\r\n * @param {(Phaser.Geom.Point|object)} point - The Point object containing the values to offset the Ellipse by.\r\n *\r\n * @return {Phaser.Geom.Ellipse} The Ellipse that was offset.\r\n */var OffsetPoint=function OffsetPoint(ellipse,point){ellipse.x+=point.x;ellipse.y+=point.y;return ellipse;};module.exports=OffsetPoint;/***/},/* 759 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Offsets the Ellipse by the values given.\r\n *\r\n * @function Phaser.Geom.Ellipse.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Ellipse} O - [ellipse,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to be offset (translated.)\r\n * @param {number} x - The amount to horizontally offset the Ellipse by.\r\n * @param {number} y - The amount to vertically offset the Ellipse by.\r\n *\r\n * @return {Phaser.Geom.Ellipse} The Ellipse that was offset.\r\n */var Offset=function Offset(ellipse,x,y){ellipse.x+=x;ellipse.y+=y;return ellipse;};module.exports=Offset;/***/},/* 760 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);/**\r\n * Returns the bounds of the Ellipse object.\r\n *\r\n * @function Phaser.Geom.Ellipse.GetBounds\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the bounds from.\r\n * @param {(Phaser.Geom.Rectangle|object)} [out] - A Rectangle, or rectangle-like object, to store the ellipse bounds in. If not given a new Rectangle will be created.\r\n *\r\n * @return {(Phaser.Geom.Rectangle|object)} The Rectangle object containing the Ellipse bounds.\r\n */var GetBounds=function GetBounds(ellipse,out){if(out===undefined){out=new Rectangle();}out.x=ellipse.left;out.y=ellipse.top;out.width=ellipse.width;out.height=ellipse.height;return out;};module.exports=GetBounds;/***/},/* 761 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Compares the `x`, `y`, `width` and `height` properties of the two given Ellipses.\r\n * Returns `true` if they all match, otherwise returns `false`.\r\n *\r\n * @function Phaser.Geom.Ellipse.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The first Ellipse to compare.\r\n * @param {Phaser.Geom.Ellipse} toCompare - The second Ellipse to compare.\r\n *\r\n * @return {boolean} `true` if the two Ellipse equal each other, otherwise `false`.\r\n */var Equals=function Equals(ellipse,toCompare){return ellipse.x===toCompare.x&&ellipse.y===toCompare.y&&ellipse.width===toCompare.width&&ellipse.height===toCompare.height;};module.exports=Equals;/***/},/* 762 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Copies the `x`, `y`, `width` and `height` properties from the `source` Ellipse\r\n * into the given `dest` Ellipse, then returns the `dest` Ellipse.\r\n *\r\n * @function Phaser.Geom.Ellipse.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Ellipse} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} source - The source Ellipse to copy the values from.\r\n * @param {Phaser.Geom.Ellipse} dest - The destination Ellipse to copy the values to.\r\n *\r\n * @return {Phaser.Geom.Ellipse} The dest Ellipse.\r\n */var CopyFrom=function CopyFrom(source,dest){return dest.setTo(source.x,source.y,source.width,source.height);};module.exports=CopyFrom;/***/},/* 763 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Contains=__webpack_require__(75);/**\r\n * Check to see if the Ellipse contains all four points of the given Rectangle object.\r\n *\r\n * @function Phaser.Geom.Ellipse.ContainsRect\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - [description]\r\n * @param {(Phaser.Geom.Rectangle|object)} rect - The Rectangle object to check if it's within the Ellipse or not.\r\n *\r\n * @return {boolean} True if all of the Rectangle coordinates are within the ellipse, otherwise false.\r\n */var ContainsRect=function ContainsRect(ellipse,rect){return Contains(ellipse,rect.x,rect.y)&&Contains(ellipse,rect.right,rect.y)&&Contains(ellipse,rect.x,rect.bottom)&&Contains(ellipse,rect.right,rect.bottom);};module.exports=ContainsRect;/***/},/* 764 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Contains=__webpack_require__(75);/**\r\n * Check to see if the Ellipse contains the given Point object.\r\n *\r\n * @function Phaser.Geom.Ellipse.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to check.\r\n * @param {(Phaser.Geom.Point|object)} point - The Point object to check if it's within the Circle or not.\r\n *\r\n * @return {boolean} True if the Point coordinates are within the circle, otherwise false.\r\n */var ContainsPoint=function ContainsPoint(ellipse,point){return Contains(ellipse,point.x,point.y);};module.exports=ContainsPoint;/***/},/* 765 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Ellipse=__webpack_require__(137);/**\r\n * Creates a new Ellipse instance based on the values contained in the given source.\r\n *\r\n * @function Phaser.Geom.Ellipse.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} source - The Ellipse to be cloned. Can be an instance of an Ellipse or a ellipse-like object, with x, y, width and height properties.\r\n *\r\n * @return {Phaser.Geom.Ellipse} A clone of the source Ellipse.\r\n */var Clone=function Clone(source){return new Ellipse(source.x,source.y,source.width,source.height);};module.exports=Clone;/***/},/* 766 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Calculates the area of the Ellipse.\r\n *\r\n * @function Phaser.Geom.Ellipse.Area\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the area of.\r\n *\r\n * @return {number} The area of the Ellipse.\r\n */var Area=function Area(ellipse){if(ellipse.isEmpty()){return 0;}//  units squared\nreturn ellipse.getMajorRadius()*ellipse.getMinorRadius()*Math.PI;};module.exports=Area;/***/},/* 767 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var DynamicBitmapTextCanvasRenderer=function DynamicBitmapTextCanvasRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){var text=src.text;var textLength=text.length;if(GameObject.RENDER_MASK!==src.renderFlags||textLength===0||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}var textureFrame=src.frame;var displayCallback=src.displayCallback;var cameraScrollX=camera.scrollX*src.scrollFactorX;var cameraScrollY=camera.scrollY*src.scrollFactorY;var chars=src.fontData.chars;var lineHeight=src.fontData.lineHeight;var xAdvance=0;var yAdvance=0;var indexCount=0;var charCode=0;var glyph=null;var glyphX=0;var glyphY=0;var glyphW=0;var glyphH=0;var x=0;var y=0;var lastGlyph=null;var lastCharCode=0;var ctx=renderer.currentContext;var image=src.frame.source.image;var textureX=textureFrame.cutX;var textureY=textureFrame.cutY;var rotation=0;var scale=src.fontSize/src.fontData.size;//  Blend Mode\nif(renderer.currentBlendMode!==src.blendMode){renderer.currentBlendMode=src.blendMode;ctx.globalCompositeOperation=renderer.blendModes[src.blendMode];}//  Alpha\nif(renderer.currentAlpha!==src.alpha){renderer.currentAlpha=src.alpha;ctx.globalAlpha=src.alpha;}//  Smoothing\nif(renderer.currentScaleMode!==src.scaleMode){renderer.currentScaleMode=src.scaleMode;}ctx.save();if(parentMatrix!==undefined){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}ctx.translate(src.x,src.y);ctx.rotate(src.rotation);ctx.translate(-src.displayOriginX,-src.displayOriginY);ctx.scale(src.scaleX,src.scaleY);if(src.cropWidth>0&&src.cropHeight>0){ctx.save();ctx.beginPath();ctx.rect(0,0,src.cropWidth,src.cropHeight);ctx.clip();}var roundPixels=renderer.config.roundPixels;for(var index=0;index<textLength;++index){//  Reset the scale (in case the callback changed it)\nscale=src.fontSize/src.fontData.size;rotation=0;charCode=text.charCodeAt(index);if(charCode===10){xAdvance=0;indexCount=0;yAdvance+=lineHeight;lastGlyph=null;continue;}glyph=chars[charCode];if(!glyph){continue;}glyphX=textureX+glyph.x;glyphY=textureY+glyph.y;glyphW=glyph.width;glyphH=glyph.height;x=indexCount+glyph.xOffset+xAdvance-src.scrollX;y=glyph.yOffset+yAdvance-src.scrollY;//  This could be optimized so that it doesn't even bother drawing it if the x/y is out of range\nif(lastGlyph!==null){var kerningOffset=glyph.kerning[lastCharCode];x+=kerningOffset!==undefined?kerningOffset:0;}if(displayCallback){var output=displayCallback({tint:{topLeft:0,topRight:0,bottomLeft:0,bottomRight:0},index:index,charCode:charCode,x:x,y:y,scale:scale,rotation:0,data:glyph.data});x=output.x;y=output.y;scale=output.scale;rotation=output.rotation;}x*=scale;y*=scale;x-=cameraScrollX;y-=cameraScrollY;if(roundPixels){x|=0;y|=0;}ctx.save();ctx.translate(x,y);ctx.rotate(rotation);ctx.scale(scale,scale);ctx.drawImage(image,glyphX,glyphY,glyphW,glyphH,0,0,glyphW,glyphH);ctx.restore();xAdvance+=glyph.xAdvance;indexCount+=1;lastGlyph=glyph;lastCharCode=charCode;}if(src.cropWidth>0&&src.cropHeight>0){ctx.restore();}ctx.restore();};module.exports=DynamicBitmapTextCanvasRenderer;/***/},/* 768 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} gameObject - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var DynamicBitmapTextWebGLRenderer=function DynamicBitmapTextWebGLRenderer(renderer,bitmapText,interpolationPercentage,camera,parentMatrix){var text=bitmapText.text;var textLength=text.length;if(GameObject.RENDER_MASK!==bitmapText.renderFlags||textLength===0||bitmapText.cameraFilter>0&&bitmapText.cameraFilter&camera._id){return;}this.pipeline.batchDynamicBitmapText(bitmapText,camera,parentMatrix);};module.exports=DynamicBitmapTextWebGLRenderer;/***/},/* 769 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(768);}if(true){renderCanvas=__webpack_require__(767);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 770 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Container#renderCanvas\r\n * @since 3.4.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Container} container - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var ContainerCanvasRenderer=function ContainerCanvasRenderer(renderer,container,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==container.renderFlags||container.cameraFilter>0&&container.cameraFilter&camera._id){return;}var children=container.list;var transformMatrix=container.localTransform;if(parentMatrix===undefined){transformMatrix.applyITRS(container.x,container.y,container.rotation,container.scaleX,container.scaleY);}else{transformMatrix.loadIdentity();transformMatrix.multiply(parentMatrix);transformMatrix.translate(container.x,container.y);transformMatrix.rotate(container.rotation);transformMatrix.scale(container.scaleX,container.scaleY);}var alpha=container._alpha;var scrollFactorX=container.scrollFactorX;var scrollFactorY=container.scrollFactorY;for(var index=0;index<children.length;++index){var child=children[index];var childAlpha=child._alpha;var childScrollFactorX=child.scrollFactorX;var childScrollFactorY=child.scrollFactorY;child.setScrollFactor(childScrollFactorX*scrollFactorX,childScrollFactorY*scrollFactorY);child.setAlpha(childAlpha*alpha);child.renderCanvas(renderer,child,interpolationPercentage,camera,transformMatrix);child.setAlpha(childAlpha);child.setScrollFactor(childScrollFactorX,childScrollFactorY);}};module.exports=ContainerCanvasRenderer;/***/},/* 771 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Container#renderWebGL\r\n * @since 3.4.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Container} container - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var ContainerWebGLRenderer=function ContainerWebGLRenderer(renderer,container,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==container.renderFlags||container.cameraFilter>0&&container.cameraFilter&camera._id){return;}var children=container.list;var transformMatrix=container.localTransform;if(parentMatrix===undefined){transformMatrix.applyITRS(container.x,container.y,container.rotation,container.scaleX,container.scaleY);}else{transformMatrix.loadIdentity();transformMatrix.multiply(parentMatrix);transformMatrix.translate(container.x,container.y);transformMatrix.rotate(container.rotation);transformMatrix.scale(container.scaleX,container.scaleY);}var alpha=container._alpha;var scrollFactorX=container.scrollFactorX;var scrollFactorY=container.scrollFactorY;for(var index=0;index<children.length;++index){var child=children[index];var childAlpha=child._alpha;var childScrollFactorX=child.scrollFactorX;var childScrollFactorY=child.scrollFactorY;child.setScrollFactor(childScrollFactorX*scrollFactorX,childScrollFactorY*scrollFactorY);child.setAlpha(childAlpha*alpha);child.renderWebGL(renderer,child,interpolationPercentage,camera,transformMatrix);child.setAlpha(childAlpha);child.setScrollFactor(childScrollFactorX,childScrollFactorY);}};module.exports=ContainerWebGLRenderer;/***/},/* 772 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(771);}if(true){renderCanvas=__webpack_require__(770);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 773 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * A Bob Game Object.\r\n *\r\n * A Bob belongs to a Blitter Game Object. The Blitter is responsible for managing and rendering this object.\r\n *\r\n * A Bob has a position, alpha value and a frame from a texture that it uses to render with. You can also toggle\r\n * the flipped and visible state of the Bob. The Frame the Bob uses to render can be changed dynamically, but it\r\n * must be a Frame within the Texture used by the parent Blitter.\r\n *\r\n * Bob positions are relative to the Blitter parent. So if you move the Blitter parent, all Bob children will\r\n * have their positions impacted by this change as well.\r\n *\r\n * You can manipulate Bob objects directly from your game code, but the creation and destruction of them should be\r\n * handled via the Blitter parent.\r\n *\r\n * @class Bob\r\n * @memberOf Phaser.GameObjects.Blitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Blitter} blitter - The parent Blitter object is responsible for updating this Bob.\r\n * @param {number} x - The horizontal position of this Game Object in the world, relative to the parent Blitter position.\r\n * @param {number} y - The vertical position of this Game Object in the world, relative to the parent Blitter position.\r\n * @param {(string|integer)} frame - The Frame this Bob will render with, as defined in the Texture the parent Blitter is using.\r\n * @param {boolean} visible - Should the Bob render visible or not to start with?\r\n */var Bob=new Class({initialize:function Bob(blitter,x,y,frame,visible){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#parent\r\n         * @type {Phaser.GameObjects.Blitter}\r\n         * @since 3.0.0\r\n         */this.parent=blitter;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.x=x;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.y=y;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#frame\r\n         * @type {(string|integer)}\r\n         * @since 3.0.0\r\n         */this.frame=frame;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#data\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */this.data={};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#_visible\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._visible=visible;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#_alpha\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this._alpha=1;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#flipX\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.flipX=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.Blitter.Bob#flipY\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.flipY=false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} [frame] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} This Bob Game Object.\r\n     */setFrame:function setFrame(frame){if(frame===undefined){frame=this.parent.frame;}else{frame=this.parent.texture.get(frame);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#resetFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} This Bob Game Object.\r\n     */resetFlip:function resetFlip(){this.flipX=false;this.flipY=false;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {Phaser.Textures.Frame} frame - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} This Bob Game Object.\r\n     */reset:function reset(x,y,frame){this.x=x;this.y=y;this.frame=frame;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#setFlipX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} This Bob Game Object.\r\n     */setFlipX:function setFlipX(value){this.flipX=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#setFlipY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} This Bob Game Object.\r\n     */setFlipY:function setFlipY(value){this.flipY=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#setFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} This Bob Game Object.\r\n     */setFlip:function setFlip(x,y){this.flipX=x;this.flipY=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} This Bob Game Object.\r\n     */setVisible:function setVisible(value){this.visible=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Blitter.Bob} This Bob Game Object.\r\n     */setAlpha:function setAlpha(value){this.alpha=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.Blitter.Bob#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.parent.dirty=true;this.parent.children.remove(this);this.parent=undefined;this.frame=undefined;this.data=undefined;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Blitter.Bob#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */visible:{get:function get(){return this._visible;},set:function set(value){this._visible=value;this.parent.dirty=true;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.GameObjects.Blitter.Bob#alpha\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */alpha:{get:function get(){return this._alpha;},set:function set(value){this._alpha=value;this.parent.dirty=true;}}});module.exports=Bob;/***/},/* 774 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Blitter#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Blitter} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var BlitterCanvasRenderer=function BlitterCanvasRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}var list=src.getRenderList();renderer.setBlendMode(src.blendMode);var ctx=renderer.gameContext;var cameraScrollX=src.x-camera.scrollX*src.scrollFactorX;var cameraScrollY=src.y-camera.scrollY*src.scrollFactorY;ctx.save();if(parentMatrix!==undefined){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}//  Render bobs\nfor(var i=0;i<list.length;i++){var bob=list[i];var flip=bob.flipX||bob.flipY;var frame=bob.frame;var cd=frame.canvasData;var dx=frame.x;var dy=frame.y;var fx=1;var fy=1;if(!flip){renderer.blitImage(dx+bob.x+cameraScrollX,dy+bob.y+cameraScrollY,bob.frame);}else{if(bob.flipX){fx=-1;dx-=cd.dWidth;}if(bob.flipY){fy=-1;dy-=cd.dHeight;}ctx.save();ctx.translate(bob.x+cameraScrollX,bob.y+cameraScrollY);ctx.scale(fx,fy);ctx.drawImage(frame.source.image,cd.sx,cd.sy,cd.sWidth,cd.sHeight,dx,dy,cd.dWidth,cd.dHeight);ctx.restore();}}ctx.restore();};module.exports=BlitterCanvasRenderer;/***/},/* 775 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Blitter#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Blitter} gameObject - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var BlitterWebGLRenderer=function BlitterWebGLRenderer(renderer,gameObject,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==gameObject.renderFlags||gameObject.cameraFilter>0&&gameObject.cameraFilter&camera._id){return;}this.pipeline.drawBlitter(gameObject,camera,parentMatrix);};module.exports=BlitterWebGLRenderer;/***/},/* 776 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(775);}if(true){renderCanvas=__webpack_require__(774);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 777 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var BitmapTextCanvasRenderer=function BitmapTextCanvasRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){var text=src.text;var textLength=text.length;if(GameObject.RENDER_MASK!==src.renderFlags||textLength===0||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}var textureFrame=src.frame;var chars=src.fontData.chars;var lineHeight=src.fontData.lineHeight;var letterSpacing=src.letterSpacing;var xAdvance=0;var yAdvance=0;var indexCount=0;var charCode=0;var glyph=null;var glyphX=0;var glyphY=0;var glyphW=0;var glyphH=0;var x=0;var y=0;var lastGlyph=null;var lastCharCode=0;var ctx=renderer.currentContext;var image=src.frame.source.image;var textureX=textureFrame.cutX;var textureY=textureFrame.cutY;var scale=src.fontSize/src.fontData.size;//  Blend Mode\nif(renderer.currentBlendMode!==src.blendMode){renderer.currentBlendMode=src.blendMode;ctx.globalCompositeOperation=renderer.blendModes[src.blendMode];}//  Alpha\nif(renderer.currentAlpha!==src.alpha){renderer.currentAlpha=src.alpha;ctx.globalAlpha=src.alpha;}//  Smoothing\nif(renderer.currentScaleMode!==src.scaleMode){renderer.currentScaleMode=src.scaleMode;}var roundPixels=renderer.config.roundPixels;var tx=src.x-camera.scrollX*src.scrollFactorX+src.frame.x;var ty=src.y-camera.scrollY*src.scrollFactorY+src.frame.y;if(roundPixels){tx|=0;ty|=0;}ctx.save();if(parentMatrix!==undefined){var matrix=parentMatrix.matrix;ctx.transform(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);}ctx.translate(tx,ty);ctx.rotate(src.rotation);ctx.translate(-src.displayOriginX,-src.displayOriginY);ctx.scale(src.scaleX,src.scaleY);for(var index=0;index<textLength;++index){charCode=text.charCodeAt(index);if(charCode===10){xAdvance=0;indexCount=0;yAdvance+=lineHeight;lastGlyph=null;continue;}glyph=chars[charCode];if(!glyph){continue;}glyphX=textureX+glyph.x;glyphY=textureY+glyph.y;glyphW=glyph.width;glyphH=glyph.height;x=indexCount+glyph.xOffset+xAdvance;y=glyph.yOffset+yAdvance;if(lastGlyph!==null){var kerningOffset=glyph.kerning[lastCharCode];x+=kerningOffset!==undefined?kerningOffset:0;}x*=scale;y*=scale;xAdvance+=glyph.xAdvance+letterSpacing;indexCount+=1;lastGlyph=glyph;lastCharCode=charCode;//  Nothing to render or a space? Then skip to the next glyph\nif(glyphW===0||glyphH===0||charCode===32){continue;}if(roundPixels){x|=0;y|=0;}ctx.save();ctx.translate(x,y);ctx.scale(scale,scale);ctx.drawImage(image,glyphX,glyphY,glyphW,glyphH,0,0,glyphW,glyphH);ctx.restore();}ctx.restore();};module.exports=BitmapTextCanvasRenderer;/***/},/* 778 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.BitmapText} gameObject - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var BitmapTextWebGLRenderer=function BitmapTextWebGLRenderer(renderer,gameObject,interpolationPercentage,camera,parentMatrix){var text=gameObject.text;var textLength=text.length;if(GameObject.RENDER_MASK!==gameObject.renderFlags||textLength===0||gameObject.cameraFilter>0&&gameObject.cameraFilter&camera._id){return;}this.pipeline.batchBitmapText(this,camera,parentMatrix);};module.exports=BitmapTextWebGLRenderer;/***/},/* 779 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(778);}if(true){renderCanvas=__webpack_require__(777);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 780 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetValue=__webpack_require__(5);// * @param {number} characterWidth - The width of each character in the font set.\n// * @param {number} characterHeight - The height of each character in the font set.\n// * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.\n// * @param {number} [charsPerRow] - The number of characters per row in the font set. If not given charsPerRow will be the image width / characterWidth.\n// * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.\n// * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.\n// * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.\n// * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.\n// Phaser.GameObject.RetroFont = function (game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset)\n// {\n//      image: key,\n//      width: 32,\n//      height: 32,\n//      chars: 'string',\n//      charsPerRow: null,\n//      spacing: { x: 0, y: 0 },\n//      offset: { x: 0, y: 0 }\n// }\n/**\r\n * [description]\r\n *\r\n * @function ParseRetroFont\r\n * @since 3.0.0\r\n * @private\r\n */var ParseRetroFont=function ParseRetroFont(scene,config){var w=config.width;var h=config.height;var cx=Math.floor(w/2);var cy=Math.floor(h/2);var letters=config.chars;var key=GetValue(config,'image','');var offsetX=GetValue(config,'offset.x',0);var offsetY=GetValue(config,'offset.y',0);var spacingX=GetValue(config,'spacing.x',0);var spacingY=GetValue(config,'spacing.y',0);var charsPerRow=GetValue(config,'charsPerRow',null);if(charsPerRow===null){charsPerRow=scene.sys.textures.getFrame(key).width/w;if(charsPerRow>letters.length){charsPerRow=letters.length;}}var x=offsetX;var y=offsetY;var data={retroFont:true,font:key,size:w,lineHeight:h,chars:{}};var r=0;for(var i=0;i<letters.length;i++){// var node = letters[i];\nvar charCode=letters.charCodeAt(i);data.chars[charCode]={x:x,y:y,width:w,height:h,centerX:cx,centerY:cy,xOffset:0,yOffset:0,xAdvance:w,data:{},kerning:{}};r++;if(r===charsPerRow){r=0;x=offsetX;y+=h+spacingY;}else{x+=w+spacingX;}}var entry={data:data,frame:null,texture:key};return entry;};/**\r\n* Text Set 1 =  !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET1=' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';/**\r\n* Text Set 2 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET2=' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ';/**\r\n* Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET3='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ';/**\r\n* Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET4='ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789';/**\r\n* Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET5='ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() \\'!?-*:0123456789';/**\r\n* Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' \r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET6='ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.\\' ';/**\r\n* Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET7='AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-\\'39';/**\r\n* Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET8='0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ';/**\r\n* Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET9='ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,\\'\"?!';/**\r\n* Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET10='ABCDEFGHIJKLMNOPQRSTUVWXYZ';/**\r\n* Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789\r\n* @constant\r\n* @type {string}\r\n*/ParseRetroFont.TEXT_SET11='ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()\\':;0123456789';module.exports=ParseRetroFont;/***/},/* 781 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ParseXMLBitmapFont=__webpack_require__(278);/**\r\n * [description]\r\n *\r\n * @function ParseFromAtlas\r\n * @since 3.0.0\r\n * @private\r\n */var ParseFromAtlas=function ParseFromAtlas(scene,fontName,textureKey,frameKey,xmlKey,xSpacing,ySpacing){var frame=scene.sys.textures.getFrame(textureKey,frameKey);var xml=scene.sys.cache.xml.get(xmlKey);if(frame&&xml){var data=ParseXMLBitmapFont(xml,xSpacing,ySpacing,frame);scene.sys.cache.bitmapFont.add(fontName,{data:data,texture:textureKey,frame:frameKey});return true;}else{return false;}};module.exports=ParseFromAtlas;/***/},/* 782 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var PluginManager=__webpack_require__(13);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class UpdateList\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var UpdateList=new Class({initialize:function UpdateList(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_list\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._list=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_pendingInsertion\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._pendingInsertion=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_pendingRemoval\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this._pendingRemoval=[];},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('preupdate',this.preUpdate,this);eventEmitter.on('update',this.update,this);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */add:function add(child){//  Is child already in this list?\nif(this._list.indexOf(child)===-1&&this._pendingInsertion.indexOf(child)===-1){this._pendingInsertion.push(child);}return child;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */preUpdate:function preUpdate(){var toRemove=this._pendingRemoval.length;var toInsert=this._pendingInsertion.length;if(toRemove===0&&toInsert===0){//  Quick bail\nreturn;}var i;var gameObject;//  Delete old gameObjects\nfor(i=0;i<toRemove;i++){gameObject=this._pendingRemoval[i];var index=this._list.indexOf(gameObject);if(index>-1){this._list.splice(index,1);}}//  Move pending to active\nthis._list=this._list.concat(this._pendingInsertion.splice(0));//  Clear the lists\nthis._pendingRemoval.length=0;this._pendingInsertion.length=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(time,delta){for(var i=0;i<this._list.length;i++){var gameObject=this._list[i];if(gameObject.active){gameObject.preUpdate.call(gameObject,time,delta);}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} [description]\r\n     */remove:function remove(child){var index=this._list.indexOf(child);if(index!==-1){this._list.splice(index,1);}return child;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#removeAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.UpdateList} The UpdateList object.\r\n     */removeAll:function removeAll(){var i=this._list.length;while(i--){this.remove(this._list[i]);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.removeAll();this._list.length=0;this._pendingRemoval.length=0;this._pendingInsertion.length=0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.shutdown();this.scene=undefined;this.systems=undefined;}});PluginManager.register('UpdateList',UpdateList,'updateList');module.exports=UpdateList;/***/},/* 783 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Swaps the position of two elements in the given array.\r\n * The elements must exist in the same array.\r\n * The array is modified in-place.\r\n *\r\n * @function Phaser.Utils.Array.Swap\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The input array.\r\n * @param {*} item1 - The first element to swap.\r\n * @param {*} item2 - The second element to swap.\r\n *\r\n * @return {array} The input array.\r\n */var Swap=function Swap(array,item1,item2){if(item1===item2){return;}var index1=array.indexOf(item1);var index2=array.indexOf(item2);if(index1<0||index2<0){throw new Error('Supplied items must be elements of the same array');}array[index1]=item2;array[index2]=item1;return array;};module.exports=Swap;/***/},/* 784 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SafeRange=__webpack_require__(48);/**\r\n * Scans the array for elements with the given property. If found, the property is set to the `value`.\r\n *\r\n * For example: `SetAll('visible', true)` would set all elements that have a `visible` property to `false`.\r\n *\r\n * Optionally you can specify a start and end index. For example if the array had 100 elements,\r\n * and you set `startIndex` to 0 and `endIndex` to 50, it would update only the first 50 elements.\r\n *\r\n * @function Phaser.Utils.Array.SetAll\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to search.\r\n * @param {string} property - The property to test for on each array element.\r\n * @param {*} value - The value to set the property to.\r\n * @param {integer} [startIndex] - An optional start index to search from.\r\n * @param {integer} [endIndex] - An optional end index to search to.\r\n *\r\n * @return {array} The input array.\r\n */var SetAll=function SetAll(array,property,value,startIndex,endIndex){if(startIndex===undefined){startIndex=0;}if(endIndex===undefined){endIndex=array.length;}if(SafeRange(array,startIndex,endIndex)){for(var i=startIndex;i<endIndex;i++){var entry=array[i];if(entry.hasOwnProperty(property)){entry[property]=value;}}}return array;};module.exports=SetAll;/***/},/* 785 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Moves the given element to the bottom of the array.\r\n * The array is modified in-place.\r\n *\r\n * @function Phaser.Utils.Array.SendToBack\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array.\r\n * @param {*} item - The element to move.\r\n *\r\n * @return {*} The element that was moved.\r\n */var SendToBack=function SendToBack(array,item){var currentIndex=array.indexOf(item);if(currentIndex!==-1&&currentIndex>0){array.splice(currentIndex,1);array.unshift(item);}return item;};module.exports=SendToBack;/***/},/* 786 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Replaces an element of the array with the new element.\r\n * The new element cannot already be a member of the array.\r\n * The array is modified in-place.\r\n *\r\n * @function Phaser.Utils.Array.Replace\r\n * @since 3.4.0\r\n *\r\n * @param {*} oldChild - The element in the array that will be replaced.\r\n * @param {*} newChild - The element to be inserted into the array at the position of `oldChild`.\r\n *\r\n * @return {boolean} Returns true if the oldChild was successfully replaced, otherwise returns false.\r\n */var Replace=function Replace(array,oldChild,newChild){var index1=array.indexOf(oldChild);var index2=array.indexOf(newChild);if(index1!==-1&&index2===-1){array[index1]=newChild;return true;}else{return false;}};module.exports=Replace;/***/},/* 787 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SpliceOne=__webpack_require__(99);/**\r\n * Removes a random object from the given array and returns it.\r\n * Will return null if there are no array items that fall within the specified range or if there is no item for the randomly chosen index.\r\n *\r\n * @function Phaser.Utils.Array.RemoveRandomElement\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to removed a random element from.\r\n * @param {integer} [start=0] - The array index to start the search from.\r\n * @param {integer} [length=array.length] - Optional restriction on the number of elements to randomly select from.\r\n *\r\n * @return {object} The random element that was removed, or `null` if there were no array elements that fell within the given range.\r\n */var RemoveRandomElement=function RemoveRandomElement(array,start,length){if(start===undefined){start=0;}if(length===undefined){length=array.length;}var randomIndex=start+Math.floor(Math.random()*length);return SpliceOne(array,randomIndex);};module.exports=RemoveRandomElement;/***/},/* 788 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SafeRange=__webpack_require__(48);/**\r\n * Removes the item within the given range in the array.\r\n * \r\n * The array is modified in-place.\r\n * \r\n * You can optionally specify a callback to be invoked for the item/s successfully removed from the array.\r\n *\r\n * @function Phaser.Utils.Array.RemoveBetween\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to be modified.\r\n * @param {integer} startIndex - The start index to remove from.\r\n * @param {integer} endIndex - The end index to remove to.\r\n * @param {function} [callback] - A callback to be invoked for the item removed from the array.\r\n * @param {object} [context] - The context in which the callback is invoked.\r\n *\r\n * @return {Array.<*>} An array of items that were removed.\r\n */var RemoveBetween=function RemoveBetween(array,startIndex,endIndex,callback,context){if(startIndex===undefined){startIndex=0;}if(endIndex===undefined){endIndex=array.length;}if(context===undefined){context=array;}if(SafeRange(array,startIndex,endIndex)){var size=endIndex-startIndex;var removed=array.splice(startIndex,size);if(callback){for(var i=0;i<removed.length;i++){var entry=removed[i];callback.call(context,entry);}}return removed;}else{return[];}};module.exports=RemoveBetween;/***/},/* 789 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SpliceOne=__webpack_require__(99);/**\r\n * Removes the item from the given position in the array.\r\n * \r\n * The array is modified in-place.\r\n * \r\n * You can optionally specify a callback to be invoked for the item if it is successfully removed from the array.\r\n *\r\n * @function Phaser.Utils.Array.RemoveAt\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to be modified.\r\n * @param {integer} index - The array index to remove the item from. The index must be in bounds or it will throw an error.\r\n * @param {function} [callback] - A callback to be invoked for the item removed from the array.\r\n * @param {object} [context] - The context in which the callback is invoked.\r\n *\r\n * @return {*} The item that was removed.\r\n */var RemoveAt=function RemoveAt(array,index,callback,context){if(context===undefined){context=array;}if(index<0||index>array.length-1){throw new Error('Index out of bounds');}var item=SpliceOne(array,index);if(callback){callback.call(context,item);}return item;};module.exports=RemoveAt;/***/},/* 790 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SpliceOne=__webpack_require__(99);/**\r\n * Removes the given item, or array of items, from the array.\r\n * \r\n * The array is modified in-place.\r\n * \r\n * You can optionally specify a callback to be invoked for each item successfully removed from the array.\r\n *\r\n * @function Phaser.Utils.Array.Remove\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to be modified.\r\n * @param {*|Array.<*>} item - The item, or array of items, to be removed from the array.\r\n * @param {function} [callback] - A callback to be invoked for each item successfully removed from the array.\r\n * @param {object} [context] - The context in which the callback is invoked.\r\n *\r\n * @return {*|Array.<*>} The item, or array of items, that were successfully removed from the array.\r\n */var Remove=function Remove(array,item,callback,context){if(context===undefined){context=array;}var index;//  Fast path to avoid array mutation and iteration\nif(!Array.isArray(item)){index=array.indexOf(item);if(index!==-1){SpliceOne(array,index);if(callback){callback.call(context,item);}return item;}else{return null;}}//  If we got this far, we have an array of items to remove\nvar itemLength=item.length-1;while(itemLength>=0){var entry=item[itemLength];index=array.indexOf(entry);if(index!==-1){SpliceOne(array,index);if(callback){callback.call(context,entry);}}else{//  Item wasn't found in the array, so remove it from our return results\nitem.pop();}itemLength--;}return item;};module.exports=Remove;/***/},/* 791 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RoundAwayFromZero=__webpack_require__(282);/**\r\n * Create an array of numbers (positive and/or negative) progressing from `start`\r\n * up to but not including `end` by advancing by `step`.\r\n *\r\n * If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.\r\n *\r\n * Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;\r\n * for forward compatibility make sure to pass in actual numbers.\r\n * \r\n * @example\r\n * NumberArrayStep(4);\r\n * // => [0, 1, 2, 3]\r\n *\r\n * NumberArrayStep(1, 5);\r\n * // => [1, 2, 3, 4]\r\n *\r\n * NumberArrayStep(0, 20, 5);\r\n * // => [0, 5, 10, 15]\r\n *\r\n * NumberArrayStep(0, -4, -1);\r\n * // => [0, -1, -2, -3]\r\n *\r\n * NumberArrayStep(1, 4, 0);\r\n * // => [1, 1, 1]\r\n *\r\n * NumberArrayStep(0);\r\n * // => []\r\n *\r\n * @function Phaser.Utils.Array.NumberArrayStep\r\n * @since 3.0.0\r\n *\r\n * @param {number} [start=0] - The start of the range.\r\n * @param {number} [end=null] - The end of the range.\r\n * @param {number} [step=1] - The value to increment or decrement by.\r\n *\r\n * @return {number[]} [description]\r\n */var NumberArrayStep=function NumberArrayStep(start,end,step){if(start===undefined){start=0;}if(end===undefined){end=null;}if(step===undefined){step=1;}if(end===null){end=start;start=0;}var result=[];var total=Math.max(RoundAwayFromZero((end-start)/(step||1)),0);for(var i=0;i<total;i++){result.push(start);start+=step;}return result;};module.exports=NumberArrayStep;/***/},/* 792 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Moves the given array element up one place in the array.\r\n * The array is modified in-place.\r\n *\r\n * @function Phaser.Utils.Array.MoveUp\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The input array.\r\n * @param {*} item - The element to move up the array.\r\n *\r\n * @return {array} The input array.\r\n */var MoveUp=function MoveUp(array,item){var currentIndex=array.indexOf(item);if(currentIndex!==-1&&currentIndex<array.length-2){var item2=array[currentIndex+1];var index2=array.indexOf(item2);array[currentIndex]=item2;array[index2]=item;}return array;};module.exports=MoveUp;/***/},/* 793 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Moves an element in an array to a new position within the same array.\r\n * The array is modified in-place.\r\n *\r\n * @function Phaser.Utils.Array.MoveTo\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array.\r\n * @param {*} item - The element to move.\r\n * @param {integer} index - The new index that the element will be moved to.\r\n *\r\n * @return {*} The element that was moved.\r\n */var MoveTo=function MoveTo(array,item,index){var currentIndex=array.indexOf(item);if(currentIndex===-1||index<0||index>=array.length){throw new Error('Supplied index out of bounds');}if(currentIndex!==index){//  Remove\narray.splice(currentIndex,1);//  Add in new location\narray.splice(index,0,item);}return item;};module.exports=MoveTo;/***/},/* 794 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Moves the given array element down one place in the array.\r\n * The array is modified in-place.\r\n *\r\n * @function Phaser.Utils.Array.MoveDown\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The input array.\r\n * @param {*} item - The element to move down the array.\r\n *\r\n * @return {array} The input array.\r\n */var MoveDown=function MoveDown(array,item){var currentIndex=array.indexOf(item);if(currentIndex>0){var item2=array[currentIndex-1];var index2=array.indexOf(item2);array[currentIndex]=item2;array[index2]=item;}return array;};module.exports=MoveDown;/***/},/* 795 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SafeRange=__webpack_require__(48);/**\r\n * Returns the first element in the array.\r\n *\r\n * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n *\r\n * For example: `getAll('visible', true)` would return the first element that had its `visible` property set.\r\n *\r\n * Optionally you can specify a start and end index. For example if the array had 100 elements,\r\n * and you set `startIndex` to 0 and `endIndex` to 50, it would search only the first 50 elements.\r\n *\r\n * @function Phaser.Utils.Array.GetFirst\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to search.\r\n * @param {string} [property] - The property to test on each array element.\r\n * @param {*} [value] - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n * @param {integer} [startIndex=0] - An optional start index to search from.\r\n * @param {integer} [endIndex=array.length] - An optional end index to search up to (but not included)\r\n *\r\n * @return {object} The first matching element from the array, or `null` if no element could be found in the range given.\r\n */var GetFirst=function GetFirst(array,property,value,startIndex,endIndex){if(startIndex===undefined){startIndex=0;}if(endIndex===undefined){endIndex=array.length;}if(SafeRange(array,startIndex,endIndex)){for(var i=startIndex;i<endIndex;i++){var child=array[i];if(!property||property&&value===undefined&&child.hasOwnProperty(property)||property&&value!==undefined&&child[property]===value){return child;}}}return null;};module.exports=GetFirst;/***/},/* 796 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SafeRange=__webpack_require__(48);/**\r\n * Returns all elements in the array.\r\n *\r\n * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n *\r\n * For example: `getAll('visible', true)` would return only elements that have their visible property set.\r\n *\r\n * Optionally you can specify a start and end index. For example if the array had 100 elements,\r\n * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n * the first 50 elements.\r\n *\r\n * @function Phaser.Utils.Array.GetAll\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to search.\r\n * @param {string} [property] - The property to test on each array element.\r\n * @param {*} [value] - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n * @param {integer} [startIndex] - An optional start index to search from.\r\n * @param {integer} [endIndex] - An optional end index to search to.\r\n *\r\n * @return {array} All matching elements from the array.\r\n */var GetAll=function GetAll(array,property,value,startIndex,endIndex){if(startIndex===undefined){startIndex=0;}if(endIndex===undefined){endIndex=array.length;}var output=[];if(SafeRange(array,startIndex,endIndex)){for(var i=startIndex;i<endIndex;i++){var child=array[i];if(!property||property&&value===undefined&&child.hasOwnProperty(property)||property&&value!==undefined&&child[property]===value){output.push(child);}}}return output;};module.exports=GetAll;/***/},/* 797 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SafeRange=__webpack_require__(48);/**\r\n * Passes each element in the array, between the start and end indexes, to the given callback.\r\n *\r\n * @function Phaser.Utils.Array.EachInRange\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to search.\r\n * @param {function} callback - A callback to be invoked for each item in the array.\r\n * @param {object} context - The context in which the callback is invoked.\r\n * @param {integer} startIndex - The start index to search from.\r\n * @param {integer} endIndex - The end index to search to.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n *\r\n * @return {array} The input array.\r\n */var EachInRange=function EachInRange(array,callback,context,startIndex,endIndex){if(startIndex===undefined){startIndex=0;}if(endIndex===undefined){endIndex=array.length;}if(SafeRange(array,startIndex,endIndex)){var i;var args=[null];for(i=5;i<arguments.length;i++){args.push(arguments[i]);}for(i=startIndex;i<endIndex;i++){args[0]=array[i];callback.apply(context,args);}}return array;};module.exports=EachInRange;/***/},/* 798 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Passes each element in the array to the given callback.\r\n *\r\n * @function Phaser.Utils.Array.Each\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to search.\r\n * @param {function} callback - A callback to be invoked for each item in the array.\r\n * @param {object} context - The context in which the callback is invoked.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n *\r\n * @return {array} The input array.\r\n */var Each=function Each(array,callback,context){var i;var args=[null];for(i=2;i<arguments.length;i++){args.push(arguments[i]);}for(i=0;i<array.length;i++){args[0]=array[i];callback.apply(context,args);}return array;};module.exports=Each;/***/},/* 799 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var SafeRange=__webpack_require__(48);/**\r\n * Returns the total number of elements in the array which have a property matching the given value.\r\n *\r\n * @function Phaser.Utils.Array.CountAllMatching\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to search.\r\n * @param {string} property - The property to test on each array element.\r\n * @param {*} value - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n * @param {integer} [startIndex] - An optional start index to search from.\r\n * @param {integer} [endIndex] - An optional end index to search to.\r\n *\r\n * @return {integer} The total number of elements with properties matching the given value.\r\n */var CountAllMatching=function CountAllMatching(array,property,value,startIndex,endIndex){if(startIndex===undefined){startIndex=0;}if(endIndex===undefined){endIndex=array.length;}var total=0;if(SafeRange(array,startIndex,endIndex)){for(var i=startIndex;i<endIndex;i++){var child=array[i];if(child[property]===value){total++;}}}return total;};module.exports=CountAllMatching;/***/},/* 800 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Moves the given element to the top of the array.\r\n * The array is modified in-place.\r\n *\r\n * @function Phaser.Utils.Array.BringToTop\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array.\r\n * @param {*} item - The element to move.\r\n *\r\n * @return {*} The element that was moved.\r\n */var BringToTop=function BringToTop(array,item){var currentIndex=array.indexOf(item);if(currentIndex!==-1&&currentIndex<array.length-2){array.splice(currentIndex,1);array.push(item);}return item;};module.exports=BringToTop;/***/},/* 801 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Adds the given item, or array of items, to the array starting at the index specified.\r\n * \r\n * Each item must be unique within the array.\r\n * \r\n * Existing elements in the array are shifted up.\r\n * \r\n * The array is modified in-place and returned.\r\n * \r\n * You can optionally specify a limit to the maximum size of the array. If the quantity of items being\r\n * added will take the array length over this limit, it will stop adding once the limit is reached.\r\n * \r\n * You can optionally specify a callback to be invoked for each item successfully added to the array.\r\n *\r\n * @function Phaser.Utils.Array.AddAt\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to be added to.\r\n * @param {any|any[]} item - The item, or array of items, to add to the array.\r\n * @param {integer} [index=0] - The index in the array where the item will be inserted.\r\n * @param {integer} [limit] - Optional limit which caps the size of the array.\r\n * @param {function} [callback] - A callback to be invoked for each item successfully added to the array.\r\n * @param {object} [context] - The context in which the callback is invoked.\r\n *\r\n * @return {array} The input array.\r\n */var AddAt=function AddAt(array,item,index,limit,callback,context){if(index===undefined){index=0;}if(context===undefined){context=array;}if(limit>0){var remaining=limit-array.length;//  There's nothing more we can do here, the array is full\nif(remaining<=0){return null;}}//  Fast path to avoid array mutation and iteration\nif(!Array.isArray(item)){if(array.indexOf(item)===-1){array.splice(index,0,item);if(callback){callback.call(context,entry);}return item;}else{return null;}}//  If we got this far, we have an array of items to insert\n//  Ensure all the items are unique\nvar itemLength=item.length-1;while(itemLength>=0){if(array.indexOf(item[itemLength])!==-1){//  Already exists in array, so remove it\nitem.pop();}itemLength--;}//  Anything left?\nitemLength=item.length;if(itemLength===0){return null;}//  Truncate to the limit\nif(limit>0&&itemLength>remaining){item.splice(remaining);itemLength=remaining;}for(var i=itemLength;i>0;i--){var entry=item[i];array.splice(index,0,entry);if(callback){callback.call(context,entry);}}return item;};module.exports=AddAt;/***/},/* 802 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Adds the given item, or array of items, to the array.\r\n * \r\n * Each item must be unique within the array.\r\n * \r\n * The array is modified in-place and returned.\r\n * \r\n * You can optionally specify a limit to the maximum size of the array. If the quantity of items being\r\n * added will take the array length over this limit, it will stop adding once the limit is reached.\r\n * \r\n * You can optionally specify a callback to be invoked for each item successfully added to the array.\r\n *\r\n * @function Phaser.Utils.Array.Add\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to be added to.\r\n * @param {any|any[]} item - The item, or array of items, to add to the array. Each item must be unique within the array.\r\n * @param {integer} [limit] - Optional limit which caps the size of the array.\r\n * @param {function} [callback] - A callback to be invoked for each item successfully added to the array.\r\n * @param {object} [context] - The context in which the callback is invoked.\r\n *\r\n * @return {array} The input array.\r\n */var Add=function Add(array,item,limit,callback,context){if(context===undefined){context=array;}if(limit>0){var remaining=limit-array.length;//  There's nothing more we can do here, the array is full\nif(remaining<=0){return null;}}//  Fast path to avoid array mutation and iteration\nif(!Array.isArray(item)){if(array.indexOf(item)===-1){array.push(item);if(callback){callback.call(context,item);}return item;}else{return null;}}//  If we got this far, we have an array of items to insert\n//  Ensure all the items are unique\nvar itemLength=item.length-1;while(itemLength>=0){if(array.indexOf(item[itemLength])!==-1){//  Already exists in array, so remove it\nitem.pop();}itemLength--;}//  Anything left?\nitemLength=item.length;if(itemLength===0){return null;}if(limit>0&&itemLength>remaining){item.splice(remaining);itemLength=remaining;}for(var i=0;i<itemLength;i++){var entry=item[i];array.push(entry);if(callback){callback.call(context,entry);}}return item;};module.exports=Add;/***/},/* 803 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RotateMatrix=__webpack_require__(100);/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.RotateRight\r\n * @since 3.0.0\r\n *\r\n * @param {array} matrix - [description]\r\n *\r\n * @return {array} [description]\r\n */var RotateRight=function RotateRight(matrix){return RotateMatrix(matrix,-90);};module.exports=RotateRight;/***/},/* 804 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RotateMatrix=__webpack_require__(100);/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.RotateLeft\r\n * @since 3.0.0\r\n *\r\n * @param {array} matrix - [description]\r\n *\r\n * @return {array} [description]\r\n */var RotateLeft=function RotateLeft(matrix){return RotateMatrix(matrix,90);};module.exports=RotateLeft;/***/},/* 805 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RotateMatrix=__webpack_require__(100);/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.Rotate180\r\n * @since 3.0.0\r\n *\r\n * @param {array} matrix - [description]\r\n *\r\n * @return {array} [description]\r\n */var Rotate180=function Rotate180(matrix){return RotateMatrix(matrix,180);};module.exports=Rotate180;/***/},/* 806 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.ReverseRows\r\n * @since 3.0.0\r\n *\r\n * @param {array} matrix - [description]\r\n *\r\n * @return {array} [description]\r\n */var ReverseRows=function ReverseRows(matrix){return matrix.reverse();};module.exports=ReverseRows;/***/},/* 807 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.ReverseColumns\r\n * @since 3.0.0\r\n *\r\n * @param {array} matrix - [description]\r\n *\r\n * @return {array} [description]\r\n */var ReverseColumns=function ReverseColumns(matrix){for(var i=0;i<matrix.length;i++){matrix[i].reverse();}return matrix;};module.exports=ReverseColumns;/***/},/* 808 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Pad=__webpack_require__(165);var CheckMatrix=__webpack_require__(145);//  Generates a string (which you can pass to console.log) from the given\n//  Array Matrix.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Utils.Array.Matrix.MatrixToString\r\n * @since 3.0.0\r\n *\r\n * @param {array} matrix - [description]\r\n *\r\n * @return {string} [description]\r\n */var MatrixToString=function MatrixToString(matrix){var str='';if(!CheckMatrix(matrix)){return str;}for(var r=0;r<matrix.length;r++){for(var c=0;c<matrix[r].length;c++){var cell=matrix[r][c].toString();if(cell!=='undefined'){str+=Pad(cell,2);}else{str+='?';}if(c<matrix[r].length-1){str+=' |';}}if(r<matrix.length-1){str+='\\n';for(var i=0;i<matrix[r].length;i++){str+='---';if(i<matrix[r].length-1){str+='+';}}str+='\\n';}}return str;};module.exports=MatrixToString;/***/},/* 809 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Utils.Array.Matrix\r\n */module.exports={CheckMatrix:__webpack_require__(145),MatrixToString:__webpack_require__(808),ReverseColumns:__webpack_require__(807),ReverseRows:__webpack_require__(806),Rotate180:__webpack_require__(805),RotateLeft:__webpack_require__(804),RotateMatrix:__webpack_require__(100),RotateRight:__webpack_require__(803),TransposeMatrix:__webpack_require__(284)};/***/},/* 810 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var List=__webpack_require__(101);var PluginManager=__webpack_require__(13);var StableSort=__webpack_require__(98);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class DisplayList\r\n * @extends Phaser.Structs.List.<Phaser.GameObjects.GameObject>\r\n * @memberOf Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var DisplayList=new Class({Extends:List,initialize:function DisplayList(scene){List.call(this,scene);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#sortChildrenFlag\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.sortChildrenFlag=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * Force a sort of the display list on the next call to depthSort.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#queueDepthSort\r\n     * @since 3.0.0\r\n     */queueDepthSort:function queueDepthSort(){this.sortChildrenFlag=true;},/**\r\n     * Immediately sorts the display list if the flag is set.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#depthSort\r\n     * @since 3.0.0\r\n     */depthSort:function depthSort(){if(this.sortChildrenFlag){StableSort.inplace(this.list,this.sortByDepth);this.sortChildrenFlag=false;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#sortByDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - [description]\r\n     * @param {Phaser.GameObjects.GameObject} childB - [description]\r\n     *\r\n     * @return {integer} [description]\r\n     */sortByDepth:function sortByDepth(childA,childB){return childA._depth-childB._depth;},/**\r\n     * Given an array of Game Objects, sort the array and return it,\r\n     * so that the objects are in index order with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#sortGameObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - [description]\r\n     *\r\n     * @return {array} [description]\r\n     */sortGameObjects:function sortGameObjects(gameObjects){if(gameObjects===undefined){gameObjects=this.list;}this.scene.sys.depthSort();return gameObjects.sort(this.sortIndexHandler.bind(this));},/**\r\n     * Note that the given array is sorted in place, even though it isn't returned directly it will still be updated.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#getTopGameObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The top-most Game Object on the Display List.\r\n     */getTopGameObject:function getTopGameObject(gameObjects){this.sortGameObjects(gameObjects);return gameObjects[gameObjects.length-1];}});PluginManager.register('DisplayList',DisplayList,'displayList');module.exports=DisplayList;/***/},/* 811 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.GameObjects\r\n */var GameObjects={DisplayList:__webpack_require__(810),GameObjectCreator:__webpack_require__(11),GameObjectFactory:__webpack_require__(9),UpdateList:__webpack_require__(782),Components:__webpack_require__(12),BuildGameObject:__webpack_require__(20),BuildGameObjectAnimation:__webpack_require__(143),GameObject:__webpack_require__(1),BitmapText:__webpack_require__(142),Blitter:__webpack_require__(141),Container:__webpack_require__(140),DynamicBitmapText:__webpack_require__(139),Graphics:__webpack_require__(138),Group:__webpack_require__(74),Image:__webpack_require__(73),Particles:__webpack_require__(752),PathFollower:__webpack_require__(251),RenderTexture:__webpack_require__(134),Sprite3D:__webpack_require__(105),Sprite:__webpack_require__(41),Text:__webpack_require__(133),TileSprite:__webpack_require__(132),Zone:__webpack_require__(110),//  Game Object Factories\nFactories:{Blitter:__webpack_require__(700),Container:__webpack_require__(699),DynamicBitmapText:__webpack_require__(698),Graphics:__webpack_require__(697),Group:__webpack_require__(696),Image:__webpack_require__(695),Particles:__webpack_require__(694),PathFollower:__webpack_require__(693),RenderTexture:__webpack_require__(692),Sprite3D:__webpack_require__(691),Sprite:__webpack_require__(690),StaticBitmapText:__webpack_require__(689),Text:__webpack_require__(688),TileSprite:__webpack_require__(687),Zone:__webpack_require__(686)},Creators:{Blitter:__webpack_require__(685),Container:__webpack_require__(684),DynamicBitmapText:__webpack_require__(683),Graphics:__webpack_require__(682),Group:__webpack_require__(681),Image:__webpack_require__(680),Particles:__webpack_require__(679),RenderTexture:__webpack_require__(678),Sprite3D:__webpack_require__(677),Sprite:__webpack_require__(676),StaticBitmapText:__webpack_require__(675),Text:__webpack_require__(674),TileSprite:__webpack_require__(673),Zone:__webpack_require__(672)}};if(true){//  WebGL only Game Objects\nGameObjects.Mesh=__webpack_require__(97);GameObjects.Quad=__webpack_require__(131);GameObjects.Factories.Mesh=__webpack_require__(668);GameObjects.Factories.Quad=__webpack_require__(667);GameObjects.Creators.Mesh=__webpack_require__(666);GameObjects.Creators.Quad=__webpack_require__(665);GameObjects.Light=__webpack_require__(249);__webpack_require__(248);__webpack_require__(664);}module.exports=GameObjects;/***/},/* 812 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Visibility Handler hidden event.\r\n *\r\n * The document in which the Game is embedded has entered a hidden state.\r\n *\r\n * @event Phaser.Boot.VisibilityHandler#hidden\r\n *//**\r\n * Visibility Handler visible event.\r\n *\r\n * The document in which the Game is embedded has entered a visible state.\r\n *\r\n * @event Phaser.Boot.VisibilityHandler#visible\r\n *//**\r\n * Visibility Handler blur event.\r\n *\r\n * The window in which the Game is embedded has entered a blurred state.\r\n *\r\n * @event Phaser.Boot.VisibilityHandler#blur\r\n *//**\r\n * Visibility Handler focus event.\r\n *\r\n * The window in which the Game is embedded has entered a focused state.\r\n *\r\n * @event Phaser.Boot.VisibilityHandler#focus\r\n *//**\r\n * The Visibility Handler is responsible for listening out for document level visibility change events.\r\n * This includes `visibilitychange` if the browser supports it, and blur and focus events. It then uses\r\n * the provided Event Emitter and fires the related events.\r\n *\r\n * @function Phaser.Boot.VisibilityHandler\r\n * @fires Phaser.Boot.VisibilityHandler#hidden\r\n * @fires Phaser.Boot.VisibilityHandler#visible\r\n * @fires Phaser.Boot.VisibilityHandler#blur\r\n * @fires Phaser.Boot.VisibilityHandler#focus\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Events.EventEmitter} eventEmitter - The EventEmitter that will emit the visibility events.\r\n */var VisibilityHandler=function VisibilityHandler(eventEmitter){var hiddenVar;if(document.hidden!==undefined){hiddenVar='visibilitychange';}else{var vendors=['webkit','moz','ms'];vendors.forEach(function(prefix){if(document[prefix+'Hidden']!==undefined){document.hidden=function(){return document[prefix+'Hidden'];};hiddenVar=prefix+'visibilitychange';}});}var onChange=function onChange(event){if(document.hidden||event.type==='pause'){eventEmitter.emit('hidden');}else{eventEmitter.emit('visible');}};if(hiddenVar){document.addEventListener(hiddenVar,onChange,false);}window.onblur=function(){eventEmitter.emit('blur');};window.onfocus=function(){eventEmitter.emit('focus');};};module.exports=VisibilityHandler;/***/},/* 813 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var GetValue=__webpack_require__(5);var NOOP=__webpack_require__(3);var RequestAnimationFrame=__webpack_require__(316);//  Frame Rate config\n//      fps: {\n//          min: 10,\n//          target: 60,\n//          forceSetTimeOut: false,\n//          deltaHistory: 10,\n//          panicMax: 120\n//     }\n// http://www.testufo.com/#test=animation-time-graph\n/**\r\n * @callback TimeStepCallback\r\n *\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} average - The Delta Average.\r\n * @param {number} interpolation - Interpolation - how far between what is expected and where we are?\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class TimeStep\r\n * @memberOf Phaser.Boot\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - A reference to the Phaser.Game instance that owns this Time Step.\r\n * @param {FPSConfig} config\r\n */var TimeStep=new Class({initialize:function TimeStep(game,config){/**\r\n         * A reference to the Phaser.Game instance.\r\n         *\r\n         * @property {Phaser.Game} game\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.game=game;/**\r\n         * [description]\r\n         *\r\n         * @property {Phaser.DOM.RequestAnimationFrame} raf\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.raf=new RequestAnimationFrame();/**\r\n         * A flag that is set once the TimeStep has started running and toggled when it stops.\r\n         *\r\n         * @property {boolean} started\r\n         * @readOnly\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.started=false;/**\r\n         * A flag that is set once the TimeStep has started running and toggled when it stops.\r\n         * The difference between this value and `started` is that `running` is toggled when\r\n         * the TimeStep is sent to sleep, where-as `started` remains `true`, only changing if\r\n         * the TimeStep is actually stopped, not just paused.\r\n         *\r\n         * @property {boolean} running\r\n         * @readOnly\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.running=false;/**\r\n         * The minimum fps rate you want the Time Step to run at.\r\n         *\r\n         * @property {integer} minFps\r\n         * @default 5\r\n         * @since 3.0.0\r\n         */this.minFps=GetValue(config,'min',5);/**\r\n         * The target fps rate for the Time Step to run at.\r\n         *\r\n         * Setting this value will not actually change the speed at which the browser runs, that is beyond\r\n         * the control of Phaser. Instead, it allows you to determine performance issues and if the Time Step\r\n         * is spiraling out of control.\r\n         *\r\n         * @property {integer} targetFps\r\n         * @default 60\r\n         * @since 3.0.0\r\n         */this.targetFps=GetValue(config,'target',60);/**\r\n         * The minFps value in ms.\r\n         * Defaults to 200ms between frames (i.e. super slow!)\r\n         *\r\n         * @property {number} _min\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._min=1000/this.minFps;/**\r\n         * The targetFps value in ms.\r\n         * Defaults to 16.66ms between frames (i.e. normal)\r\n         *\r\n         * @property {number} _target\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._target=1000/this.targetFps;/**\r\n         * An exponential moving average of the frames per second.\r\n         *\r\n         * @property {integer} actualFps\r\n         * @readOnly\r\n         * @default 60\r\n         * @since 3.0.0\r\n         */this.actualFps=this.targetFps;/**\r\n         * [description]\r\n         *\r\n         * @property {integer} nextFpsUpdate\r\n         * @readOnly\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.nextFpsUpdate=0;/**\r\n         * The number of frames processed this second.\r\n         *\r\n         * @property {integer} framesThisSecond\r\n         * @readOnly\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.framesThisSecond=0;/**\r\n         * A callback to be invoked each time the Time Step steps.\r\n         *\r\n         * @property {TimeStepCallback} callback\r\n         * @default NOOP\r\n         * @since 3.0.0\r\n         */this.callback=NOOP;/**\r\n         * You can force the Time Step to use Set Timeout instead of Request Animation Frame by setting\r\n         * the `forceSetTimeOut` property to `true` in the Game Configuration object. It cannot be changed at run-time.\r\n         *\r\n         * @property {boolean} forceSetTimeOut\r\n         * @readOnly\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.forceSetTimeOut=GetValue(config,'forceSetTimeOut',false);/**\r\n         * [description]\r\n         *\r\n         * @property {integer} time\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.time=0;/**\r\n         * [description]\r\n         *\r\n         * @property {integer} startTime\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.startTime=0;/**\r\n         * [description]\r\n         *\r\n         * @property {integer} lastTime\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.lastTime=0;/**\r\n         * [description]\r\n         *\r\n         * @property {integer} frame\r\n         * @readOnly\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.frame=0;/**\r\n         * [description]\r\n         *\r\n         * @property {boolean} inFocus\r\n         * @readOnly\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.inFocus=true;/**\r\n         * [description]\r\n         *\r\n         * @property {integer} _pauseTime\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._pauseTime=0;/**\r\n         * [description]\r\n         *\r\n         * @property {integer} _coolDown\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._coolDown=0;/**\r\n         * [description]\r\n         *\r\n         * @property {integer} delta\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.delta=0;/**\r\n         * [description]\r\n         *\r\n         * @property {integer} deltaIndex\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.deltaIndex=0;/**\r\n         * [description]\r\n         *\r\n         * @property {array} deltaHistory\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.deltaHistory=[];/**\r\n         * [description]\r\n         *\r\n         * @property {integer} deltaSmoothingMax\r\n         * @default 10\r\n         * @since 3.0.0\r\n         */this.deltaSmoothingMax=GetValue(config,'deltaHistory',10);/**\r\n         * [description]\r\n         *\r\n         * @property {integer} panicMax\r\n         * @default 120\r\n         * @since 3.0.0\r\n         */this.panicMax=GetValue(config,'panicMax',120);/**\r\n         * The actual elapsed time in ms between one update and the next.\r\n         * Unlike with `delta` no smoothing, capping, or averaging is applied to this value.\r\n         * So please be careful when using this value in calculations.\r\n         *\r\n         * @property {number} rawDelta\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.rawDelta=0;},/**\r\n     * Called when the DOM window.onBlur event triggers.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#blur\r\n     * @since 3.0.0\r\n     */blur:function blur(){this.inFocus=false;},/**\r\n     * Called when the DOM window.onFocus event triggers.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#focus\r\n     * @since 3.0.0\r\n     */focus:function focus(){this.inFocus=true;this.resetDelta();},/**\r\n     * Called when the visibility API says the game is 'hidden' (tab switch out of view, etc)\r\n     *\r\n     * @method Phaser.Boot.TimeStep#pause\r\n     * @since 3.0.0\r\n     */pause:function pause(){this._pauseTime=window.performance.now();},/**\r\n     * Called when the visibility API says the game is 'visible' again (tab switch back into view, etc)\r\n     *\r\n     * @method Phaser.Boot.TimeStep#resume\r\n     * @since 3.0.0\r\n     */resume:function resume(){this.resetDelta();this.startTime+=this.time-this._pauseTime;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Boot.TimeStep#resetDelta\r\n     * @since 3.0.0\r\n     */resetDelta:function resetDelta(){var now=window.performance.now();this.time=now;this.lastTime=now;this.nextFpsUpdate=now+1000;this.framesThisSecond=0;this.frame=0;//  Pre-populate smoothing array\nfor(var i=0;i<this.deltaSmoothingMax;i++){this.deltaHistory[i]=Math.min(this._target,this.deltaHistory[i]);}this.delta=0;this.deltaIndex=0;this._coolDown=this.panicMax;},/**\r\n     * Starts the Time Step running, if it is not already doing so.\r\n     * Called automatically by the Game Boot process.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TimeStepCallback} callback - The callback to be invoked each time the Time Step steps.\r\n     */start:function start(callback){if(this.started){return this;}this.started=true;this.running=true;for(var i=0;i<this.deltaSmoothingMax;i++){this.deltaHistory[i]=this._target;}this.resetDelta();this.startTime=window.performance.now();this.callback=callback;this.raf.start(this.step.bind(this),this.forceSetTimeOut);},/**\r\n     * The main step method. This is called each time the browser updates, either by Request Animation Frame,\r\n     * or by Set Timeout. It is responsible for calculating the delta values, frame totals, cool down history and more.\r\n     * You generally should never call this method directly.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#step\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     */step:function step(time){this.frame++;this.rawDelta=time-this.lastTime;var idx=this.deltaIndex;var history=this.deltaHistory;var max=this.deltaSmoothingMax;//  delta time (time is in ms)\nvar dt=time-this.lastTime;//  When a browser switches tab, then comes back again, it takes around 10 frames before\n//  the delta time settles down so we employ a 'cooling down' period before we start\n//  trusting the delta values again, to avoid spikes flooding through our delta average\nif(this._coolDown>0||!this.inFocus){this._coolDown--;dt=Math.min(dt,this._target);}if(dt>this._min){//  Probably super bad start time or browser tab context loss,\n//  so use the last 'sane' dt value\ndt=history[idx];//  Clamp delta to min (in case history has become corrupted somehow)\ndt=Math.min(dt,this._min);}//  Smooth out the delta over the previous X frames\n//  add the delta to the smoothing array\nhistory[idx]=dt;//  adjusts the delta history array index based on the smoothing count\n//  this stops the array growing beyond the size of deltaSmoothingMax\nthis.deltaIndex++;if(this.deltaIndex>max){this.deltaIndex=0;}//  Delta Average\nvar avg=0;//  Loop the history array, adding the delta values together\nfor(var i=0;i<max;i++){avg+=history[i];}//  Then divide by the array length to get the average delta\navg/=max;//  Set as the world delta value\nthis.delta=avg;//  Real-world timer advance\nthis.time+=this.rawDelta;// Update the estimate of the frame rate, `fps`. Every second, the number\n// of frames that occurred in that second are included in an exponential\n// moving average of all frames per second, with an alpha of 0.25. This\n// means that more recent seconds affect the estimated frame rate more than\n// older seconds.\n//\n// When a browser window is NOT minimized, but is covered up (i.e. you're using\n// another app which has spawned a window over the top of the browser), then it\n// will start to throttle the raf callback time. It waits for a while, and then\n// starts to drop the frame rate at 1 frame per second until it's down to just over 1fps.\n// So if the game was running at 60fps, and the player opens a new window, then\n// after 60 seconds (+ the 'buffer time') it'll be down to 1fps, so rafin'g at 1Hz.\n//\n// When they make the game visible again, the frame rate is increased at a rate of\n// approx. 8fps, back up to 60fps (or the max it can obtain)\n//\n// There is no easy way to determine if this drop in frame rate is because the\n// browser is throttling raf, or because the game is struggling with performance\n// because you're asking it to do too much on the device.\nif(time>this.nextFpsUpdate){//  Compute the new exponential moving average with an alpha of 0.25.\nthis.actualFps=0.25*this.framesThisSecond+0.75*this.actualFps;this.nextFpsUpdate=time+1000;this.framesThisSecond=0;}this.framesThisSecond++;//  Interpolation - how far between what is expected and where we are?\nvar interpolation=avg/this._target;this.callback(time,avg,interpolation);//  Shift time value over\nthis.lastTime=time;},/**\r\n     * Manually calls TimeStep.step, passing in the performance.now value to it.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#tick\r\n     * @since 3.0.0\r\n     */tick:function tick(){this.step(window.performance.now());},/**\r\n     * Sends the TimeStep to sleep, stopping Request Animation Frame (or SetTimeout) and toggling the `running` flag to false.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#sleep\r\n     * @since 3.0.0\r\n     */sleep:function sleep(){if(this.running){this.raf.stop();this.running=false;}},/**\r\n     * Wakes-up the TimeStep, restarting Request Animation Frame (or SetTimeout) and toggling the `running` flag to true.\r\n     * The `seamless` argument controls if the wake-up should adjust the start time or not.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [seamless=false] - Adjust the startTime based on the lastTime values.\r\n     */wake:function wake(seamless){if(this.running){this.sleep();}else if(seamless){this.startTime+=-this.lastTime+(this.lastTime=window.performance.now());}this.raf.start(this.step.bind(this),this.useRAF);this.running=true;this.step(window.performance.now());},/**\r\n     * Stops the TimeStep running.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Boot.TimeStep} The TimeStep object.\r\n     */stop:function stop(){this.running=false;this.started=false;this.raf.stop();return this;},/**\r\n     * Destroys the TimeStep. This will stop Request Animation Frame, stop the step, clear the callbacks and null\r\n     * any objects.\r\n     *\r\n     * @method Phaser.Boot.TimeStep#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.stop();this.callback=NOOP;this.raf=null;this.game=null;}});module.exports=TimeStep;/***/},/* 814 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var imageHeight=0;/**\r\n * @function addFrame\r\n * @private\r\n * @since 3.0.0\r\n */var addFrame=function addFrame(texture,sourceIndex,name,frame){//  The frame values are the exact coordinates to cut the frame out of the atlas from\nvar y=imageHeight-frame.y-frame.height;texture.add(name,sourceIndex,frame.x,y,frame.width,frame.height);//  These are the original (non-trimmed) sprite values\n/*\r\n    if (src.trimmed)\r\n    {\r\n        newFrame.setTrim(\r\n            src.sourceSize.w,\r\n            src.sourceSize.h,\r\n            src.spriteSourceSize.x,\r\n            src.spriteSourceSize.y,\r\n            src.spriteSourceSize.w,\r\n            src.spriteSourceSize.h\r\n        );\r\n    }\r\n    */};/**\r\n * Parses a Unity YAML File and creates Frames in the Texture.\r\n * For more details about Sprite Meta Data see https://docs.unity3d.com/ScriptReference/SpriteMetaData.html\r\n *\r\n * @function Phaser.Textures.Parsers.UnityYAML\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {object} yaml - The YAML data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var UnityYAML=function UnityYAML(texture,sourceIndex,yaml){//  Add in a __BASE entry (for the entire atlas)\nvar source=texture.source[sourceIndex];texture.add('__BASE',sourceIndex,0,0,source.width,source.height);imageHeight=source.height;var data=yaml.split('\\n');var lineRegExp=/^[ ]*(- )*(\\w+)+[: ]+(.*)/;var prevSprite='';var currentSprite='';var rect={x:0,y:0,width:0,height:0};// var pivot = { x: 0, y: 0 };\n// var border = { x: 0, y: 0, z: 0, w: 0 };\nfor(var i=0;i<data.length;i++){var results=data[i].match(lineRegExp);if(!results){continue;}var isList=results[1]==='- ';var key=results[2];var value=results[3];if(isList){if(currentSprite!==prevSprite){addFrame(texture,sourceIndex,currentSprite,rect);prevSprite=currentSprite;}rect={x:0,y:0,width:0,height:0};}if(key==='name'){//  Start new list\ncurrentSprite=value;continue;}switch(key){case'x':case'y':case'width':case'height':rect[key]=parseInt(value,10);break;// case 'pivot':\n//     pivot = eval('var obj = ' + value);\n//     break;\n// case 'border':\n//     border = eval('var obj = ' + value);\n//     break;\n}}if(currentSprite!==prevSprite){addFrame(texture,sourceIndex,currentSprite,rect);}return texture;};module.exports=UnityYAML;/*\r\nExample data:\r\n\r\nTextureImporter:\r\n  spritePivot: {x: .5, y: .5}\r\n  spriteBorder: {x: 0, y: 0, z: 0, w: 0}\r\n  spritePixelsToUnits: 100\r\n  spriteSheet:\r\n    sprites:\r\n    - name: asteroids_0\r\n      rect:\r\n        serializedVersion: 2\r\n        x: 5\r\n        y: 328\r\n        width: 65\r\n        height: 82\r\n      alignment: 0\r\n      pivot: {x: 0, y: 0}\r\n      border: {x: 0, y: 0, z: 0, w: 0}\r\n    - name: asteroids_1\r\n      rect:\r\n        serializedVersion: 2\r\n        x: 80\r\n        y: 322\r\n        width: 53\r\n        height: 88\r\n      alignment: 0\r\n      pivot: {x: 0, y: 0}\r\n      border: {x: 0, y: 0, z: 0, w: 0}\r\n  spritePackingTag: Asteroids\r\n*//***/},/* 815 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Parses a Starling XML object and adds all the Frames into a Texture.\r\n *\r\n * @function Phaser.Textures.Parsers.StarlingXML\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {*} xml - The XML data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var StarlingXML=function StarlingXML(texture,xml){//  Malformed?\nif(!xml.getElementsByTagName('TextureAtlas')){// console.warn(\"Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag\");\nreturn;}//  Let's create some frames then\nvar data=new Phaser.FrameData();var frames=xml.getElementsByTagName('SubTexture');var newFrame;var name;var frame;var x;var y;var width;var height;var frameX;var frameY;var frameWidth;var frameHeight;for(var i=0;i<frames.length;i++){frame=frames[i].attributes;name=frame.name.value;x=parseInt(frame.x.value,10);y=parseInt(frame.y.value,10);width=parseInt(frame.width.value,10);height=parseInt(frame.height.value,10);frameX=null;frameY=null;if(frame.frameX){frameX=Math.abs(parseInt(frame.frameX.value,10));frameY=Math.abs(parseInt(frame.frameY.value,10));frameWidth=parseInt(frame.frameWidth.value,10);frameHeight=parseInt(frame.frameHeight.value,10);}newFrame=data.addFrame(new Phaser.Frame(i,x,y,width,height,name));//  Trimmed?\nif(frameX!==null||frameY!==null){newFrame.setTrim(true,width,height,frameX,frameY,frameWidth,frameHeight);}}return data;};module.exports=StarlingXML;/***/},/* 816 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetFastValue=__webpack_require__(2);/**\r\n * Parses a Sprite Sheet and adds the Frames to the Texture, where the Sprite Sheet is stored as a frame within an Atlas.\r\n *\r\n * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n * same size and cannot be trimmed or rotated.\r\n *\r\n * @function Phaser.Textures.Parsers.SpriteSheetFromAtlas\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {Phaser.Textures.Frame} frame - The Frame that contains the Sprite Sheet.\r\n * @param {object} config - An object describing how to parse the Sprite Sheet.\r\n * @param {number} config.frameWidth - Width in pixels of a single frame in the sprite sheet.\r\n * @param {number} [config.frameHeight] - Height in pixels of a single frame in the sprite sheet. Defaults to frameWidth if not provided.\r\n * @param {number} [config.startFrame=0] - [description]\r\n * @param {number} [config.endFrame=-1] - [description]\r\n * @param {number} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.\r\n * @param {number} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var SpriteSheetFromAtlas=function SpriteSheetFromAtlas(texture,frame,config){var frameWidth=GetFastValue(config,'frameWidth',null);var frameHeight=GetFastValue(config,'frameHeight',frameWidth);//  If missing we can't proceed\nif(!frameWidth){throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.');}//  Add in a __BASE entry (for the entire atlas)\n// var source = texture.source[sourceIndex];\n// texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\nvar startFrame=GetFastValue(config,'startFrame',0);var endFrame=GetFastValue(config,'endFrame',-1);var margin=GetFastValue(config,'margin',0);var spacing=GetFastValue(config,'spacing',0);var x=frame.cutX;var y=frame.cutY;var cutWidth=frame.cutWidth;var cutHeight=frame.cutHeight;var sheetWidth=frame.realWidth;var sheetHeight=frame.realHeight;var row=Math.floor((sheetWidth-margin+spacing)/(frameWidth+spacing));var column=Math.floor((sheetHeight-margin+spacing)/(frameHeight+spacing));var total=row*column;//  trim offsets\nvar leftPad=frame.x;var leftWidth=frameWidth-leftPad;var rightWidth=frameWidth-(sheetWidth-cutWidth-leftPad);var topPad=frame.y;var topHeight=frameHeight-topPad;var bottomHeight=frameHeight-(sheetHeight-cutHeight-topPad);// console.log('x / y', x, y);\n// console.log('cutW / H', cutWidth, cutHeight);\n// console.log('sheetW / H', sheetWidth, sheetHeight);\n// console.log('row', row, 'column', column, 'total', total);\n// console.log('LW', leftWidth, 'RW', rightWidth, 'TH', topHeight, 'BH', bottomHeight);\nif(startFrame>total||startFrame<-total){startFrame=0;}if(startFrame<0){//  Allow negative skipframes.\nstartFrame=total+startFrame;}if(endFrame!==-1){total=startFrame+(endFrame+1);}var sheetFrame;var frameX=margin;var frameY=margin;var frameIndex=0;var sourceIndex=frame.sourceIndex;for(var sheetY=0;sheetY<column;sheetY++){var topRow=sheetY===0;var bottomRow=sheetY===column-1;for(var sheetX=0;sheetX<row;sheetX++){var leftRow=sheetX===0;var rightRow=sheetX===row-1;sheetFrame=texture.add(frameIndex,sourceIndex,x+frameX,y+frameY,frameWidth,frameHeight);if(leftRow||topRow||rightRow||bottomRow){var destX=leftRow?leftPad:0;var destY=topRow?topPad:0;var destWidth=frameWidth;var destHeight=frameHeight;if(leftRow){destWidth=leftWidth;}else if(rightRow){destWidth=rightWidth;}if(topRow){destHeight=topHeight;}else if(bottomRow){destHeight=bottomHeight;}sheetFrame.cutWidth=destWidth;sheetFrame.cutHeight=destHeight;sheetFrame.setTrim(frameWidth,frameHeight,destX,destY,destWidth,destHeight);}frameX+=spacing;if(leftRow){frameX+=leftWidth;}else if(rightRow){frameX+=rightRow;}else{frameX+=frameWidth;}frameIndex++;}frameX=margin;frameY+=spacing;if(topRow){frameY+=topHeight;}else if(bottomRow){frameY+=bottomHeight;}else{frameY+=frameHeight;}}return texture;};module.exports=SpriteSheetFromAtlas;/***/},/* 817 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetFastValue=__webpack_require__(2);/**\r\n * Parses a Sprite Sheet and adds the Frames to the Texture.\r\n * \r\n * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n * same size and cannot be trimmed or rotated.\r\n *\r\n * @function Phaser.Textures.Parsers.SpriteSheet\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {integer} x - [description]\r\n * @param {integer} y - [description]\r\n * @param {integer} width - [description]\r\n * @param {integer} height - [description]\r\n * @param {object} config - An object describing how to parse the Sprite Sheet.\r\n * @param {number} config.frameWidth - Width in pixels of a single frame in the sprite sheet.\r\n * @param {number} [config.frameHeight] - Height in pixels of a single frame in the sprite sheet. Defaults to frameWidth if not provided.\r\n * @param {number} [config.startFrame=0] - [description]\r\n * @param {number} [config.endFrame=-1] - [description]\r\n * @param {number} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.\r\n * @param {number} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var SpriteSheet=function SpriteSheet(texture,sourceIndex,x,y,width,height,config){var frameWidth=GetFastValue(config,'frameWidth',null);var frameHeight=GetFastValue(config,'frameHeight',frameWidth);//  If missing we can't proceed\nif(frameWidth===null){throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.');}//  Add in a __BASE entry (for the entire atlas)\nvar source=texture.source[sourceIndex];texture.add('__BASE',sourceIndex,0,0,source.width,source.height);var startFrame=GetFastValue(config,'startFrame',0);var endFrame=GetFastValue(config,'endFrame',-1);var margin=GetFastValue(config,'margin',0);var spacing=GetFastValue(config,'spacing',0);var row=Math.floor((width-margin+spacing)/(frameWidth+spacing));var column=Math.floor((height-margin+spacing)/(frameHeight+spacing));var total=row*column;if(startFrame>total||startFrame<-total){startFrame=0;}if(startFrame<0){//  Allow negative skipframes.\nstartFrame=total+startFrame;}if(endFrame!==-1){total=startFrame+(endFrame+1);}var fx=margin;var fy=margin;var ax=0;var ay=0;for(var i=0;i<total;i++){ax=0;ay=0;var w=fx+frameWidth;var h=fy+frameHeight;if(w>width){ax=w-width;}if(h>height){ay=h-height;}texture.add(i,sourceIndex,x+fx,y+fy,frameWidth-ax,frameHeight-ay);fx+=frameWidth+spacing;if(fx+frameWidth>width){fx=margin;fy+=frameHeight+spacing;}}return texture;};module.exports=SpriteSheet;/***/},/* 818 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Parses a Pyxel JSON object and adds the Frames to a Texture.\r\n *\r\n * @function Phaser.Textures.Parsers.Pyxel\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var Pyxel=function Pyxel(texture,json){//  Malformed? There are a few keys to check here.\nvar signature=['layers','tilewidth','tileheight','tileswide','tileshigh'];signature.forEach(function(key){if(!json[key]){// console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing \"' + key + '\" key.');\n// console.log(json);\nreturn;}});// For this purpose, I only care about parsing tilemaps with a single layer.\nif(json['layers'].length!==1){// console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.');\n// console.log(json);\nreturn;}var data=new Phaser.FrameData();var tileheight=json['tileheight'];var tilewidth=json['tilewidth'];var frames=json['layers'][0]['tiles'];var newFrame;for(var i=0;i<frames.length;i++){newFrame=data.addFrame(new Phaser.Frame(i,frames[i].x,frames[i].y,tilewidth,tileheight,'frame_'+i// No names are included in pyxel tilemap data.\n));// No trim data is included.\nnewFrame.setTrim(false);}return data;};module.exports=Pyxel;/***/},/* 819 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clone=__webpack_require__(57);/**\r\n * Parses a Texture Atlas JSON Hash and adds the Frames to the Texture.\r\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an object of Frames.\r\n *\r\n * @function Phaser.Textures.Parsers.JSONHash\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var JSONHash=function JSONHash(texture,sourceIndex,json){//  Malformed?\nif(!json['frames']){console.warn('Invalid Texture Atlas JSON Hash given, missing \\'frames\\' Object');return;}//  Add in a __BASE entry (for the entire atlas)\nvar source=texture.source[sourceIndex];texture.add('__BASE',sourceIndex,0,0,source.width,source.height);//  By this stage frames is a fully parsed Object\nvar frames=json['frames'];var newFrame;for(var key in frames){var src=frames[key];//  The frame values are the exact coordinates to cut the frame out of the atlas from\nnewFrame=texture.add(key,sourceIndex,src.frame.x,src.frame.y,src.frame.w,src.frame.h);//  These are the original (non-trimmed) sprite values\nif(src.trimmed){newFrame.setTrim(src.sourceSize.w,src.sourceSize.h,src.spriteSourceSize.x,src.spriteSourceSize.y,src.spriteSourceSize.w,src.spriteSourceSize.h);}if(src.rotated){newFrame.rotated=true;newFrame.updateUVsInverted();}//  Copy over any extra data\nnewFrame.customData=Clone(src);}//  Copy over any additional data that was in the JSON to Texture.customData\nfor(var dataKey in json){if(dataKey==='frames'){continue;}if(Array.isArray(json[dataKey])){texture.customData[dataKey]=json[dataKey].slice(0);}else{texture.customData[dataKey]=json[dataKey];}}return texture;};module.exports=JSONHash;/***/},/* 820 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clone=__webpack_require__(57);/**\r\n * Parses a Texture Atlas JSON Array and adds the Frames to the Texture.\r\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an array of Frames.\r\n *\r\n * @function Phaser.Textures.Parsers.JSONArray\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var JSONArray=function JSONArray(texture,sourceIndex,json){//  Malformed?\nif(!json['frames']&&!json['textures']){console.warn('Invalid Texture Atlas JSON Array given, missing \\'frames\\' and \\'textures\\' array');return;}//  Add in a __BASE entry (for the entire atlas)\nvar source=texture.source[sourceIndex];texture.add('__BASE',sourceIndex,0,0,source.width,source.height);//  By this stage frames is a fully parsed array\nvar frames=Array.isArray(json.textures)?json.textures[sourceIndex].frames:json.frames;var newFrame;for(var i=0;i<frames.length;i++){var src=frames[i];//  The frame values are the exact coordinates to cut the frame out of the atlas from\nnewFrame=texture.add(src.filename,sourceIndex,src.frame.x,src.frame.y,src.frame.w,src.frame.h);//  These are the original (non-trimmed) sprite values\nif(src.trimmed){newFrame.setTrim(src.sourceSize.w,src.sourceSize.h,src.spriteSourceSize.x,src.spriteSourceSize.y,src.spriteSourceSize.w,src.spriteSourceSize.h);}if(src.rotated){newFrame.rotated=true;newFrame.updateUVsInverted();}if(src.anchor){newFrame.customPivot=true;newFrame.pivotX=src.anchor.x;newFrame.pivotY=src.anchor.y;}//  Copy over any extra data\nnewFrame.customData=Clone(src);}//  Copy over any additional data that was in the JSON to Texture.customData\nfor(var dataKey in json){if(dataKey==='frames'){continue;}if(Array.isArray(json[dataKey])){texture.customData[dataKey]=json[dataKey].slice(0);}else{texture.customData[dataKey]=json[dataKey];}}return texture;};module.exports=JSONArray;/***/},/* 821 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Adds an Image Element to a Texture.\r\n *\r\n * @function Phaser.Textures.Parsers.Image\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var Image=function Image(texture,sourceIndex){var source=texture.source[sourceIndex];texture.add('__BASE',sourceIndex,0,0,source.width,source.height);return texture;};module.exports=Image;/***/},/* 822 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Adds a Canvas Element to a Texture.\r\n *\r\n * @function Phaser.Textures.Parsers.Canvas\r\n * @memberOf Phaser.Textures.Parsers\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */var Canvas=function Canvas(texture,sourceIndex){var source=texture.source[sourceIndex];texture.add('__BASE',sourceIndex,0,0,source.width,source.height);return texture;};module.exports=Canvas;/***/},/* 823 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  These properties get injected into the Scene and map to local systems\n//  The map value is the property that is injected into the Scene, the key is the Scene.Systems reference.\n//  These defaults can be modified via the Scene config object\n//          var config = {\n//            map: {\n//                add: 'makeStuff',\n//                load: 'loader'\n//            }\n//        };\nvar InjectionMap={game:'game',anims:'anims',cache:'cache',registry:'registry',sound:'sound',textures:'textures',events:'events',cameras:'cameras',cameras3d:'cameras3d',add:'add',make:'make',scenePlugin:'scene',displayList:'children',lights:'lights',data:'data',input:'input',load:'load',time:'time',tweens:'tweens',arcadePhysics:'physics',impactPhysics:'impact',matterPhysics:'matter'};module.exports=InjectionMap;/***/},/* 824 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetFastValue=__webpack_require__(2);/**\r\n * Builds an array of which plugins (not including physics plugins) should be activated for the given Scene.\r\n *\r\n * @function Phaser.Scenes.GetScenePlugins\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - [description]\r\n *\r\n * @return {array} [description]\r\n */var GetScenePlugins=function GetScenePlugins(sys){var defaultPlugins=sys.game.config.defaultPlugins;var scenePlugins=GetFastValue(sys.settings,'plugins',false);//  Scene Plugins always override Default Plugins\nif(Array.isArray(scenePlugins)){return scenePlugins;}else if(defaultPlugins){return defaultPlugins;}else{//  No default plugins or plugins in this scene\nreturn[];}};module.exports=GetScenePlugins;/***/},/* 825 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetFastValue=__webpack_require__(2);var UppercaseFirst=__webpack_require__(297);/**\r\n * Builds an array of which physics plugins should be activated for the given Scene.\r\n *\r\n * @function Phaser.Scenes.GetPhysicsPlugins\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - [description]\r\n *\r\n * @return {array} [description]\r\n */var GetPhysicsPlugins=function GetPhysicsPlugins(sys){var defaultSystem=sys.game.config.defaultPhysicsSystem;var sceneSystems=GetFastValue(sys.settings,'physics',false);if(!defaultSystem&&!sceneSystems){//  No default physics system or systems in this scene\nreturn;}//  Let's build the systems array\nvar output=[];if(defaultSystem){output.push(UppercaseFirst(defaultSystem+'Physics'));}if(sceneSystems){for(var key in sceneSystems){key=UppercaseFirst(key.concat('Physics'));if(output.indexOf(key)===-1){output.push(key);}}}//  An array of Physics systems to start for this Scene\nreturn output;};module.exports=GetPhysicsPlugins;/***/},/* 826 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Used internally by the KeyboardManager.\r\n *\r\n * @function Phaser.Input.Keyboard.Keys.ProcessKeyUp\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - [description]\r\n * @param {KeyboardEvent} event - [description]\r\n *\r\n * @return {Phaser.Input.Keyboard.Key} [description]\r\n */var ProcessKeyUp=function ProcessKeyUp(key,event){key.originalEvent=event;if(key.preventDefault){event.preventDefault();}if(!key.enabled){return;}key.isDown=false;key.isUp=true;key.timeUp=event.timeStamp;key.duration=key.timeUp-key.timeDown;key.repeats=0;key._justDown=false;key._justUp=true;return key;};module.exports=ProcessKeyUp;/***/},/* 827 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Used internally by the KeyboardManager.\r\n *\r\n * @function Phaser.Input.Keyboard.Keys.ProcessKeyDown\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - [description]\r\n * @param {KeyboardEvent} event - [description]\r\n *\r\n * @return {Phaser.Input.Keyboard.Key} [description]\r\n */var ProcessKeyDown=function ProcessKeyDown(key,event){key.originalEvent=event;if(key.preventDefault){event.preventDefault();}if(!key.enabled){return;}key.altKey=event.altKey;key.ctrlKey=event.ctrlKey;key.shiftKey=event.shiftKey;key.location=event.location;if(key.isDown===false){key.isDown=true;key.isUp=false;key.timeDown=event.timeStamp;key.duration=0;key._justDown=true;key._justUp=false;}key.repeats++;return key;};module.exports=ProcessKeyDown;/***/},/* 828 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var KeyCodes=__webpack_require__(149);var KeyMap={};for(var key in KeyCodes){KeyMap[KeyCodes[key]]=key;}module.exports=KeyMap;/***/},/* 829 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Used internally by the KeyCombo class.\r\n *\r\n * @function Phaser.Input.Keyboard.KeyCombo.ResetKeyCombo\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo to reset.\r\n *\r\n * @return {Phaser.Input.Keyboard.KeyCombo} The KeyCombo.\r\n */var ResetKeyCombo=function ResetKeyCombo(combo){combo.current=combo.keyCodes[0];combo.index=0;combo.timeLastMatched=0;combo.matched=false;combo.timeMatched=0;return combo;};module.exports=ResetKeyCombo;/***/},/* 830 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Used internally by the KeyCombo class.\r\n * Return `true` if it reached the end of the combo, `false` if not.\r\n *\r\n * @function Phaser.Input.Keyboard.KeyCombo.AdvanceKeyCombo\r\n * @since 3.0.0\r\n *\r\n * @param {KeyboardEvent} event - [description]\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - [description]\r\n *\r\n * @return {boolean} `true` if it reached the end of the combo, `false` if not.\r\n */var AdvanceKeyCombo=function AdvanceKeyCombo(event,combo){combo.timeLastMatched=event.timeStamp;combo.index++;if(combo.index===combo.size){return true;}else{combo.current=combo.keyCodes[combo.index];return false;}};module.exports=AdvanceKeyCombo;/***/},/* 831 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var AdvanceKeyCombo=__webpack_require__(830);/**\r\n * Used internally by the KeyCombo class.\r\n *\r\n * @function Phaser.Input.Keyboard.KeyCombo.ProcessKeyCombo\r\n * @since 3.0.0\r\n *\r\n * @param {KeyboardEvent} event - [description]\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - [description]\r\n *\r\n * @return {boolean} [description]\r\n */var ProcessKeyCombo=function ProcessKeyCombo(event,combo){if(combo.matched){return true;}var comboMatched=false;var keyMatched=false;if(event.keyCode===combo.current){//  Key was correct\nif(combo.index>0&&combo.maxKeyDelay>0){//  We have to check to see if the delay between\n//  the new key and the old one was too long (if enabled)\nvar timeLimit=combo.timeLastMatched+combo.maxKeyDelay;//  Check if they pressed it in time or not\nif(event.timeStamp<=timeLimit){keyMatched=true;comboMatched=AdvanceKeyCombo(event,combo);}}else{keyMatched=true;//  We don't check the time for the first key pressed, so just advance it\ncomboMatched=AdvanceKeyCombo(event,combo);}}if(!keyMatched&&combo.resetOnWrongKey){//  Wrong key was pressed\ncombo.index=0;combo.current=combo.keyCodes[0];}if(comboMatched){combo.timeLastMatched=event.timeStamp;combo.matched=true;combo.timeMatched=event.timeStamp;}return comboMatched;};module.exports=ProcessKeyCombo;/***/},/* 832 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Determines the full screen support of the browser running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.fullscreen` from within any Scene.\r\n * \r\n * @typedef {object} Phaser.Device.Fullscreen\r\n * @since 3.0.0\r\n * \r\n * @property {boolean} available - Does the browser support the Full Screen API?\r\n * @property {boolean} keyboard - Does the browser support access to the Keyboard during Full Screen mode?\r\n * @property {string} cancel - If the browser supports the Full Screen API this holds the call you need to use to cancel it.\r\n * @property {string} request - If the browser supports the Full Screen API this holds the call you need to use to activate it.\r\n */var Fullscreen={available:false,cancel:'',keyboard:false,request:''};/**\r\n* Checks for support of the Full Screen API.\r\n*/function init(){var i;var fs=['requestFullscreen','requestFullScreen','webkitRequestFullscreen','webkitRequestFullScreen','msRequestFullscreen','msRequestFullScreen','mozRequestFullScreen','mozRequestFullscreen'];var element=document.createElement('div');for(i=0;i<fs.length;i++){if(element[fs[i]]){Fullscreen.available=true;Fullscreen.request=fs[i];break;}}var cfs=['cancelFullScreen','exitFullscreen','webkitCancelFullScreen','webkitExitFullscreen','msCancelFullScreen','msExitFullscreen','mozCancelFullScreen','mozExitFullscreen'];if(Fullscreen.available){for(i=0;i<cfs.length;i++){if(document[cfs[i]]){Fullscreen.cancel=cfs[i];break;}}}//  Keyboard Input?\nif(window['Element']&&Element['ALLOW_KEYBOARD_INPUT']){Fullscreen.keyboard=true;}return Fullscreen;}module.exports=init();/***/},/* 833 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Determines the video support of the browser running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.video` from within any Scene.\r\n * \r\n * @typedef {object} Phaser.Device.Video\r\n * @since 3.0.0\r\n * \r\n * @property {boolean} h264Video - Can this device play h264 mp4 video files?\r\n * @property {boolean} hlsVideo - Can this device play hls video files?\r\n * @property {boolean} mp4Video - Can this device play h264 mp4 video files?\r\n * @property {boolean} oggVideo - Can this device play ogg video files?\r\n * @property {boolean} vp9Video - Can this device play vp9 video files?\r\n * @property {boolean} webmVideo - Can this device play webm video files?\r\n */var Video={h264Video:false,hlsVideo:false,mp4Video:false,oggVideo:false,vp9Video:false,webmVideo:false};function init(){var videoElement=document.createElement('video');var result=!!videoElement.canPlayType;try{if(result){if(videoElement.canPlayType('video/ogg; codecs=\"theora\"').replace(/^no$/,'')){Video.oggVideo=true;}if(videoElement.canPlayType('video/mp4; codecs=\"avc1.42E01E\"').replace(/^no$/,'')){// Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546\nVideo.h264Video=true;Video.mp4Video=true;}if(videoElement.canPlayType('video/webm; codecs=\"vp8, vorbis\"').replace(/^no$/,'')){Video.webmVideo=true;}if(videoElement.canPlayType('video/webm; codecs=\"vp9\"').replace(/^no$/,'')){Video.vp9Video=true;}if(videoElement.canPlayType('application/x-mpegURL; codecs=\"avc1.42E01E\"').replace(/^no$/,'')){Video.hlsVideo=true;}}}catch(e){//  Nothing to do\n}return Video;}module.exports=init();/***/},/* 834 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Browser=__webpack_require__(104);/**\r\n * Determines the audio playback capabilities of the device running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.audio` from within any Scene.\r\n * \r\n * @typedef {object} Phaser.Device.Audio\r\n * @since 3.0.0\r\n * \r\n * @property {boolean} audioData - Can this device play HTML Audio tags?\r\n * @property {boolean} dolby - Can this device play EC-3 Dolby Digital Plus files?\r\n * @property {boolean} m4a - Can this device can play m4a files.\r\n * @property {boolean} mp3 - Can this device play mp3 files?\r\n * @property {boolean} ogg - Can this device play ogg files?\r\n * @property {boolean} opus - Can this device play opus files?\r\n * @property {boolean} wav - Can this device play wav files?\r\n * @property {boolean} webAudio - Does this device have the Web Audio API?\r\n * @property {boolean} webm - Can this device play webm files?\r\n */var Audio={audioData:false,dolby:false,m4a:false,mp3:false,ogg:false,opus:false,wav:false,webAudio:false,webm:false};function init(){Audio.audioData=!!window['Audio'];Audio.webAudio=!!(window['AudioContext']||window['webkitAudioContext']);var audioElement=document.createElement('audio');var result=!!audioElement.canPlayType;try{if(result){if(audioElement.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/,'')){Audio.ogg=true;}if(audioElement.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/,'')||audioElement.canPlayType('audio/opus;').replace(/^no$/,'')){Audio.opus=true;}if(audioElement.canPlayType('audio/mpeg;').replace(/^no$/,'')){Audio.mp3=true;}//  Mimetypes accepted:\n//  developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements\n//  bit.ly/iphoneoscodecs\nif(audioElement.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/,'')){Audio.wav=true;}if(audioElement.canPlayType('audio/x-m4a;')||audioElement.canPlayType('audio/aac;').replace(/^no$/,'')){Audio.m4a=true;}if(audioElement.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/,'')){Audio.webm=true;}if(audioElement.canPlayType('audio/mp4;codecs=\"ec-3\"')!==''){if(Browser.edge){Audio.dolby=true;}else if(Browser.safari&&Browser.safariVersion>=9){if(/Mac OS X (\\d+)_(\\d+)/.test(navigator.userAgent)){var major=parseInt(RegExp.$1,10);var minor=parseInt(RegExp.$2,10);if(major===10&&minor>=11||major>10){Audio.dolby=true;}}}}}}catch(e){//  Nothing to do here\n}return Audio;}module.exports=init();/***/},/* 835 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var OS=__webpack_require__(77);var Browser=__webpack_require__(104);/**\r\n * Determines the input support of the browser running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.input` from within any Scene.\r\n * \r\n * @typedef {object} Phaser.Device.Input\r\n * @since 3.0.0\r\n * \r\n * @property {?string} wheelType - The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'\r\n * @property {boolean} gamepads - Is navigator.getGamepads available?\r\n * @property {boolean} mspointer - Is mspointer available?\r\n * @property {boolean} touch - Is touch available?\r\n */var Input={gamepads:false,mspointer:false,touch:false,wheelEvent:null};function init(){if('ontouchstart'in document.documentElement||navigator.maxTouchPoints&&navigator.maxTouchPoints>=1){Input.touch=true;}if(navigator.msPointerEnabled||navigator.pointerEnabled){Input.mspointer=true;}if(navigator.getGamepads){Input.gamepads=true;}if(!OS.cocoonJS){// See https://developer.mozilla.org/en-US/docs/Web/Events/wheel\nif('onwheel'in window||Browser.ie&&'WheelEvent'in window){// DOM3 Wheel Event: FF 17+, IE 9+, Chrome 31+, Safari 7+\nInput.wheelEvent='wheel';}else if('onmousewheel'in window){// Non-FF legacy: IE 6-9, Chrome 1-31, Safari 5-7.\nInput.wheelEvent='mousewheel';}else if(Browser.firefox&&'MouseScrollEvent'in window){// FF prior to 17. This should probably be scrubbed.\nInput.wheelEvent='DOMMouseScroll';}}return Input;}module.exports=init();/***/},/* 836 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  This singleton is instantiated as soon as Phaser loads,\n//  before a Phaser.Game instance has even been created.\n//  Which means all instances of Phaser Games can share it,\n//  without having to re-poll the device all over again\n/**\r\n * @namespace Phaser.Device\r\n * @since 3.0.0\r\n *//**\r\n * @typedef {object} Phaser.DeviceConf\r\n *\r\n * @property {Phaser.Device.OS} os - The OS Device functions.\r\n * @property {Phaser.Device.Browser} browser - The Browser Device functions.\r\n * @property {Phaser.Device.Features} features - The Features Device functions.\r\n * @property {Phaser.Device.Input} input - The Input Device functions.\r\n * @property {Phaser.Device.Audio} audio - The Audio Device functions.\r\n * @property {Phaser.Device.Video} video - The Video Device functions.\r\n * @property {Phaser.Device.Fullscreen} fullscreen - The Fullscreen Device functions.\r\n * @property {Phaser.Device.CanvasFeatures} canvasFeatures - The Canvas Device functions.\r\n */module.exports={os:__webpack_require__(77),browser:__webpack_require__(104),features:__webpack_require__(152),input:__webpack_require__(835),audio:__webpack_require__(834),video:__webpack_require__(833),fullscreen:__webpack_require__(832),canvasFeatures:__webpack_require__(314)};/***/},/* 837 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(22);/**\r\n * Called automatically by Phaser.Game and responsible for creating the console.log debug header.\r\n *\r\n * You can customize or disable the header via the Game Config object.\r\n *\r\n * @function Phaser.Boot.DebugHeader\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance which will output this debug header.\r\n */var DebugHeader=function DebugHeader(game){var config=game.config;if(config.hideBanner){return;}var renderType='WebGL';if(config.renderType===CONST.CANVAS){renderType='Canvas';}else if(config.renderType===CONST.HEADLESS){renderType='Headless';}var audioConfig=config.audio;var deviceAudio=game.device.audio;var audioType;if(deviceAudio.webAudio&&!(audioConfig&&audioConfig.disableWebAudio)){audioType='Web Audio';}else if(audioConfig&&audioConfig.noAudio||!deviceAudio.webAudio&&!deviceAudio.audioData){audioType='No Audio';}else{audioType='HTML5 Audio';}if(!game.device.browser.ie){var c='';var args=[c];if(Array.isArray(config.bannerBackgroundColor)){var lastColor;config.bannerBackgroundColor.forEach(function(color){c=c.concat('%c ');args.push('background: '+color);lastColor=color;});//  inject the text color\nargs[args.length-1]='color: '+config.bannerTextColor+'; background: '+lastColor;}else{c=c.concat('%c ');args.push('color: '+config.bannerTextColor+'; background: '+config.bannerBackgroundColor);}//  URL link background color (always white)\nargs.push('background: #fff');if(config.gameTitle){c=c.concat(config.gameTitle);if(config.gameVersion){c=c.concat(' v'+config.gameVersion);}if(!config.hidePhaser){c=c.concat(' / ');}}if(!config.hidePhaser){c=c.concat('Phaser v'+CONST.VERSION+' ('+renderType+' | '+audioType+')');}c=c.concat(' %c '+config.gameURL);//  Inject the new string back into the args array\nargs[0]=c;console.log.apply(console,args);}else if(window['console']){console.log('Phaser v'+CONST.VERSION+' / https://phaser.io');}};module.exports=DebugHeader;/***/},/* 838 *//***/function(module,exports){module.exports=\"#define SHADER_NAME PHASER_TEXTURE_TINT_VS\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\nuniform mat4 uProjectionMatrix;\\r\\nuniform mat4 uViewMatrix;\\r\\nuniform mat4 uModelMatrix;\\r\\n\\r\\nattribute vec2 inPosition;\\r\\nattribute vec2 inTexCoord;\\r\\nattribute vec4 inTint;\\r\\n\\r\\nvarying vec2 outTexCoord;\\r\\nvarying vec4 outTint;\\r\\n\\r\\nvoid main () \\r\\n{\\r\\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);\\r\\n    outTexCoord = inTexCoord;\\r\\n    outTint = inTint;\\r\\n}\\r\\n\\r\\n\";/***/},/* 839 *//***/function(module,exports){module.exports=\"#define SHADER_NAME PHASER_TEXTURE_TINT_FS\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\nuniform sampler2D uMainSampler;\\r\\n\\r\\nvarying vec2 outTexCoord;\\r\\nvarying vec4 outTint;\\r\\n\\r\\nvoid main() \\r\\n{\\r\\n    vec4 texel = texture2D(uMainSampler, outTexCoord);\\r\\n    texel *= vec4(outTint.rgb * outTint.a, outTint.a);\\r\\n    gl_FragColor = texel;\\r\\n}\\r\\n\";/***/},/* 840 *//***/function(module,exports){module.exports=\"#define SHADER_NAME PHASER_FORWARD_DIFFUSE_FS\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\nstruct Light\\r\\n{\\r\\n    vec2 position;\\r\\n    vec3 color;\\r\\n    float intensity;\\r\\n    float radius;\\r\\n};\\r\\n\\r\\nconst int kMaxLights = %LIGHT_COUNT%;\\r\\n\\r\\nuniform vec4 uCamera; /* x, y, rotation, zoom */\\r\\nuniform vec2 uResolution;\\r\\nuniform sampler2D uMainSampler;\\r\\nuniform sampler2D uNormSampler;\\r\\nuniform vec3 uAmbientLightColor;\\r\\nuniform Light uLights[kMaxLights];\\r\\n\\r\\nvarying vec2 outTexCoord;\\r\\nvarying vec4 outTint;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\\r\\n    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.rgb * outTint.a, outTint.a);\\r\\n    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;\\r\\n    vec3 normal = normalize(vec3(normalMap * 2.0 - 1.0));\\r\\n    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;\\r\\n\\r\\n    for (int index = 0; index < kMaxLights; ++index)\\r\\n    {\\r\\n        Light light = uLights[index];\\r\\n        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);\\r\\n        vec3 lightNormal = normalize(lightDir);\\r\\n        float distToSurf = length(lightDir) * uCamera.w;\\r\\n        float diffuseFactor = max(dot(normal, lightNormal), 0.0);\\r\\n        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;\\r\\n        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);\\r\\n        vec3 diffuse = light.color * diffuseFactor;\\r\\n        finalColor += (attenuation * diffuse) * light.intensity;\\r\\n    }\\r\\n\\r\\n    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);\\r\\n    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);\\r\\n\\r\\n}\\r\\n\";/***/},/* 841 *//***/function(module,exports){module.exports=\"#define SHADER_NAME PHASER_FLAT_TINT_VS\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\nuniform mat4 uProjectionMatrix;\\r\\nuniform mat4 uViewMatrix;\\r\\nuniform mat4 uModelMatrix;\\r\\n\\r\\nattribute vec2 inPosition;\\r\\nattribute vec4 inTint;\\r\\n\\r\\nvarying vec4 outTint;\\r\\n\\r\\nvoid main () {\\r\\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);\\r\\n    outTint = inTint;\\r\\n}\\r\\n\";/***/},/* 842 *//***/function(module,exports){module.exports=\"#define SHADER_NAME PHASER_FLAT_TINT_FS\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\nvarying vec4 outTint;\\r\\n\\r\\nvoid main() {\\r\\n    gl_FragColor = vec4(outTint.rgb * outTint.a, outTint.a);\\r\\n}\\r\\n\";/***/},/* 843 *//***/function(module,exports){module.exports=\"#define SHADER_NAME PHASER_BITMAP_MASK_VS\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\nattribute vec2 inPosition;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    gl_Position = vec4(inPosition, 0.0, 1.0);\\r\\n}\\r\\n\";/***/},/* 844 *//***/function(module,exports){module.exports=\"#define SHADER_NAME PHASER_BITMAP_MASK_FS\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\nuniform vec2 uResolution;\\r\\nuniform sampler2D uMainSampler;\\r\\nuniform sampler2D uMaskSampler;\\r\\nuniform bool uInvertMaskAlpha;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    vec2 uv = gl_FragCoord.xy / uResolution;\\r\\n    vec4 mainColor = texture2D(uMainSampler, uv);\\r\\n    vec4 maskColor = texture2D(uMaskSampler, uv);\\r\\n    float alpha = mainColor.a;\\r\\n\\r\\n    if (!uInvertMaskAlpha)\\r\\n    {\\r\\n        alpha *= (maskColor.a);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        alpha *= (1.0 - maskColor.a);\\r\\n    }\\r\\n    \\r\\n    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);\\r\\n}\\r\\n\";/***/},/* 845 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CanvasInterpolation=__webpack_require__(325);var CanvasPool=__webpack_require__(23);var CONST=__webpack_require__(22);var Features=__webpack_require__(152);/**\r\n * Called automatically by Phaser.Game and responsible for creating the renderer it will use.\r\n *\r\n * Relies upon two webpack global flags to be defined: `WEBGL_RENDERER` and `CANVAS_RENDERER` during build time, but not at run-time.\r\n *\r\n * @function Phaser.Boot.CreateRenderer\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance on which the renderer will be set.\r\n */var CreateRenderer=function CreateRenderer(game){var config=game.config;//  Game either requested Canvas,\n//  or requested AUTO or WEBGL but the browser doesn't support it, so fall back to Canvas\nif(config.renderType!==CONST.HEADLESS){if(config.renderType===CONST.CANVAS||config.renderType!==CONST.CANVAS&&!Features.webGL){if(Features.canvas){//  They requested Canvas and their browser supports it\nconfig.renderType=CONST.CANVAS;}else{throw new Error('Cannot create Canvas or WebGL context, aborting.');}}else{//  Game requested WebGL and browser says it supports it\nconfig.renderType=CONST.WEBGL;}}//  Pixel Art mode?\nif(config.pixelArt){CanvasPool.disableSmoothing();}//  Does the game config provide its own canvas element to use?\nif(config.canvas){game.canvas=config.canvas;}else{game.canvas=CanvasPool.create(game,config.width,config.height,config.renderType);}//  Does the game config provide some canvas css styles to use?\nif(config.canvasStyle){game.canvas.style=config.canvasStyle;}//  Pixel Art mode?\nif(config.pixelArt){CanvasInterpolation.setCrisp(game.canvas);}//  Zoomed?\nif(config.zoom!==1){game.canvas.style.width=(config.width*config.zoom).toString()+'px';game.canvas.style.height=(config.height*config.zoom).toString()+'px';}if(config.renderType===CONST.HEADLESS){//  Nothing more to do here\nreturn;}var CanvasRenderer;var WebGLRenderer;if(true){CanvasRenderer=__webpack_require__(393);WebGLRenderer=__webpack_require__(388);//  Let the config pick the renderer type, both are included\nif(config.renderType===CONST.WEBGL){game.renderer=new WebGLRenderer(game);game.context=null;}else{game.renderer=new CanvasRenderer(game);game.context=game.renderer.gameContext;}}if(false){}if(false){}};module.exports=CreateRenderer;/***/},/* 846 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var CONST=__webpack_require__(22);var GetValue=__webpack_require__(5);var MATH=__webpack_require__(16);var NOOP=__webpack_require__(3);var Plugins=__webpack_require__(315);var ValueToColor=__webpack_require__(163);/**\r\n * This callback type is completely empty, a no-operation.\r\n *\r\n * @callback NOOP\r\n *//**\r\n * @callback BootCallback\r\n *\r\n * @param {Phaser.Game} game - [description]\r\n *//**\r\n * @typedef {object} FPSConfig\r\n *\r\n * @property {integer} [min=10] - [description]\r\n * @property {integer} [target=60] - [description]\r\n * @property {boolean} [forceSetTimeOut=false] - [description]\r\n * @property {integer} [deltaHistory=10] - [description]\r\n * @property {integer} [panicMax=120] - [description]\r\n *//**\r\n * @typedef {object} LoaderConfig\r\n *\r\n * @property {string} [baseURL] - [description]\r\n * @property {string} [path] - [description]\r\n * @property {boolean} [enableParallel=true] - [description]\r\n * @property {integer} [maxParallelDownloads=4] - [description]\r\n * @property {(string|undefined)} [crossOrigin=undefined] - [description]\r\n * @property {string} [responseType] - [description]\r\n * @property {boolean} [async=true] - [description]\r\n * @property {string} [user] - [description]\r\n * @property {string} [password] - [description]\r\n * @property {integer} [timeout=0] - [description]\r\n *//**\r\n * @typedef {object} GameConfig\r\n *\r\n * @property {(integer|string)} [width=1024] - [description]\r\n * @property {(integer|string)} [height=768] - [description]\r\n * @property {number} [zoom=1] - [description]\r\n * @property {number} [resolution=1] - [description]\r\n * @property {number} [type=CONST.AUTO] - [description]\r\n * @property {*} [parent=null] - [description]\r\n * @property {HTMLCanvasElement} [canvas=null] - [description]\r\n * @property {string} [canvasStyle=null] - [description]\r\n * @property {object} [scene=null] - [description]\r\n * @property {string[]} [seed] - [description]\r\n * @property {string} [title=''] - [description]\r\n * @property {string} [url='http://phaser.io'] - [description]\r\n * @property {string} [version=''] - [description]\r\n * @property {(boolean|object)} [input] - [description]\r\n * @property {boolean} [input.keyboard=true] - [description]\r\n * @property {*} [input.keyboard.target=window] - [description]\r\n * @property {(boolean|object)} [input.mouse=true] - [description]\r\n * @property {*} [input.mouse.target=null] - [description]\r\n * @property {boolean} [input.touch=true] - [description]\r\n * @property {*} [input.touch.target=null] - [description]\r\n * @property {boolean} [input.touch.capture=true] - [description]\r\n * @property {(boolean|object)} [input.gamepad=false] - [description]\r\n * @property {boolean} [disableContextMenu=false] - [description]\r\n * @property {(boolean|object)} [banner=false] - [description]\r\n * @property {boolean} [banner.hidePhaser=false] - [description]\r\n * @property {string} [banner.text='#ffffff'] - [description]\r\n * @property {string[]} [banner.background] - [description]\r\n * @property {FPSConfig} [fps] - [description]\r\n * @property {boolean} [antialias=true] - [description]\r\n * @property {boolean} [pixelArt=false] - [description]\r\n * @property {boolean} [autoResize=false] - [description]\r\n * @property {boolean} [roundPixels=false] - [description]\r\n * @property {boolean} [transparent=false] - [description]\r\n * @property {boolean} [clearBeforeRender=true] - [description]\r\n * @property {boolean} [premultipliedAlpha=true] - [description]\r\n * @property {boolean} [preserveDrawingBuffer=false] - [description]\r\n * @property {boolean} [failIfMajorPerformanceCaveat=false] - [description]\r\n * @property {boolean} [powerPreference='default'] - \"high-performance\", \"low-power\" or \"default\"\r\n * @property {(string|number)} [backgroundColor=0x000000] - [description]\r\n * @property {object} [callbacks] - [description]\r\n * @property {BootCallback} [callbacks.preBoot=NOOP] - [description]\r\n * @property {BootCallback} [callbacks.postBoot=NOOP] - [description]\r\n * @property {LoaderConfig} [loader] - [description]\r\n * @property {object} [images] - [description]\r\n * @property {string} [images.default] - [description]\r\n * @property {string} [images.missing] - [description]\r\n * @property {object} [physics] - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Config\r\n * @memberOf Phaser.Boot\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {GameConfig} [GameConfig] - The configuration object for your Phaser Game instance.\r\n *\r\n */var Config=new Class({initialize:function Config(config){if(config===undefined){config={};}var defaultBannerColor=['#ff0000','#ffff00','#00ff00','#00ffff','#000000'];var defaultBannerTextColor='#ffffff';this.width=GetValue(config,'width',1024);this.height=GetValue(config,'height',768);this.zoom=GetValue(config,'zoom',1);this.resolution=GetValue(config,'resolution',1);this.renderType=GetValue(config,'type',CONST.AUTO);this.parent=GetValue(config,'parent',null);this.canvas=GetValue(config,'canvas',null);this.canvasStyle=GetValue(config,'canvasStyle',null);this.sceneConfig=GetValue(config,'scene',null);this.seed=GetValue(config,'seed',[(Date.now()*Math.random()).toString()]);MATH.RND.init(this.seed);this.gameTitle=GetValue(config,'title','');this.gameURL=GetValue(config,'url','https://phaser.io');this.gameVersion=GetValue(config,'version','');//  Input\nthis.inputKeyboard=GetValue(config,'input.keyboard',true);this.inputKeyboardEventTarget=GetValue(config,'input.keyboard.target',window);this.inputMouse=GetValue(config,'input.mouse',true);this.inputMouseEventTarget=GetValue(config,'input.mouse.target',null);this.inputMouseCapture=GetValue(config,'input.mouse.capture',true);this.inputTouch=GetValue(config,'input.touch',true);this.inputTouchEventTarget=GetValue(config,'input.touch.target',null);this.inputTouchCapture=GetValue(config,'input.touch.capture',true);this.inputGamepad=GetValue(config,'input.gamepad',false);this.disableContextMenu=GetValue(config,'disableContextMenu',false);this.audio=GetValue(config,'audio');//  If you do: { banner: false } it won't display any banner at all\nthis.hideBanner=GetValue(config,'banner',null)===false;this.hidePhaser=GetValue(config,'banner.hidePhaser',false);this.bannerTextColor=GetValue(config,'banner.text',defaultBannerTextColor);this.bannerBackgroundColor=GetValue(config,'banner.background',defaultBannerColor);if(this.gameTitle===''&&this.hidePhaser){this.hideBanner=true;}//  Frame Rate config\n//      fps: {\n//          min: 10,\n//          target: 60,\n//          forceSetTimeOut: false,\n//          deltaHistory: 10\n//     }\nthis.fps=GetValue(config,'fps',null);//  Renderer Settings\n//  These can either be in a `render` object within the Config, or specified on their own\nvar renderConfig=GetValue(config,'render',config);this.antialias=GetValue(renderConfig,'antialias',true);this.pixelArt=GetValue(renderConfig,'pixelArt',false);this.autoResize=GetValue(renderConfig,'autoResize',false);this.roundPixels=GetValue(renderConfig,'roundPixels',false);this.transparent=GetValue(renderConfig,'transparent',false);this.clearBeforeRender=GetValue(renderConfig,'clearBeforeRender',true);this.premultipliedAlpha=GetValue(renderConfig,'premultipliedAlpha',true);this.preserveDrawingBuffer=GetValue(renderConfig,'preserveDrawingBuffer',false);this.failIfMajorPerformanceCaveat=GetValue(renderConfig,'failIfMajorPerformanceCaveat',false);this.powerPreference=GetValue(renderConfig,'powerPreference','default');var bgc=GetValue(config,'backgroundColor',0);this.backgroundColor=ValueToColor(bgc);if(bgc===0&&this.transparent){this.backgroundColor.alpha=0;}//  Callbacks\nthis.preBoot=GetValue(config,'callbacks.preBoot',NOOP);this.postBoot=GetValue(config,'callbacks.postBoot',NOOP);//  Physics\n//  physics: {\n//      system: 'impact',\n//      setBounds: true,\n//      gravity: 0,\n//      cellSize: 64\n//  }\nthis.physics=GetValue(config,'physics',{});this.defaultPhysicsSystem=GetValue(this.physics,'default',false);//  Loader Defaults\nthis.loaderBaseURL=GetValue(config,'loader.baseURL','');this.loaderPath=GetValue(config,'loader.path','');this.loaderEnableParallel=GetValue(config,'loader.enableParallel',true);this.loaderMaxParallelDownloads=GetValue(config,'loader.maxParallelDownloads',4);this.loaderCrossOrigin=GetValue(config,'loader.crossOrigin',undefined);this.loaderResponseType=GetValue(config,'loader.responseType','');this.loaderAsync=GetValue(config,'loader.async',true);this.loaderUser=GetValue(config,'loader.user','');this.loaderPassword=GetValue(config,'loader.password','');this.loaderTimeout=GetValue(config,'loader.timeout',0);//  Scene Plugins\nthis.defaultPlugins=GetValue(config,'plugins',Plugins.DefaultScene);//  Default / Missing Images\nvar pngPrefix='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg';this.defaultImage=GetValue(config,'images.default',pngPrefix+'AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==');this.missingImage=GetValue(config,'images.missing',pngPrefix+'CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==');}});module.exports=Config;/***/},/* 847 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var AddToDOM=__webpack_require__(153);var AnimationManager=__webpack_require__(352);var CacheManager=__webpack_require__(350);var CanvasPool=__webpack_require__(23);var Class=__webpack_require__(0);var Config=__webpack_require__(846);var CreateRenderer=__webpack_require__(845);var DataManager=__webpack_require__(107);var DebugHeader=__webpack_require__(837);var Device=__webpack_require__(836);var DOMContentLoaded=__webpack_require__(319);var EventEmitter=__webpack_require__(14);var InputManager=__webpack_require__(311);var NOOP=__webpack_require__(3);var PluginManager=__webpack_require__(13);var SceneManager=__webpack_require__(299);var SoundManagerCreator=__webpack_require__(295);var TextureManager=__webpack_require__(288);var TimeStep=__webpack_require__(813);var VisibilityHandler=__webpack_require__(812);/**\r\n * @callback GameStepCallback\r\n *//**\r\n * @classdesc\r\n * The Phaser.Game instance is the main controller for the entire Phaser game. It is responsible\r\n * for handling the boot process, parsing the configuration values, creating the renderer,\r\n * and setting-up all of the global Phaser systems, such as sound and input.\r\n * Once that is complete it will start the Scene Manager and then begin the main game loop.\r\n *\r\n * You should generally avoid accessing any of the systems created by Game, and instead use those\r\n * made available to you via the Phaser.Scene Systems class instead.\r\n *\r\n * @class Game\r\n * @memberOf Phaser\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {GameConfig} [GameConfig] - The configuration object for your Phaser Game instance.\r\n */var Game=new Class({initialize:function Game(config){/**\r\n         * The parsed Game Configuration object.\r\n         *\r\n         * The values stored within this object are read-only and should not be changed at run-time.\r\n         *\r\n         * @name Phaser.Game#config\r\n         * @type {Phaser.Boot.Config}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.config=new Config(config);/**\r\n         * A reference to either the Canvas or WebGL Renderer that this Game is using.\r\n         *\r\n         * @name Phaser.Game#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.0.0\r\n         */this.renderer=null;/**\r\n         * A reference to the HTML Canvas Element on which the renderer is drawing.\r\n         *\r\n         * @name Phaser.Game#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */this.canvas=null;/**\r\n         * A reference to the Canvas Rendering Context belonging to the Canvas Element this game is rendering to.\r\n         *\r\n         * @name Phaser.Game#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */this.context=null;/**\r\n         * A flag indicating when this Game instance has finished its boot process.\r\n         *\r\n         * @name Phaser.Game#isBooted\r\n         * @type {boolean}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isBooted=false;/**\r\n         * A flag indicating if this Game is currently running its game step or not.\r\n         *\r\n         * @name Phaser.Game#isRunning\r\n         * @type {boolean}\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.isRunning=false;/**\r\n         * An Event Emitter which is used to broadcast game-level events from the global systems.\r\n         *\r\n         * @name Phaser.Game#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */this.events=new EventEmitter();/**\r\n         * An instance of the Animation Manager.\r\n         *\r\n         * The Animation Manager is a global system responsible for managing all animations used within your game.\r\n         *\r\n         * @name Phaser.Game#anims\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */this.anims=new AnimationManager(this);/**\r\n         * An instance of the Texture Manager.\r\n         *\r\n         * The Texture Manager is a global system responsible for managing all textures being used by your game.\r\n         *\r\n         * @name Phaser.Game#textures\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.0.0\r\n         */this.textures=new TextureManager(this);/**\r\n         * An instance of the Cache Manager.\r\n         *\r\n         * The Cache Manager is a global system responsible for caching, accessing and releasing external game assets.\r\n         *\r\n         * @name Phaser.Game#cache\r\n         * @type {Phaser.Cache.CacheManager}\r\n         * @since 3.0.0\r\n         */this.cache=new CacheManager(this);/**\r\n         * An instance of the Data Manager\r\n         *\r\n         * @name Phaser.Game#registry\r\n         * @type {Phaser.Data.DataManager}\r\n         * @since 3.0.0\r\n         */this.registry=new DataManager(this);/**\r\n         * An instance of the Input Manager.\r\n         *\r\n         * The Input Manager is a global system responsible for the capture of browser-level input events.\r\n         *\r\n         * @name Phaser.Game#input\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */this.input=new InputManager(this,this.config);/**\r\n         * An instance of the Scene Manager.\r\n         *\r\n         * The Scene Manager is a global system responsible for creating, modifying and updating the Scenes in your game.\r\n         *\r\n         * @name Phaser.Game#scene\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @since 3.0.0\r\n         */this.scene=new SceneManager(this,this.config.sceneConfig);/**\r\n         * A reference to the Device inspector.\r\n         *\r\n         * Contains information about the device running this game, such as OS, browser vendor and feature support.\r\n         * Used by various systems to determine capabilities and code paths.\r\n         *\r\n         * @name Phaser.Game#device\r\n         * @type {Phaser.DeviceConf}\r\n         * @since 3.0.0\r\n         */this.device=Device;/**\r\n         * An instance of the base Sound Manager.\r\n         *\r\n         * The Sound Manager is a global system responsible for the playback and updating of all audio in your game.\r\n         *\r\n         * @name Phaser.Game#sound\r\n         * @type {Phaser.Sound.BaseSoundManager}\r\n         * @since 3.0.0\r\n         */this.sound=SoundManagerCreator.create(this);/**\r\n         * An instance of the Time Step.\r\n         *\r\n         * The Time Step is a global system responsible for setting-up and responding to the browser frame events, processing\r\n         * them and calculating delta values. It then automatically calls the game step.\r\n         *\r\n         * @name Phaser.Game#loop\r\n         * @type {Phaser.Boot.TimeStep}\r\n         * @since 3.0.0\r\n         */this.loop=new TimeStep(this,this.config.fps);/**\r\n         * An instance of the Plugin Manager.\r\n         *\r\n         * The Plugin Manager is a global system that allows plugins to register themselves with it, and can then install\r\n         * those plugins into Scenes as required.\r\n         *\r\n         * @name Phaser.Game#plugins\r\n         * @type {Phaser.Boot.PluginManager}\r\n         * @since 3.0.0\r\n         */this.plugins=new PluginManager(this,this.config);/**\r\n         * The `onStepCallback` is a callback that is fired each time the Time Step ticks.\r\n         * It is set automatically when the Game boot process has completed.\r\n         *\r\n         * @name Phaser.Game#onStepCallback\r\n         * @type {GameStepCallback}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.onStepCallback=NOOP;//  Wait for the DOM Ready event, then call boot.\nDOMContentLoaded(this.boot.bind(this));},/**\r\n     * Game boot event.\r\n     *\r\n     * This is an internal event dispatched when the game has finished booting, but before it is ready to start running.\r\n     * The global systems use this event to know when to set themselves up, dispatching their own `ready` events as required.\r\n     *\r\n     * @event Phaser.Game#boot\r\n     *//**\r\n     * This method is called automatically when the DOM is ready. It is responsible for creating the renderer,\r\n     * displaying the Debug Header, adding the game canvas to the DOM and emitting the 'boot' event.\r\n     * It listens for a 'ready' event from the base systems and once received it will call `Game.start`.\r\n     *\r\n     * @method Phaser.Game#boot\r\n     * @protected\r\n     * @fires Phaser.Game#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){this.isBooted=true;this.config.preBoot(this);CreateRenderer(this);DebugHeader(this);AddToDOM(this.canvas,this.config.parent);this.events.emit('boot');//  The Texture Manager has to wait on a couple of non-blocking events before it's fully ready, so it will emit this event\nthis.events.once('ready',this.start,this);},/**\r\n     * Called automatically by Game.boot once all of the global systems have finished setting themselves up.\r\n     * By this point the Game is now ready to start the main loop running.\r\n     * It will also enable the Visibility Handler.\r\n     *\r\n     * @method Phaser.Game#start\r\n     * @protected\r\n     * @since 3.0.0\r\n     */start:function start(){this.isRunning=true;this.config.postBoot(this);if(this.renderer){this.loop.start(this.step.bind(this));}else{this.loop.start(this.headlessStep.bind(this));}VisibilityHandler(this.events);this.events.on('hidden',this.onHidden,this);this.events.on('visible',this.onVisible,this);this.events.on('blur',this.onBlur,this);this.events.on('focus',this.onFocus,this);},/**\r\n     * Game Pre-Render event.\r\n     *\r\n     * This event is dispatched immediately before any of the Scenes have started to render.\r\n     * The renderer will already have been initialized this frame, clearing itself and preparing to receive\r\n     * the Scenes for rendering, but it won't have actually drawn anything yet.\r\n     *\r\n     * @event Phaser.Game#prerenderEvent\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - A reference to the current renderer.\r\n     *//**\r\n     * Game Post-Render event.\r\n     *\r\n     * This event is dispatched right at the end of the render process.\r\n     * Every Scene will have rendered and drawn to the canvas.\r\n     *\r\n     * @event Phaser.Game#postrenderEvent\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - A reference to the current renderer.\r\n     *//**\r\n     * The main Game Step. Called automatically by the Time Step, once per browser frame (typically as a result of\r\n     * Request Animation Frame, or Set Timeout on very old browsers.)\r\n     *\r\n     * The step will update the global managers first, then proceed to update each Scene in turn, via the Scene Manager.\r\n     *\r\n     * It will then render each Scene in turn, via the Renderer. This process emits `prerender` and `postrender` events.\r\n     *\r\n     * @method Phaser.Game#step\r\n     * @fires Phaser.Game#prerenderEvent\r\n     * @fires Phaser.Game#postrenderEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */step:function step(time,delta){//  Global Managers\nthis.input.update(time,delta);this.sound.update(time,delta);//  Scenes\nthis.onStepCallback();this.scene.update(time,delta);//  Render\nvar renderer=this.renderer;renderer.preRender();this.events.emit('prerender',renderer);this.scene.render(renderer);renderer.postRender();this.events.emit('postrender',renderer);},/**\r\n     * A special version of the Game Step for the HEADLESS renderer only.\r\n     *\r\n     * The main Game Step. Called automatically by the Time Step, once per browser frame (typically as a result of\r\n     * Request Animation Frame, or Set Timeout on very old browsers.)\r\n     *\r\n     * The step will update the global managers first, then proceed to update each Scene in turn, via the Scene Manager.\r\n     *\r\n     * This process emits `prerender` and `postrender` events, even though nothing actually displays.\r\n     *\r\n     * @method Phaser.Game#headlessStep\r\n     * @fires Phaser.Game#prerenderEvent\r\n     * @fires Phaser.Game#postrenderEvent\r\n     * @since 3.2.0\r\n     *\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */headlessStep:function headlessStep(time,delta){//  Global Managers\nthis.input.update(time,delta);this.sound.update(time,delta);//  Scenes\nthis.onStepCallback();this.scene.update(time,delta);//  Render\nthis.events.emit('prerender');this.events.emit('postrender');},/**\r\n     * Game Pause event.\r\n     *\r\n     * This event is dispatched when the game loop enters a paused state, usually as a result of the Visibility Handler.\r\n     *\r\n     * @event Phaser.Game#pauseEvent\r\n     *//**\r\n     * Called automatically by the Visibility Handler.\r\n     * This will pause the main loop and then emit a pause event.\r\n     *\r\n     * @method Phaser.Game#onHidden\r\n     * @protected\r\n     * @fires Phaser.Game#pauseEvent\r\n     * @since 3.0.0\r\n     */onHidden:function onHidden(){this.loop.pause();this.events.emit('pause');},/**\r\n     * Game Resume event.\r\n     *\r\n     * This event is dispatched when the game loop leaves a paused state and resumes running.\r\n     *\r\n     * @event Phaser.Game#resumeEvent\r\n     *//**\r\n     * Called automatically by the Visibility Handler.\r\n     * This will resume the main loop and then emit a resume event.\r\n     *\r\n     * @method Phaser.Game#onVisible\r\n     * @protected\r\n     * @fires Phaser.Game#resumeEvent\r\n     * @since 3.0.0\r\n     */onVisible:function onVisible(){this.loop.resume();this.events.emit('resume');},/**\r\n     * Called automatically by the Visibility Handler.\r\n     * This will set the main loop into a 'blurred' state, which pauses it.\r\n     *\r\n     * @method Phaser.Game#onBlur\r\n     * @protected\r\n     * @since 3.0.0\r\n     */onBlur:function onBlur(){this.loop.blur();},/**\r\n     * Called automatically by the Visibility Handler.\r\n     * This will set the main loop into a 'focused' state, which resumes it.\r\n     *\r\n     * @method Phaser.Game#onFocus\r\n     * @protected\r\n     * @since 3.0.0\r\n     */onFocus:function onFocus(){this.loop.focus();},/**\r\n     * Game Resize event.\r\n     *\r\n     * @event Phaser.Game#resizeEvent\r\n     * @param {number} width - The new width of the Game.\r\n     * @param {number} height - The new height of the Game.\r\n     *//**\r\n     * Updates the Game Config with the new width and height values given.\r\n     * Then resizes the Renderer and Input Manager scale.\r\n     *\r\n     * @method Phaser.Game#resize\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     */resize:function resize(width,height){this.config.width=width;this.config.height=height;this.renderer.resize(width,height);this.input.resize();this.scene.resize(width,height);this.events.emit('resize',width,height);},/**\r\n     * Destroys this Phaser.Game instance, all global systems, all sub-systems and all Scenes.\r\n     *\r\n     * @method Phaser.Game#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(removeCanvas){this.loop.destroy();this.scene.destroy();if(this.renderer){this.renderer.destroy();}this.events.emit('destroy');this.events.removeAllListeners();this.onStepCallback=null;if(removeCanvas&&this.canvas){CanvasPool.remove(this.canvas);}}});module.exports=Game;/***/},/* 848 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var EE=__webpack_require__(14);var PluginManager=__webpack_require__(13);/**\r\n * @namespace Phaser.Events\r\n *//**\r\n * @classdesc\r\n * EventEmitter is a Scene Systems plugin compatible version of eventemitter3.\r\n *\r\n * @class EventEmitter\r\n * @memberOf Phaser.Events\r\n * @constructor\r\n * @since 3.0.0\r\n */var EventEmitter=new Class({Extends:EE,initialize:function EventEmitter(){EE.call(this);},/**\r\n     * Removes all listeners.\r\n     *\r\n     * @method Phaser.Events.EventEmitter#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.removeAllListeners();},/**\r\n     * Removes all listeners.\r\n     *\r\n     * @method Phaser.Events.EventEmitter#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.removeAllListeners();}});/**\r\n * Return an array listing the events for which the emitter has registered listeners.\r\n *\r\n * @method Phaser.Events.EventEmitter#eventNames\r\n * @since 3.0.0\r\n *\r\n * @return {array}\r\n *//**\r\n * Return the listeners registered for a given event.\r\n *\r\n * @method Phaser.Events.EventEmitter#listeners\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} event - The event name.\r\n *\r\n * @return {array} The registered listeners.\r\n *//**\r\n * Return the number of listeners listening to a given event.\r\n *\r\n * @method Phaser.Events.EventEmitter#listenerCount\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} event - The event name.\r\n *\r\n * @return {number} The number of listeners.\r\n *//**\r\n * Calls each of the listeners registered for a given event.\r\n *\r\n * @method Phaser.Events.EventEmitter#emit\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} event - The event name.\r\n * @param {...*} [args] - Additional arguments that will be passed to the event handler.\r\n *\r\n * @return {boolean} `true` if the event had listeners, else `false`.\r\n *//**\r\n * Add a listener for a given event.\r\n *\r\n * @method Phaser.Events.EventEmitter#on\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} event - The event name.\r\n * @param {function} fn - The listener function.\r\n * @param {*} [context=this] - The context to invoke the listener with.\r\n *\r\n * @return {Phaser.Events.EventEmitter} `this`.\r\n *//**\r\n * Add a listener for a given event.\r\n *\r\n * @method Phaser.Events.EventEmitter#addListener\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} event - The event name.\r\n * @param {function} fn - The listener function.\r\n * @param {*} [context=this] - The context to invoke the listener with.\r\n *\r\n * @return {Phaser.Events.EventEmitter} `this`.\r\n *//**\r\n * Add a one-time listener for a given event.\r\n *\r\n * @method Phaser.Events.EventEmitter#once\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} event - The event name.\r\n * @param {function} fn - The listener function.\r\n * @param {*} [context=this] - The context to invoke the listener with.\r\n *\r\n * @return {Phaser.Events.EventEmitter} `this`.\r\n *//**\r\n * Remove the listeners of a given event.\r\n *\r\n * @method Phaser.Events.EventEmitter#removeListener\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} event - The event name.\r\n * @param {function} fn - Only remove the listeners that match this function.\r\n * @param {*} context - Only remove the listeners that have this context.\r\n * @param {boolean} once - Only remove one-time listeners.\r\n *\r\n * @return {Phaser.Events.EventEmitter} `this`.\r\n *//**\r\n * Remove the listeners of a given event.\r\n *\r\n * @method Phaser.Events.EventEmitter#off\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} event - The event name.\r\n * @param {function} fn - Only remove the listeners that match this function.\r\n * @param {*} context - Only remove the listeners that have this context.\r\n * @param {boolean} once - Only remove one-time listeners.\r\n *\r\n * @return {Phaser.Events.EventEmitter} `this`.\r\n *//**\r\n * Remove all listeners, or those of the specified event.\r\n *\r\n * @method Phaser.Events.EventEmitter#removeAllListeners\r\n * @since 3.0.0\r\n *\r\n * @param {(string|symbol)} [event] - The event name.\r\n *\r\n * @return {Phaser.Events.EventEmitter} `this`.\r\n */PluginManager.register('EventEmitter',EventEmitter,'events');module.exports=EventEmitter;/***/},/* 849 *//***/function(module,exports){// shim for using process in browser\nvar process=module.exports={};// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}(function(){try{if(typeof setTimeout==='function'){cachedSetTimeout=setTimeout;}else{cachedSetTimeout=defaultSetTimout;}}catch(e){cachedSetTimeout=defaultSetTimout;}try{if(typeof clearTimeout==='function'){cachedClearTimeout=clearTimeout;}else{cachedClearTimeout=defaultClearTimeout;}}catch(e){cachedClearTimeout=defaultClearTimeout;}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations\nreturn setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined\nif((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness\nreturn cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\nreturn cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\nreturn cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations\nreturn clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined\nif((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness\nreturn cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\nreturn cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n// Some versions of I.E. have different rules for clearTimeout vs setTimeout\nreturn cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else{queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}};// v8 likes predictible objects\nfunction Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};process.title='browser';process.browser=true;process.env={};process.argv=[];process.version='';// empty string to avoid regexp issues\nprocess.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return[];};process.binding=function(name){throw new Error('process.binding is not supported');};process.cwd=function(){return'/';};process.chdir=function(dir){throw new Error('process.chdir is not supported');};process.umask=function(){return 0;};/***/},/* 850 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.DOM\r\n */module.exports={AddToDOM:__webpack_require__(153),DOMContentLoaded:__webpack_require__(319),ParseXML:__webpack_require__(318),RemoveFromDOM:__webpack_require__(317),RequestAnimationFrame:__webpack_require__(316)};/***/},/* 851 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class GeometryMask\r\n * @memberOf Phaser.Display.Masks\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {Phaser.GameObjects.Graphics} graphicsGeometry - [description]\r\n */var GeometryMask=new Class({initialize:function GeometryMask(scene,graphicsGeometry){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#geometryMask\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */this.geometryMask=graphicsGeometry;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#setShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphicsGeometry - [description]\r\n     */setShape:function setShape(graphicsGeometry){this.geometryMask=graphicsGeometry;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#preRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     * @param {Phaser.GameObjects.GameObject} mask - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */preRenderWebGL:function preRenderWebGL(renderer,mask,camera){var gl=renderer.gl;var geometryMask=this.geometryMask;// Force flushing before drawing to stencil buffer\nrenderer.flush();// Enable and setup GL state to write to stencil buffer\ngl.enable(gl.STENCIL_TEST);gl.clear(gl.STENCIL_BUFFER_BIT);gl.colorMask(false,false,false,false);gl.stencilFunc(gl.NOTEQUAL,1,1);gl.stencilOp(gl.REPLACE,gl.REPLACE,gl.REPLACE);// Write stencil buffer\ngeometryMask.renderWebGL(renderer,geometryMask,0.0,camera);renderer.flush();// Use stencil buffer to affect next rendering object\ngl.colorMask(true,true,true,true);gl.stencilFunc(gl.EQUAL,1,1);gl.stencilOp(gl.INVERT,gl.INVERT,gl.INVERT);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#postRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     */postRenderWebGL:function postRenderWebGL(renderer){var gl=renderer.gl;// Force flush before disabling stencil test\nrenderer.flush();gl.disable(gl.STENCIL_TEST);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#preRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     * @param {Phaser.GameObjects.GameObject} mask - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */preRenderCanvas:function preRenderCanvas(renderer,mask,camera){var geometryMask=this.geometryMask;renderer.currentContext.save();geometryMask.renderCanvas(renderer,geometryMask,0.0,camera,undefined,null,true);renderer.currentContext.clip();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#postRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     */postRenderCanvas:function postRenderCanvas(renderer){renderer.currentContext.restore();}});module.exports=GeometryMask;/***/},/* 852 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class BitmapMask\r\n * @memberOf Phaser.Display.Masks\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {Phaser.GameObjects.GameObject} renderable - A renderable Game Object that uses a texture, such as a Sprite.\r\n */var BitmapMask=new Class({initialize:function BitmapMask(scene,renderable){var renderer=scene.sys.game.renderer;/**\r\n         * A renderable Game Object that uses a texture, such as a Sprite.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#bitmapMask\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */this.bitmapMask=renderable;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#maskTexture\r\n         * @type {WebGLTexture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.maskTexture=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#mainTexture\r\n         * @type {WebGLTexture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.mainTexture=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#dirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.dirty=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#mainFramebuffer\r\n         * @type {WebGLFramebuffer}\r\n         * @since 3.0.0\r\n         */this.mainFramebuffer=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#maskFramebuffer\r\n         * @type {WebGLFramebuffer}\r\n         * @since 3.0.0\r\n         */this.maskFramebuffer=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#invertAlpha\r\n         * @type {boolean}\r\n         * @since 3.1.2\r\n         */this.invertAlpha=false;if(renderer&&renderer.gl){var width=renderer.width;var height=renderer.height;var pot=(width&width-1)===0&&(height&height-1)===0;var gl=renderer.gl;var wrap=pot?gl.REPEAT:gl.CLAMP_TO_EDGE;var filter=gl.LINEAR;this.mainTexture=renderer.createTexture2D(0,filter,filter,wrap,wrap,gl.RGBA,null,width,height);this.maskTexture=renderer.createTexture2D(0,filter,filter,wrap,wrap,gl.RGBA,null,width,height);this.mainFramebuffer=renderer.createFramebuffer(width,height,this.mainTexture,false);this.maskFramebuffer=renderer.createFramebuffer(width,height,this.maskTexture,false);renderer.onContextRestored(function(renderer){var width=renderer.width;var height=renderer.height;var pot=(width&width-1)===0&&(height&height-1)===0;var gl=renderer.gl;var wrap=pot?gl.REPEAT:gl.CLAMP_TO_EDGE;var filter=gl.LINEAR;this.mainTexture=renderer.createTexture2D(0,filter,filter,wrap,wrap,gl.RGBA,null,width,height);this.maskTexture=renderer.createTexture2D(0,filter,filter,wrap,wrap,gl.RGBA,null,width,height);this.mainFramebuffer=renderer.createFramebuffer(width,height,this.mainTexture,false);this.maskFramebuffer=renderer.createFramebuffer(width,height,this.maskTexture,false);},this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#setBitmap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} renderable - A renderable Game Object that uses a texture, such as a Sprite.\r\n     */setBitmap:function setBitmap(renderable){this.bitmapMask=renderable;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#preRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     * @param {Phaser.GameObjects.GameObject} maskedObject - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to render to.\r\n     */preRenderWebGL:function preRenderWebGL(renderer,maskedObject,camera){renderer.pipelines.BitmapMaskPipeline.beginMask(this,maskedObject,camera);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#postRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     */postRenderWebGL:function postRenderWebGL(renderer){renderer.pipelines.BitmapMaskPipeline.endMask(this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#preRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     * @param {Phaser.GameObjects.GameObject} mask - [description]\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to render to.\r\n     */preRenderCanvas:function preRenderCanvas(){// NOOP\n},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#postRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - [description]\r\n     */postRenderCanvas:function postRenderCanvas(){// NOOP\n}});module.exports=BitmapMask;/***/},/* 853 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Display.Masks\r\n */module.exports={BitmapMask:__webpack_require__(852),GeometryMask:__webpack_require__(851)};/***/},/* 854 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ComponentToHex=__webpack_require__(323);/**\r\n * Converts the color values into an HTML compatible color string, prefixed with either `#` or `0x`.\r\n *\r\n * @function Phaser.Display.Color.RGBToString\r\n * @since 3.0.0\r\n *\r\n * @param {integer} r - The red color value. A number between 0 and 255.\r\n * @param {integer} g - The green color value. A number between 0 and 255.\r\n * @param {integer} b - The blue color value. A number between 0 and 255.\r\n * @param {integer} [a=255] - The alpha value. A number between 0 and 255.\r\n * @param {string} [prefix=#] - The prefix of the string. Either `#` or `0x`.\r\n *\r\n * @return {string} A string-based representation of the color values.\r\n */var RGBToString=function RGBToString(r,g,b,a,prefix){if(a===undefined){a=255;}if(prefix===undefined){prefix='#';}if(prefix==='#'){return'#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);}else{return'0x'+ComponentToHex(a)+ComponentToHex(r)+ComponentToHex(g)+ComponentToHex(b);}};module.exports=RGBToString;/***/},/* 855 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} HSLColorObject\r\n *\r\n * @property {number} h - The hue color value. A number between 0 and 1\r\n * @property {number} s - The saturation color value. A number between 0 and 1\r\n * @property {number} l - The lightness color value. A number between 0 and 1\r\n *//**\r\n * Converts an RGB color value to HSV (hue, saturation and value).\r\n * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\r\n * Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].\r\n * Based on code by Michael Jackson (https://github.com/mjijackson)\r\n *\r\n * @function Phaser.Display.Color.RGBToHSV\r\n * @since 3.0.0\r\n *\r\n * @param {integer} r - The red color value. A number between 0 and 255.\r\n * @param {integer} g - The green color value. A number between 0 and 255.\r\n * @param {integer} b - The blue color value. A number between 0 and 255.\r\n *\r\n * @return {HSLColorObject} An object with the properties `h`, `s` and `v`.\r\n */var RGBToHSV=function RGBToHSV(r,g,b){r/=255;g/=255;b/=255;var min=Math.min(r,g,b);var max=Math.max(r,g,b);var d=max-min;// achromatic by default\nvar h=0;var s=max===0?0:d/max;var v=max;if(max!==min){if(max===r){h=(g-b)/d+(g<b?6:0);}else if(max===g){h=(b-r)/d+2;}else if(max===b){h=(r-g)/d+4;}h/=6;}return{h:h,s:s,v:v};};module.exports=RGBToHSV;/***/},/* 856 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Between=__webpack_require__(320);var Color=__webpack_require__(42);/**\r\n * Creates a new Color object where the r, g, and b values have been set to random values\r\n * based on the given min max values.\r\n *\r\n * @function Phaser.Display.Color.RandomRGB\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [min=0] - The minimum value to set the random range from (between 0 and 255)\r\n * @param {integer} [max=255] - The maximum value to set the random range from (between 0 and 255)\r\n *\r\n * @return {Phaser.Display.Color} A Color object.\r\n */var RandomRGB=function RandomRGB(min,max){if(min===undefined){min=0;}if(max===undefined){max=255;}return new Color(Between(min,max),Between(min,max),Between(min,max));};module.exports=RandomRGB;/***/},/* 857 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Linear=__webpack_require__(154);/**\r\n * Interpolates color values\r\n *\r\n * @namespace Phaser.Display.Color.Interpolate\r\n * @since 3.0.0\r\n *//**\r\n * Interpolates between the two given color ranges over the length supplied.\r\n *\r\n * @function Phaser.Display.Color.Interpolate.RGBWithRGB\r\n * @since 3.0.0\r\n *\r\n * @param {number} r1 - Red value.\r\n * @param {number} g1 - Blue value.\r\n * @param {number} b1 - Green value.\r\n * @param {number} r2 - Red value.\r\n * @param {number} g2 - Blue value.\r\n * @param {number} b2 - Green value.\r\n * @param {number} [length=100] - Distance to interpolate over.\r\n * @param {number} [index=0] - Index to start from.\r\n *\r\n * @return {ColorObject} An object containing the interpolated color values.\r\n */var RGBWithRGB=function RGBWithRGB(r1,g1,b1,r2,g2,b2,length,index){if(length===undefined){length=100;}if(index===undefined){index=0;}var t=index/length;return{r:Linear(r1,r2,t),g:Linear(g1,g2,t),b:Linear(b1,b2,t)};};/**\r\n * Interpolates between the two given color objects over the length supplied.\r\n *\r\n * @function Phaser.Display.Color.Interpolate.ColorWithColor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Display.Color} color1 - The first Color object.\r\n * @param {Phaser.Display.Color} color2 - The second Color object.\r\n * @param {number} [length=100] - Distance to interpolate over.\r\n * @param {number} [index=0] - Index to start from.\r\n *\r\n * @return {ColorObject} An object containing the interpolated color values.\r\n */var ColorWithColor=function ColorWithColor(color1,color2,length,index){if(length===undefined){length=100;}if(index===undefined){index=0;}return RGBWithRGB(color1.r,color1.g,color1.b,color2.r,color2.g,color2.b,length,index);};/**\r\n * Interpolates between the Color object and color values over the length supplied.\r\n *\r\n * @function Phaser.Display.Color.Interpolate.ColorWithRGB\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Display.Color} color1 - The first Color object.\r\n * @param {number} r - Red value.\r\n * @param {number} g - Blue value.\r\n * @param {number} b - Green value.\r\n * @param {number} [length=100] - Distance to interpolate over.\r\n * @param {number} [index=0] - Index to start from.\r\n *\r\n * @return {ColorObject} An object containing the interpolated color values.\r\n */var ColorWithRGB=function ColorWithRGB(color,r,g,b,length,index){if(length===undefined){length=100;}if(index===undefined){index=0;}return RGBWithRGB(color.r,color.g,color.b,r,g,b,length,index);};module.exports={RGBWithRGB:RGBWithRGB,ColorWithRGB:ColorWithRGB,ColorWithColor:ColorWithColor};/***/},/* 858 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var HSVToRGB=__webpack_require__(321);/**\r\n * Get HSV color wheel values in an array which will be 360 elements in size.\r\n *\r\n * @function Phaser.Display.Color.HSVColorWheel\r\n * @since 3.0.0\r\n *\r\n * @param {number} [s=1] - The saturation, in the range 0 - 1.\r\n * @param {number} [v=1] - The value, in the range 0 - 1.\r\n *\r\n * @return {array} An array containing 360 elements, where each contains a single numeric value corresponding to the color at that point in the HSV color wheel.\r\n */var HSVColorWheel=function HSVColorWheel(s,v){if(s===undefined){s=1;}if(v===undefined){v=1;}var colors=[];for(var c=0;c<=359;c++){colors.push(HSVToRGB(c/359,s,v));}return colors;};module.exports=HSVColorWheel;/***/},/* 859 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Color=__webpack_require__(42);var HueToComponent=__webpack_require__(322);/**\r\n * Converts HSL (hue, saturation and lightness) values to a Phaser Color object.\r\n *\r\n * @function Phaser.Display.Color.HSLToColor\r\n * @since 3.0.0\r\n *\r\n * @param {number} h - The hue value in the range 0 to 1.\r\n * @param {number} s - The saturation value in the range 0 to 1.\r\n * @param {number} l - The lightness value in the range 0 to 1.\r\n *\r\n * @return {Phaser.Display.Color} A Color object created from the results of the h, s and l values.\r\n */var HSLToColor=function HSLToColor(h,s,l){// achromatic by default\nvar r=l;var g=l;var b=l;if(s!==0){var q=l<0.5?l*(1+s):l+s-l*s;var p=2*l-q;r=HueToComponent(p,q,h+1/3);g=HueToComponent(p,q,h);b=HueToComponent(p,q,h-1/3);}var color=new Color();return color.setGLTo(r,g,b,1);};module.exports=HSLToColor;/***/},/* 860 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Converts the given color value into an Object containing r,g,b and a properties.\r\n *\r\n * @function Phaser.Display.Color.ColorToRGBA\r\n * @since 3.0.0\r\n *\r\n * @param {number} color - A color value, optionally including the alpha value.\r\n *\r\n * @return {ColorObject} An object containing the parsed color values.\r\n */var ColorToRGBA=function ColorToRGBA(color){var output={r:color>>16&0xFF,g:color>>8&0xFF,b:color&0xFF,a:255};if(color>16777215){output.a=color>>>24;}return output;};module.exports=ColorToRGBA;/***/},/* 861 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.\r\n *\r\n * @function Phaser.Display.Canvas.UserSelect\r\n * @since 3.0.0\r\n *\r\n * @param {HTMLCanvasElement} canvas - The canvas element to have the style applied to.\r\n * @param {string} [value='none'] - The touch callout value to set on the canvas. Set to `none` to disable touch callouts.\r\n *\r\n * @return {HTMLCanvasElement} The canvas element.\r\n */var UserSelect=function UserSelect(canvas,value){if(value===undefined){value='none';}var vendors=['-webkit-','-khtml-','-moz-','-ms-',''];vendors.forEach(function(vendor){canvas.style[vendor+'user-select']=value;});canvas.style['-webkit-touch-callout']=value;canvas.style['-webkit-tap-highlight-color']='rgba(0, 0, 0, 0)';return canvas;};module.exports=UserSelect;/***/},/* 862 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.\r\n *\r\n * @function Phaser.Display.Canvas.TouchAction\r\n * @since 3.0.0\r\n *\r\n * @param {HTMLCanvasElement} canvas - The canvas element to have the style applied to.\r\n * @param {string} [value='none'] - The touch action value to set on the canvas. Set to `none` to disable touch actions.\r\n *\r\n * @return {HTMLCanvasElement} The canvas element.\r\n */var TouchAction=function TouchAction(canvas,value){if(value===undefined){value='none';}canvas.style['msTouchAction']=value;canvas.style['ms-touch-action']=value;canvas.style['touch-action']=value;return canvas;};module.exports=TouchAction;/***/},/* 863 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Display.Canvas\r\n */module.exports={Interpolation:__webpack_require__(325),Pool:__webpack_require__(23),Smoothing:__webpack_require__(158),TouchAction:__webpack_require__(862),UserSelect:__webpack_require__(861)};/***/},/* 864 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the amount the Game Object is visually offset from its y coordinate.\r\n * This is the same as `width * origin.y`.\r\n * This value will only be > 0 if `origin.y` is not equal to zero.\r\n *\r\n * @function Phaser.Display.Bounds.GetOffsetY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to get the bounds value from.\r\n *\r\n * @return {number} The vertical offset of the Game Object.\r\n */var GetOffsetY=function GetOffsetY(gameObject){return gameObject.height*gameObject.originY;};module.exports=GetOffsetY;/***/},/* 865 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Returns the amount the Game Object is visually offset from its x coordinate.\r\n * This is the same as `width * origin.x`.\r\n * This value will only be > 0 if `origin.x` is not equal to zero.\r\n *\r\n * @function Phaser.Display.Bounds.GetOffsetX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to get the bounds value from.\r\n *\r\n * @return {number} The horizontal offset of the Game Object.\r\n */var GetOffsetX=function GetOffsetX(gameObject){return gameObject.width*gameObject.originX;};module.exports=GetOffsetX;/***/},/* 866 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Display.Bounds\r\n */module.exports={CenterOn:__webpack_require__(374),GetBottom:__webpack_require__(36),GetCenterX:__webpack_require__(63),GetCenterY:__webpack_require__(60),GetLeft:__webpack_require__(34),GetOffsetX:__webpack_require__(865),GetOffsetY:__webpack_require__(864),GetRight:__webpack_require__(32),GetTop:__webpack_require__(30),SetBottom:__webpack_require__(35),SetCenterX:__webpack_require__(62),SetCenterY:__webpack_require__(61),SetLeft:__webpack_require__(33),SetRight:__webpack_require__(31),SetTop:__webpack_require__(29)};/***/},/* 867 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetRight=__webpack_require__(32);var GetTop=__webpack_require__(30);var SetBottom=__webpack_require__(35);var SetRight=__webpack_require__(31);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the top right position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.TopRight\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var TopRight=function TopRight(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetRight(gameObject,GetRight(alignTo)+offsetX);SetBottom(gameObject,GetTop(alignTo)-offsetY);return gameObject;};module.exports=TopRight;/***/},/* 868 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetLeft=__webpack_require__(34);var GetTop=__webpack_require__(30);var SetBottom=__webpack_require__(35);var SetLeft=__webpack_require__(33);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the top left position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.TopLeft\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var TopLeft=function TopLeft(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetLeft(gameObject,GetLeft(alignTo)-offsetX);SetBottom(gameObject,GetTop(alignTo)-offsetY);return gameObject;};module.exports=TopLeft;/***/},/* 869 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetCenterX=__webpack_require__(63);var GetTop=__webpack_require__(30);var SetBottom=__webpack_require__(35);var SetCenterX=__webpack_require__(62);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the top center position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.TopCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var TopCenter=function TopCenter(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetCenterX(gameObject,GetCenterX(alignTo)+offsetX);SetBottom(gameObject,GetTop(alignTo)-offsetY);return gameObject;};module.exports=TopCenter;/***/},/* 870 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetRight=__webpack_require__(32);var GetTop=__webpack_require__(30);var SetLeft=__webpack_require__(33);var SetTop=__webpack_require__(29);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the right top position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.RightTop\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var RightTop=function RightTop(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetLeft(gameObject,GetRight(alignTo)+offsetX);SetTop(gameObject,GetTop(alignTo)-offsetY);return gameObject;};module.exports=RightTop;/***/},/* 871 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetCenterY=__webpack_require__(60);var GetRight=__webpack_require__(32);var SetCenterY=__webpack_require__(61);var SetLeft=__webpack_require__(33);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the right center position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.RightCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var RightCenter=function RightCenter(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetLeft(gameObject,GetRight(alignTo)+offsetX);SetCenterY(gameObject,GetCenterY(alignTo)+offsetY);return gameObject;};module.exports=RightCenter;/***/},/* 872 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetBottom=__webpack_require__(36);var GetRight=__webpack_require__(32);var SetBottom=__webpack_require__(35);var SetLeft=__webpack_require__(33);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the right bottom position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.RightBottom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var RightBottom=function RightBottom(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetLeft(gameObject,GetRight(alignTo)+offsetX);SetBottom(gameObject,GetBottom(alignTo)+offsetY);return gameObject;};module.exports=RightBottom;/***/},/* 873 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetLeft=__webpack_require__(34);var GetTop=__webpack_require__(30);var SetRight=__webpack_require__(31);var SetTop=__webpack_require__(29);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the left top position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.LeftTop\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var LeftTop=function LeftTop(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetRight(gameObject,GetLeft(alignTo)-offsetX);SetTop(gameObject,GetTop(alignTo)-offsetY);return gameObject;};module.exports=LeftTop;/***/},/* 874 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetCenterY=__webpack_require__(60);var GetLeft=__webpack_require__(34);var SetCenterY=__webpack_require__(61);var SetRight=__webpack_require__(31);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the left center position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.LeftCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var LeftCenter=function LeftCenter(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetRight(gameObject,GetLeft(alignTo)-offsetX);SetCenterY(gameObject,GetCenterY(alignTo)+offsetY);return gameObject;};module.exports=LeftCenter;/***/},/* 875 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetBottom=__webpack_require__(36);var GetLeft=__webpack_require__(34);var SetBottom=__webpack_require__(35);var SetRight=__webpack_require__(31);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the left bottom position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.LeftBottom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var LeftBottom=function LeftBottom(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetRight(gameObject,GetLeft(alignTo)-offsetX);SetBottom(gameObject,GetBottom(alignTo)+offsetY);return gameObject;};module.exports=LeftBottom;/***/},/* 876 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetBottom=__webpack_require__(36);var GetRight=__webpack_require__(32);var SetRight=__webpack_require__(31);var SetTop=__webpack_require__(29);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the bottom right position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.BottomRight\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var BottomRight=function BottomRight(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetRight(gameObject,GetRight(alignTo)+offsetX);SetTop(gameObject,GetBottom(alignTo)+offsetY);return gameObject;};module.exports=BottomRight;/***/},/* 877 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetBottom=__webpack_require__(36);var GetLeft=__webpack_require__(34);var SetLeft=__webpack_require__(33);var SetTop=__webpack_require__(29);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the bottom left position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.BottomLeft\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var BottomLeft=function BottomLeft(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetLeft(gameObject,GetLeft(alignTo)-offsetX);SetTop(gameObject,GetBottom(alignTo)+offsetY);return gameObject;};module.exports=BottomLeft;/***/},/* 878 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetBottom=__webpack_require__(36);var GetCenterX=__webpack_require__(63);var SetCenterX=__webpack_require__(62);var SetTop=__webpack_require__(29);/**\r\n * Takes given Game Object and aligns it so that it is positioned next to the bottom center position of the other.\r\n *\r\n * @function Phaser.Display.Align.To.BottomCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will be positioned.\r\n * @param {Phaser.GameObjects.GameObject} alignTo - The Game Object to base the alignment position on.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was aligned.\r\n */var BottomCenter=function BottomCenter(gameObject,alignTo,offsetX,offsetY){if(offsetX===undefined){offsetX=0;}if(offsetY===undefined){offsetY=0;}SetCenterX(gameObject,GetCenterX(alignTo)+offsetX);SetTop(gameObject,GetBottom(alignTo)+offsetY);return gameObject;};module.exports=BottomCenter;/***/},/* 879 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Display.Align.To\r\n */module.exports={BottomCenter:__webpack_require__(878),BottomLeft:__webpack_require__(877),BottomRight:__webpack_require__(876),LeftBottom:__webpack_require__(875),LeftCenter:__webpack_require__(874),LeftTop:__webpack_require__(873),RightBottom:__webpack_require__(872),RightCenter:__webpack_require__(871),RightTop:__webpack_require__(870),TopCenter:__webpack_require__(869),TopLeft:__webpack_require__(868),TopRight:__webpack_require__(867)};/***/},/* 880 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Display.Align.In\r\n */module.exports={BottomCenter:__webpack_require__(378),BottomLeft:__webpack_require__(377),BottomRight:__webpack_require__(376),Center:__webpack_require__(375),LeftCenter:__webpack_require__(373),QuickSet:__webpack_require__(379),RightCenter:__webpack_require__(372),TopCenter:__webpack_require__(371),TopLeft:__webpack_require__(370),TopRight:__webpack_require__(369)};/***/},/* 881 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var CONST=__webpack_require__(176);var Extend=__webpack_require__(18);/**\r\n * @namespace Phaser.Display.Align\r\n */var Align={In:__webpack_require__(880),To:__webpack_require__(879)};//   Merge in the consts\nAlign=Extend(false,Align,CONST);module.exports=Align;/***/},/* 882 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Display\r\n */module.exports={Align:__webpack_require__(881),Bounds:__webpack_require__(866),Canvas:__webpack_require__(863),Color:__webpack_require__(324),Masks:__webpack_require__(853)};/***/},/* 883 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var DataManager=__webpack_require__(107);var PluginManager=__webpack_require__(13);/**\r\n * @classdesc\r\n * The Data Component features a means to store pieces of data specific to a Game Object, System or Plugin.\r\n * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,\r\n * or have a property called `events` that is an instance of it.\r\n *\r\n * @class DataManagerPlugin\r\n * @extends Phaser.Data.DataManager\r\n * @memberOf Phaser.Data\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var DataManagerPlugin=new Class({Extends:DataManager,initialize:function DataManagerPlugin(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Data.DataManagerPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Data.DataManagerPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}DataManager.call(this,this.scene,scene.sys.events);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Data.DataManagerPlugin#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('shutdown',this.shutdownPlugin,this);eventEmitter.on('destroy',this.destroyPlugin,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Data.DataManagerPlugin#shutdownPlugin\r\n     * @since 3.0.0\r\n     */shutdownPlugin:function shutdownPlugin(){//  Should we reset the events?\n},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Data.DataManagerPlugin#destroyPlugin\r\n     * @since 3.0.0\r\n     */destroyPlugin:function destroyPlugin(){this.destroy();this.scene=undefined;this.systems=undefined;}});PluginManager.register('DataManagerPlugin',DataManagerPlugin,'data');module.exports=DataManagerPlugin;/***/},/* 884 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Data\r\n */module.exports={DataManager:__webpack_require__(107),DataManagerPlugin:__webpack_require__(883)};/***/},/* 885 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class MoveTo\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - [description]\r\n * @param {number} [y] - [description]\r\n */var MoveTo=new Class({initialize:function MoveTo(x,y){//  Skip length calcs in paths\n/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.MoveTo#active\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.active=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.MoveTo#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.p0=new Vector2(x,y);},/**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.MoveTo#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */getPoint:function getPoint(t,out){if(out===undefined){out=new Vector2();}return out.copy(this.p0);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.MoveTo#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {float} u - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getPointAt:function getPointAt(u,out){return this.getPoint(u,out);},/**\r\n     * Gets the resolution of this curve.\r\n     *\r\n     * @method Phaser.Curves.MoveTo#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The resolution of this curve. For a MoveTo the value is always 1.\r\n     */getResolution:function getResolution(){return 1;},/**\r\n     * Gets the length of this curve.\r\n     *\r\n     * @method Phaser.Curves.MoveTo#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this curve. For a MoveTo the value is always 0.\r\n     */getLength:function getLength(){return 0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.MoveTo#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONCurve} [description]\r\n     */toJSON:function toJSON(){return{type:'MoveTo',points:[this.p0.x,this.p0.y]};}});module.exports=MoveTo;/***/},/* 886 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar Class=__webpack_require__(0);var CubicBezierCurve=__webpack_require__(332);var EllipseCurve=__webpack_require__(330);var GameObjectFactory=__webpack_require__(9);var LineCurve=__webpack_require__(329);var MovePathTo=__webpack_require__(885);var QuadraticBezierCurve=__webpack_require__(328);var Rectangle=__webpack_require__(10);var SplineCurve=__webpack_require__(326);var Vector2=__webpack_require__(6);/**\r\n * @typedef {object} JSONPath\r\n *\r\n * @property {string} type - The of the curve.\r\n * @property {number} x - [description]\r\n * @property {number} y - [description]\r\n * @property {boolean} autoClose - The path is auto closed.\r\n * @property {JSONCurve[]} curves - The list of the curves\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Path\r\n * @memberOf Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - [description]\r\n * @param {number} [y=0] - [description]\r\n */var Path=new Class({initialize:function Path(x,y){if(x===undefined){x=0;}if(y===undefined){y=0;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.name='';/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#curves\r\n         * @type {Phaser.Curves.Curve[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.curves=[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Path#cacheLengths\r\n         * @type {number[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */this.cacheLengths=[];/**\r\n         * Automatically closes the path.\r\n         *\r\n         * @name Phaser.Curves.Path#autoClose\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.autoClose=false;/**\r\n         * [description]\r\n         *\r\n         * @name {Phaser.Curves.Path#startPoint\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.startPoint=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name {Phaser.Curves.Path#_tmpVec2A\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tmpVec2A=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name {Phaser.Curves.Path#_tmpVec2B\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tmpVec2B=new Vector2();if((typeof x==='undefined'?'undefined':_typeof(x))==='object'){this.fromJSON(x);}else{this.startPoint.set(x,y);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Curves.Curve} curve - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */add:function add(curve){this.curves.push(curve);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#circleTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - [description]\r\n     * @param {boolean} [clockwise=false] - [description]\r\n     * @param {number} [rotation=0] - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */circleTo:function circleTo(radius,clockwise,rotation){if(clockwise===undefined){clockwise=false;}return this.ellipseTo(radius,radius,0,360,clockwise,rotation);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#closePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */closePath:function closePath(){// Add a line curve if start and end of lines are not connected\nvar startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){//  This will copy a reference to the vectors, which probably isn't sensible\nthis.curves.push(new LineCurve(endPoint,startPoint));}return this;},//  Creates a cubic bezier curve starting at the previous end point and ending at p3, using p1 and p2 as control points\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#cubicBezierTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {Phaser.Math.Vector2} control1X - [description]\r\n     * @param {Phaser.Math.Vector2} control1Y - [description]\r\n     * @param {Phaser.Math.Vector2} control2X - [description]\r\n     * @param {Phaser.Math.Vector2} control2Y - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */cubicBezierTo:function cubicBezierTo(x,y,control1X,control1Y,control2X,control2Y){var p0=this.getEndPoint();var p1;var p2;var p3;//  Assume they're all vec2s\nif(x instanceof Vector2){p1=x;p2=y;p3=control1X;}else{p1=new Vector2(control1X,control1Y);p2=new Vector2(control2X,control2Y);p3=new Vector2(x,y);}return this.add(new CubicBezierCurve(p0,p1,p2,p3));},//  Creates a quadratic bezier curve starting at the previous end point and ending at p2, using p1 as a control point\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#quadraticBezierTo\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2[])} x - [description]\r\n     * @param {number} [y] - [description]\r\n     * @param {number} [controlX] - [description]\r\n     * @param {number} [controlY] - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */quadraticBezierTo:function quadraticBezierTo(x,y,controlX,controlY){var p0=this.getEndPoint();var p1;var p2;//  Assume they're all vec2s\nif(x instanceof Vector2){p1=x;p2=y;}else{p1=new Vector2(controlX,controlY);p2=new Vector2(x,y);}return this.add(new QuadraticBezierCurve(p0,p1,p2));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [out,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - [description]\r\n     * @param {integer} [pointsTotal=32] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} [description]\r\n     */draw:function draw(graphics,pointsTotal){for(var i=0;i<this.curves.length;i++){var curve=this.curves[i];if(!curve.active){continue;}curve.draw(graphics,pointsTotal);}return graphics;},/**\r\n     * Creates an ellipse curve positioned at the previous end point, using the given parameters.\r\n     *\r\n     * @method Phaser.Curves.Path#ellipseTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} xRadius - [description]\r\n     * @param {number} yRadius - [description]\r\n     * @param {number} startAngle - [description]\r\n     * @param {number} endAngle - [description]\r\n     * @param {boolean} clockwise - [description]\r\n     * @param {number} rotation - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */ellipseTo:function ellipseTo(xRadius,yRadius,startAngle,endAngle,clockwise,rotation){var ellipse=new EllipseCurve(0,0,xRadius,yRadius,startAngle,endAngle,clockwise,rotation);var end=this.getEndPoint(this._tmpVec2A);//  Calculate where to center the ellipse\nvar start=ellipse.getStartPoint(this._tmpVec2B);end.subtract(start);ellipse.x=end.x;ellipse.y=end.y;return this.add(ellipse);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} data - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */fromJSON:function fromJSON(data){//  data should be an object matching the Path.toJSON object structure.\nthis.curves=[];this.cacheLengths=[];this.startPoint.set(data.x,data.y);this.autoClose=data.autoClose;for(var i=0;i<data.curves.length;i++){var curve=data.curves[i];switch(curve.type){case'LineCurve':this.add(LineCurve.fromJSON(curve));break;case'EllipseCurve':this.add(EllipseCurve.fromJSON(curve));break;case'SplineCurve':this.add(SplineCurve.fromJSON(curve));break;case'CubicBezierCurve':this.add(CubicBezierCurve.fromJSON(curve));break;case'QuadraticBezierCurve':this.add(QuadraticBezierCurve.fromJSON(curve));break;}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - [description]\r\n     * @param {integer} [accuracy=16] - [description]\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} [description]\r\n     */getBounds:function getBounds(out,accuracy){if(out===undefined){out=new Rectangle();}if(accuracy===undefined){accuracy=16;}out.x=Number.MAX_VALUE;out.y=Number.MAX_VALUE;var bounds=new Rectangle();var maxRight=Number.MIN_SAFE_INTEGER;var maxBottom=Number.MIN_SAFE_INTEGER;for(var i=0;i<this.curves.length;i++){var curve=this.curves[i];if(!curve.active){continue;}curve.getBounds(bounds,accuracy);out.x=Math.min(out.x,bounds.x);out.y=Math.min(out.y,bounds.y);maxRight=Math.max(maxRight,bounds.right);maxBottom=Math.max(maxBottom,bounds.bottom);}out.right=maxRight;out.bottom=maxBottom;return out;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getCurveLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number[]} [description]\r\n     */getCurveLengths:function getCurveLengths(){// We use cache values if curves and cache array are same length\nif(this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve\n// Push sums into cached array\nvar lengths=[];var sums=0;for(var i=0;i<this.curves.length;i++){sums+=this.curves[i].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getEndPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getEndPoint:function getEndPoint(out){if(out===undefined){out=new Vector2();}if(this.curves.length>0){this.curves[this.curves.length-1].getPoint(1,out);}else{out.copy(this.startPoint);}return out;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getLength:function getLength(){var lens=this.getCurveLengths();return lens[lens.length-1];},// To get accurate point with reference to\n// entire path distance at time t,\n// following has to be done:\n// 1. Length of each sub path have to be known\n// 2. Locate and identify type of curve\n// 3. Get t for the curve\n// 4. Return curve.getPointAt(t')\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {?Phaser.Math.Vector2} [description]\r\n     */getPoint:function getPoint(t,out){if(out===undefined){out=new Vector2();}var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u,out);}i++;}// loop where sum != 0, sum > d , sum+1 <d\nreturn null;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions=12] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */getPoints:function getPoints(divisions){if(divisions===undefined){divisions=12;}var points=[];var last;for(var i=0;i<this.curves.length;i++){var curve=this.curves[i];if(!curve.active){continue;}var resolution=curve.getResolution(divisions);var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point)){// ensures no consecutive points are duplicates\ncontinue;}points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getRandomPoint:function getRandomPoint(out){if(out===undefined){out=new Vector2();}return this.getPoint(Math.random(),out);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getSpacedPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions=40] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */getSpacedPoints:function getSpacedPoints(divisions){if(divisions===undefined){divisions=40;}var points=[];for(var i=0;i<=divisions;i++){points.push(this.getPoint(i/divisions));}if(this.autoClose){points.push(points[0]);}return points;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */getStartPoint:function getStartPoint(out){if(out===undefined){out=new Vector2();}return out.copy(this.startPoint);},//  Creates a line curve from the previous end point to x/y\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#lineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2)} x - [description]\r\n     * @param {number} [y] - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */lineTo:function lineTo(x,y){if(x instanceof Vector2){this._tmpVec2B.copy(x);}else{this._tmpVec2B.set(x,y);}var end=this.getEndPoint(this._tmpVec2A);return this.add(new LineCurve([end.x,end.y,this._tmpVec2B.x,this._tmpVec2B.y]));},//  Creates a spline curve starting at the previous end point, using the given parameters\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#splineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2[]} points - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */splineTo:function splineTo(points){points.unshift(this.getEndPoint());return this.add(new SplineCurve(points));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.Curves.Path} [description]\r\n     */moveTo:function moveTo(x,y){return this.add(new MovePathTo(x,y));},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONPath} [description]\r\n     */toJSON:function toJSON(){var out=[];for(var i=0;i<this.curves.length;i++){out.push(this.curves[i].toJSON());}return{type:'Path',x:this.startPoint.x,y:this.startPoint.y,autoClose:this.autoClose,curves:out};},// cacheLengths must be recalculated.\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#updateArcLengths\r\n     * @since 3.0.0\r\n     */updateArcLengths:function updateArcLengths(){this.cacheLengths=[];this.getCurveLengths();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Path#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.curves.length=0;this.cacheLengths.length=0;this.startPoint=undefined;}});/**\r\n * Creates a new Path Object.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#path\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Path.\r\n * @param {number} y - The vertical position of this Path.\r\n *\r\n * @return {Phaser.Curves.Path} The Path Object that was created.\r\n */GameObjectFactory.register('path',function(x,y){return new Path(x,y);});//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\nmodule.exports=Path;/***/},/* 887 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Curves\r\n *//**\r\n * @typedef {object} JSONCurve\r\n *\r\n * @property {string} type - The of the curve\r\n * @property {number[]} points - The arrays of points like `[x1, y1, x2, y2]`\r\n */module.exports={Path:__webpack_require__(886),CubicBezier:__webpack_require__(332),Curve:__webpack_require__(58),Ellipse:__webpack_require__(330),Line:__webpack_require__(329),QuadraticBezier:__webpack_require__(328),Spline:__webpack_require__(326)};/***/},/* 888 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * A 16 color palette inspired by Japanese computers like the MSX.\r\n *\r\n * @name Phaser.Create.Palettes.MSX\r\n * @since 3.0.0\r\n *\r\n * @type {Palette}\r\n */module.exports={0:'#000',1:'#191028',2:'#46af45',3:'#a1d685',4:'#453e78',5:'#7664fe',6:'#833129',7:'#9ec2e8',8:'#dc534b',9:'#e18d79',A:'#d6b97b',B:'#e9d8a1',C:'#216c4b',D:'#d365c8',E:'#afaab9',F:'#fff'};/***/},/* 889 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * A 16 color JMP palette by [Arne](http://androidarts.com/palette/16pal.htm)\r\n *\r\n * @name Phaser.Create.Palettes.JMP\r\n * @since 3.0.0\r\n *\r\n * @type {Palette}\r\n */module.exports={0:'#000',1:'#191028',2:'#46af45',3:'#a1d685',4:'#453e78',5:'#7664fe',6:'#833129',7:'#9ec2e8',8:'#dc534b',9:'#e18d79',A:'#d6b97b',B:'#e9d8a1',C:'#216c4b',D:'#d365c8',E:'#afaab9',F:'#f5f4eb'};/***/},/* 890 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * A 16 color CGA inspired palette by [Arne](http://androidarts.com/palette/16pal.htm)\r\n *\r\n * @name Phaser.Create.Palettes.CGA\r\n * @since 3.0.0\r\n *\r\n * @type {Palette}\r\n */module.exports={0:'#000',1:'#2234d1',2:'#0c7e45',3:'#44aacc',4:'#8a3622',5:'#5c2e78',6:'#aa5c3d',7:'#b5b5b5',8:'#5e606e',9:'#4c81fb',A:'#6cd947',B:'#7be2f9',C:'#eb8a60',D:'#e23d69',E:'#ffd93f',F:'#fff'};/***/},/* 891 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * A 16 color palette inspired by the Commodore 64.\r\n *\r\n * @name Phaser.Create.Palettes.C64\r\n * @since 3.0.0\r\n *\r\n * @type {Palette}\r\n */module.exports={0:'#000',1:'#fff',2:'#8b4131',3:'#7bbdc5',4:'#8b41ac',5:'#6aac41',6:'#3931a4',7:'#d5de73',8:'#945a20',9:'#5a4100',A:'#bd736a',B:'#525252',C:'#838383',D:'#acee8b',E:'#7b73de',F:'#acacac'};/***/},/* 892 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} Palette\r\n *\r\n * @property {string} 0 - Color value 1.\r\n * @property {string} 1 - Color value 2.\r\n * @property {string} 2 - Color value 3.\r\n * @property {string} 3 - Color value 4.\r\n * @property {string} 4 - Color value 5.\r\n * @property {string} 5 - Color value 6.\r\n * @property {string} 6 - Color value 7.\r\n * @property {string} 7 - Color value 8.\r\n * @property {string} 8 - Color value 9.\r\n * @property {string} 9 - Color value 10.\r\n * @property {string} A - Color value 11.\r\n * @property {string} B - Color value 12.\r\n * @property {string} C - Color value 13.\r\n * @property {string} D - Color value 14.\r\n * @property {string} E - Color value 15.\r\n * @property {string} F - Color value 16.\r\n *//**\r\n * @namespace Phaser.Create.Palettes\r\n */module.exports={ARNE16:__webpack_require__(333),C64:__webpack_require__(891),CGA:__webpack_require__(890),JMP:__webpack_require__(889),MSX:__webpack_require__(888)};/***/},/* 893 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Create\r\n */module.exports={GenerateTexture:__webpack_require__(334),Palettes:__webpack_require__(892)};/***/},/* 894 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var OrthographicCamera=__webpack_require__(336);var PerspectiveCamera=__webpack_require__(335);var PluginManager=__webpack_require__(13);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CameraManager\r\n * @memberOf Phaser.Cameras.Sprite3D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var CameraManager=new Class({initialize:function CameraManager(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.CameraManager#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.CameraManager#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;/**\r\n         * An Array of the Camera objects being managed by this Camera Manager.\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.CameraManager#cameras\r\n         * @type {Phaser.Cameras.Sprite3D.Camera[]}\r\n         * @since 3.0.0\r\n         */this.cameras=[];if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('update',this.update,this);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [fieldOfView=80] - [description]\r\n     * @param {number} [width] - [description]\r\n     * @param {number} [height] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]\r\n     */add:function add(fieldOfView,width,height){return this.addPerspectiveCamera(fieldOfView,width,height);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#addOrthographicCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]\r\n     */addOrthographicCamera:function addOrthographicCamera(width,height){var config=this.scene.sys.game.config;if(width===undefined){width=config.width;}if(height===undefined){height=config.height;}var camera=new OrthographicCamera(this.scene,width,height);this.cameras.push(camera);return camera;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#addPerspectiveCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [fieldOfView=80] - [description]\r\n     * @param {number} [width] - [description]\r\n     * @param {number} [height] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]\r\n     */addPerspectiveCamera:function addPerspectiveCamera(fieldOfView,width,height){var config=this.scene.sys.game.config;if(fieldOfView===undefined){fieldOfView=80;}if(width===undefined){width=config.width;}if(height===undefined){height=config.height;}var camera=new PerspectiveCamera(this.scene,fieldOfView,width,height);this.cameras.push(camera);return camera;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#getCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - [description]\r\n     *\r\n     * @return {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} [description]\r\n     */getCamera:function getCamera(name){for(var i=0;i<this.cameras.length;i++){if(this.cameras[i].name===name){return this.cameras[i];}}return null;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#removeCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} camera - [description]\r\n     */removeCamera:function removeCamera(camera){var cameraIndex=this.cameras.indexOf(camera);if(cameraIndex!==-1){this.cameras.splice(cameraIndex,1);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#removeAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} [description]\r\n     */removeAll:function removeAll(){while(this.cameras.length>0){var camera=this.cameras.pop();camera.destroy();}return this.main;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestep - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(timestep,delta){for(var i=0,l=this.cameras.length;i<l;++i){this.cameras[i].update(timestep,delta);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.scene=undefined;}});PluginManager.register('CameraManager3D',CameraManager,'cameras3d');module.exports=CameraManager;/***/},/* 895 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var SpriteCanvasRenderer=function SpriteCanvasRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}renderer.drawImage(src,camera,parentMatrix);};module.exports=SpriteCanvasRenderer;/***/},/* 896 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GameObject=__webpack_require__(1);/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */var SpriteWebGLRenderer=function SpriteWebGLRenderer(renderer,src,interpolationPercentage,camera,parentMatrix){if(GameObject.RENDER_MASK!==src.renderFlags||src.cameraFilter>0&&src.cameraFilter&camera._id){return;}this.pipeline.batchSprite(src,camera,parentMatrix);};module.exports=SpriteWebGLRenderer;/***/},/* 897 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var renderWebGL=__webpack_require__(3);var renderCanvas=__webpack_require__(3);if(true){renderWebGL=__webpack_require__(896);}if(true){renderCanvas=__webpack_require__(895);}module.exports={renderWebGL:renderWebGL,renderCanvas:renderCanvas};/***/},/* 898 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Cameras.Sprite3D\r\n */module.exports={Camera:__webpack_require__(161),CameraManager:__webpack_require__(894),OrthographicCamera:__webpack_require__(336),PerspectiveCamera:__webpack_require__(335)};/***/},/* 899 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Camera=__webpack_require__(164);var Class=__webpack_require__(0);var GetFastValue=__webpack_require__(2);var PluginManager=__webpack_require__(13);var RectangleContains=__webpack_require__(27);/**\r\n * @typedef {object} InputJSONCameraObject\r\n *\r\n * @property {string} [name=''] - [description]\r\n * @property {integer} [x=0] - [description]\r\n * @property {integer} [y=0] - [description]\r\n * @property {integer} [width] - [description]\r\n * @property {integer} [height] - [description]\r\n * @property {float} [zoom=1] - [description]\r\n * @property {float} [rotation=0] - [description]\r\n * @property {boolean} [roundPixels=false] - [description]\r\n * @property {float} [scrollX=0] - [description]\r\n * @property {float} [scrollY=0] - [description]\r\n * @property {(false|string)} [backgroundColor=false] - [description]\r\n * @property {?object} [bounds] - [description]\r\n * @property {number} [bounds.x=0] - [description]\r\n * @property {number} [bounds.y=0] - [description]\r\n * @property {number} [bounds.width] - [description]\r\n * @property {number} [bounds.height] - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CameraManager\r\n * @memberOf Phaser.Cameras.Scene2D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that owns the Camera Manager plugin.\r\n */var CameraManager=new Class({initialize:function CameraManager(scene){/**\r\n         * The Scene that owns the Camera Manager plugin.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * A reference to the Scene.Systems handler for the Scene that owns the Camera Manager.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * The current Camera ID.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#currentCameraId\r\n         * @type {number}\r\n         * @default 1\r\n         * @readOnly\r\n         * @since 3.0.0\r\n         */this.currentCameraId=1;/**\r\n         * An Array of the Camera objects being managed by this Camera Manager.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#cameras\r\n         * @type {Phaser.Cameras.Scene2D.Camera[]}\r\n         * @since 3.0.0\r\n         */this.cameras=[];/**\r\n         * A pool of Camera objects available to be used by the Camera Manager.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#cameraPool\r\n         * @type {Phaser.Cameras.Scene2D.Camera[]}\r\n         * @since 3.0.0\r\n         */this.cameraPool=[];if(scene.sys.settings.cameras){//  We have cameras to create\nthis.fromJSON(scene.sys.settings.cameras);}else{//  Make one\nthis.add();}/**\r\n         * The default Camera in the Camera Manager.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#main\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @since 3.0.0\r\n         */this.main=this.cameras[0];/**\r\n         * This scale affects all cameras. It's used by Scale Manager.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#baseScale\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.baseScale=1.0;},/**\r\n     * Called when the Camera Manager boots.\r\n     * Starts the event listeners running.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var eventEmitter=this.systems.events;eventEmitter.on('update',this.update,this);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - [description]\r\n     * @param {number} [y=0] - [description]\r\n     * @param {number} [width] - [description]\r\n     * @param {number} [height] - [description]\r\n     * @param {boolean} [makeMain=false] - [description]\r\n     * @param {string} [name=''] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} [description]\r\n     */add:function add(x,y,width,height,makeMain,name){if(x===undefined){x=0;}if(y===undefined){y=0;}if(width===undefined){width=this.scene.sys.game.config.width;}if(height===undefined){height=this.scene.sys.game.config.height;}if(makeMain===undefined){makeMain=false;}if(name===undefined){name='';}var camera=null;if(this.cameraPool.length>0){camera=this.cameraPool.pop();camera.setViewport(x,y,width,height);}else{camera=new Camera(x,y,width,height);}camera.setName(name);camera.setScene(this.scene);this.cameras.push(camera);if(makeMain){this.main=camera;}camera._id=this.currentCameraId;this.currentCameraId=this.currentCameraId<<1;return camera;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#addExisting\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} [description]\r\n     */addExisting:function addExisting(camera){var index=this.cameras.indexOf(camera);var poolIndex=this.cameraPool.indexOf(camera);if(index<0&&poolIndex>=0){this.cameras.push(camera);this.cameraPool.slice(poolIndex,1);return camera;}return null;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(InputJSONCameraObject|InputJSONCameraObject[])} config - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.CameraManager} [description]\r\n     */fromJSON:function fromJSON(config){if(!Array.isArray(config)){config=[config];}var gameWidth=this.scene.sys.game.config.width;var gameHeight=this.scene.sys.game.config.height;for(var i=0;i<config.length;i++){var cameraConfig=config[i];var x=GetFastValue(cameraConfig,'x',0);var y=GetFastValue(cameraConfig,'y',0);var width=GetFastValue(cameraConfig,'width',gameWidth);var height=GetFastValue(cameraConfig,'height',gameHeight);var camera=this.add(x,y,width,height);//  Direct properties\ncamera.name=GetFastValue(cameraConfig,'name','');camera.zoom=GetFastValue(cameraConfig,'zoom',1);camera.rotation=GetFastValue(cameraConfig,'rotation',0);camera.scrollX=GetFastValue(cameraConfig,'scrollX',0);camera.scrollY=GetFastValue(cameraConfig,'scrollY',0);camera.roundPixels=GetFastValue(cameraConfig,'roundPixels',false);// Background Color\nvar backgroundColor=GetFastValue(cameraConfig,'backgroundColor',false);if(backgroundColor){camera.setBackgroundColor(backgroundColor);}//  Bounds\nvar boundsConfig=GetFastValue(cameraConfig,'bounds',null);if(boundsConfig){var bx=GetFastValue(boundsConfig,'x',0);var by=GetFastValue(boundsConfig,'y',0);var bwidth=GetFastValue(boundsConfig,'width',gameWidth);var bheight=GetFastValue(boundsConfig,'height',gameHeight);camera.setBounds(bx,by,bwidth,bheight);}}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#getCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} [description]\r\n     */getCamera:function getCamera(name){for(var i=0;i<this.cameras.length;i++){if(this.cameras[i].name===name){return this.cameras[i];}}return null;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#getCameraBelowPointer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} [description]\r\n     */getCameraBelowPointer:function getCameraBelowPointer(pointer){var cameras=this.cameras;//  Start from the most recently added camera (the 'top' camera)\nfor(var i=cameras.length-1;i>=0;i--){var camera=cameras[i];if(camera.inputEnabled&&RectangleContains(camera,pointer.x,pointer.y)){return camera;}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */remove:function remove(camera){var cameraIndex=this.cameras.indexOf(camera);if(cameraIndex>=0&&this.cameras.length>1){this.cameraPool.push(this.cameras[cameraIndex]);this.cameras.splice(cameraIndex,1);if(this.main===camera){this.main=this.cameras[0];}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The Renderer that will render the children to this camera.\r\n     * @param {Phaser.GameObjects.GameObject[]} children - An array of renderable Game Objects.\r\n     * @param {number} interpolation - Interpolation value. Reserved for future use.\r\n     */render:function render(renderer,children,interpolation){var cameras=this.cameras;var baseScale=this.baseScale;for(var i=0,l=cameras.length;i<l;++i){var camera=cameras[i];camera.preRender(baseScale,renderer.config.resolution);renderer.render(this.scene,children,interpolation,camera);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#resetAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} [description]\r\n     */resetAll:function resetAll(){while(this.cameras.length>0){this.cameraPool.push(this.cameras.pop());}this.main=this.add();return this.main;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestep - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(timestep,delta){for(var i=0,l=this.cameras.length;i<l;++i){this.cameras[i].update(timestep,delta);}},/**\r\n     * Resizes all cameras to the given dimensions.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#resize\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} width - The new width of the camera.\r\n     * @param {number} height - The new height of the camera.\r\n     */resize:function resize(width,height){for(var i=0,l=this.cameras.length;i<l;++i){this.cameras[i].setSize(width,height);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){//  TODO\n},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.main=undefined;for(var i=0;i<this.cameras.length;i++){this.cameras[i].destroy();}for(i=0;i<this.cameraPool.length;i++){this.cameraPool[i].destroy();}this.cameras=[];this.cameraPool=[];this.scene=undefined;}});PluginManager.register('CameraManager',CameraManager,'cameras');module.exports=CameraManager;/***/},/* 900 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Cameras.Scene2D\r\n */module.exports={Camera:__webpack_require__(164),CameraManager:__webpack_require__(899)};/***/},/* 901 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Cameras.Controls\r\n */module.exports={/**\r\n     * This alias will be removed in a future version.\r\n     * Use `FixedKeyControl` instead.\r\n     * \r\n     * @deprecated\r\n     * @name Phaser.Cameras.Controls.Fixed\r\n     */Fixed:__webpack_require__(349),FixedKeyControl:__webpack_require__(349),/**\r\n     * This alias will be removed in a future version.\r\n     * Use `SmoothedKeyControl` instead.\r\n     * \r\n     * @deprecated\r\n     * @name Phaser.Cameras.Controls.Smoothed\r\n     */Smoothed:__webpack_require__(348),SmoothedKeyControl:__webpack_require__(348)};/***/},/* 902 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Cameras\r\n */module.exports={Controls:__webpack_require__(901),Scene2D:__webpack_require__(900),Sprite3D:__webpack_require__(898)};/***/},/* 903 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Cache\r\n */module.exports={BaseCache:__webpack_require__(351),CacheManager:__webpack_require__(350)};/***/},/* 904 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Animations\r\n */module.exports={Animation:__webpack_require__(355),AnimationFrame:__webpack_require__(353),AnimationManager:__webpack_require__(352)};/***/},/* 905 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       samme <samme.npm@gmail.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Wrap=__webpack_require__(44);/**\r\n * Wrap each item's coordinates within a rectangle's area.\r\n *\r\n * @function Phaser.Actions.WrapInRectangle\r\n * @since 3.0.0\r\n * @see Phaser.Math.Wrap\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle.\r\n * @param {number} [padding=0] - An amount added to each side of the rectangle during the operation.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var WrapInRectangle=function WrapInRectangle(items,rect,padding){if(padding===undefined){padding=0;}for(var i=0;i<items.length;i++){var item=items[i];item.x=Wrap(item.x,rect.left-padding,rect.right+padding);item.y=Wrap(item.y,rect.top-padding,rect.bottom+padding);}return items;};module.exports=WrapInRectangle;/***/},/* 906 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.ToggleVisible\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var ToggleVisible=function ToggleVisible(items){for(var i=0;i<items.length;i++){items[i].visible=!items[i].visible;}return items;};module.exports=ToggleVisible;/***/},/* 907 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.Spread\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {string} property - [description]\r\n * @param {number} min - [description]\r\n * @param {number} max - [description]\r\n * @param {number} [inc=false] - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var Spread=function Spread(items,property,min,max,inc){if(inc===undefined){inc=false;}var step=Math.abs(max-min)/items.length;var i;if(inc){for(i=0;i<items.length;i++){items[i][property]+=i*step;}}else{for(i=0;i<items.length;i++){items[i][property]=i*step;}}return items;};module.exports=Spread;/***/},/* 908 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MathSmoothStep=__webpack_require__(356);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.SmoothStep\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {string} property - [description]\r\n * @param {number} min - [description]\r\n * @param {number} max - [description]\r\n * @param {number} inc - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var SmoothStep=function SmoothStep(items,property,min,max,inc){if(inc===undefined){inc=false;}var step=Math.abs(max-min)/items.length;var i;if(inc){for(i=0;i<items.length;i++){items[i][property]+=MathSmoothStep(i*step,min,max);}}else{for(i=0;i<items.length;i++){items[i][property]=MathSmoothStep(i*step,min,max);}}return items;};module.exports=SmoothStep;/***/},/* 909 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MathSmootherStep=__webpack_require__(357);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.SmootherStep\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {string} property - [description]\r\n * @param {number} min - [description]\r\n * @param {number} max - [description]\r\n * @param {number} inc - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var SmootherStep=function SmootherStep(items,property,min,max,inc){if(inc===undefined){inc=false;}var step=Math.abs(max-min)/items.length;var i;if(inc){for(i=0;i<items.length;i++){items[i][property]+=MathSmootherStep(i*step,min,max);}}else{for(i=0;i<items.length;i++){items[i][property]=MathSmootherStep(i*step,min,max);}}return items;};module.exports=SmootherStep;/***/},/* 910 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ArrayShuffle=__webpack_require__(106);/**\r\n * Shuffles the array in place. The shuffled array is both modified and returned.\r\n *\r\n * @function Phaser.Actions.Shuffle\r\n * @since 3.0.0\r\n * @see Phaser.Utils.Array.Shuffle\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var Shuffle=function Shuffle(items){return ArrayShuffle(items);};module.exports=Shuffle;/***/},/* 911 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Vector2=__webpack_require__(6);/**\r\n * Iterate through items changing the position of each element to\r\n * be that of the element that came before it in the array (or after it if direction = 1)\r\n * The first items position is set to x/y.\r\n * The final x/y coords are returned\r\n *\r\n * @function Phaser.Actions.ShiftPosition\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items]\r\n * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {integer} [direction=0] - [description]\r\n * @param {(Phaser.Math.Vector2|object)} [output] - [description]\r\n *\r\n * @return {Phaser.Math.Vector2} The output vector.\r\n */var ShiftPosition=function ShiftPosition(items,x,y,direction,output){if(direction===undefined){direction=0;}if(output===undefined){output=new Vector2();}var px;var py;if(items.length>1){var i;var cx;var cy;var cur;if(direction===0){//  Bottom to Top\nvar len=items.length-1;px=items[len].x;py=items[len].y;for(i=len-1;i>=0;i--){//  Current item\ncur=items[i];//  Get current item x/y, to be passed to the next item in the list\ncx=cur.x;cy=cur.y;//  Set current item to the previous items x/y\ncur.x=px;cur.y=py;//  Set current as previous\npx=cx;py=cy;}//  Update the head item to the new x/y coordinates\nitems[len].x=x;items[len].y=y;}else{//  Top to Bottom\npx=items[0].x;py=items[0].y;for(i=1;i<items.length;i++){//  Current item\ncur=items[i];//  Get current item x/y, to be passed to the next item in the list\ncx=cur.x;cy=cur.y;//  Set current item to the previous items x/y\ncur.x=px;cur.y=py;//  Set current as previous\npx=cx;py=cy;}//  Update the head item to the new x/y coordinates\nitems[0].x=x;items[0].y=y;}}else{px=items[0].x;py=items[0].y;items[0].x=x;items[0].y=y;}//  Return the final set of coordinates as they're effectively lost from the shift and may be needed\noutput.x=px;output.y=py;return output;};module.exports=ShiftPosition;/***/},/* 912 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `y`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetY=function SetY(items,value,step,index,direction){return PropertyValueSet(items,'y',value,step,index,direction);};module.exports=SetY;/***/},/* 913 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public properties `x` and `y`\r\n * and then sets them to the given values.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetXY(group.getChildren(), x, y, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.SetXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} x - The amount to set the `x` property to.\r\n * @param {number} [y=x] - The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value.\r\n * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetXY=function SetXY(items,x,y,stepX,stepY,index,direction){if(y===undefined||y===null){y=x;}PropertyValueSet(items,'x',x,stepX,index,direction);return PropertyValueSet(items,'y',y,stepY,index,direction);};module.exports=SetXY;/***/},/* 914 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `x`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetX=function SetX(items,value,step,index,direction){return PropertyValueSet(items,'x',value,step,index,direction);};module.exports=SetX;/***/},/* 915 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `visible`\r\n * and then sets it to the given value.\r\n *\r\n * To use this with a Group: `SetVisible(group.getChildren(), value)`\r\n *\r\n * @function Phaser.Actions.SetVisible\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {boolean} value - The value to set the property to.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetVisible=function SetVisible(items,value,index,direction){return PropertyValueSet(items,'visible',value,0,index,direction);};module.exports=SetVisible;/***/},/* 916 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.SetTint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {number} topLeft - [description]\r\n * @param {number} [topRight] - [description]\r\n * @param {number} [bottomLeft] - [description]\r\n * @param {number} [bottomRight] - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var SetTint=function SetTint(items,topLeft,topRight,bottomLeft,bottomRight){for(var i=0;i<items.length;i++){items[i].setTint(topLeft,topRight,bottomLeft,bottomRight);}return items;};module.exports=SetTint;/***/},/* 917 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `scaleY`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScaleY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetScaleY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetScaleY=function SetScaleY(items,value,step,index,direction){return PropertyValueSet(items,'scaleY',value,step,index,direction);};module.exports=SetScaleY;/***/},/* 918 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `scaleX`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScaleX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetScaleX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetScaleX=function SetScaleX(items,value,step,index,direction){return PropertyValueSet(items,'scaleX',value,step,index,direction);};module.exports=SetScaleX;/***/},/* 919 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public properties `scaleX` and `scaleY`\r\n * and then sets them to the given values.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScale(group.getChildren(), scaleX, scaleY, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.SetScale\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} scaleX - The amount to set the `scaleX` property to.\r\n * @param {number} [scaleY] - The amount to set the `scaleY` property to. If `undefined` or `null` it uses the `scaleX` value.\r\n * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `scaleY` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetScale=function SetScale(items,scaleX,scaleY,stepX,stepY,index,direction){if(scaleY===undefined||scaleY===null){scaleY=scaleX;}PropertyValueSet(items,'scaleX',scaleX,stepX,index,direction);return PropertyValueSet(items,'scaleY',scaleY,stepY,index,direction);};module.exports=SetScale;/***/},/* 920 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `rotation`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetRotation(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetRotation\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetRotation=function SetRotation(items,value,step,index,direction){return PropertyValueSet(items,'rotation',value,step,index,direction);};module.exports=SetRotation;/***/},/* 921 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public properties `originX` and `originY`\r\n * and then sets them to the given values.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetOrigin(group.getChildren(), originX, originY, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.SetOrigin\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} originX - The amount to set the `originX` property to.\r\n * @param {number} [originY] - The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.\r\n * @param {number} [stepX=0] - This is added to the `originX` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `originY` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetOrigin=function SetOrigin(items,originX,originY,stepX,stepY,index,direction){if(originY===undefined||originY===null){originY=originX;}PropertyValueSet(items,'originX',originX,stepX,index,direction);return PropertyValueSet(items,'originY',originY,stepY,index,direction);};module.exports=SetOrigin;/***/},/* 922 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.SetHitArea\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {*} hitArea - [description]\r\n * @param {HitAreaCallback} hitAreaCallback - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var SetHitArea=function SetHitArea(items,hitArea,hitAreaCallback){for(var i=0;i<items.length;i++){items[i].setInteractive(hitArea,hitAreaCallback);}return items;};module.exports=SetHitArea;/***/},/* 923 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `depth`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetDepth(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetDepth\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetDepth=function SetDepth(items,value,step,index,direction){return PropertyValueSet(items,'depth',value,step,index,direction);};module.exports=SetDepth;/***/},/* 924 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `blendMode`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetBlendMode(group.getChildren(), value)`\r\n *\r\n * @function Phaser.Actions.SetBlendMode\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetBlendMode=function SetBlendMode(items,value,index,direction){return PropertyValueSet(items,'blendMode',value,0,index,direction);};module.exports=SetBlendMode;/***/},/* 925 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueSet=__webpack_require__(21);/**\r\n * Takes an array of Game Objects, or any objects that have the public property `alpha`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetAlpha(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetAlpha\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var SetAlpha=function SetAlpha(items,value,step,index,direction){return PropertyValueSet(items,'alpha',value,step,index,direction);};module.exports=SetAlpha;/***/},/* 926 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have a public `scaleY` property,\r\n * and then adds the given value to each of their `scaleY` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `ScaleY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.ScaleY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `scaleY` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var ScaleY=function ScaleY(items,value,step,index,direction){return PropertyValueInc(items,'scaleY',value,step,index,direction);};module.exports=ScaleY;/***/},/* 927 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have public `scaleX` and `scaleY` properties,\r\n * and then adds the given value to each of them.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `ScaleXY(group.getChildren(), scaleX, scaleY, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.ScaleXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} scaleX - The amount to be added to the `scaleX` property.\r\n * @param {number} [scaleY] - The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.\r\n * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var ScaleXY=function ScaleXY(items,scaleX,scaleY,stepX,stepY,index,direction){if(scaleY===undefined||scaleY===null){scaleY=scaleX;}PropertyValueInc(items,'scaleX',scaleX,stepX,index,direction);return PropertyValueInc(items,'scaleY',scaleY,stepY,index,direction);};module.exports=ScaleXY;/***/},/* 928 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have a public `scaleX` property,\r\n * and then adds the given value to each of their `scaleX` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `ScaleX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.ScaleX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `scaleX` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var ScaleX=function ScaleX(items,value,step,index,direction){return PropertyValueInc(items,'scaleX',value,step,index,direction);};module.exports=ScaleX;/***/},/* 929 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MathRotateAroundDistance=__webpack_require__(167);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.RotateAroundDistance\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {object} point - Any object with public `x` and `y` properties.\r\n * @param {number} angle - The angle to rotate by, in radians.\r\n * @param {number} distance - The distance from the point of rotation in pixels.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var RotateAroundDistance=function RotateAroundDistance(items,point,angle,distance){var x=point.x;var y=point.y;//  There's nothing to do\nif(distance===0){return items;}for(var i=0;i<items.length;i++){MathRotateAroundDistance(items[i],x,y,angle,distance);}return items;};module.exports=RotateAroundDistance;/***/},/* 930 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var RotateAroundDistance=__webpack_require__(167);var DistanceBetween=__webpack_require__(49);/**\r\n * Rotates each item around the given point by the given angle.\r\n *\r\n * @function Phaser.Actions.RotateAround\r\n * @since 3.0.0\r\n * @see Phaser.Math.RotateAroundDistance\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {object} point - Any object with public `x` and `y` properties.\r\n * @param {number} angle - The angle to rotate by, in radians.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var RotateAround=function RotateAround(items,point,angle){var x=point.x;var y=point.y;for(var i=0;i<items.length;i++){var item=items[i];RotateAroundDistance(item,x,y,angle,Math.max(1,DistanceBetween(item.x,item.y,x,y)));}return items;};module.exports=RotateAround;/***/},/* 931 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have a public `rotation` property,\r\n * and then adds the given value to each of their `rotation` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `Rotate(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.Rotate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `rotation` property (in radians).\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var Rotate=function Rotate(items,value,step,index,direction){return PropertyValueInc(items,'rotation',value,step,index,direction);};module.exports=Rotate;/***/},/* 932 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Random=__webpack_require__(168);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.RandomTriangle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var RandomTriangle=function RandomTriangle(items,triangle){for(var i=0;i<items.length;i++){Random(triangle,items[i]);}return items;};module.exports=RandomTriangle;/***/},/* 933 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Random=__webpack_require__(170);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.RandomRectangle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var RandomRectangle=function RandomRectangle(items,rect){for(var i=0;i<items.length;i++){Random(rect,items[i]);}return items;};module.exports=RandomRectangle;/***/},/* 934 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Random=__webpack_require__(171);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.RandomLine\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var RandomLine=function RandomLine(items,line){for(var i=0;i<items.length;i++){Random(line,items[i]);}return items;};module.exports=RandomLine;/***/},/* 935 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Random=__webpack_require__(169);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.RandomEllipse\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Ellipse} ellipse - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var RandomEllipse=function RandomEllipse(items,ellipse){for(var i=0;i<items.length;i++){Random(ellipse,items[i]);}return items;};module.exports=RandomEllipse;/***/},/* 936 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Random=__webpack_require__(174);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.RandomCircle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Circle} circle - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var RandomCircle=function RandomCircle(items,circle){for(var i=0;i<items.length;i++){Random(circle,items[i]);}return items;};module.exports=RandomCircle;/***/},/* 937 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.PlayAnimation\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {string} key - [description]\r\n * @param {(string|integer)} [startFrame] - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var PlayAnimation=function PlayAnimation(items,key,startFrame){for(var i=0;i<items.length;i++){items[i].anims.play(key,startFrame);}return items;};module.exports=PlayAnimation;/***/},/* 938 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */// var GetPointsOnLine = require('../geom/line/GetPointsOnLine');\nvar BresenhamPoints=__webpack_require__(358);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.PlaceOnTriangle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Triangle} triangle - [description]\r\n * @param {number} [stepRate=1] - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var PlaceOnTriangle=function PlaceOnTriangle(items,triangle,stepRate){var p1=BresenhamPoints({x1:triangle.x1,y1:triangle.y1,x2:triangle.x2,y2:triangle.y2},stepRate);var p2=BresenhamPoints({x1:triangle.x2,y1:triangle.y2,x2:triangle.x3,y2:triangle.y3},stepRate);var p3=BresenhamPoints({x1:triangle.x3,y1:triangle.y3,x2:triangle.x1,y2:triangle.y1},stepRate);//  Remove overlaps\np1.pop();p2.pop();p3.pop();p1=p1.concat(p2,p3);var step=p1.length/items.length;var p=0;for(var i=0;i<items.length;i++){var item=items[i];var point=p1[Math.floor(p)];item.x=point.x;item.y=point.y;p+=step;}return items;};module.exports=PlaceOnTriangle;/***/},/* 939 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MarchingAnts=__webpack_require__(361);var RotateLeft=__webpack_require__(360);var RotateRight=__webpack_require__(359);//  Place the items in the array around the perimeter of the given rectangle.\n//  Placement starts from the top-left of the rectangle, and proceeds in a\n//  clockwise direction. If the shift parameter is given you can offset where\n//  placement begins.\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.PlaceOnRectangle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {integer} [shift=1] - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var PlaceOnRectangle=function PlaceOnRectangle(items,rect,shift){if(shift===undefined){shift=0;}var points=MarchingAnts(rect,false,items.length);if(shift>0){RotateLeft(points,shift);}else if(shift<0){RotateRight(points,Math.abs(shift));}for(var i=0;i<items.length;i++){items[i].x=points[i].x;items[i].y=points[i].y;}return items;};module.exports=PlaceOnRectangle;/***/},/* 940 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var GetPoints=__webpack_require__(172);/**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.PlaceOnLine\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Line} line - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var PlaceOnLine=function PlaceOnLine(items,line){var points=GetPoints(line,items.length);for(var i=0;i<items.length;i++){var item=items[i];var point=points[i];item.x=point.x;item.y=point.y;}return items;};module.exports=PlaceOnLine;/***/},/* 941 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.PlaceOnEllipse\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Ellipse} ellipse - [description]\r\n * @param {number} [startAngle=0] - [description]\r\n * @param {number} [endAngle=6.28] - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var PlaceOnEllipse=function PlaceOnEllipse(items,ellipse,startAngle,endAngle){if(startAngle===undefined){startAngle=0;}if(endAngle===undefined){endAngle=6.28;}var angle=startAngle;var angleStep=(endAngle-startAngle)/items.length;var a=ellipse.width/2;var b=ellipse.height/2;for(var i=0;i<items.length;i++){items[i].x=ellipse.x+a*Math.cos(angle);items[i].y=ellipse.y+b*Math.sin(angle);angle+=angleStep;}return items;};module.exports=PlaceOnEllipse;/***/},/* 942 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Actions.PlaceOnCircle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Circle} circle - [description]\r\n * @param {number} [startAngle=0] - [description]\r\n * @param {number} [endAngle=6.28] - [description]\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */var PlaceOnCircle=function PlaceOnCircle(items,circle,startAngle,endAngle){if(startAngle===undefined){startAngle=0;}if(endAngle===undefined){endAngle=6.28;}var angle=startAngle;var angleStep=(endAngle-startAngle)/items.length;for(var i=0;i<items.length;i++){items[i].x=circle.x+circle.radius*Math.cos(angle);items[i].y=circle.y+circle.radius*Math.sin(angle);angle+=angleStep;}return items;};module.exports=PlaceOnCircle;/***/},/* 943 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have a public `y` property,\r\n * and then adds the given value to each of their `y` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `IncY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.IncY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `y` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var IncY=function IncY(items,value,step,index,direction){return PropertyValueInc(items,'y',value,step,index,direction);};module.exports=IncY;/***/},/* 944 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,\r\n * and then adds the given value to each of them.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `IncXY(group.getChildren(), x, y, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.IncXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} x - The amount to be added to the `x` property.\r\n * @param {number} [y=x] - The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value.\r\n * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var IncXY=function IncXY(items,x,y,stepX,stepY,index,direction){if(y===undefined||y===null){y=x;}PropertyValueInc(items,'x',x,stepX,index,direction);return PropertyValueInc(items,'y',y,stepY,index,direction);};module.exports=IncXY;/***/},/* 945 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have a public `x` property,\r\n * and then adds the given value to each of their `x` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `IncX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.IncX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `x` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var IncX=function IncX(items,value,step,index,direction){return PropertyValueInc(items,'x',value,step,index,direction);};module.exports=IncX;/***/},/* 946 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have a public `alpha` property,\r\n * and then adds the given value to each of their `alpha` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `IncAlpha(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.IncAlpha\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `alpha` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var IncAlpha=function IncAlpha(items,value,step,index,direction){return PropertyValueInc(items,'alpha',value,step,index,direction);};module.exports=IncAlpha;/***/},/* 947 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  bitmask flag for GameObject.renderMask\nvar _FLAG=1;// 0001\n/**\r\n * Provides methods used for setting the visibility of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.Visible\r\n * @since 3.0.0\r\n */var Visible={/**\r\n     * Private internal value. Holds the visible value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#_visible\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.0.0\r\n     */_visible:true,/**\r\n     * The visible state of the Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */visible:{get:function get(){return this._visible;},set:function set(value){if(value){this._visible=true;this.renderFlags|=_FLAG;}else{this._visible=false;this.renderFlags&=~_FLAG;}}},/**\r\n     * Sets the visibility of this Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Visible#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible state of the Game Object.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setVisible:function setVisible(value){this.visible=value;return this;}};module.exports=Visible;/***/},/* 948 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MATH_CONST=__webpack_require__(16);var TransformMatrix=__webpack_require__(78);var WrapAngle=__webpack_require__(182);var WrapAngleDegrees=__webpack_require__(181);//  global bitmask flag for GameObject.renderMask (used by Scale)\nvar _FLAG=4;// 0100\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @name Phaser.GameObjects.Components.Transform\r\n * @since 3.0.0\r\n */var Transform={/**\r\n     * Private internal value. Holds the horizontal scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_scaleX\r\n     * @type {float}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */_scaleX:1,/**\r\n     * Private internal value. Holds the vertical scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_scaleY\r\n     * @type {float}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */_scaleY:1,/**\r\n     * Private internal value. Holds the rotation value in radians.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_rotation\r\n     * @type {float}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */_rotation:0,/**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */x:0,/**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */y:0,/**\r\n     * The z position of this Game Object.\r\n     * Note: Do not use this value to set the z-index, instead see the `depth` property.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#z\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */z:0,/**\r\n     * The w position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#w\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */w:0,/**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */scaleX:{get:function get(){return this._scaleX;},set:function set(value){this._scaleX=value;if(this._scaleX===0){this.renderFlags&=~_FLAG;}else{this.renderFlags|=_FLAG;}}},/**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */scaleY:{get:function get(){return this._scaleY;},set:function set(value){this._scaleY=value;if(this._scaleY===0){this.renderFlags&=~_FLAG;}else{this.renderFlags|=_FLAG;}}},/**\r\n     * The angle of this Game Object as expressed in degrees.\r\n     *\r\n     * Where 0 is to the right, 90 is down, 180 is left.\r\n     *\r\n     * If you prefer to work in radians, see the `rotation` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#angle\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */angle:{get:function get(){return WrapAngleDegrees(this._rotation*MATH_CONST.RAD_TO_DEG);},set:function set(value){//  value is in degrees\nthis.rotation=WrapAngleDegrees(value)*MATH_CONST.DEG_TO_RAD;}},/**\r\n     * The angle of this Game Object in radians.\r\n     *\r\n     * If you prefer to work in degrees, see the `angle` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#rotation\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */rotation:{get:function get(){return this._rotation;},set:function set(value){//  value is in radians\nthis._rotation=WrapAngle(value);}},/**\r\n     * Sets the position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of this Game Object.\r\n     * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.\r\n     * @param {number} [z=0] - The z position of this Game Object.\r\n     * @param {number} [w=0] - The w position of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setPosition:function setPosition(x,y,z,w){if(x===undefined){x=0;}if(y===undefined){y=x;}if(z===undefined){z=0;}if(w===undefined){w=0;}this.x=x;this.y=y;this.z=z;this.w=w;return this;},/**\r\n     * Sets the rotation of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - The rotation of this Game Object, in radians.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setRotation:function setRotation(radians){if(radians===undefined){radians=0;}this.rotation=radians;return this;},/**\r\n     * Sets the angle of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setAngle:function setAngle(degrees){if(degrees===undefined){degrees=0;}this.angle=degrees;return this;},/**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setScale:function setScale(x,y){if(x===undefined){x=1;}if(y===undefined){y=x;}this.scaleX=x;this.scaleY=y;return this;},/**\r\n     * Sets the x position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The x position of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setX:function setX(value){if(value===undefined){value=0;}this.x=value;return this;},/**\r\n     * Sets the y position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The y position of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setY:function setY(value){if(value===undefined){value=0;}this.y=value;return this;},/**\r\n     * Sets the z position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The z position of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setZ:function setZ(value){if(value===undefined){value=0;}this.z=value;return this;},/**\r\n     * Sets the w position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setW\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The w position of this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setW:function setW(value){if(value===undefined){value=0;}this.w=value;return this;},/**\r\n     * Gets the local transform matrix for this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */getLocalTransformMatrix:function getLocalTransformMatrix(tempMatrix){if(tempMatrix===undefined){tempMatrix=new TransformMatrix();}return tempMatrix.applyITRS(this.x,this.y,this._rotation,this._scaleX,this._scaleY);},/**\r\n     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */getWorldTransformMatrix:function getWorldTransformMatrix(tempMatrix){if(tempMatrix===undefined){tempMatrix=new TransformMatrix();}var parent=this.parentContainer;if(!parent){return this.getLocalTransformMatrix(tempMatrix);}var parents=[];while(parent){parents.unshift(parent);parent=parent.parentContainer;}tempMatrix.loadIdentity();var length=parents.length;for(var i=0;i<length;++i){parent=parents[i];tempMatrix.translate(parent.x,parent.y);tempMatrix.rotate(parent.rotation);tempMatrix.scale(parent.scaleX,parent.scaleY);}tempMatrix.translate(this.x,this.y);tempMatrix.rotate(this._rotation);tempMatrix.scale(this._scaleX,this._scaleY);return tempMatrix;}};module.exports=Transform;/***/},/* 949 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} JSONGameObject\r\n *\r\n * @property {string} name - The name of this Game Object.\r\n * @property {string} type - A textual representation of this Game Object, i.e. `sprite`.\r\n * @property {number} x - The x position of this Game Object.\r\n * @property {number} y - The y position of this Game Object.\r\n * @property {object} scale - The scale of this Game Object\r\n * @property {number} scale.x - The horizontal scale of this Game Object.\r\n * @property {number} scale.y - The vertical scale of this Game Object.\r\n * @property {object} origin - The origin of this Game Object.\r\n * @property {float} origin.x - The horizontal origin of this Game Object.\r\n * @property {float} origin.y - The vertical origin of this Game Object.\r\n * @property {boolean} flipX - The horizontally flipped state of the Game Object.\r\n * @property {boolean} flipY - The vertically flipped state of the Game Object.\r\n * @property {number} rotation - The angle of this Game Object in radians.\r\n * @property {float} alpha - The alpha value of the Game Object.\r\n * @property {boolean} visible - The visible state of the Game Object.\r\n * @property {integer} scaleMode - The Scale Mode being used by this Game Object.\r\n * @property {(integer|string)} blendMode - Sets the Blend Mode being used by this Game Object.\r\n * @property {string} textureKey - The texture key of this Game Object.\r\n * @property {string} frameKey - The frame key of this Game Object.\r\n * @property {object} data - The data of this Game Object.\r\n *///  Default Game Object JSON export\n//  Is extended further by Game Object specific implementations\n/**\r\n * [description]\r\n *\r\n * @method Phaser.GameObjects.Components.ToJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n *\r\n * @return {JSONGameObject} [description]\r\n */var ToJSON=function ToJSON(gameObject){var out={name:gameObject.name,type:gameObject.type,x:gameObject.x,y:gameObject.y,depth:gameObject.depth,scale:{x:gameObject.scaleX,y:gameObject.scaleY},origin:{x:gameObject.originX,y:gameObject.originY},flipX:gameObject.flipX,flipY:gameObject.flipY,rotation:gameObject.rotation,alpha:gameObject.alpha,visible:gameObject.visible,scaleMode:gameObject.scaleMode,blendMode:gameObject.blendMode,textureKey:'',frameKey:'',data:{}};if(gameObject.texture){out.textureKey=gameObject.texture.key;out.frameKey=gameObject.frame.name;}return out;};module.exports=ToJSON;/***/},/* 950 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @function GetColor\r\n * @since 3.0.0\r\n * @private\r\n */var GetColor=function GetColor(value){return(value>>16)+(value&0xff00)+((value&0xff)<<16);};/**\r\n * Provides methods used for setting the tint of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.Tint\r\n * @webglOnly\r\n * @since 3.0.0\r\n */var Tint={/**\r\n     * Private internal value. Holds the top-left tint value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#_tintTL\r\n     * @type {number}\r\n     * @private\r\n     * @default 16777215\r\n     * @since 3.0.0\r\n     */_tintTL:16777215,/**\r\n     * Private internal value. Holds the top-right tint value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#_tintTR\r\n     * @type {number}\r\n     * @private\r\n     * @default 16777215\r\n     * @since 3.0.0\r\n     */_tintTR:16777215,/**\r\n     * Private internal value. Holds the bottom-left tint value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#_tintBL\r\n     * @type {number}\r\n     * @private\r\n     * @default 16777215\r\n     * @since 3.0.0\r\n     */_tintBL:16777215,/**\r\n     * Private internal value. Holds the bottom-right tint value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#_tintBR\r\n     * @type {number}\r\n     * @private\r\n     * @default 16777215\r\n     * @since 3.0.0\r\n     */_tintBR:16777215,/**\r\n     * Clears all tint values associated with this Game Object.\r\n     * Immediately sets the alpha levels back to 0xffffff (no tint)\r\n     *\r\n     * @method Phaser.GameObjects.Components.Tint#clearTint\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */clearTint:function clearTint(){this.setTint(0xffffff);return this;},/**\r\n     * Sets the tint values for this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Tint#setTint\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [topLeft=0xffffff] - The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object.\r\n     * @param {integer} [topRight] - The tint being applied to the top-right of the Game Object.\r\n     * @param {integer} [bottomLeft] - The tint being applied to the bottom-left of the Game Object.\r\n     * @param {integer} [bottomRight] - The tint being applied to the bottom-right of the Game Object.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setTint:function setTint(topLeft,topRight,bottomLeft,bottomRight){if(topLeft===undefined){topLeft=0xffffff;}if(topRight===undefined){topRight=topLeft;bottomLeft=topLeft;bottomRight=topLeft;}this._tintTL=GetColor(topLeft);this._tintTR=GetColor(topRight);this._tintBL=GetColor(bottomLeft);this._tintBR=GetColor(bottomRight);return this;},/**\r\n     * The tint value being applied to the top-left of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#tintTopLeft\r\n     * @type {integer}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */tintTopLeft:{get:function get(){return this._tintTL;},set:function set(value){this._tintTL=GetColor(value);}},/**\r\n     * The tint value being applied to the top-right of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#tintTopRight\r\n     * @type {integer}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */tintTopRight:{get:function get(){return this._tintTR;},set:function set(value){this._tintTR=GetColor(value);}},/**\r\n     * The tint value being applied to the bottom-left of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#tintBottomLeft\r\n     * @type {integer}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */tintBottomLeft:{get:function get(){return this._tintBL;},set:function set(value){this._tintBL=GetColor(value);}},/**\r\n     * The tint value being applied to the bottom-right of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#tintBottomRight\r\n     * @type {integer}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */tintBottomRight:{get:function get(){return this._tintBR;},set:function set(value){this._tintBR=GetColor(value);}},/**\r\n     * The tint value being applied to the whole of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Tint#tint\r\n     * @type {integer}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */tint:{set:function set(value){this.setTint(value,value,value,value);}}};module.exports=Tint;/***/},/* 951 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *///  bitmask flag for GameObject.renderMask\nvar _FLAG=8;// 1000\n/**\r\n * Provides methods used for getting and setting the texture of a Game Object.\r\n *\r\n * @name Phaser.GameObjects.Components.Texture\r\n * @since 3.0.0\r\n */var Texture={/**\r\n     * The Texture this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Texture#texture\r\n     * @type {Phaser.Textures.Texture}\r\n     * @since 3.0.0\r\n     */texture:null,/**\r\n     * The Texture Frame this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Texture#frame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @since 3.0.0\r\n     */frame:null,/**\r\n     * Sets the texture and frame this Game Object will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Texture#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setTexture:function setTexture(key,frame){this.texture=this.scene.sys.textures.get(key);return this.setFrame(frame);},/**\r\n     * Sets the frame this Game Object will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.\r\n     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Texture#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer)} frame - The name or index of the frame within the Texture.\r\n     * @param {boolean} [updateSize=true] - Should this call adjust the size of the Game Object?\r\n     * @param {boolean} [updateOrigin=true] - Should this call adjust the origin of the Game Object?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setFrame:function setFrame(frame,updateSize,updateOrigin){if(updateSize===undefined){updateSize=true;}if(updateOrigin===undefined){updateOrigin=true;}this.frame=this.texture.get(frame);if(!this.frame.cutWidth||!this.frame.cutHeight){this.renderFlags&=~_FLAG;}else{this.renderFlags|=_FLAG;}if(this._sizeComponent&&updateSize){this.setSizeToFrame();}if(this._originComponent&&updateOrigin){if(this.frame.customPivot){this.setOrigin(this.frame.pivotX,this.frame.pivotY);}else{this.updateDisplayOrigin();}}return this;}};module.exports=Texture;/***/},/* 952 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Provides methods used for getting and setting the size of a Game Object.\r\n * \r\n * @name Phaser.GameObjects.Components.Size\r\n * @since 3.0.0\r\n */var Size={/**\r\n     * A property indicating that a Game Object has this component.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#_sizeComponent\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.2.0\r\n     */_sizeComponent:true,/**\r\n     * The native (un-scaled) width of this Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */width:0,/**\r\n     * The native (un-scaled) height of this Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */height:0,/**\r\n     * The displayed width of this Game Object.\r\n     * This value takes into account the scale factor.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#displayWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */displayWidth:{get:function get(){return this.scaleX*this.frame.realWidth;},set:function set(value){this.scaleX=value/this.frame.realWidth;}},/**\r\n     * The displayed height of this Game Object.\r\n     * This value takes into account the scale factor.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#displayHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */displayHeight:{get:function get(){return this.scaleY*this.frame.realHeight;},set:function set(value){this.scaleY=value/this.frame.realHeight;}},/**\r\n     * Sets the size of this Game Object to be that of the given Frame.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Size#setSizeToFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} frame - The frame to base the size of this Game Object on.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setSizeToFrame:function setSizeToFrame(frame){if(frame===undefined){frame=this.frame;}this.width=frame.realWidth;this.height=frame.realHeight;return this;},/**\r\n     * Sets the size of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Size#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setSize:function setSize(width,height){this.width=width;this.height=height;return this;},/**\r\n     * Sets the display size of this Game Object.\r\n     * Calling this will adjust the scale.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Size#setDisplaySize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setDisplaySize:function setDisplaySize(width,height){this.displayWidth=width;this.displayHeight=height;return this;}};module.exports=Size;/***/},/* 953 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Provides methods used for getting and setting the Scroll Factor of a Game Object.\r\n *\r\n * @name Phaser.GameObjects.Components.ScrollFactor\r\n * @since 3.0.0\r\n */var ScrollFactor={/**\r\n     * The horizontal scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */scrollFactorX:1,/**\r\n     * The vertical scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */scrollFactorY:1,/**\r\n     * Sets the scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.ScrollFactor#setScrollFactor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scroll factor of this Game Object.\r\n     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setScrollFactor:function setScrollFactor(x,y){if(y===undefined){y=x;}this.scrollFactorX=x;this.scrollFactorY=y;return this;}};module.exports=ScrollFactor;/***/},/* 954 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var ScaleModes=__webpack_require__(82);/**\r\n * Provides methods used for getting and setting the scale of a Game Object.\r\n *\r\n * @name Phaser.GameObjects.Components.ScaleMode\r\n * @since 3.0.0\r\n */var ScaleMode={_scaleMode:ScaleModes.DEFAULT,/**\r\n     * The Scale Mode being used by this Game Object.\r\n     * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScaleMode#scaleMode\r\n     * @type {Phaser.ScaleModes}\r\n     * @since 3.0.0\r\n     */scaleMode:{get:function get(){return this._scaleMode;},set:function set(value){if(value===ScaleModes.LINEAR||value===ScaleModes.NEAREST){this._scaleMode=value;}}},/**\r\n     * Sets the Scale Mode being used by this Game Object.\r\n     * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.ScaleMode#setScaleMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.ScaleModes} value - The Scale Mode to be used by this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setScaleMode:function setScaleMode(value){this.scaleMode=value;return this;}};module.exports=ScaleMode;/***/},/* 955 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Provides methods used for getting and setting the origin of a Game Object.\r\n * Values are normalized, given in the range 0 to 1.\r\n * Display values contain the calculated pixel values.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @name Phaser.GameObjects.Components.Origin\r\n * @since 3.0.0\r\n */var Origin={/**\r\n     * A property indicating that a Game Object has this component.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#_originComponent\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.2.0\r\n     */_originComponent:true,/**\r\n     * The horizontal origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the left of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#originX\r\n     * @type {float}\r\n     * @default 0.5\r\n     * @since 3.0.0\r\n     */originX:0.5,/**\r\n     * The vertical origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the top of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#originY\r\n     * @type {float}\r\n     * @default 0.5\r\n     * @since 3.0.0\r\n     */originY:0.5,//  private + read only\n_displayOriginX:0,_displayOriginY:0,/**\r\n     * The horizontal display origin of this Game Object.\r\n     * The origin is a normalized value between 0 and 1.\r\n     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#displayOriginX\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */displayOriginX:{get:function get(){return this._displayOriginX;},set:function set(value){this._displayOriginX=value;this.originX=value/this.width;}},/**\r\n     * The vertical display origin of this Game Object.\r\n     * The origin is a normalized value between 0 and 1.\r\n     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#displayOriginY\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */displayOriginY:{get:function get(){return this._displayOriginY;},set:function set(value){this._displayOriginY=value;this.originY=value/this.height;}},/**\r\n     * Sets the origin of this Game Object.\r\n     *\r\n     * The values are given in the range 0 to 1.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Origin#setOrigin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0.5] - The horizontal origin value.\r\n     * @param {number} [y=x] - The vertical origin value. If not defined it will be set to the value of `x`.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setOrigin:function setOrigin(x,y){if(x===undefined){x=0.5;}if(y===undefined){y=x;}this.originX=x;this.originY=y;return this.updateDisplayOrigin();},/**\r\n     * Sets the origin of this Game Object based on the Pivot values in its Frame.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Origin#setOriginFromFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setOriginFromFrame:function setOriginFromFrame(){if(!this.frame||!this.frame.customPivot){return this.setOrigin();}else{this.originX=this.frame.pivotX;this.originY=this.frame.pivotY;}return this.updateDisplayOrigin();},/**\r\n     * Sets the display origin of this Game Object.\r\n     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Origin#setDisplayOrigin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal display origin value.\r\n     * @param {number} [y=x] - The vertical display origin value. If not defined it will be set to the value of `x`.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setDisplayOrigin:function setDisplayOrigin(x,y){if(x===undefined){x=0;}if(y===undefined){y=x;}this.displayOriginX=x;this.displayOriginY=y;return this;},/**\r\n     * Updates the Display Origin cached values internally stored on this Game Object.\r\n     * You don't usually call this directly, but it is exposed for edge-cases where you may.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Origin#updateDisplayOrigin\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */updateDisplayOrigin:function updateDisplayOrigin(){this._displayOriginX=Math.round(this.originX*this.width);this._displayOriginY=Math.round(this.originY*this.height);return this;}};module.exports=Origin;/***/},/* 956 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Provides methods used for getting and setting the transform values of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.MatrixStack\r\n * @since 3.2.0\r\n */var MatrixStack={/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.GameObjects.Components.MatrixStack#matrixStack\r\n     * @type {Float32Array}\r\n     * @private\r\n     * @since 3.2.0\r\n     */matrixStack:null,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.GameObjects.Components.MatrixStack#currentMatrix\r\n     * @type {Float32Array}\r\n     * @private\r\n     * @since 3.2.0\r\n     */currentMatrix:null,/**\r\n     * [description]\r\n     * \r\n     * @name Phaser.GameObjects.Components.MatrixStack#currentMatrixIndex\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.2.0\r\n     */currentMatrixIndex:0,/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#initMatrixStack\r\n     * @since 3.2.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */initMatrixStack:function initMatrixStack(){this.matrixStack=new Float32Array(6000);// up to 1000 matrices\nthis.currentMatrix=new Float32Array([1,0,0,1,0,0]);this.currentMatrixIndex=0;return this;},/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#save\r\n     * @since 3.2.0\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */save:function save(){if(this.currentMatrixIndex>=this.matrixStack.length){return this;}var matrixStack=this.matrixStack;var currentMatrix=this.currentMatrix;var currentMatrixIndex=this.currentMatrixIndex;this.currentMatrixIndex+=6;matrixStack[currentMatrixIndex+0]=currentMatrix[0];matrixStack[currentMatrixIndex+1]=currentMatrix[1];matrixStack[currentMatrixIndex+2]=currentMatrix[2];matrixStack[currentMatrixIndex+3]=currentMatrix[3];matrixStack[currentMatrixIndex+4]=currentMatrix[4];matrixStack[currentMatrixIndex+5]=currentMatrix[5];return this;},/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#restore\r\n     * @since 3.2.0\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */restore:function restore(){if(this.currentMatrixIndex<=0){return this;}this.currentMatrixIndex-=6;var matrixStack=this.matrixStack;var currentMatrix=this.currentMatrix;var currentMatrixIndex=this.currentMatrixIndex;currentMatrix[0]=matrixStack[currentMatrixIndex+0];currentMatrix[1]=matrixStack[currentMatrixIndex+1];currentMatrix[2]=matrixStack[currentMatrixIndex+2];currentMatrix[3]=matrixStack[currentMatrixIndex+3];currentMatrix[4]=matrixStack[currentMatrixIndex+4];currentMatrix[5]=matrixStack[currentMatrixIndex+5];return this;},/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#loadIdentity\r\n     * @since 3.2.0\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */loadIdentity:function loadIdentity(){this.setTransform(1,0,0,1,0,0);return this;},/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#transform\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} a - [description]\r\n     * @param {number} b - [description]\r\n     * @param {number} c - [description]\r\n     * @param {number} d - [description]\r\n     * @param {number} tx - [description]\r\n     * @param {number} ty - [description]\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */transform:function transform(a,b,c,d,tx,ty){var currentMatrix=this.currentMatrix;var m0=currentMatrix[0];var m1=currentMatrix[1];var m2=currentMatrix[2];var m3=currentMatrix[3];var m4=currentMatrix[4];var m5=currentMatrix[5];currentMatrix[0]=m0*a+m2*b;currentMatrix[1]=m1*a+m3*b;currentMatrix[2]=m0*c+m2*d;currentMatrix[3]=m1*c+m3*d;currentMatrix[4]=m0*tx+m2*ty+m4;currentMatrix[5]=m1*tx+m3*ty+m5;return this;},/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#setTransform\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} a - [description]\r\n     * @param {number} b - [description]\r\n     * @param {number} c - [description]\r\n     * @param {number} d - [description]\r\n     * @param {number} tx - [description]\r\n     * @param {number} ty - [description]\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setTransform:function setTransform(a,b,c,d,tx,ty){var currentMatrix=this.currentMatrix;currentMatrix[0]=a;currentMatrix[1]=b;currentMatrix[2]=c;currentMatrix[3]=d;currentMatrix[4]=tx;currentMatrix[5]=ty;return this;},/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#translate\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */translate:function translate(x,y){var currentMatrix=this.currentMatrix;var m0=currentMatrix[0];var m1=currentMatrix[1];var m2=currentMatrix[2];var m3=currentMatrix[3];var m4=currentMatrix[4];var m5=currentMatrix[5];currentMatrix[4]=m0*x+m2*y+m4;currentMatrix[5]=m1*x+m3*y+m5;return this;},/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#scale\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */scale:function scale(x,y){var currentMatrix=this.currentMatrix;var m0=currentMatrix[0];var m1=currentMatrix[1];var m2=currentMatrix[2];var m3=currentMatrix[3];currentMatrix[0]=m0*x;currentMatrix[1]=m1*x;currentMatrix[2]=m2*y;currentMatrix[3]=m3*y;return this;},/**\r\n     * [description]\r\n     * \r\n     * @method Phaser.GameObjects.Components.MatrixStack#rotate\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} t - The angle of rotation, in radians.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */rotate:function rotate(t){var currentMatrix=this.currentMatrix;var m0=currentMatrix[0];var m1=currentMatrix[1];var m2=currentMatrix[2];var m3=currentMatrix[3];var st=Math.sin(t);var ct=Math.cos(t);currentMatrix[0]=m0*ct+m2*st;currentMatrix[1]=m1*ct+m3*st;currentMatrix[2]=m0*-st+m2*ct;currentMatrix[3]=m1*-st+m3*ct;return this;}};module.exports=MatrixStack;/***/},/* 957 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Rectangle=__webpack_require__(10);var RotateAround=__webpack_require__(363);var Vector2=__webpack_require__(6);/**\r\n * Provides methods used for obtaining the bounds of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @name Phaser.GameObjects.Components.GetBounds\r\n * @since 3.0.0\r\n */var GetBounds={/**\r\n     * Gets the center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getCenter\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */getCenter:function getCenter(output){if(output===undefined){output=new Vector2();}output.x=this.x-this.displayWidth*this.originX+this.displayWidth/2;output.y=this.y-this.displayHeight*this.originY+this.displayHeight/2;return output;},/**\r\n     * Gets the top-left corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getTopLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */getTopLeft:function getTopLeft(output,includeParent){if(!output){output=new Vector2();}if(includeParent===undefined){includeParent=false;}output.x=this.x-this.displayWidth*this.originX;output.y=this.y-this.displayHeight*this.originY;if(this.rotation!==0){RotateAround(output,this.x,this.y,this.rotation);}if(includeParent&&this.parentContainer){var parentMatrix=this.parentContainer.getBoundsTransformMatrix();parentMatrix.transformPoint(output.x,output.y,output);}return output;},/**\r\n     * Gets the top-right corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getTopRight\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */getTopRight:function getTopRight(output,includeParent){if(!output){output=new Vector2();}if(includeParent===undefined){includeParent=false;}output.x=this.x-this.displayWidth*this.originX+this.displayWidth;output.y=this.y-this.displayHeight*this.originY;if(this.rotation!==0){RotateAround(output,this.x,this.y,this.rotation);}if(includeParent&&this.parentContainer){var parentMatrix=this.parentContainer.getBoundsTransformMatrix();parentMatrix.transformPoint(output.x,output.y,output);}return output;},/**\r\n     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBottomLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */getBottomLeft:function getBottomLeft(output,includeParent){if(!output){output=new Vector2();}if(includeParent===undefined){includeParent=false;}output.x=this.x-this.displayWidth*this.originX;output.y=this.y-this.displayHeight*this.originY+this.displayHeight;if(this.rotation!==0){RotateAround(output,this.x,this.y,this.rotation);}if(includeParent&&this.parentContainer){var parentMatrix=this.parentContainer.getBoundsTransformMatrix();parentMatrix.transformPoint(output.x,output.y,output);}return output;},/**\r\n     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBottomRight\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */getBottomRight:function getBottomRight(output,includeParent){if(!output){output=new Vector2();}if(includeParent===undefined){includeParent=false;}output.x=this.x-this.displayWidth*this.originX+this.displayWidth;output.y=this.y-this.displayHeight*this.originY+this.displayHeight;if(this.rotation!==0){RotateAround(output,this.x,this.y,this.rotation);}if(includeParent&&this.parentContainer){var parentMatrix=this.parentContainer.getBoundsTransformMatrix();parentMatrix.transformPoint(output.x,output.y,output);}return output;},/**\r\n     * Gets the bounds of this Game Object, regardless of origin.\r\n     * The values are stored and returned in a Rectangle, or Rectangle-like, object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Geom.Rectangle|object)} [output] - An object to store the values in. If not provided a new Rectangle will be created.\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)} The values stored in the output object.\r\n     */getBounds:function getBounds(output){if(output===undefined){output=new Rectangle();}//  We can use the output object to temporarily store the x/y coords in:\nvar TLx,TLy,TRx,TRy,BLx,BLy,BRx,BRy;// Instead of doing a check if parent container is \n// defined per corner we only do it once.\nif(this.parentContainer){var parentMatrix=this.parentContainer.getBoundsTransformMatrix();this.getTopLeft(output);parentMatrix.transformPoint(output.x,output.y,output);TLx=output.x;TLy=output.y;this.getTopRight(output);parentMatrix.transformPoint(output.x,output.y,output);TRx=output.x;TRy=output.y;this.getBottomLeft(output);parentMatrix.transformPoint(output.x,output.y,output);BLx=output.x;BLy=output.y;this.getBottomRight(output);parentMatrix.transformPoint(output.x,output.y,output);BRx=output.x;BRy=output.y;}else{this.getTopLeft(output);TLx=output.x;TLy=output.y;this.getTopRight(output);TRx=output.x;TRy=output.y;this.getBottomLeft(output);BLx=output.x;BLy=output.y;this.getBottomRight(output);BRx=output.x;BRy=output.y;}output.x=Math.min(TLx,TRx,BLx,BRx);output.y=Math.min(TLy,TRy,BLy,BRy);output.width=Math.max(TLx,TRx,BLx,BRx)-output.x;output.height=Math.max(TLy,TRy,BLy,BRy)-output.y;return output;}};module.exports=GetBounds;/***/},/* 958 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Provides methods used for visually flipping a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.Flip\r\n * @since 3.0.0\r\n */var Flip={/**\r\n     * The horizontally flipped state of the Game Object.\r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */flipX:false,/**\r\n     * The vertically flipped state of the Game Object.\r\n     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */flipY:false,/**\r\n     * Toggles the horizontal flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipX\r\n     * @since 3.0.0\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */toggleFlipX:function toggleFlipX(){this.flipX=!this.flipX;return this;},/**\r\n     * Toggles the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipY\r\n     * @since 3.0.0\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */toggleFlipY:function toggleFlipY(){this.flipY=!this.flipY;return this;},/**\r\n     * Sets the horizontal flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setFlipX:function setFlipX(value){this.flipX=value;return this;},/**\r\n     * Sets the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setFlipY:function setFlipY(value){this.flipY=value;return this;},/**\r\n     * Sets the horizontal and vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setFlip:function setFlip(x,y){this.flipX=x;this.flipY=y;return this;},/**\r\n     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#resetFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */resetFlip:function resetFlip(){this.flipX=false;this.flipY=false;return this;}};module.exports=Flip;/***/},/* 959 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Provides methods used for setting the depth of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.Depth\r\n * @since 3.0.0\r\n */var Depth={/**\r\n     * Private internal value. Holds the depth of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Depth#_depth\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */_depth:0,/**\r\n     * The depth of this Game Object within the Scene.\r\n     * \r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Depth#depth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */depth:{get:function get(){return this._depth;},set:function set(value){this.scene.sys.queueDepthSort();this._depth=value;}},/**\r\n     * The depth of this Game Object within the Scene.\r\n     * \r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Depth#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} value - The depth of this Game Object.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setDepth:function setDepth(value){if(value===undefined){value=0;}this.depth=value;return this;}};module.exports=Depth;/***/},/* 960 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Provides methods used for calculating and setting the size of a non-Frame based Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.ComputedSize\r\n * @since 3.0.0\r\n */var ComputedSize={/**\r\n     * The native (un-scaled) width of this Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */width:0,/**\r\n     * The native (un-scaled) height of this Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */height:0,/**\r\n     * The displayed width of this Game Object.\r\n     * This value takes into account the scale factor.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#displayWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */displayWidth:{get:function get(){return this.scaleX*this.width;},set:function set(value){this.scaleX=value/this.width;}},/**\r\n     * The displayed height of this Game Object.\r\n     * This value takes into account the scale factor.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#displayHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */displayHeight:{get:function get(){return this.scaleY*this.height;},set:function set(value){this.scaleY=value/this.height;}},/**\r\n     * Sets the size of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.ComputedSize#setSize\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setSize:function setSize(width,height){this.width=width;this.height=height;return this;},/**\r\n     * Sets the display size of this Game Object.\r\n     * Calling this will adjust the scale.\r\n     * \r\n     * @method Phaser.GameObjects.Components.ComputedSize#setDisplaySize\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setDisplaySize:function setDisplaySize(width,height){this.displayWidth=width;this.displayHeight=height;return this;}};module.exports=ComputedSize;/***/},/* 961 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var BlendModes=__webpack_require__(64);/**\r\n * Provides methods used for setting the blend mode of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @name Phaser.GameObjects.Components.BlendMode\r\n * @since 3.0.0\r\n */var BlendMode={/**\r\n     * Private internal value. Holds the current blend mode.\r\n     * \r\n     * @name Phaser.GameObjects.Components.BlendMode#_blendMode\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */_blendMode:BlendModes.NORMAL,/**\r\n     * Sets the Blend Mode being used by this Game Object.\r\n     *\r\n     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)\r\n     *\r\n     * Under WebGL only the following Blend Modes are available:\r\n     *\r\n     * * ADD\r\n     * * MULTIPLY\r\n     * * SCREEN\r\n     *\r\n     * Canvas has more available depending on browser support.\r\n     *\r\n     * You can also create your own custom Blend Modes in WebGL.\r\n     *\r\n     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending\r\n     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these\r\n     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes\r\n     * are used.\r\n     *\r\n     * @name Phaser.GameObjects.Components.BlendMode#blendMode\r\n     * @type {(Phaser.BlendModes|string)}\r\n     * @since 3.0.0\r\n     */blendMode:{get:function get(){return this._blendMode;},set:function set(value){if(typeof value==='string'){value=BlendModes[value];}value|=0;if(value>=0){this._blendMode=value;}}},/**\r\n     * Sets the Blend Mode being used by this Game Object.\r\n     *\r\n     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)\r\n     *\r\n     * Under WebGL only the following Blend Modes are available:\r\n     *\r\n     * * ADD\r\n     * * MULTIPLY\r\n     * * SCREEN\r\n     *\r\n     * Canvas has more available depending on browser support.\r\n     *\r\n     * You can also create your own custom Blend Modes in WebGL.\r\n     *\r\n     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending\r\n     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these\r\n     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes\r\n     * are used.\r\n     *\r\n     * @method Phaser.GameObjects.Components.BlendMode#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.BlendModes)} value - The BlendMode value. Either a string or a CONST.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setBlendMode:function setBlendMode(value){this.blendMode=value;return this;}};module.exports=BlendMode;/***/},/* 962 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clamp=__webpack_require__(50);//  bitmask flag for GameObject.renderMask\nvar _FLAG=2;// 0010\n/**\r\n * Provides methods used for setting the alpha properties of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @name Phaser.GameObjects.Components.Alpha\r\n * @since 3.0.0\r\n */var Alpha={/**\r\n     * Private internal value. Holds the global alpha value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#_alpha\r\n     * @type {float}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */_alpha:1,/**\r\n     * Private internal value. Holds the top-left alpha value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaTL\r\n     * @type {float}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */_alphaTL:1,/**\r\n     * Private internal value. Holds the top-right alpha value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaTR\r\n     * @type {float}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */_alphaTR:1,/**\r\n     * Private internal value. Holds the bottom-left alpha value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaBL\r\n     * @type {float}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */_alphaBL:1,/**\r\n     * Private internal value. Holds the bottom-right alpha value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaBR\r\n     * @type {float}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */_alphaBR:1,/**\r\n     * Clears all alpha values associated with this Game Object.\r\n     * Immediately sets the alpha levels back to 1 (fully opaque)\r\n     *\r\n     * @method Phaser.GameObjects.Components.Alpha#clearAlpha\r\n     * @since 3.0.0\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */clearAlpha:function clearAlpha(){return this.setAlpha(1);},/**\r\n     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.\r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * If your game is running under WebGL you can optionally specify four different alpha values, each of which\r\n     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Alpha#setAlpha\r\n     * @since 3.0.0\r\n     * \r\n     * @param {float} [topLeft=1] - The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object.\r\n     * @param {float} [topRight] - The alpha value used for the top-right of the Game Object. WebGL only.\r\n     * @param {float} [bottomLeft] - The alpha value used for the bottom-left of the Game Object. WebGL only.\r\n     * @param {float} [bottomRight] - The alpha value used for the bottom-right of the Game Object. WebGL only.\r\n     * \r\n     * @return {Phaser.GameObjects.GameObject} This Game Object instance.\r\n     */setAlpha:function setAlpha(topLeft,topRight,bottomLeft,bottomRight){if(topLeft===undefined){topLeft=1;}//  Treat as if there is only one alpha value for the whole Game Object\nif(topRight===undefined){this.alpha=topLeft;}else{this._alphaTL=Clamp(topLeft,0,1);this._alphaTR=Clamp(topRight,0,1);this._alphaBL=Clamp(bottomLeft,0,1);this._alphaBR=Clamp(bottomRight,0,1);}return this;},/**\r\n     * The alpha value of the Game Object.\r\n     *\r\n     * This is a global value, impacting the entire Game Object, not just a region of it.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#alpha\r\n     * @type {float}\r\n     * @since 3.0.0\r\n     */alpha:{get:function get(){return this._alpha;},set:function set(value){var v=Clamp(value,0,1);this._alpha=v;this._alphaTL=v;this._alphaTR=v;this._alphaBL=v;this._alphaBR=v;if(v===0){this.renderFlags&=~_FLAG;}else{this.renderFlags|=_FLAG;}}},/**\r\n     * The alpha value starting from the top-left of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#alphaTopLeft\r\n     * @type {float}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */alphaTopLeft:{get:function get(){return this._alphaTL;},set:function set(value){var v=Clamp(value,0,1);this._alphaTL=v;if(v!==0){this.renderFlags|=_FLAG;}}},/**\r\n     * The alpha value starting from the top-right of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#alphaTopRight\r\n     * @type {float}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */alphaTopRight:{get:function get(){return this._alphaTR;},set:function set(value){var v=Clamp(value,0,1);this._alphaTR=v;if(v!==0){this.renderFlags|=_FLAG;}}},/**\r\n     * The alpha value starting from the bottom-left of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#alphaBottomLeft\r\n     * @type {float}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */alphaBottomLeft:{get:function get(){return this._alphaBL;},set:function set(value){var v=Clamp(value,0,1);this._alphaBL=v;if(v!==0){this.renderFlags|=_FLAG;}}},/**\r\n     * The alpha value starting from the bottom-right of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Alpha#alphaBottomRight\r\n     * @type {float}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */alphaBottomRight:{get:function get(){return this._alphaBR;},set:function set(value){var v=Clamp(value,0,1);this._alphaBR=v;if(v!==0){this.renderFlags|=_FLAG;}}}};module.exports=Alpha;/***/},/* 963 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class RandomDataGenerator\r\n * @memberOf Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string[]} [seeds] - [description]\r\n */var RandomDataGenerator=new Class({initialize:function RandomDataGenerator(seeds){/**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#c\r\n         * @type {number}\r\n         * @default 1\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.c=1;/**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s0\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.s0=0;/**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s1\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.s1=0;/**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s2\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */this.s2=0;/**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#n\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.2.0\r\n         */this.n=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#sign\r\n         * @type {number[]}\r\n         * @since 3.0.0\r\n         */this.signs=[-1,1];if(seeds){this.init(seeds);}},/**\r\n     * Private random helper.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#rnd\r\n     * @since 3.0.0\r\n     * @private\r\n     *\r\n     * @return {number} [description]\r\n     */rnd:function rnd(){var t=2091639*this.s0+this.c*2.3283064365386963e-10;// 2^-32\nthis.c=t|0;this.s0=this.s1;this.s1=this.s2;this.s2=t-this.c;return this.s2;},/**\r\n     * Internal method that creates a seed hash.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#hash\r\n     * @since 3.0.0\r\n     * @private\r\n     *\r\n     * @param {string} data - [description]\r\n     *\r\n     * @return {number} The hashed value.\r\n     */hash:function hash(data){var h;var n=this.n;data=data.toString();for(var i=0;i<data.length;i++){n+=data.charCodeAt(i);h=0.02519603282416938*n;n=h>>>0;h-=n;h*=n;n=h>>>0;h-=n;n+=h*0x100000000;// 2^32\n}this.n=n;return(n>>>0)*2.3283064365386963e-10;// 2^-32\n},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} seeds - [description]\r\n     */init:function init(seeds){if(typeof seeds==='string'){this.state(seeds);}else{this.sow(seeds);}},/**\r\n     * Reset the seed of the random data generator.\r\n     *\r\n     * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#sow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string[]} seeds - The array of seeds: the `toString()` of each value is used.\r\n     */sow:function sow(seeds){// Always reset to default seed\nthis.n=0xefc8249d;this.s0=this.hash(' ');this.s1=this.hash(' ');this.s2=this.hash(' ');this.c=1;if(!seeds){return;}// Apply any seeds\nfor(var i=0;i<seeds.length&&seeds[i]!=null;i++){var seed=seeds[i];this.s0-=this.hash(seed);this.s0+=~~(this.s0<0);this.s1-=this.hash(seed);this.s1+=~~(this.s1<0);this.s2-=this.hash(seed);this.s2+=~~(this.s2<0);}},/**\r\n     * Returns a random integer between 0 and 2^32.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#integer\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random integer between 0 and 2^32.\r\n     */integer:function integer(){// 2^32\nreturn this.rnd()*0x100000000;},/**\r\n     * Returns a random real number between 0 and 1.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#frac\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between 0 and 1.\r\n     */frac:function frac(){// 2^-53\nreturn this.rnd()+(this.rnd()*0x200000|0)*1.1102230246251565e-16;},/**\r\n     * Returns a random real number between 0 and 2^32.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#real\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between 0 and 2^32.\r\n     */real:function real(){return this.integer()+this.frac();},/**\r\n     * Returns a random integer between and including min and max.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#integerInRange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */integerInRange:function integerInRange(min,max){return Math.floor(this.realInRange(0,max-min+1)+min);},/**\r\n     * Returns a random integer between and including min and max.\r\n     * This method is an alias for RandomDataGenerator.integerInRange.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#between\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */between:function between(min,max){return Math.floor(this.realInRange(0,max-min+1)+min);},/**\r\n     * Returns a random real number between min and max.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#realInRange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */realInRange:function realInRange(min,max){return this.frac()*(max-min)+min;},/**\r\n     * Returns a random real number between -1 and 1.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#normal\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between -1 and 1.\r\n     */normal:function normal(){return 1-2*this.frac();},/**\r\n     * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#uuid\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string} A valid RFC4122 version4 ID hex string\r\n     */uuid:function uuid(){var a='';var b='';for(b=a='';a++<36;b+=~a%5|a*3&4?(a^15?8^this.frac()*(a^20?16:4):4).toString(16):'-'){// eslint-disable-next-line no-empty\n}return b;},/**\r\n     * Returns a random element from within the given array.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#pick\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} array - The array to pick a random element from.\r\n     *\r\n     * @return {*} A random member of the array.\r\n     */pick:function pick(array){return array[this.integerInRange(0,array.length-1)];},/**\r\n     * Returns a sign to be used with multiplication operator.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#sign\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} -1 or +1.\r\n     */sign:function sign(){return this.pick(this.signs);},/**\r\n     * Returns a random element from within the given array, favoring the earlier entries.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#weightedPick\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} array - The array to pick a random element from.\r\n     *\r\n     * @return {*} A random member of the array.\r\n     */weightedPick:function weightedPick(array){return array[~~(Math.pow(this.frac(),2)*(array.length-1)+0.5)];},/**\r\n     * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#timestamp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random timestamp between min and max.\r\n     */timestamp:function timestamp(min,max){return this.realInRange(min||946684800000,max||1577862000000);},/**\r\n     * Returns a random angle between -180 and 180.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random number between -180 and 180.\r\n     */angle:function angle(){return this.integerInRange(-180,180);},/**\r\n     * Returns a random rotation in radians, between -3.141 and 3.141\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#rotation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random number between -3.141 and 3.141\r\n     */rotation:function rotation(){return this.realInRange(-3.1415926,3.1415926);},/**\r\n     * Gets or Sets the state of the generator. This allows you to retain the values\r\n     * that the generator is using between games, i.e. in a game save file.\r\n     *\r\n     * To seed this generator with a previously saved state you can pass it as the\r\n     * `seed` value in your game config, or call this method directly after Phaser has booted.\r\n     *\r\n     * Call this method with no parameters to return the current state.\r\n     *\r\n     * If providing a state it should match the same format that this method\r\n     * returns, which is a string with a header `!rnd` followed by the `c`,\r\n     * `s0`, `s1` and `s2` values respectively, each comma-delimited.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#state\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [state] - Generator state to be set.\r\n     *\r\n     * @return {string} The current state of the generator.\r\n     */state:function state(_state){if(typeof _state==='string'&&_state.match(/^!rnd/)){_state=_state.split(',');this.c=parseFloat(_state[1]);this.s0=parseFloat(_state[2]);this.s1=parseFloat(_state[3]);this.s2=parseFloat(_state[4]);}return['!rnd',this.c,this.s0,this.s1,this.s2].join(',');}});module.exports=RandomDataGenerator;/***/},/* 964 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var AlignIn=__webpack_require__(379);var CONST=__webpack_require__(176);var GetFastValue=__webpack_require__(2);var NOOP=__webpack_require__(3);var Zone=__webpack_require__(110);var tempZone=new Zone({sys:{queueDepthSort:NOOP}},0,0,1,1);/**\r\n * @typedef {object} GridAlignConfig\r\n *\r\n * @property {integer} [width=-1] - The width of the grid in items (not pixels). -1 means lay all items out horizontally, regardless of quantity.\r\n *                                  If both this value and height are set to -1 then this value overrides it and the `height` value is ignored.\r\n * @property {integer} [height=-1] - The height of the grid in items (not pixels). -1 means lay all items out vertically, regardless of quantity.\r\n *                                   If both this value and `width` are set to -1 then `width` overrides it and this value is ignored.\r\n * @property {boolean} [cellWidth=1] - The width of the cell, in pixels, in which the item is positioned.\r\n * @property {integer} [cellHeight=1] - The height of the cell, in pixels, in which the item is positioned.\r\n * @property {integer} [position=0] - The alignment position. One of the Phaser.Display.Align consts such as `TOP_LEFT` or `RIGHT_CENTER`.\r\n * @property {number} [x=0] - Optionally place the top-left of the final grid at this coordinate.\r\n * @property {number} [y=0] - Optionally place the top-left of the final grid at this coordinate.\r\n *//**\r\n * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,\r\n * and then aligns them based on the grid configuration given to this action.\r\n *\r\n * @function Phaser.Actions.GridAlign\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {GridAlignConfig} options - The GridAlign Configuration object.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var GridAlign=function GridAlign(items,options){if(options===undefined){options={};}var width=GetFastValue(options,'width',-1);var height=GetFastValue(options,'height',-1);var cellWidth=GetFastValue(options,'cellWidth',1);var cellHeight=GetFastValue(options,'cellHeight',cellWidth);var position=GetFastValue(options,'position',CONST.TOP_LEFT);var x=GetFastValue(options,'x',0);var y=GetFastValue(options,'y',0);var cx=0;var cy=0;var w=width*cellWidth;var h=height*cellHeight;tempZone.setPosition(x,y);tempZone.setSize(cellWidth,cellHeight);for(var i=0;i<items.length;i++){AlignIn(items[i],tempZone,position);if(width===-1){//  We keep laying them out horizontally until we've done them all\ncy+=cellHeight;tempZone.y+=cellHeight;if(cy===h){cy=0;tempZone.x+=cellWidth;tempZone.y=y;}}else if(height===-1){//  We keep laying them out vertically until we've done them all\ncx+=cellWidth;tempZone.x+=cellWidth;if(cx===w){cx=0;tempZone.x=x;tempZone.y+=cellHeight;}}else{//  We keep laying them out until we hit the column limit\ncx+=cellWidth;tempZone.x+=cellWidth;if(cx===w){cx=0;cy+=cellHeight;tempZone.x=x;tempZone.y+=cellHeight;if(cy===h){//  We've hit the column limit, so return, even if there are items left\nbreak;}}}}return items;};module.exports=GridAlign;/***/},/* 965 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Takes an array of objects and returns the last element in the array that has properties which match\r\n * all of those specified in the `compare` object. For example, if the compare object was: `{ scaleX: 0.5, alpha: 1 }`\r\n * then it would return the last item which had the property `scaleX` set to 0.5 and `alpha` set to 1.\r\n *\r\n * To use this with a Group: `GetLast(group.getChildren(), compare, index)`\r\n *\r\n * @function Phaser.Actions.GetLast\r\n * @since 3.3.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be searched by this action.\r\n * @param {object} compare - The comparison object. Each property in this object will be checked against the items of the array.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n *\r\n * @return {?(object|Phaser.GameObjects.GameObject)} The last object in the array that matches the comparison object, or `null` if no match was found.\r\n */var GetLast=function GetLast(items,compare,index){if(index===undefined){index=0;}for(var i=index;i<items.length;i++){var item=items[i];var match=true;for(var property in compare){if(item[property]!==compare[property]){match=false;}}if(match){return item;}}return null;};module.exports=GetLast;/***/},/* 966 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Takes an array of objects and returns the first element in the array that has properties which match\r\n * all of those specified in the `compare` object. For example, if the compare object was: `{ scaleX: 0.5, alpha: 1 }`\r\n * then it would return the first item which had the property `scaleX` set to 0.5 and `alpha` set to 1.\r\n *\r\n * To use this with a Group: `GetFirst(group.getChildren(), compare, index)`\r\n *\r\n * @function Phaser.Actions.GetFirst\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be searched by this action.\r\n * @param {object} compare - The comparison object. Each property in this object will be checked against the items of the array.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n *\r\n * @return {?(object|Phaser.GameObjects.GameObject)} The first object in the array that matches the comparison object, or `null` if no match was found.\r\n */var GetFirst=function GetFirst(items,compare,index){if(index===undefined){index=0;}for(var i=index;i<items.length;i++){var item=items[i];var match=true;for(var property in compare){if(item[property]!==compare[property]){match=false;}}if(match){return item;}}return null;};module.exports=GetFirst;/***/},/* 967 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @callback CallCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} item - [description]\r\n *//**\r\n * Takes an array of objects and passes each of them to the given callback.\r\n *\r\n * @function Phaser.Actions.Call\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {CallCallback} callback - The callback to be invoked. It will be passed just one argument: the item from the array.\r\n * @param {*} context - The scope in which the callback will be invoked.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that was passed to this Action.\r\n */var Call=function Call(items,callback,context){for(var i=0;i<items.length;i++){var item=items[i];callback.call(context,item);}return items;};module.exports=Call;/***/},/* 968 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var PropertyValueInc=__webpack_require__(25);/**\r\n * Takes an array of Game Objects, or any objects that have a public `angle` property,\r\n * and then adds the given value to each of their `angle` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `Angle(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.Angle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `angle` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */var Angle=function Angle(items,value,step,index,direction){return PropertyValueInc(items,'angle',value,step,index,direction);};module.exports=Angle;/***/},/* 969 *//***/function(module,exports){/**\r\n* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9\r\n* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/\r\n* Cameron Foale (http://www.kibibu.com)\r\n*/if(typeof window.Uint32Array!=='function'&&_typeof(window.Uint32Array)!=='object'){var CheapArray=function CheapArray(fakeType){var proto=new Array();// jshint ignore:line\nwindow[fakeType]=function(arg){if(typeof arg==='number'){Array.call(this,arg);this.length=arg;for(var i=0;i<this.length;i++){this[i]=0;}}else{Array.call(this,arg.length);this.length=arg.length;for(var i=0;i<this.length;i++){this[i]=arg[i];}}};window[fakeType].prototype=proto;window[fakeType].constructor=window[fakeType];};CheapArray('Float32Array');// jshint ignore:line\nCheapArray('Uint32Array');// jshint ignore:line\nCheapArray('Uint16Array');// jshint ignore:line\nCheapArray('Int16Array');// jshint ignore:line\nCheapArray('ArrayBuffer');// jshint ignore:line\n}/***/},/* 970 *//***/function(module,exports,__webpack_require__){/* WEBPACK VAR INJECTION */(function(global){// References:\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// https://gist.github.com/1579671\n// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n// https://gist.github.com/timhall/4078614\n// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame\n// Expected to be used with Browserfiy\n// Browserify automatically detects the use of `global` and passes the\n// correct reference of `global`, `self`, and finally `window`\n// Date.now\nif(!(Date.now&&Date.prototype.getTime)){Date.now=function now(){return new Date().getTime();};}// performance.now\nif(!(global.performance&&global.performance.now)){var startTime=Date.now();if(!global.performance){global.performance={};}global.performance.now=function(){return Date.now()-startTime;};}// requestAnimationFrame\nvar lastTime=Date.now();var vendors=['ms','moz','webkit','o'];for(var x=0;x<vendors.length&&!global.requestAnimationFrame;++x){global.requestAnimationFrame=global[vendors[x]+'RequestAnimationFrame'];global.cancelAnimationFrame=global[vendors[x]+'CancelAnimationFrame']||global[vendors[x]+'CancelRequestAnimationFrame'];}if(!global.requestAnimationFrame){global.requestAnimationFrame=function(callback){if(typeof callback!=='function'){throw new TypeError(callback+'is not a function');}var currentTime=Date.now(),delay=16+lastTime-currentTime;if(delay<0){delay=0;}lastTime=currentTime;return setTimeout(function(){lastTime=Date.now();callback(performance.now());},delay);};}if(!global.cancelAnimationFrame){global.cancelAnimationFrame=function(id){clearTimeout(id);};}/* WEBPACK VAR INJECTION */}).call(this,__webpack_require__(382));/***/},/* 971 *//***/function(module,exports){/**\r\n * performance.now\r\n */(function(){if('performance'in window===false){window.performance={};}//  Thanks IE8\nDate.now=Date.now||function(){return new Date().getTime();};if('now'in window.performance===false){var nowOffset=Date.now();if(performance.timing&&performance.timing.navigationStart){nowOffset=performance.timing.navigationStart;}window.performance.now=function now(){return Date.now()-nowOffset;};}})();/***/},/* 972 *//***/function(module,exports){// ES6 Math.trunc - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\nif(!Math.trunc){Math.trunc=function trunc(x){return x<0?Math.ceil(x):Math.floor(x);};}/***/},/* 973 *//***/function(module,exports){/**\r\n* A polyfill for Function.prototype.bind\r\n*/if(!Function.prototype.bind){/* jshint freeze: false */Function.prototype.bind=function(){var slice=Array.prototype.slice;return function(thisArg){var target=this,boundArgs=slice.call(arguments,1);if(typeof target!=='function'){throw new TypeError();}function bound(){var args=boundArgs.concat(slice.call(arguments));target.apply(this instanceof bound?this:thisArg,args);}bound.prototype=function F(proto){if(proto){F.prototype=proto;}if(!(this instanceof F)){/* jshint supernew: true */return new F();}}(target.prototype);return bound;};}();}/***/},/* 974 *//***/function(module,exports){/**\r\n * Also fix for the absent console in IE9\r\n */if(!window.console){window.console={};window.console.log=window.console.assert=function(){};window.console.warn=window.console.assert=function(){};}/***/},/* 975 *//***/function(module,exports){/* Copyright 2013 Chris Wilson\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n*//*\r\n\r\nThis monkeypatch library is intended to be included in projects that are\r\nwritten to the proper AudioContext spec (instead of webkitAudioContext),\r\nand that use the new naming and proper bits of the Web Audio API (e.g.\r\nusing BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may\r\nhave to run on systems that only support the deprecated bits.\r\n\r\nThis library should be harmless to include if the browser supports\r\nunprefixed \"AudioContext\", and/or if it supports the new names.\r\n\r\nThe patches this library handles:\r\nif window.AudioContext is unsupported, it will be aliased to webkitAudioContext().\r\nif AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or\r\nnoteGrainOn(), depending on parameters.\r\n\r\nThe following aliases only take effect if the new names are not already in place:\r\n\r\nAudioBufferSourceNode.stop() is aliased to noteOff()\r\nAudioContext.createGain() is aliased to createGainNode()\r\nAudioContext.createDelay() is aliased to createDelayNode()\r\nAudioContext.createScriptProcessor() is aliased to createJavaScriptNode()\r\nAudioContext.createPeriodicWave() is aliased to createWaveTable()\r\nOscillatorNode.start() is aliased to noteOn()\r\nOscillatorNode.stop() is aliased to noteOff()\r\nOscillatorNode.setPeriodicWave() is aliased to setWaveTable()\r\nAudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()\r\n\r\nThis library does NOT patch the enumerated type changes, as it is\r\nrecommended in the specification that implementations support both integer\r\nand string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel\r\nBiquadFilterNode.type and OscillatorNode.type.\r\n\r\n*/(function(global,exports,perf){'use strict';function fixSetTarget(param){if(!param)// if NYI, just return\nreturn;if(!param.setTargetAtTime)param.setTargetAtTime=param.setTargetValueAtTime;}if(window.hasOwnProperty('webkitAudioContext')&&!window.hasOwnProperty('AudioContext')){window.AudioContext=webkitAudioContext;if(!AudioContext.prototype.hasOwnProperty('createGain'))AudioContext.prototype.createGain=AudioContext.prototype.createGainNode;if(!AudioContext.prototype.hasOwnProperty('createDelay'))AudioContext.prototype.createDelay=AudioContext.prototype.createDelayNode;if(!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))AudioContext.prototype.createScriptProcessor=AudioContext.prototype.createJavaScriptNode;if(!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))AudioContext.prototype.createPeriodicWave=AudioContext.prototype.createWaveTable;AudioContext.prototype.internal_createGain=AudioContext.prototype.createGain;AudioContext.prototype.createGain=function(){var node=this.internal_createGain();fixSetTarget(node.gain);return node;};AudioContext.prototype.internal_createDelay=AudioContext.prototype.createDelay;AudioContext.prototype.createDelay=function(maxDelayTime){var node=maxDelayTime?this.internal_createDelay(maxDelayTime):this.internal_createDelay();fixSetTarget(node.delayTime);return node;};AudioContext.prototype.internal_createBufferSource=AudioContext.prototype.createBufferSource;AudioContext.prototype.createBufferSource=function(){var node=this.internal_createBufferSource();if(!node.start){node.start=function(when,offset,duration){if(offset||duration)this.noteGrainOn(when||0,offset,duration);else this.noteOn(when||0);};}else{node.internal_start=node.start;node.start=function(when,offset,duration){if(typeof duration!=='undefined')node.internal_start(when||0,offset,duration);else node.internal_start(when||0,offset||0);};}if(!node.stop){node.stop=function(when){this.noteOff(when||0);};}else{node.internal_stop=node.stop;node.stop=function(when){node.internal_stop(when||0);};}fixSetTarget(node.playbackRate);return node;};AudioContext.prototype.internal_createDynamicsCompressor=AudioContext.prototype.createDynamicsCompressor;AudioContext.prototype.createDynamicsCompressor=function(){var node=this.internal_createDynamicsCompressor();fixSetTarget(node.threshold);fixSetTarget(node.knee);fixSetTarget(node.ratio);fixSetTarget(node.reduction);fixSetTarget(node.attack);fixSetTarget(node.release);return node;};AudioContext.prototype.internal_createBiquadFilter=AudioContext.prototype.createBiquadFilter;AudioContext.prototype.createBiquadFilter=function(){var node=this.internal_createBiquadFilter();fixSetTarget(node.frequency);fixSetTarget(node.detune);fixSetTarget(node.Q);fixSetTarget(node.gain);return node;};if(AudioContext.prototype.hasOwnProperty('createOscillator')){AudioContext.prototype.internal_createOscillator=AudioContext.prototype.createOscillator;AudioContext.prototype.createOscillator=function(){var node=this.internal_createOscillator();if(!node.start){node.start=function(when){this.noteOn(when||0);};}else{node.internal_start=node.start;node.start=function(when){node.internal_start(when||0);};}if(!node.stop){node.stop=function(when){this.noteOff(when||0);};}else{node.internal_stop=node.stop;node.stop=function(when){node.internal_stop(when||0);};}if(!node.setPeriodicWave)node.setPeriodicWave=node.setWaveTable;fixSetTarget(node.frequency);fixSetTarget(node.detune);return node;};}}if(window.hasOwnProperty('webkitOfflineAudioContext')&&!window.hasOwnProperty('OfflineAudioContext')){window.OfflineAudioContext=webkitOfflineAudioContext;}})(window);/***/},/* 976 *//***/function(module,exports){/**\r\n* A polyfill for Array.isArray\r\n*/if(!Array.isArray){Array.isArray=function(arg){return Object.prototype.toString.call(arg)==='[object Array]';};}/***/},/* 977 *//***/function(module,exports){/**\r\n* A polyfill for Array.forEach\r\n* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\r\n*/if(!Array.prototype.forEach){Array.prototype.forEach=function(fun/*, thisArg */){'use strict';if(this===void 0||this===null){throw new TypeError();}var t=Object(this);var len=t.length>>>0;if(typeof fun!=='function'){throw new TypeError();}var thisArg=arguments.length>=2?arguments[1]:void 0;for(var i=0;i<len;i++){if(i in t){fun.call(thisArg,t[i],i,t);}}};}/***/},/* 978 *//***/function(module,exports,__webpack_require__){__webpack_require__(977);__webpack_require__(976);__webpack_require__(975);__webpack_require__(974);__webpack_require__(973);__webpack_require__(972);__webpack_require__(971);__webpack_require__(970);__webpack_require__(969);/***/},/* 979 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Bodies=__webpack_require__(123);var Class=__webpack_require__(0);var Common=__webpack_require__(37);var Composite=__webpack_require__(122);var Engine=__webpack_require__(980);var EventEmitter=__webpack_require__(14);var GetFastValue=__webpack_require__(2);var GetValue=__webpack_require__(5);var MatterBody=__webpack_require__(51);var MatterEvents=__webpack_require__(178);var MatterTileBody=__webpack_require__(469);var MatterWorld=__webpack_require__(464);var Vector=__webpack_require__(83);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {object} config - [description]\r\n */var World=new Class({Extends:EventEmitter,initialize:function World(scene,config){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.World#engine\r\n         * @type {MatterJS.Engine}\r\n         * @since 3.0.0\r\n         */this.engine=Engine.create(config);/**\r\n         * A `World` composite object that will contain all simulated bodies and constraints.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#localWorld\r\n         * @type {MatterJS.World}\r\n         * @since 3.0.0\r\n         */this.localWorld=this.engine.world;var gravity=GetValue(config,'gravity',null);if(gravity){this.setGravity(gravity.x,gravity.y,gravity.scale);}/**\r\n         * An object containing the 4 wall bodies that bound the physics world.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#walls\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.walls={left:null,right:null,top:null,bottom:null};if(GetFastValue(config,'setBounds',false)){var boundsConfig=config['setBounds'];if(typeof boundsConfig==='boolean'){this.setBounds();}else{var x=GetFastValue(boundsConfig,'x',0);var y=GetFastValue(boundsConfig,'y',0);var width=GetFastValue(boundsConfig,'width',scene.sys.game.config.width);var height=GetFastValue(boundsConfig,'height',scene.sys.game.config.height);var thickness=GetFastValue(boundsConfig,'thickness',64);var left=GetFastValue(boundsConfig,'left',true);var right=GetFastValue(boundsConfig,'right',true);var top=GetFastValue(boundsConfig,'top',true);var bottom=GetFastValue(boundsConfig,'bottom',true);this.setBounds(x,y,width,height,thickness,left,right,top,bottom);}}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.World#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.enabled=GetValue(config,'enabled',true);/**\r\n         * The correction argument is an optional Number that specifies the time correction factor to apply to the update.\r\n         * This can help improve the accuracy of the simulation in cases where delta is changing between updates.\r\n         * The value of correction is defined as delta / lastDelta, i.e. the percentage change of delta over the last step.\r\n         * Therefore the value is always 1 (no correction) when delta constant (or when no correction is desired, which is the default).\r\n         * See the paper on Time Corrected Verlet for more information.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#correction\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.4.0\r\n         */this.correction=GetValue(config,'correction',1);/**\r\n         * This function is called every time the core game loop steps, which is bound to the\r\n         * Request Animation Frame frequency unless otherwise modified.\r\n         * \r\n         * The function is passed two values: `time` and `delta`, both of which come from the game step values.\r\n         * \r\n         * It must return a number. This number is used as the delta value passed to Matter.Engine.update.\r\n         * \r\n         * You can override this function with your own to define your own timestep.\r\n         * \r\n         * If you need to update the Engine multiple times in a single game step then call\r\n         * `World.update` as many times as required. Each call will trigger the `getDelta` function.\r\n         * If you wish to have full control over when the Engine updates then see the property `autoUpdate`.\r\n         *\r\n         * You can also adjust the number of iterations that Engine.update performs.\r\n         * Use the Scene Matter Physics config object to set the following properties:\r\n         *\r\n         * positionIterations (defaults to 6)\r\n         * velocityIterations (defaults to 4)\r\n         * constraintIterations (defaults to 2)\r\n         *\r\n         * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n         * of your game.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#getDelta\r\n         * @type {function}\r\n         * @since 3.4.0\r\n         */this.getDelta=GetValue(config,'getDelta',this.update60Hz);/**\r\n         * Automatically call Engine.update every time the game steps.\r\n         * If you disable this then you are responsible for calling `World.step` directly from your game.\r\n         * If you call `set60Hz` or `set30Hz` then `autoUpdate` is reset to `true`.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#autoUpdate\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.4.0\r\n         */this.autoUpdate=GetValue(config,'autoUpdate',true);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.World#drawDebug\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.drawDebug=GetValue(config,'debug',false);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */this.debugGraphic;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.World#defaults\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.defaults={debugShowBody:GetValue(config,'debugShowBody',true),debugShowStaticBody:GetValue(config,'debugShowStaticBody',true),debugShowVelocity:GetValue(config,'debugShowVelocity',true),bodyDebugColor:GetValue(config,'debugBodyColor',0xff00ff),staticBodyDebugColor:GetValue(config,'debugBodyColor',0x0000ff),velocityDebugColor:GetValue(config,'debugVelocityColor',0x00ff00),debugShowJoint:GetValue(config,'debugShowJoint',true),jointDebugColor:GetValue(config,'debugJointColor',0x000000)};if(this.drawDebug){this.createDebugGraphic();}this.setEventsProxy();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setEventsProxy\r\n     * @since 3.0.0\r\n     */setEventsProxy:function setEventsProxy(){var _this=this;var engine=this.engine;MatterEvents.on(engine,'beforeUpdate',function(event){_this.emit('beforeupdate',event);});MatterEvents.on(engine,'afterUpdate',function(event){_this.emit('afterupdate',event);});MatterEvents.on(engine,'collisionStart',function(event){var pairs=event.pairs;var bodyA;var bodyB;if(pairs.length>0){bodyA=pairs[0].bodyA;bodyB=pairs[0].bodyB;}_this.emit('collisionstart',event,bodyA,bodyB);});MatterEvents.on(engine,'collisionActive',function(event){var pairs=event.pairs;var bodyA;var bodyB;if(pairs.length>0){bodyA=pairs[0].bodyA;bodyB=pairs[0].bodyB;}_this.emit('collisionactive',event,bodyA,bodyB);});MatterEvents.on(engine,'collisionEnd',function(event){var pairs=event.pairs;var bodyA;var bodyB;if(pairs.length>0){bodyA=pairs[0].bodyA;bodyB=pairs[0].bodyB;}_this.emit('collisionend',event,bodyA,bodyB);});},/**\r\n     * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n     * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n     * If none of the walls are given it will default to use the walls settings it had previously.\r\n     * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n     * the newly created bounds will also not have the left and right walls.\r\n     * Explicitly state them in the parameters to override this.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x coordinate of the top-left corner of the bounds.\r\n     * @param {number} [y=0] - The y coordinate of the top-left corner of the bounds.\r\n     * @param {number} [width] - The width of the bounds.\r\n     * @param {number} [height] - The height of the bounds.\r\n     * @param {number} [thickness=128] - The thickness of each wall, in pixels.\r\n     * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n     * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n     * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n     * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */setBounds:function setBounds(x,y,width,height,thickness,left,right,top,bottom){if(x===undefined){x=0;}if(y===undefined){y=0;}if(width===undefined){width=this.scene.sys.game.config.width;}if(height===undefined){height=this.scene.sys.game.config.height;}if(thickness===undefined){thickness=128;}if(left===undefined){left=true;}if(right===undefined){right=true;}if(top===undefined){top=true;}if(bottom===undefined){bottom=true;}this.updateWall(left,'left',x-thickness,y,thickness,height);this.updateWall(right,'right',x+width,y,thickness,height);this.updateWall(top,'top',x,y-thickness,width,thickness);this.updateWall(bottom,'bottom',x,y+height,width,thickness);return this;},//  position = 'left', 'right', 'top' or 'bottom'\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#updateWall\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} add - [description]\r\n     * @param {string} position - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     */updateWall:function updateWall(add,position,x,y,width,height){var wall=this.walls[position];if(add){if(wall){MatterWorld.remove(this.localWorld,wall);}//  adjust center\nx+=width/2;y+=height/2;this.walls[position]=this.create(x,y,width,height,{isStatic:true,friction:0,frictionStatic:0});}else{if(wall){MatterWorld.remove(this.localWorld,wall);}this.walls[position]=null;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} [description]\r\n     */createDebugGraphic:function createDebugGraphic(){var graphic=this.scene.sys.add.graphics({x:0,y:0});graphic.setDepth(Number.MAX_VALUE);this.debugGraphic=graphic;this.drawDebug=true;return graphic;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#disableGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */disableGravity:function disableGravity(){this.localWorld.gravity.x=0;this.localWorld.gravity.y=0;this.localWorld.gravity.scale=0;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - [description]\r\n     * @param {number} [y=1] - [description]\r\n     * @param {number} [scale] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */setGravity:function setGravity(x,y,scale){if(x===undefined){x=0;}if(y===undefined){y=1;}this.localWorld.gravity.x=x;this.localWorld.gravity.y=y;if(scale!==undefined){this.localWorld.gravity.scale=scale;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {MatterJS.Body} [description]\r\n     */create:function create(x,y,width,height,options){var body=Bodies.rectangle(x,y,width,height,options);MatterWorld.add(this.localWorld,body);return body;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(object|object[])} object - Can be single or an array, and can be a body, composite or constraint\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */add:function add(object){MatterWorld.add(this.localWorld,object);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to be removed from the world.\r\n     * @param {boolean} deep - [description]\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */remove:function remove(object,deep){var body=object.body?object.body:object;Composite.removeBody(this.localWorld,body,deep);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#removeConstraint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Constraint} constraint - [description]\r\n     * @param {boolean} deep - [description]\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */removeConstraint:function removeConstraint(constraint,deep){Composite.remove(this.localWorld,constraint,deep);return this;},/**\r\n     * Adds MatterTileBody instances for all the colliding tiles within the given tilemap layer. Set\r\n     * the appropriate tiles in your layer to collide before calling this method!\r\n     *\r\n     * @method Phaser.Physics.Matter.World#convertTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer -\r\n     * An array of tiles.\r\n     * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@ee Phaser.Physics.Matter.TileBody}\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */convertTilemapLayer:function convertTilemapLayer(tilemapLayer,options){var layerData=tilemapLayer.layer;var tiles=tilemapLayer.getTilesWithin(0,0,layerData.width,layerData.height,{isColliding:true});this.convertTiles(tiles,options);return this;},/**\r\n     * Adds MatterTileBody instances for the given tiles. This adds bodies regardless of whether the\r\n     * tiles are set to collide or not.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#convertTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of tiles.\r\n     * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */convertTiles:function convertTiles(tiles,options){if(tiles.length===0){return this;}for(var i=0;i<tiles.length;i++){new MatterTileBody(this,tiles[i],options);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#nextGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} isNonColliding - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */nextGroup:function nextGroup(isNonColliding){return MatterBody.nextGroup(isNonColliding);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#nextCategory\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */nextCategory:function nextCategory(){return MatterBody.nextCategory();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */pause:function pause(){this.enabled=false;this.emit('pause');return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */resume:function resume(){this.enabled=true;this.emit('resume');return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(time,delta){if(this.enabled&&this.autoUpdate){Engine.update(this.engine,this.getDelta(time,delta),this.correction);}},/**\r\n     * Manually advances the physics simulation by one iteration.\r\n     * \r\n     * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.\r\n     * If undefined they use the Matter defaults of 60Hz and no correction.\r\n     * \r\n     * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.\r\n     * \r\n     * It also ignores any custom `getDelta` functions, as you should be passing the delta\r\n     * value in to this call.\r\n     *\r\n     * You can adjust the number of iterations that Engine.update performs internally.\r\n     * Use the Scene Matter Physics config object to set the following properties:\r\n     *\r\n     * positionIterations (defaults to 6)\r\n     * velocityIterations (defaults to 4)\r\n     * constraintIterations (defaults to 2)\r\n     *\r\n     * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n     * of your game.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#step\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [delta=16.666] - [description]\r\n     * @param {number} [correction=1] - [description]\r\n     */step:function step(delta,correction){Engine.update(this.engine,delta,correction);},/**\r\n     * Runs the Matter Engine.update at a fixed timestep of 60Hz.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update60Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The delta value to be passed to Engine.update.\r\n     */update60Hz:function update60Hz(){return 1000/60;},/**\r\n     * Runs the Matter Engine.update at a fixed timestep of 30Hz.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update30Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The delta value to be passed to Engine.update.\r\n     */update30Hz:function update30Hz(){return 1000/30;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#postUpdate\r\n     * @since 3.0.0\r\n     */postUpdate:function postUpdate(){if(!this.drawDebug){return;}var graphics=this.debugGraphic;var bodies=Composite.allBodies(this.localWorld);graphics.clear();graphics.lineStyle(1,this.defaults.bodyDebugColor);graphics.beginPath();var i,j;for(i=0;i<bodies.length;i++){if(!bodies[i].render.visible){return;}// Handle drawing both single bodies and compound bodies. If compound, draw both the\n// convex hull (first part) and the rest of the bodies.\nfor(j=0;j<bodies[i].parts.length;j++){var body=bodies[i].parts[j];var vertices=body.vertices;graphics.moveTo(vertices[0].x,vertices[0].y);for(var k=1;k<vertices.length;k++){graphics.lineTo(vertices[k].x,vertices[k].y);}graphics.lineTo(vertices[0].x,vertices[0].y);graphics.strokePath();}}graphics.closePath();if(this.defaults.debugShowJoint){graphics.lineStyle(2,this.defaults.jointDebugColor);// Render constraints \nvar constraints=Composite.allConstraints(this.localWorld);for(i=0;i<constraints.length;i++){var constraint=constraints[i];if(!constraint.render.visible||!constraint.pointA||!constraint.pointB){continue;}if(constraint.render.lineWidth){graphics.lineStyle(constraint.render.lineWidth,Common.colorToNumber(constraint.render.strokeStyle));}var bodyA=constraint.bodyA;var bodyB=constraint.bodyB;var start;var end;if(bodyA){start=Vector.add(bodyA.position,constraint.pointA);}else{start=constraint.pointA;}if(constraint.render.type==='pin'){graphics.beginPath();graphics.arc(start.x,start.y,3,0,2*Math.PI);graphics.closePath();}else{if(bodyB){end=Vector.add(bodyB.position,constraint.pointB);}else{end=constraint.pointB;}graphics.beginPath();graphics.moveTo(start.x,start.y);if(constraint.render.type==='spring'){var delta=Vector.sub(end,start);var normal=Vector.perp(Vector.normalise(delta));var coils=Math.ceil(Common.clamp(constraint.length/5,12,20));var offset;for(j=1;j<coils;j+=1){offset=j%2===0?1:-1;graphics.lineTo(start.x+delta.x*(j/coils)+normal.x*offset*4,start.y+delta.y*(j/coils)+normal.y*offset*4);}}graphics.lineTo(end.x,end.y);}if(constraint.render.lineWidth){graphics.strokePath();}if(constraint.render.anchors){graphics.fillStyle(Common.colorToNumber(constraint.render.strokeStyle));graphics.beginPath();graphics.arc(start.x,start.y,6,0,2*Math.PI);graphics.arc(end.x,end.y,6,0,2*Math.PI);graphics.closePath();graphics.fillPath();}}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#fromPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} path - [description]\r\n     * @param {array} points - [description]\r\n     *\r\n     * @return {array} [description]\r\n     */fromPath:function fromPath(path,points){if(points===undefined){points=[];}// var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig;\n// eslint-disable-next-line no-useless-escape\nvar pathPattern=/L?\\s*([\\-\\d\\.e]+)[\\s,]*([\\-\\d\\.e]+)*/ig;path.replace(pathPattern,function(match,x,y){points.push({x:parseFloat(x),y:parseFloat(y)});});return points;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){MatterEvents.off();this.removeAllListeners();MatterWorld.clear(this.localWorld,false);Engine.clear(this.engine);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.World#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.shutdown();}});module.exports=World;/***/},/* 980 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\r\n* An engine is a controller that manages updating the simulation of the world.\r\n* See `Matter.Runner` for an optional game loop utility.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Engine\r\n*/var Engine={};module.exports=Engine;var World=__webpack_require__(464);var Sleeping=__webpack_require__(203);var Resolver=__webpack_require__(981);var Pairs=__webpack_require__(982);var Metrics=__webpack_require__(1007);var Grid=__webpack_require__(983);var Events=__webpack_require__(178);var Composite=__webpack_require__(122);var Constraint=__webpack_require__(177);var Common=__webpack_require__(37);var Body=__webpack_require__(51);(function(){/**\r\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {object} [options]\r\n     * @return {engine} engine\r\n     */Engine.create=function(element,options){// options may be passed as the first (and only) argument\noptions=Common.isElement(element)?options:element;element=Common.isElement(element)?element:null;options=options||{};if(element||options.render){Common.warn('Engine.create: engine.render is deprecated (see docs)');}var defaults={positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:false,events:[],plugin:{},timing:{timestamp:0,timeScale:1},broadphase:{controller:Grid}};var engine=Common.extend(defaults,options);/*\r\n        // @deprecated\r\n        if (element || engine.render) {\r\n            var renderDefaults = {\r\n                element: element,\r\n                controller: Render\r\n            };\r\n            \r\n            engine.render = Common.extend(renderDefaults, engine.render);\r\n        }\r\n\r\n        // @deprecated\r\n        if (engine.render && engine.render.controller) {\r\n            engine.render = engine.render.controller.create(engine.render);\r\n        }\r\n\r\n        // @deprecated\r\n        if (engine.render) {\r\n            engine.render.engine = engine;\r\n        }\r\n        */engine.world=options.world||World.create(engine.world);engine.pairs=Pairs.create();engine.broadphase=engine.broadphase.controller.create(engine.broadphase);engine.metrics=engine.metrics||{extended:false};// @if DEBUG\nengine.metrics=Metrics.create(engine.metrics);// @endif\nreturn engine;};/**\r\n     * Moves the simulation forward in time by `delta` ms.\r\n     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.\r\n     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.\r\n     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.\r\n     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).\r\n     * See the paper on <a href=\"http://lonesock.net/article/verlet.html\">Time Corrected Verlet</a> for more information.\r\n     *\r\n     * Triggers `beforeUpdate` and `afterUpdate` events.\r\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\r\n     * @method update\r\n     * @param {engine} engine\r\n     * @param {number} [delta=16.666]\r\n     * @param {number} [correction=1]\r\n     */Engine.update=function(engine,delta,correction){delta=delta||1000/60;correction=correction||1;var world=engine.world,timing=engine.timing,broadphase=engine.broadphase,broadphasePairs=[],i;// increment timestamp\ntiming.timestamp+=delta*timing.timeScale;// create an event object\nvar event={timestamp:timing.timestamp};Events.trigger(engine,'beforeUpdate',event);// get lists of all bodies and constraints, no matter what composites they are in\nvar allBodies=Composite.allBodies(world),allConstraints=Composite.allConstraints(world);// @if DEBUG\n// reset metrics logging\nMetrics.reset(engine.metrics);// @endif\n// if sleeping enabled, call the sleeping controller\nif(engine.enableSleeping)Sleeping.update(allBodies,timing.timeScale);// applies gravity to all bodies\n_bodiesApplyGravity(allBodies,world.gravity);// update all body position and rotation by integration\n_bodiesUpdate(allBodies,delta,timing.timeScale,correction,world.bounds);// update all constraints (first pass)\nConstraint.preSolveAll(allBodies);for(i=0;i<engine.constraintIterations;i++){Constraint.solveAll(allConstraints,timing.timeScale);}Constraint.postSolveAll(allBodies);// broadphase pass: find potential collision pairs\nif(broadphase.controller){// if world is dirty, we must flush the whole grid\nif(world.isModified)broadphase.controller.clear(broadphase);// update the grid buckets based on current bodies\nbroadphase.controller.update(broadphase,allBodies,engine,world.isModified);broadphasePairs=broadphase.pairsList;}else{// if no broadphase set, we just pass all bodies\nbroadphasePairs=allBodies;}// clear all composite modified flags\nif(world.isModified){Composite.setModified(world,false,false,true);}// narrowphase pass: find actual collisions, then create or update collision pairs\nvar collisions=broadphase.detector(broadphasePairs,engine);// update collision pairs\nvar pairs=engine.pairs,timestamp=timing.timestamp;Pairs.update(pairs,collisions,timestamp);Pairs.removeOld(pairs,timestamp);// wake up bodies involved in collisions\nif(engine.enableSleeping)Sleeping.afterCollisions(pairs.list,timing.timeScale);// trigger collision events\nif(pairs.collisionStart.length>0)Events.trigger(engine,'collisionStart',{pairs:pairs.collisionStart});// iteratively resolve position between collisions\nResolver.preSolvePosition(pairs.list);for(i=0;i<engine.positionIterations;i++){Resolver.solvePosition(pairs.list,allBodies,timing.timeScale);}Resolver.postSolvePosition(allBodies);// update all constraints (second pass)\nConstraint.preSolveAll(allBodies);for(i=0;i<engine.constraintIterations;i++){Constraint.solveAll(allConstraints,timing.timeScale);}Constraint.postSolveAll(allBodies);// iteratively resolve velocity between collisions\nResolver.preSolveVelocity(pairs.list);for(i=0;i<engine.velocityIterations;i++){Resolver.solveVelocity(pairs.list,timing.timeScale);}// trigger collision events\nif(pairs.collisionActive.length>0)Events.trigger(engine,'collisionActive',{pairs:pairs.collisionActive});if(pairs.collisionEnd.length>0)Events.trigger(engine,'collisionEnd',{pairs:pairs.collisionEnd});// @if DEBUG\n// update metrics log\nMetrics.update(engine.metrics,engine);// @endif\n// clear force buffers\n_bodiesClearForces(allBodies);Events.trigger(engine,'afterUpdate',event);return engine;};/**\r\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\r\n     * @method merge\r\n     * @param {engine} engineA\r\n     * @param {engine} engineB\r\n     */Engine.merge=function(engineA,engineB){Common.extend(engineA,engineB);if(engineB.world){engineA.world=engineB.world;Engine.clear(engineA);var bodies=Composite.allBodies(engineA.world);for(var i=0;i<bodies.length;i++){var body=bodies[i];Sleeping.set(body,false);body.id=Common.nextId();}}};/**\r\n     * Clears the engine including the world, pairs and broadphase.\r\n     * @method clear\r\n     * @param {engine} engine\r\n     */Engine.clear=function(engine){var world=engine.world;Pairs.clear(engine.pairs);var broadphase=engine.broadphase;if(broadphase.controller){var bodies=Composite.allBodies(world);broadphase.controller.clear(broadphase);broadphase.controller.update(broadphase,bodies,engine,true);}};/**\r\n     * Zeroes the `body.force` and `body.torque` force buffers.\r\n     * @method bodiesClearForces\r\n     * @private\r\n     * @param {body[]} bodies\r\n     */var _bodiesClearForces=function _bodiesClearForces(bodies){for(var i=0;i<bodies.length;i++){var body=bodies[i];// reset force buffers\nbody.force.x=0;body.force.y=0;body.torque=0;}};/**\r\n     * Applys a mass dependant force to all given bodies.\r\n     * @method bodiesApplyGravity\r\n     * @private\r\n     * @param {body[]} bodies\r\n     * @param {vector} gravity\r\n     */var _bodiesApplyGravity=function _bodiesApplyGravity(bodies,gravity){var gravityScale=typeof gravity.scale!=='undefined'?gravity.scale:0.001;if(gravity.x===0&&gravity.y===0||gravityScale===0){return;}for(var i=0;i<bodies.length;i++){var body=bodies[i];if(body.ignoreGravity||body.isStatic||body.isSleeping)continue;// apply gravity\nbody.force.y+=body.mass*gravity.y*gravityScale;body.force.x+=body.mass*gravity.x*gravityScale;}};/**\r\n     * Applys `Body.update` to all given `bodies`.\r\n     * @method updateAll\r\n     * @private\r\n     * @param {body[]} bodies\r\n     * @param {number} deltaTime \r\n     * The amount of time elapsed between updates\r\n     * @param {number} timeScale\r\n     * @param {number} correction \r\n     * The Verlet correction factor (deltaTime / lastDeltaTime)\r\n     * @param {bounds} worldBounds\r\n     */var _bodiesUpdate=function _bodiesUpdate(bodies,deltaTime,timeScale,correction,worldBounds){for(var i=0;i<bodies.length;i++){var body=bodies[i];if(body.isStatic||body.isSleeping)continue;Body.update(body,deltaTime,timeScale,correction);}};/**\r\n     * An alias for `Runner.run`, see `Matter.Runner` for more information.\r\n     * @method run\r\n     * @param {engine} engine\r\n     *//**\r\n    * Fired just before an update\r\n    *\r\n    * @event beforeUpdate\r\n    * @param {} event An event object\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//**\r\n    * Fired after engine update and all collision events\r\n    *\r\n    * @event afterUpdate\r\n    * @param {} event An event object\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//**\r\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\r\n    *\r\n    * @event collisionStart\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//**\r\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\r\n    *\r\n    * @event collisionActive\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//**\r\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\r\n    *\r\n    * @event collisionEnd\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    *//*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    *//**\r\n     * An integer `Number` that specifies the number of position iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     *\r\n     * @property positionIterations\r\n     * @type number\r\n     * @default 6\r\n     *//**\r\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     *\r\n     * @property velocityIterations\r\n     * @type number\r\n     * @default 4\r\n     *//**\r\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     * The default value of `2` is usually very adequate.\r\n     *\r\n     * @property constraintIterations\r\n     * @type number\r\n     * @default 2\r\n     *//**\r\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\r\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\r\n     *\r\n     * @property enableSleeping\r\n     * @type boolean\r\n     * @default false\r\n     *//**\r\n     * An `Object` containing properties regarding the timing systems of the engine. \r\n     *\r\n     * @property timing\r\n     * @type object\r\n     *//**\r\n     * A `Number` that specifies the global scaling factor of time for all bodies.\r\n     * A value of `0` freezes the simulation.\r\n     * A value of `0.1` gives a slow-motion effect.\r\n     * A value of `1.2` gives a speed-up effect.\r\n     *\r\n     * @property timing.timeScale\r\n     * @type number\r\n     * @default 1\r\n     *//**\r\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \r\n     * It is incremented on every `Engine.update` by the given `delta` argument. \r\n     *\r\n     * @property timing.timestamp\r\n     * @type number\r\n     * @default 0\r\n     *//**\r\n     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.\r\n     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.\r\n     *\r\n     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).\r\n     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.\r\n     *\r\n     * @property render\r\n     * @type render\r\n     * @deprecated see Demo.js for an example of creating a renderer\r\n     * @default a Matter.Render instance\r\n     *//**\r\n     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.\r\n     *\r\n     * @property broadphase\r\n     * @type grid\r\n     * @default a Matter.Grid instance\r\n     *//**\r\n     * A `World` composite object that will contain all simulated bodies and constraints.\r\n     *\r\n     * @property world\r\n     * @type world\r\n     * @default a Matter.World instance\r\n     *//**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */})();/***/},/* 981 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\r\n*\r\n* @class Resolver\r\n*/var Resolver={};module.exports=Resolver;var Vertices=__webpack_require__(93);var Vector=__webpack_require__(83);var Common=__webpack_require__(37);var Bounds=__webpack_require__(92);(function(){Resolver._restingThresh=4;Resolver._restingThreshTangent=6;Resolver._positionDampen=0.9;Resolver._positionWarming=0.8;Resolver._frictionNormalMultiplier=5;/**\r\n     * Prepare pairs for position solving.\r\n     * @method preSolvePosition\r\n     * @param {pair[]} pairs\r\n     */Resolver.preSolvePosition=function(pairs){var i,pair,activeCount;// find total contacts on each body\nfor(i=0;i<pairs.length;i++){pair=pairs[i];if(!pair.isActive)continue;activeCount=pair.activeContacts.length;pair.collision.parentA.totalContacts+=activeCount;pair.collision.parentB.totalContacts+=activeCount;}};/**\r\n     * Find a solution for pair positions.\r\n     * @method solvePosition\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */Resolver.solvePosition=function(pairs,bodies,timeScale){var i,normalX,normalY,pair,collision,bodyA,bodyB,normal,separation,penetration,positionImpulseA,positionImpulseB,contactShare,bodyBtoAX,bodyBtoAY,positionImpulse,impulseCoefficient=timeScale*Resolver._positionDampen;for(i=0;i<bodies.length;i++){var body=bodies[i];body.previousPositionImpulse.x=body.positionImpulse.x;body.previousPositionImpulse.y=body.positionImpulse.y;}// find impulses required to resolve penetration\nfor(i=0;i<pairs.length;i++){pair=pairs[i];if(!pair.isActive||pair.isSensor)continue;collision=pair.collision;bodyA=collision.parentA;bodyB=collision.parentB;normal=collision.normal;positionImpulseA=bodyA.previousPositionImpulse;positionImpulseB=bodyB.previousPositionImpulse;penetration=collision.penetration;// bodyBtoA = positionImpulseB - positionImpulseA + penetration\nbodyBtoAX=positionImpulseB.x-positionImpulseA.x+penetration.x;bodyBtoAY=positionImpulseB.y-positionImpulseA.y+penetration.y;normalX=normal.x;normalY=normal.y;// separation = dot(normal, bodyBtoA)\nseparation=normalX*bodyBtoAX+normalY*bodyBtoAY;pair.separation=separation;positionImpulse=(separation-pair.slop)*impulseCoefficient;if(bodyA.isStatic||bodyB.isStatic)positionImpulse*=2;if(!(bodyA.isStatic||bodyA.isSleeping)){contactShare=positionImpulse/bodyA.totalContacts;bodyA.positionImpulse.x+=normalX*contactShare;bodyA.positionImpulse.y+=normalY*contactShare;}if(!(bodyB.isStatic||bodyB.isSleeping)){contactShare=positionImpulse/bodyB.totalContacts;bodyB.positionImpulse.x-=normalX*contactShare;bodyB.positionImpulse.y-=normalY*contactShare;}}};/**\r\n     * Apply position resolution.\r\n     * @method postSolvePosition\r\n     * @param {body[]} bodies\r\n     */Resolver.postSolvePosition=function(bodies){for(var i=0;i<bodies.length;i++){var body=bodies[i];// reset contact count\nbody.totalContacts=0;if(body.positionImpulse.x!==0||body.positionImpulse.y!==0){// update body geometry\nfor(var j=0;j<body.parts.length;j++){var part=body.parts[j];Vertices.translate(part.vertices,body.positionImpulse);Bounds.update(part.bounds,part.vertices,body.velocity);part.position.x+=body.positionImpulse.x;part.position.y+=body.positionImpulse.y;}// move the body without changing velocity\nbody.positionPrev.x+=body.positionImpulse.x;body.positionPrev.y+=body.positionImpulse.y;if(Vector.dot(body.positionImpulse,body.velocity)<0){// reset cached impulse if the body has velocity along it\nbody.positionImpulse.x=0;body.positionImpulse.y=0;}else{// warm the next iteration\nbody.positionImpulse.x*=Resolver._positionWarming;body.positionImpulse.y*=Resolver._positionWarming;}}}};/**\r\n     * Prepare pairs for velocity solving.\r\n     * @method preSolveVelocity\r\n     * @param {pair[]} pairs\r\n     */Resolver.preSolveVelocity=function(pairs){var i,j,pair,contacts,collision,bodyA,bodyB,normal,tangent,contact,contactVertex,normalImpulse,tangentImpulse,offset,impulse=Vector._temp[0],tempA=Vector._temp[1];for(i=0;i<pairs.length;i++){pair=pairs[i];if(!pair.isActive||pair.isSensor)continue;contacts=pair.activeContacts;collision=pair.collision;bodyA=collision.parentA;bodyB=collision.parentB;normal=collision.normal;tangent=collision.tangent;// resolve each contact\nfor(j=0;j<contacts.length;j++){contact=contacts[j];contactVertex=contact.vertex;normalImpulse=contact.normalImpulse;tangentImpulse=contact.tangentImpulse;if(normalImpulse!==0||tangentImpulse!==0){// total impulse from contact\nimpulse.x=normal.x*normalImpulse+tangent.x*tangentImpulse;impulse.y=normal.y*normalImpulse+tangent.y*tangentImpulse;// apply impulse from contact\nif(!(bodyA.isStatic||bodyA.isSleeping)){offset=Vector.sub(contactVertex,bodyA.position,tempA);bodyA.positionPrev.x+=impulse.x*bodyA.inverseMass;bodyA.positionPrev.y+=impulse.y*bodyA.inverseMass;bodyA.anglePrev+=Vector.cross(offset,impulse)*bodyA.inverseInertia;}if(!(bodyB.isStatic||bodyB.isSleeping)){offset=Vector.sub(contactVertex,bodyB.position,tempA);bodyB.positionPrev.x-=impulse.x*bodyB.inverseMass;bodyB.positionPrev.y-=impulse.y*bodyB.inverseMass;bodyB.anglePrev-=Vector.cross(offset,impulse)*bodyB.inverseInertia;}}}}};/**\r\n     * Find a solution for pair velocities.\r\n     * @method solveVelocity\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */Resolver.solveVelocity=function(pairs,timeScale){var timeScaleSquared=timeScale*timeScale,impulse=Vector._temp[0],tempA=Vector._temp[1],tempB=Vector._temp[2],tempC=Vector._temp[3],tempD=Vector._temp[4],tempE=Vector._temp[5];for(var i=0;i<pairs.length;i++){var pair=pairs[i];if(!pair.isActive||pair.isSensor)continue;var collision=pair.collision,bodyA=collision.parentA,bodyB=collision.parentB,normal=collision.normal,tangent=collision.tangent,contacts=pair.activeContacts,contactShare=1/contacts.length;// update body velocities\nbodyA.velocity.x=bodyA.position.x-bodyA.positionPrev.x;bodyA.velocity.y=bodyA.position.y-bodyA.positionPrev.y;bodyB.velocity.x=bodyB.position.x-bodyB.positionPrev.x;bodyB.velocity.y=bodyB.position.y-bodyB.positionPrev.y;bodyA.angularVelocity=bodyA.angle-bodyA.anglePrev;bodyB.angularVelocity=bodyB.angle-bodyB.anglePrev;// resolve each contact\nfor(var j=0;j<contacts.length;j++){var contact=contacts[j],contactVertex=contact.vertex,offsetA=Vector.sub(contactVertex,bodyA.position,tempA),offsetB=Vector.sub(contactVertex,bodyB.position,tempB),velocityPointA=Vector.add(bodyA.velocity,Vector.mult(Vector.perp(offsetA),bodyA.angularVelocity),tempC),velocityPointB=Vector.add(bodyB.velocity,Vector.mult(Vector.perp(offsetB),bodyB.angularVelocity),tempD),relativeVelocity=Vector.sub(velocityPointA,velocityPointB,tempE),normalVelocity=Vector.dot(normal,relativeVelocity);var tangentVelocity=Vector.dot(tangent,relativeVelocity),tangentSpeed=Math.abs(tangentVelocity),tangentVelocityDirection=Common.sign(tangentVelocity);// raw impulses\nvar normalImpulse=(1+pair.restitution)*normalVelocity,normalForce=Common.clamp(pair.separation+normalVelocity,0,1)*Resolver._frictionNormalMultiplier;// coulomb friction\nvar tangentImpulse=tangentVelocity,maxFriction=Infinity;if(tangentSpeed>pair.friction*pair.frictionStatic*normalForce*timeScaleSquared){maxFriction=tangentSpeed;tangentImpulse=Common.clamp(pair.friction*tangentVelocityDirection*timeScaleSquared,-maxFriction,maxFriction);}// modify impulses accounting for mass, inertia and offset\nvar oAcN=Vector.cross(offsetA,normal),oBcN=Vector.cross(offsetB,normal),share=contactShare/(bodyA.inverseMass+bodyB.inverseMass+bodyA.inverseInertia*oAcN*oAcN+bodyB.inverseInertia*oBcN*oBcN);normalImpulse*=share;tangentImpulse*=share;// handle high velocity and resting collisions separately\nif(normalVelocity<0&&normalVelocity*normalVelocity>Resolver._restingThresh*timeScaleSquared){// high normal velocity so clear cached contact normal impulse\ncontact.normalImpulse=0;}else{// solve resting collision constraints using Erin Catto's method (GDC08)\n// impulse constraint tends to 0\nvar contactNormalImpulse=contact.normalImpulse;contact.normalImpulse=Math.min(contact.normalImpulse+normalImpulse,0);normalImpulse=contact.normalImpulse-contactNormalImpulse;}// handle high velocity and resting collisions separately\nif(tangentVelocity*tangentVelocity>Resolver._restingThreshTangent*timeScaleSquared){// high tangent velocity so clear cached contact tangent impulse\ncontact.tangentImpulse=0;}else{// solve resting collision constraints using Erin Catto's method (GDC08)\n// tangent impulse tends to -tangentSpeed or +tangentSpeed\nvar contactTangentImpulse=contact.tangentImpulse;contact.tangentImpulse=Common.clamp(contact.tangentImpulse+tangentImpulse,-maxFriction,maxFriction);tangentImpulse=contact.tangentImpulse-contactTangentImpulse;}// total impulse from contact\nimpulse.x=normal.x*normalImpulse+tangent.x*tangentImpulse;impulse.y=normal.y*normalImpulse+tangent.y*tangentImpulse;// apply impulse from contact\nif(!(bodyA.isStatic||bodyA.isSleeping)){bodyA.positionPrev.x+=impulse.x*bodyA.inverseMass;bodyA.positionPrev.y+=impulse.y*bodyA.inverseMass;bodyA.anglePrev+=Vector.cross(offsetA,impulse)*bodyA.inverseInertia;}if(!(bodyB.isStatic||bodyB.isSleeping)){bodyB.positionPrev.x-=impulse.x*bodyB.inverseMass;bodyB.positionPrev.y-=impulse.y*bodyB.inverseMass;bodyB.anglePrev-=Vector.cross(offsetB,impulse)*bodyB.inverseInertia;}}}};})();/***/},/* 982 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\r\n*\r\n* @class Pairs\r\n*/var Pairs={};module.exports=Pairs;var Pair=__webpack_require__(383);var Common=__webpack_require__(37);(function(){var _pairMaxIdleLife=1000;/**\r\n     * Creates a new pairs structure.\r\n     * @method create\r\n     * @param {object} options\r\n     * @return {pairs} A new pairs structure\r\n     */Pairs.create=function(options){return Common.extend({table:{},list:[],collisionStart:[],collisionActive:[],collisionEnd:[]},options);};/**\r\n     * Updates pairs given a list of collisions.\r\n     * @method update\r\n     * @param {object} pairs\r\n     * @param {collision[]} collisions\r\n     * @param {number} timestamp\r\n     */Pairs.update=function(pairs,collisions,timestamp){var pairsList=pairs.list,pairsTable=pairs.table,collisionStart=pairs.collisionStart,collisionEnd=pairs.collisionEnd,collisionActive=pairs.collisionActive,collision,pairId,pair,i;// clear collision state arrays, but maintain old reference\ncollisionStart.length=0;collisionEnd.length=0;collisionActive.length=0;for(i=0;i<pairsList.length;i++){pairsList[i].confirmedActive=false;}for(i=0;i<collisions.length;i++){collision=collisions[i];if(collision.collided){pairId=Pair.id(collision.bodyA,collision.bodyB);pair=pairsTable[pairId];if(pair){// pair already exists (but may or may not be active)\nif(pair.isActive){// pair exists and is active\ncollisionActive.push(pair);}else{// pair exists but was inactive, so a collision has just started again\ncollisionStart.push(pair);}// update the pair\nPair.update(pair,collision,timestamp);pair.confirmedActive=true;}else{// pair did not exist, create a new pair\npair=Pair.create(collision,timestamp);pairsTable[pairId]=pair;// push the new pair\ncollisionStart.push(pair);pairsList.push(pair);}}}// deactivate previously active pairs that are now inactive\nfor(i=0;i<pairsList.length;i++){pair=pairsList[i];if(!pair.confirmedActive){Pair.setActive(pair,false,timestamp);collisionEnd.push(pair);}}};/**\r\n     * Finds and removes pairs that have been inactive for a set amount of time.\r\n     * @method removeOld\r\n     * @param {object} pairs\r\n     * @param {number} timestamp\r\n     */Pairs.removeOld=function(pairs,timestamp){var pairsList=pairs.list,pairsTable=pairs.table,indexesToRemove=[],pair,collision,pairIndex,i;for(i=0;i<pairsList.length;i++){pair=pairsList[i];collision=pair.collision;// never remove sleeping pairs\nif(collision.bodyA.isSleeping||collision.bodyB.isSleeping){pair.timeUpdated=timestamp;continue;}// if pair is inactive for too long, mark it to be removed\nif(timestamp-pair.timeUpdated>_pairMaxIdleLife){indexesToRemove.push(i);}}// remove marked pairs\nfor(i=0;i<indexesToRemove.length;i++){pairIndex=indexesToRemove[i]-i;pair=pairsList[pairIndex];delete pairsTable[pair.id];pairsList.splice(pairIndex,1);}};/**\r\n     * Clears the given pairs structure.\r\n     * @method clear\r\n     * @param {pairs} pairs\r\n     * @return {pairs} pairs\r\n     */Pairs.clear=function(pairs){pairs.table={};pairs.list.length=0;pairs.collisionStart.length=0;pairs.collisionActive.length=0;pairs.collisionEnd.length=0;return pairs;};})();/***/},/* 983 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\r\n*\r\n* @class Grid\r\n*/var Grid={};module.exports=Grid;var Pair=__webpack_require__(383);var Detector=__webpack_require__(468);var Common=__webpack_require__(37);(function(){/**\r\n     * Creates a new grid.\r\n     * @method create\r\n     * @param {} options\r\n     * @return {grid} A new grid\r\n     */Grid.create=function(options){var defaults={controller:Grid,detector:Detector.collisions,buckets:{},pairs:{},pairsList:[],bucketWidth:48,bucketHeight:48};return Common.extend(defaults,options);};/**\r\n     * The width of a single grid bucket.\r\n     *\r\n     * @property bucketWidth\r\n     * @type number\r\n     * @default 48\r\n     *//**\r\n     * The height of a single grid bucket.\r\n     *\r\n     * @property bucketHeight\r\n     * @type number\r\n     * @default 48\r\n     *//**\r\n     * Updates the grid.\r\n     * @method update\r\n     * @param {grid} grid\r\n     * @param {body[]} bodies\r\n     * @param {engine} engine\r\n     * @param {boolean} forceUpdate\r\n     */Grid.update=function(grid,bodies,engine,forceUpdate){var i,col,row,world=engine.world,buckets=grid.buckets,bucket,bucketId,gridChanged=false;// @if DEBUG\nvar metrics=engine.metrics;metrics.broadphaseTests=0;// @endif\nfor(i=0;i<bodies.length;i++){var body=bodies[i];if(body.isSleeping&&!forceUpdate)continue;// don't update out of world bodies\nif(body.bounds.max.x<world.bounds.min.x||body.bounds.min.x>world.bounds.max.x||body.bounds.max.y<world.bounds.min.y||body.bounds.min.y>world.bounds.max.y)continue;var newRegion=_getRegion(grid,body);// if the body has changed grid region\nif(!body.region||newRegion.id!==body.region.id||forceUpdate){// @if DEBUG\nmetrics.broadphaseTests+=1;// @endif\nif(!body.region||forceUpdate)body.region=newRegion;var union=_regionUnion(newRegion,body.region);// update grid buckets affected by region change\n// iterate over the union of both regions\nfor(col=union.startCol;col<=union.endCol;col++){for(row=union.startRow;row<=union.endRow;row++){bucketId=_getBucketId(col,row);bucket=buckets[bucketId];var isInsideNewRegion=col>=newRegion.startCol&&col<=newRegion.endCol&&row>=newRegion.startRow&&row<=newRegion.endRow;var isInsideOldRegion=col>=body.region.startCol&&col<=body.region.endCol&&row>=body.region.startRow&&row<=body.region.endRow;// remove from old region buckets\nif(!isInsideNewRegion&&isInsideOldRegion){if(isInsideOldRegion){if(bucket)_bucketRemoveBody(grid,bucket,body);}}// add to new region buckets\nif(body.region===newRegion||isInsideNewRegion&&!isInsideOldRegion||forceUpdate){if(!bucket)bucket=_createBucket(buckets,bucketId);_bucketAddBody(grid,bucket,body);}}}// set the new region\nbody.region=newRegion;// flag changes so we can update pairs\ngridChanged=true;}}// update pairs list only if pairs changed (i.e. a body changed region)\nif(gridChanged)grid.pairsList=_createActivePairsList(grid);};/**\r\n     * Clears the grid.\r\n     * @method clear\r\n     * @param {grid} grid\r\n     */Grid.clear=function(grid){grid.buckets={};grid.pairs={};grid.pairsList=[];};/**\r\n     * Finds the union of two regions.\r\n     * @method _regionUnion\r\n     * @private\r\n     * @param {} regionA\r\n     * @param {} regionB\r\n     * @return {} region\r\n     */var _regionUnion=function _regionUnion(regionA,regionB){var startCol=Math.min(regionA.startCol,regionB.startCol),endCol=Math.max(regionA.endCol,regionB.endCol),startRow=Math.min(regionA.startRow,regionB.startRow),endRow=Math.max(regionA.endRow,regionB.endRow);return _createRegion(startCol,endCol,startRow,endRow);};/**\r\n     * Gets the region a given body falls in for a given grid.\r\n     * @method _getRegion\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} body\r\n     * @return {} region\r\n     */var _getRegion=function _getRegion(grid,body){var bounds=body.bounds,startCol=Math.floor(bounds.min.x/grid.bucketWidth),endCol=Math.floor(bounds.max.x/grid.bucketWidth),startRow=Math.floor(bounds.min.y/grid.bucketHeight),endRow=Math.floor(bounds.max.y/grid.bucketHeight);return _createRegion(startCol,endCol,startRow,endRow);};/**\r\n     * Creates a region.\r\n     * @method _createRegion\r\n     * @private\r\n     * @param {} startCol\r\n     * @param {} endCol\r\n     * @param {} startRow\r\n     * @param {} endRow\r\n     * @return {} region\r\n     */var _createRegion=function _createRegion(startCol,endCol,startRow,endRow){return{id:startCol+','+endCol+','+startRow+','+endRow,startCol:startCol,endCol:endCol,startRow:startRow,endRow:endRow};};/**\r\n     * Gets the bucket id at the given position.\r\n     * @method _getBucketId\r\n     * @private\r\n     * @param {} column\r\n     * @param {} row\r\n     * @return {string} bucket id\r\n     */var _getBucketId=function _getBucketId(column,row){return'C'+column+'R'+row;};/**\r\n     * Creates a bucket.\r\n     * @method _createBucket\r\n     * @private\r\n     * @param {} buckets\r\n     * @param {} bucketId\r\n     * @return {} bucket\r\n     */var _createBucket=function _createBucket(buckets,bucketId){var bucket=buckets[bucketId]=[];return bucket;};/**\r\n     * Adds a body to a bucket.\r\n     * @method _bucketAddBody\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} bucket\r\n     * @param {} body\r\n     */var _bucketAddBody=function _bucketAddBody(grid,bucket,body){// add new pairs\nfor(var i=0;i<bucket.length;i++){var bodyB=bucket[i];if(body.id===bodyB.id||body.isStatic&&bodyB.isStatic)continue;// keep track of the number of buckets the pair exists in\n// important for Grid.update to work\nvar pairId=Pair.id(body,bodyB),pair=grid.pairs[pairId];if(pair){pair[2]+=1;}else{grid.pairs[pairId]=[body,bodyB,1];}}// add to bodies (after pairs, otherwise pairs with self)\nbucket.push(body);};/**\r\n     * Removes a body from a bucket.\r\n     * @method _bucketRemoveBody\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} bucket\r\n     * @param {} body\r\n     */var _bucketRemoveBody=function _bucketRemoveBody(grid,bucket,body){// remove from bucket\nbucket.splice(bucket.indexOf(body),1);// update pair counts\nfor(var i=0;i<bucket.length;i++){// keep track of the number of buckets the pair exists in\n// important for _createActivePairsList to work\nvar bodyB=bucket[i],pairId=Pair.id(body,bodyB),pair=grid.pairs[pairId];if(pair)pair[2]-=1;}};/**\r\n     * Generates a list of the active pairs in the grid.\r\n     * @method _createActivePairsList\r\n     * @private\r\n     * @param {} grid\r\n     * @return [] pairs\r\n     */var _createActivePairsList=function _createActivePairsList(grid){var pairKeys,pair,pairs=[];// grid.pairs is used as a hashmap\npairKeys=Common.keys(grid.pairs);// iterate over grid.pairs\nfor(var k=0;k<pairKeys.length;k++){pair=grid.pairs[pairKeys[k]];// if pair exists in at least one bucket\n// it is a pair that needs further collision testing so push it\nif(pair[2]>0){pairs.push(pair);}else{delete grid.pairs[pairKeys[k]];}}return pairs;};})();/***/},/* 984 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n*\r\n* @class Matter\r\n*/var Matter={};module.exports=Matter;var Plugin=__webpack_require__(465);var Common=__webpack_require__(37);(function(){/**\r\n     * The library name.\r\n     * @property name\r\n     * @readOnly\r\n     * @type {String}\r\n     */Matter.name='matter-js';/**\r\n     * The library version.\r\n     * @property version\r\n     * @readOnly\r\n     * @type {String}\r\n     */Matter.version='0.13.1';/**\r\n     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n     * @property uses\r\n     * @type {Array}\r\n     */Matter.uses=[];/**\r\n     * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n     * @property used\r\n     * @readOnly\r\n     * @type {Array}\r\n     */Matter.used=[];/**\r\n     * Installs the given plugins on the `Matter` namespace.\r\n     * This is a short-hand for `Plugin.use`, see it for more information.\r\n     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n     * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n     */Matter.use=function(){Plugin.use(Matter,Array.prototype.slice.call(arguments));};/**\r\n     * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method before\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */Matter.before=function(path,func){path=path.replace(/^Matter./,'');return Common.chainPathBefore(Matter,path,func);};/**\r\n     * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method after\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */Matter.after=function(path,func){path=path.replace(/^Matter./,'');return Common.chainPathAfter(Matter,path,func);};})();/***/},/* 985 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var AnimationComponent=__webpack_require__(394);var Class=__webpack_require__(0);var Components=__webpack_require__(384);var GameObject=__webpack_require__(1);var GetFastValue=__webpack_require__(2);var Pipeline=__webpack_require__(362);var Sprite=__webpack_require__(41);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * A Matter Physics Sprite Game Object.\r\n *\r\n * A Sprite Game Object is used for the display of both static and animated images in your game.\r\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\r\n * and animated.\r\n *\r\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\r\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\r\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\r\n *\r\n * @class Sprite\r\n * @extends Phaser.GameObjects.Sprite\r\n * @memberOf Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Force\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.SetBody\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n * @extends Phaser.Physics.Matter.Components.Transform\r\n * @extends Phaser.Physics.Matter.Components.Velocity\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Animation\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {object} [options={}] - Matter.js configuration object.\r\n */var MatterSprite=new Class({Extends:Sprite,Mixins:[Components.Bounce,Components.Collision,Components.Force,Components.Friction,Components.Gravity,Components.Mass,Components.Sensor,Components.SetBody,Components.Sleep,Components.Static,Components.Transform,Components.Velocity,Pipeline],initialize:function MatterSprite(world,x,y,texture,frame,options){GameObject.call(this,world.scene,'Image');this.anims=new AnimationComponent(this);this.setTexture(texture,frame);this.setSizeToFrame();this.setOrigin();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.Sprite#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.Sprite#_tempVec2\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tempVec2=new Vector2(x,y);var shape=GetFastValue(options,'shape',null);if(shape){this.setBody(shape,options);}else{this.setRectangle(this.width,this.height,options);}this.setPosition(x,y);this.initPipeline('TextureTintPipeline');}});module.exports=MatterSprite;/***/},/* 986 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(384);var GameObject=__webpack_require__(1);var GetFastValue=__webpack_require__(2);var Image=__webpack_require__(73);var Pipeline=__webpack_require__(362);var Vector2=__webpack_require__(6);/**\r\n * @classdesc\r\n * A Matter Physics Image Game Object.\r\n * \r\n * An Image is a light-weight Game Object useful for the display of static images in your game,\r\n * such as logos, backgrounds, scenery or other non-animated elements. Images can have input\r\n * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an\r\n * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.\r\n *\r\n * @class Image\r\n * @extends Phaser.GameObjects.Image\r\n * @memberOf Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Force\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.SetBody\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n * @extends Phaser.Physics.Matter.Components.Transform\r\n * @extends Phaser.Physics.Matter.Components.Velocity\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {object} [options={}] - Matter.js configuration object.\r\n */var MatterImage=new Class({Extends:Image,Mixins:[Components.Bounce,Components.Collision,Components.Force,Components.Friction,Components.Gravity,Components.Mass,Components.Sensor,Components.SetBody,Components.Sleep,Components.Static,Components.Transform,Components.Velocity,Pipeline],initialize:function MatterImage(world,x,y,texture,frame,options){GameObject.call(this,world.scene,'Image');this.setTexture(texture,frame);this.setSizeToFrame();this.setOrigin();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.Image#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.Image#_tempVec2\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */this._tempVec2=new Vector2(x,y);var shape=GetFastValue(options,'shape',null);if(shape){this.setBody(shape,options);}else{this.setRectangle(this.width,this.height,options);}this.setPosition(x,y);this.initPipeline('TextureTintPipeline');}});module.exports=MatterImage;/***/},/* 987 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Composites` module contains factory methods for creating composite bodies\r\n* with commonly used configurations (such as stacks and chains).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composites\r\n*/var Composites={};module.exports=Composites;var Composite=__webpack_require__(122);var Constraint=__webpack_require__(177);var Common=__webpack_require__(37);var Body=__webpack_require__(51);var Bodies=__webpack_require__(123);(function(){/**\r\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\r\n     * This function uses the body's bounds to prevent overlaps.\r\n     * @method stack\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {function} callback\r\n     * @return {composite} A new composite containing objects created in the callback\r\n     */Composites.stack=function(xx,yy,columns,rows,columnGap,rowGap,callback){var stack=Composite.create({label:'Stack'}),x=xx,y=yy,lastBody,i=0;for(var row=0;row<rows;row++){var maxHeight=0;for(var column=0;column<columns;column++){var body=callback(x,y,column,row,lastBody,i);if(body){var bodyHeight=body.bounds.max.y-body.bounds.min.y,bodyWidth=body.bounds.max.x-body.bounds.min.x;if(bodyHeight>maxHeight)maxHeight=bodyHeight;Body.translate(body,{x:bodyWidth*0.5,y:bodyHeight*0.5});x=body.bounds.max.x+columnGap;Composite.addBody(stack,body);lastBody=body;i+=1;}else{x+=columnGap;}}y+=maxHeight+rowGap;x=xx;}return stack;};/**\r\n     * Chains all bodies in the given composite together using constraints.\r\n     * @method chain\r\n     * @param {composite} composite\r\n     * @param {number} xOffsetA\r\n     * @param {number} yOffsetA\r\n     * @param {number} xOffsetB\r\n     * @param {number} yOffsetB\r\n     * @param {object} options\r\n     * @return {composite} A new composite containing objects chained together with constraints\r\n     */Composites.chain=function(composite,xOffsetA,yOffsetA,xOffsetB,yOffsetB,options){var bodies=composite.bodies;for(var i=1;i<bodies.length;i++){var bodyA=bodies[i-1],bodyB=bodies[i],bodyAHeight=bodyA.bounds.max.y-bodyA.bounds.min.y,bodyAWidth=bodyA.bounds.max.x-bodyA.bounds.min.x,bodyBHeight=bodyB.bounds.max.y-bodyB.bounds.min.y,bodyBWidth=bodyB.bounds.max.x-bodyB.bounds.min.x;var defaults={bodyA:bodyA,pointA:{x:bodyAWidth*xOffsetA,y:bodyAHeight*yOffsetA},bodyB:bodyB,pointB:{x:bodyBWidth*xOffsetB,y:bodyBHeight*yOffsetB}};var constraint=Common.extend(defaults,options);Composite.addConstraint(composite,Constraint.create(constraint));}composite.label+=' Chain';return composite;};/**\r\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\r\n     * @method mesh\r\n     * @param {composite} composite\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {boolean} crossBrace\r\n     * @param {object} options\r\n     * @return {composite} The composite containing objects meshed together with constraints\r\n     */Composites.mesh=function(composite,columns,rows,crossBrace,options){var bodies=composite.bodies,row,col,bodyA,bodyB,bodyC;for(row=0;row<rows;row++){for(col=1;col<columns;col++){bodyA=bodies[col-1+row*columns];bodyB=bodies[col+row*columns];Composite.addConstraint(composite,Constraint.create(Common.extend({bodyA:bodyA,bodyB:bodyB},options)));}if(row>0){for(col=0;col<columns;col++){bodyA=bodies[col+(row-1)*columns];bodyB=bodies[col+row*columns];Composite.addConstraint(composite,Constraint.create(Common.extend({bodyA:bodyA,bodyB:bodyB},options)));if(crossBrace&&col>0){bodyC=bodies[col-1+(row-1)*columns];Composite.addConstraint(composite,Constraint.create(Common.extend({bodyA:bodyC,bodyB:bodyB},options)));}if(crossBrace&&col<columns-1){bodyC=bodies[col+1+(row-1)*columns];Composite.addConstraint(composite,Constraint.create(Common.extend({bodyA:bodyC,bodyB:bodyB},options)));}}}}composite.label+=' Mesh';return composite;};/**\r\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\r\n     * This function uses the body's bounds to prevent overlaps.\r\n     * @method pyramid\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {function} callback\r\n     * @return {composite} A new composite containing objects created in the callback\r\n     */Composites.pyramid=function(xx,yy,columns,rows,columnGap,rowGap,callback){return Composites.stack(xx,yy,columns,rows,columnGap,rowGap,function(x,y,column,row,lastBody,i){var actualRows=Math.min(rows,Math.ceil(columns/2)),lastBodyWidth=lastBody?lastBody.bounds.max.x-lastBody.bounds.min.x:0;if(row>actualRows)return;// reverse row order\nrow=actualRows-row;var start=row,end=columns-1-row;if(column<start||column>end)return;// retroactively fix the first body's position, since width was unknown\nif(i===1){Body.translate(lastBody,{x:(column+(columns%2===1?1:-1))*lastBodyWidth,y:0});}var xOffset=lastBody?column*lastBodyWidth:0;return callback(xx+xOffset+column*columnGap,y,column,row,lastBody,i);});};/**\r\n     * Creates a composite with a Newton's Cradle setup of bodies and constraints.\r\n     * @method newtonsCradle\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} number\r\n     * @param {number} size\r\n     * @param {number} length\r\n     * @return {composite} A new composite newtonsCradle body\r\n     */Composites.newtonsCradle=function(xx,yy,number,size,length){var newtonsCradle=Composite.create({label:'Newtons Cradle'});for(var i=0;i<number;i++){var separation=1.9,circle=Bodies.circle(xx+i*(size*separation),yy+length,size,{inertia:Infinity,restitution:1,friction:0,frictionAir:0.0001,slop:1}),constraint=Constraint.create({pointA:{x:xx+i*(size*separation),y:yy},bodyB:circle});Composite.addBody(newtonsCradle,circle);Composite.addConstraint(newtonsCradle,constraint);}return newtonsCradle;};/**\r\n     * Creates a composite with simple car setup of bodies and constraints.\r\n     * @method car\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {number} wheelSize\r\n     * @return {composite} A new composite car body\r\n     */Composites.car=function(xx,yy,width,height,wheelSize){var group=Body.nextGroup(true),wheelBase=20,wheelAOffset=-width*0.5+wheelBase,wheelBOffset=width*0.5-wheelBase,wheelYOffset=0;var car=Composite.create({label:'Car'}),body=Bodies.rectangle(xx,yy,width,height,{collisionFilter:{group:group},chamfer:{radius:height*0.5},density:0.0002});var wheelA=Bodies.circle(xx+wheelAOffset,yy+wheelYOffset,wheelSize,{collisionFilter:{group:group},friction:0.8});var wheelB=Bodies.circle(xx+wheelBOffset,yy+wheelYOffset,wheelSize,{collisionFilter:{group:group},friction:0.8});var axelA=Constraint.create({bodyB:body,pointB:{x:wheelAOffset,y:wheelYOffset},bodyA:wheelA,stiffness:1,length:0});var axelB=Constraint.create({bodyB:body,pointB:{x:wheelBOffset,y:wheelYOffset},bodyA:wheelB,stiffness:1,length:0});Composite.addBody(car,body);Composite.addBody(car,wheelA);Composite.addBody(car,wheelB);Composite.addConstraint(car,axelA);Composite.addConstraint(car,axelB);return car;};/**\r\n     * Creates a simple soft body like object.\r\n     * @method softBody\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {boolean} crossBrace\r\n     * @param {number} particleRadius\r\n     * @param {} particleOptions\r\n     * @param {} constraintOptions\r\n     * @return {composite} A new composite softBody\r\n     */Composites.softBody=function(xx,yy,columns,rows,columnGap,rowGap,crossBrace,particleRadius,particleOptions,constraintOptions){particleOptions=Common.extend({inertia:Infinity},particleOptions);constraintOptions=Common.extend({stiffness:0.2,render:{type:'line',anchors:false}},constraintOptions);var softBody=Composites.stack(xx,yy,columns,rows,columnGap,rowGap,function(x,y){return Bodies.circle(x,y,particleRadius,particleOptions);});Composites.mesh(softBody,columns,rows,crossBrace,constraintOptions);softBody.label='Soft Body';return softBody;};})();/***/},/* 988 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */module.exports={decomp:polygonDecomp,quickDecomp:polygonQuickDecomp,isSimple:polygonIsSimple,removeCollinearPoints:polygonRemoveCollinearPoints,makeCCW:polygonMakeCCW};/**\r\n * Compute the intersection between two lines.\r\n * @static\r\n * @method lineInt\r\n * @param  {Array}  l1          Line vector 1\r\n * @param  {Array}  l2          Line vector 2\r\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\r\n * @return {Array}              The intersection point.\r\n */function lineInt(l1,l2,precision){precision=precision||0;var i=[0,0];// point\nvar a1,b1,c1,a2,b2,c2,det;// scalars\na1=l1[1][1]-l1[0][1];b1=l1[0][0]-l1[1][0];c1=a1*l1[0][0]+b1*l1[0][1];a2=l2[1][1]-l2[0][1];b2=l2[0][0]-l2[1][0];c2=a2*l2[0][0]+b2*l2[0][1];det=a1*b2-a2*b1;if(!scalar_eq(det,0,precision)){// lines are not parallel\ni[0]=(b2*c1-b1*c2)/det;i[1]=(a1*c2-a2*c1)/det;}return i;}/**\r\n * Checks if two line segments intersects.\r\n * @method segmentsIntersect\r\n * @param {Array} p1 The start vertex of the first line segment.\r\n * @param {Array} p2 The end vertex of the first line segment.\r\n * @param {Array} q1 The start vertex of the second line segment.\r\n * @param {Array} q2 The end vertex of the second line segment.\r\n * @return {Boolean} True if the two line segments intersect\r\n */function lineSegmentsIntersect(p1,p2,q1,q2){var dx=p2[0]-p1[0];var dy=p2[1]-p1[1];var da=q2[0]-q1[0];var db=q2[1]-q1[1];// segments are parallel\nif(da*dy-db*dx===0){return false;}var s=(dx*(q1[1]-p1[1])+dy*(p1[0]-q1[0]))/(da*dy-db*dx);var t=(da*(p1[1]-q1[1])+db*(q1[0]-p1[0]))/(db*dx-da*dy);return s>=0&&s<=1&&t>=0&&t<=1;}/**\r\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\r\n * @static\r\n * @method area\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @return {Number}\r\n */function triangleArea(a,b,c){return(b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1]);}function isLeft(a,b,c){return triangleArea(a,b,c)>0;}function isLeftOn(a,b,c){return triangleArea(a,b,c)>=0;}function isRight(a,b,c){return triangleArea(a,b,c)<0;}function isRightOn(a,b,c){return triangleArea(a,b,c)<=0;}var tmpPoint1=[],tmpPoint2=[];/**\r\n * Check if three points are collinear\r\n * @method collinear\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\r\n * @return {Boolean}\r\n */function collinear(a,b,c,thresholdAngle){if(!thresholdAngle){return triangleArea(a,b,c)===0;}else{var ab=tmpPoint1,bc=tmpPoint2;ab[0]=b[0]-a[0];ab[1]=b[1]-a[1];bc[0]=c[0]-b[0];bc[1]=c[1]-b[1];var dot=ab[0]*bc[0]+ab[1]*bc[1],magA=Math.sqrt(ab[0]*ab[0]+ab[1]*ab[1]),magB=Math.sqrt(bc[0]*bc[0]+bc[1]*bc[1]),angle=Math.acos(dot/(magA*magB));return angle<thresholdAngle;}}function sqdist(a,b){var dx=b[0]-a[0];var dy=b[1]-a[1];return dx*dx+dy*dy;}/**\r\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\r\n * @method at\r\n * @param  {Number} i\r\n * @return {Array}\r\n */function polygonAt(polygon,i){var s=polygon.length;return polygon[i<0?i%s+s:i%s];}/**\r\n * Clear the polygon data\r\n * @method clear\r\n * @return {Array}\r\n */function polygonClear(polygon){polygon.length=0;}/**\r\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\r\n * @method append\r\n * @param {Polygon} poly The polygon to get points from.\r\n * @param {Number}  from The vertex index in \"poly\".\r\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\r\n * @return {Array}\r\n */function polygonAppend(polygon,poly,from,to){for(var i=from;i<to;i++){polygon.push(poly[i]);}}/**\r\n * Make sure that the polygon vertices are ordered counter-clockwise.\r\n * @method makeCCW\r\n */function polygonMakeCCW(polygon){var br=0,v=polygon;// find bottom right point\nfor(var i=1;i<polygon.length;++i){if(v[i][1]<v[br][1]||v[i][1]===v[br][1]&&v[i][0]>v[br][0]){br=i;}}// reverse poly if clockwise\nif(!isLeft(polygonAt(polygon,br-1),polygonAt(polygon,br),polygonAt(polygon,br+1))){polygonReverse(polygon);}}/**\r\n * Reverse the vertices in the polygon\r\n * @method reverse\r\n */function polygonReverse(polygon){var tmp=[];var N=polygon.length;for(var i=0;i!==N;i++){tmp.push(polygon.pop());}for(var i=0;i!==N;i++){polygon[i]=tmp[i];}}/**\r\n * Check if a point in the polygon is a reflex point\r\n * @method isReflex\r\n * @param  {Number}  i\r\n * @return {Boolean}\r\n */function polygonIsReflex(polygon,i){return isRight(polygonAt(polygon,i-1),polygonAt(polygon,i),polygonAt(polygon,i+1));}var tmpLine1=[],tmpLine2=[];/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */function polygonCanSee(polygon,a,b){var p,dist,l1=tmpLine1,l2=tmpLine2;if(isLeftOn(polygonAt(polygon,a+1),polygonAt(polygon,a),polygonAt(polygon,b))&&isRightOn(polygonAt(polygon,a-1),polygonAt(polygon,a),polygonAt(polygon,b))){return false;}dist=sqdist(polygonAt(polygon,a),polygonAt(polygon,b));for(var i=0;i!==polygon.length;++i){// for each edge\nif((i+1)%polygon.length===a||i===a){// ignore incident edges\ncontinue;}if(isLeftOn(polygonAt(polygon,a),polygonAt(polygon,b),polygonAt(polygon,i+1))&&isRightOn(polygonAt(polygon,a),polygonAt(polygon,b),polygonAt(polygon,i))){// if diag intersects an edge\nl1[0]=polygonAt(polygon,a);l1[1]=polygonAt(polygon,b);l2[0]=polygonAt(polygon,i);l2[1]=polygonAt(polygon,i+1);p=lineInt(l1,l2);if(sqdist(polygonAt(polygon,a),p)<dist){// if edge is blocking visibility to b\nreturn false;}}}return true;}/**\r\n * Copy the polygon from vertex i to vertex j.\r\n * @method copy\r\n * @param  {Number} i\r\n * @param  {Number} j\r\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\r\n * @return {Polygon}                The resulting copy.\r\n */function polygonCopy(polygon,i,j,targetPoly){var p=targetPoly||[];polygonClear(p);if(i<j){// Insert all vertices from i to j\nfor(var k=i;k<=j;k++){p.push(polygon[k]);}}else{// Insert vertices 0 to j\nfor(var k=0;k<=j;k++){p.push(polygon[k]);}// Insert vertices i to end\nfor(var k=i;k<polygon.length;k++){p.push(polygon[k]);}}return p;}/**\r\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\r\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\r\n * @method getCutEdges\r\n * @return {Array}\r\n */function polygonGetCutEdges(polygon){var min=[],tmp1=[],tmp2=[],tmpPoly=[];var nDiags=Number.MAX_VALUE;for(var i=0;i<polygon.length;++i){if(polygonIsReflex(polygon,i)){for(var j=0;j<polygon.length;++j){if(polygonCanSee(polygon,i,j)){tmp1=polygonGetCutEdges(polygonCopy(polygon,i,j,tmpPoly));tmp2=polygonGetCutEdges(polygonCopy(polygon,j,i,tmpPoly));for(var k=0;k<tmp2.length;k++){tmp1.push(tmp2[k]);}if(tmp1.length<nDiags){min=tmp1;nDiags=tmp1.length;min.push([polygonAt(polygon,i),polygonAt(polygon,j)]);}}}}}return min;}/**\r\n * Decomposes the polygon into one or more convex sub-Polygons.\r\n * @method decomp\r\n * @return {Array} An array or Polygon objects.\r\n */function polygonDecomp(polygon){var edges=polygonGetCutEdges(polygon);if(edges.length>0){return polygonSlice(polygon,edges);}else{return[polygon];}}/**\r\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\r\n * @method slice\r\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\r\n * @return {Array}\r\n */function polygonSlice(polygon,cutEdges){if(cutEdges.length===0){return[polygon];}if(cutEdges instanceof Array&&cutEdges.length&&cutEdges[0]instanceof Array&&cutEdges[0].length===2&&cutEdges[0][0]instanceof Array){var polys=[polygon];for(var i=0;i<cutEdges.length;i++){var cutEdge=cutEdges[i];// Cut all polys\nfor(var j=0;j<polys.length;j++){var poly=polys[j];var result=polygonSlice(poly,cutEdge);if(result){// Found poly! Cut and quit\npolys.splice(j,1);polys.push(result[0],result[1]);break;}}}return polys;}else{// Was given one edge\nvar cutEdge=cutEdges;var i=polygon.indexOf(cutEdge[0]);var j=polygon.indexOf(cutEdge[1]);if(i!==-1&&j!==-1){return[polygonCopy(polygon,i,j),polygonCopy(polygon,j,i)];}else{return false;}}}/**\r\n * Checks that the line segments of this polygon do not intersect each other.\r\n * @method isSimple\r\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\r\n * @return {Boolean}\r\n * @todo Should it check all segments with all others?\r\n */function polygonIsSimple(polygon){var path=polygon,i;// Check\nfor(i=0;i<path.length-1;i++){for(var j=0;j<i-1;j++){if(lineSegmentsIntersect(path[i],path[i+1],path[j],path[j+1])){return false;}}}// Check the segment between the last and the first point to all others\nfor(i=1;i<path.length-2;i++){if(lineSegmentsIntersect(path[0],path[path.length-1],path[i],path[i+1])){return false;}}return true;}function getIntersectionPoint(p1,p2,q1,q2,delta){delta=delta||0;var a1=p2[1]-p1[1];var b1=p1[0]-p2[0];var c1=a1*p1[0]+b1*p1[1];var a2=q2[1]-q1[1];var b2=q1[0]-q2[0];var c2=a2*q1[0]+b2*q1[1];var det=a1*b2-a2*b1;if(!scalar_eq(det,0,delta)){return[(b2*c1-b1*c2)/det,(a1*c2-a2*c1)/det];}else{return[0,0];}}/**\r\n * Quickly decompose the Polygon into convex sub-polygons.\r\n * @method quickDecomp\r\n * @param  {Array} result\r\n * @param  {Array} [reflexVertices]\r\n * @param  {Array} [steinerPoints]\r\n * @param  {Number} [delta]\r\n * @param  {Number} [maxlevel]\r\n * @param  {Number} [level]\r\n * @return {Array}\r\n */function polygonQuickDecomp(polygon,result,reflexVertices,steinerPoints,delta,maxlevel,level){maxlevel=maxlevel||100;level=level||0;delta=delta||25;result=typeof result!==\"undefined\"?result:[];reflexVertices=reflexVertices||[];steinerPoints=steinerPoints||[];var upperInt=[0,0],lowerInt=[0,0],p=[0,0];// Points\nvar upperDist=0,lowerDist=0,d=0,closestDist=0;// scalars\nvar upperIndex=0,lowerIndex=0,closestIndex=0;// Integers\nvar lowerPoly=[],upperPoly=[];// polygons\nvar poly=polygon,v=polygon;if(v.length<3){return result;}level++;if(level>maxlevel){console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");return result;}for(var i=0;i<polygon.length;++i){if(polygonIsReflex(poly,i)){reflexVertices.push(poly[i]);upperDist=lowerDist=Number.MAX_VALUE;for(var j=0;j<polygon.length;++j){if(isLeft(polygonAt(poly,i-1),polygonAt(poly,i),polygonAt(poly,j))&&isRightOn(polygonAt(poly,i-1),polygonAt(poly,i),polygonAt(poly,j-1))){// if line intersects with an edge\np=getIntersectionPoint(polygonAt(poly,i-1),polygonAt(poly,i),polygonAt(poly,j),polygonAt(poly,j-1));// find the point of intersection\nif(isRight(polygonAt(poly,i+1),polygonAt(poly,i),p)){// make sure it's inside the poly\nd=sqdist(poly[i],p);if(d<lowerDist){// keep only the closest intersection\nlowerDist=d;lowerInt=p;lowerIndex=j;}}}if(isLeft(polygonAt(poly,i+1),polygonAt(poly,i),polygonAt(poly,j+1))&&isRightOn(polygonAt(poly,i+1),polygonAt(poly,i),polygonAt(poly,j))){p=getIntersectionPoint(polygonAt(poly,i+1),polygonAt(poly,i),polygonAt(poly,j),polygonAt(poly,j+1));if(isLeft(polygonAt(poly,i-1),polygonAt(poly,i),p)){d=sqdist(poly[i],p);if(d<upperDist){upperDist=d;upperInt=p;upperIndex=j;}}}}// if there are no vertices to connect to, choose a point in the middle\nif(lowerIndex===(upperIndex+1)%polygon.length){//console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\np[0]=(lowerInt[0]+upperInt[0])/2;p[1]=(lowerInt[1]+upperInt[1])/2;steinerPoints.push(p);if(i<upperIndex){//lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\npolygonAppend(lowerPoly,poly,i,upperIndex+1);lowerPoly.push(p);upperPoly.push(p);if(lowerIndex!==0){//upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\npolygonAppend(upperPoly,poly,lowerIndex,poly.length);}//upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\npolygonAppend(upperPoly,poly,0,i+1);}else{if(i!==0){//lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\npolygonAppend(lowerPoly,poly,i,poly.length);}//lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\npolygonAppend(lowerPoly,poly,0,upperIndex+1);lowerPoly.push(p);upperPoly.push(p);//upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\npolygonAppend(upperPoly,poly,lowerIndex,i+1);}}else{// connect to the closest point within the triangle\n//console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\nif(lowerIndex>upperIndex){upperIndex+=polygon.length;}closestDist=Number.MAX_VALUE;if(upperIndex<lowerIndex){return result;}for(var j=lowerIndex;j<=upperIndex;++j){if(isLeftOn(polygonAt(poly,i-1),polygonAt(poly,i),polygonAt(poly,j))&&isRightOn(polygonAt(poly,i+1),polygonAt(poly,i),polygonAt(poly,j))){d=sqdist(polygonAt(poly,i),polygonAt(poly,j));if(d<closestDist){closestDist=d;closestIndex=j%polygon.length;}}}if(i<closestIndex){polygonAppend(lowerPoly,poly,i,closestIndex+1);if(closestIndex!==0){polygonAppend(upperPoly,poly,closestIndex,v.length);}polygonAppend(upperPoly,poly,0,i+1);}else{if(i!==0){polygonAppend(lowerPoly,poly,i,v.length);}polygonAppend(lowerPoly,poly,0,closestIndex+1);polygonAppend(upperPoly,poly,closestIndex,i+1);}}// solve smallest poly first\nif(lowerPoly.length<upperPoly.length){polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);}else{polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);}return result;}}result.push(polygon);return result;}/**\r\n * Remove collinear points in the polygon.\r\n * @method removeCollinearPoints\r\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\r\n * @return {Number}           The number of points removed\r\n */function polygonRemoveCollinearPoints(polygon,precision){var num=0;for(var i=polygon.length-1;polygon.length>3&&i>=0;--i){if(collinear(polygonAt(polygon,i-1),polygonAt(polygon,i),polygonAt(polygon,i+1),precision)){// Remove the middle point\npolygon.splice(i%polygon.length,1);num++;}}return num;}/**\r\n * Check if two scalars are equal\r\n * @static\r\n * @method eq\r\n * @param  {Number} a\r\n * @param  {Number} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */function scalar_eq(a,b,precision){precision=precision||0;return Math.abs(a-b)<precision;}/***/},/* 989 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Bodies=__webpack_require__(123);var Class=__webpack_require__(0);var Composites=__webpack_require__(987);var Constraint=__webpack_require__(177);var MatterGameObject=__webpack_require__(1022);var MatterImage=__webpack_require__(986);var MatterSprite=__webpack_require__(985);var MatterTileBody=__webpack_require__(469);var PointerConstraint=__webpack_require__(1009);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Factory\r\n * @memberOf Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n */var Factory=new Class({initialize:function Factory(world){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.Factory#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.Factory#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=world.scene;/**\r\n         * A reference to the Scene.Systems this Matter Physics instance belongs to.\r\n         *\r\n         * @name Phaser.Physics.Matter.Factory#sys\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.sys=world.scene.sys;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#rectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {MatterJS.Body} A Matter JS Body.\r\n     */rectangle:function rectangle(x,y,width,height,options){var body=Bodies.rectangle(x,y,width,height,options);this.world.add(body);return body;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#trapezoid\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} slope - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {MatterJS.Body} A Matter JS Body.\r\n     */trapezoid:function trapezoid(x,y,width,height,slope,options){var body=Bodies.trapezoid(x,y,width,height,slope,options);this.world.add(body);return body;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#circle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} radius - [description]\r\n     * @param {object} options - [description]\r\n     * @param {number} maxSides - [description]\r\n     *\r\n     * @return {MatterJS.Body} A Matter JS Body.\r\n     */circle:function circle(x,y,radius,options,maxSides){var body=Bodies.circle(x,y,radius,options,maxSides);this.world.add(body);return body;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#polygon\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} sides - [description]\r\n     * @param {number} radius - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {MatterJS.Body} A Matter JS Body.\r\n     */polygon:function polygon(x,y,sides,radius,options){var body=Bodies.polygon(x,y,sides,radius,options);this.world.add(body);return body;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#fromVertices\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {array} vertexSets - [description]\r\n     * @param {object} options - [description]\r\n     * @param {boolean} flagInternal - [description]\r\n     * @param {boolean} removeCollinear - [description]\r\n     * @param {number} minimumArea - [description]\r\n     *\r\n     * @return {MatterJS.Body} A Matter JS Body.\r\n     */fromVertices:function fromVertices(x,y,vertexSets,options,flagInternal,removeCollinear,minimumArea){var body=Bodies.fromVertices(x,y,vertexSets,options,flagInternal,removeCollinear,minimumArea);this.world.add(body);return body;},/**\r\n     * Create a new composite containing Matter Image objects created in a grid arrangement.\r\n     * This function uses the body bounds to prevent overlaps.\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#imageStack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} frame - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.\r\n     * @param {number} x - The horizontal position of this composite in the world.\r\n     * @param {number} y - The vertical position of this composite in the world.\r\n     * @param {number} columns - The number of columns in the grid.\r\n     * @param {number} rows - The number of rows in the grid.\r\n     * @param {number} [columnGap=0] - The distance between each column.\r\n     * @param {number} [rowGap=0] - The distance between each row.\r\n     * @param {object} [options] - [description]\r\n     *\r\n     * @return {MatterJS.Composite} A Matter JS Composite Stack.\r\n     */imageStack:function imageStack(key,frame,x,y,columns,rows,columnGap,rowGap,options){if(columnGap===undefined){columnGap=0;}if(rowGap===undefined){rowGap=0;}if(options===undefined){options={};}var world=this.world;var displayList=this.sys.displayList;options.addToWorld=false;var stack=Composites.stack(x,y,columns,rows,columnGap,rowGap,function(x,y){var image=new MatterImage(world,x,y,key,frame,options);displayList.add(image);return image.body;});world.add(stack);return stack;},/**\r\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\r\n     * This function uses the body bounds to prevent overlaps.\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#stack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this composite in the world.\r\n     * @param {number} y - The vertical position of this composite in the world.\r\n     * @param {number} columns - The number of columns in the grid.\r\n     * @param {number} rows - The number of rows in the grid.\r\n     * @param {number} columnGap - The distance between each column.\r\n     * @param {number} rowGap - The distance between each row.\r\n     * @param {function} callback - The callback that creates the stack.\r\n     *\r\n     * @return {MatterJS.Composite} A new composite containing objects created in the callback.\r\n     */stack:function stack(x,y,columns,rows,columnGap,rowGap,callback){var stack=Composites.stack(x,y,columns,rows,columnGap,rowGap,callback);this.world.add(stack);return stack;},/**\r\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\r\n     * This function uses the body bounds to prevent overlaps.\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#pyramid\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this composite in the world.\r\n     * @param {number} y - The vertical position of this composite in the world.\r\n     * @param {number} columns - The number of columns in the pyramid.\r\n     * @param {number} rows - The number of rows in the pyramid.\r\n     * @param {number} columnGap - The distance between each column.\r\n     * @param {number} rowGap - The distance between each row.\r\n     * @param {function} callback - [description]\r\n     *\r\n     * @return {MatterJS.Composite} A Matter JS Composite pyramid.\r\n     */pyramid:function pyramid(x,y,columns,rows,columnGap,rowGap,callback){var stack=Composites.pyramid(x,y,columns,rows,columnGap,rowGap,callback);this.world.add(stack);return stack;},/**\r\n     * Chains all bodies in the given composite together using constraints.\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#chain\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Composite} composite - [description]\r\n     * @param {number} xOffsetA - [description]\r\n     * @param {number} yOffsetA - [description]\r\n     * @param {number} xOffsetB - [description]\r\n     * @param {number} yOffsetB - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {MatterJS.Composite} A new composite containing objects chained together with constraints.\r\n     */chain:function chain(composite,xOffsetA,yOffsetA,xOffsetB,yOffsetB,options){return Composites.chain(composite,xOffsetA,yOffsetA,xOffsetB,yOffsetB,options);},/**\r\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#mesh\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Composite} composite - [description]\r\n     * @param {number} columns - [description]\r\n     * @param {number} rows - [description]\r\n     * @param {boolean} crossBrace - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {MatterJS.Composite} The composite containing objects meshed together with constraints.\r\n     */mesh:function mesh(composite,columns,rows,crossBrace,options){return Composites.mesh(composite,columns,rows,crossBrace,options);},/**\r\n     * Creates a composite with a Newton's Cradle setup of bodies and constraints.\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#newtonsCradle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} number - [description]\r\n     * @param {number} size - [description]\r\n     * @param {number} length - [description]\r\n     *\r\n     * @return {MatterJS.Composite} A new composite newtonsCradle body.\r\n     */newtonsCradle:function newtonsCradle(x,y,number,size,length){var composite=Composites.newtonsCradle(x,y,number,size,length);this.world.add(composite);return composite;},/**\r\n     * Creates a composite with simple car setup of bodies and constraints.\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#car\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} wheelSize - [description]\r\n     *\r\n     * @return {MatterJS.Composite} A new composite car body.\r\n     */car:function car(x,y,width,height,wheelSize){var composite=Composites.car(x,y,width,height,wheelSize);this.world.add(composite);return composite;},/**\r\n     * Creates a simple soft body like object.\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#softBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this composite in the world.\r\n     * @param {number} y - The vertical position of this composite in the world.\r\n     * @param {number} columns - The number of columns in the Composite.\r\n     * @param {number} rows - The number of rows in the Composite.\r\n     * @param {number} columnGap - The distance between each column.\r\n     * @param {number} rowGap - The distance between each row.\r\n     * @param {boolean} crossBrace - [description]\r\n     * @param {number} particleRadius - [description]\r\n     * @param {object} particleOptions - [description]\r\n     * @param {object} constraintOptions - [description]\r\n     *\r\n     * @return {MatterJS.Composite} A new composite simple soft body.\r\n     */softBody:function softBody(x,y,columns,rows,columnGap,rowGap,crossBrace,particleRadius,particleOptions,constraintOptions){var composite=Composites.softBody(x,y,columns,rows,columnGap,rowGap,crossBrace,particleRadius,particleOptions,constraintOptions);this.world.add(composite);return composite;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#joint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} bodyA - [description]\r\n     * @param {MatterJS.Body} bodyB - [description]\r\n     * @param {number} length - [description]\r\n     * @param {number} [stiffness=1] - [description]\r\n     * @param {object} [options={}] - [description]\r\n     *\r\n     * @return {MatterJS.Constraint} A Matter JS Constraint.\r\n     */joint:function joint(bodyA,bodyB,length,stiffness,options){return this.constraint(bodyA,bodyB,length,stiffness,options);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#spring\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} bodyA - [description]\r\n     * @param {MatterJS.Body} bodyB - [description]\r\n     * @param {number} length - [description]\r\n     * @param {number} [stiffness=1] - [description]\r\n     * @param {object} [options={}] - [description]\r\n     *\r\n     * @return {MatterJS.Constraint} A Matter JS Constraint.\r\n     */spring:function spring(bodyA,bodyB,length,stiffness,options){return this.constraint(bodyA,bodyB,length,stiffness,options);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#constraint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} bodyA - [description]\r\n     * @param {MatterJS.Body} bodyB - [description]\r\n     * @param {number} length - [description]\r\n     * @param {number} [stiffness=1] - [description]\r\n     * @param {object} [options={}] - [description]\r\n     *\r\n     * @return {MatterJS.Constraint} A Matter JS Constraint.\r\n     */constraint:function constraint(bodyA,bodyB,length,stiffness,options){if(stiffness===undefined){stiffness=1;}if(options===undefined){options={};}options.bodyA=bodyA.type==='body'?bodyA:bodyA.body;options.bodyB=bodyB.type==='body'?bodyB:bodyB.body;options.length=length;options.stiffness=stiffness;var constraint=Constraint.create(options);this.world.add(constraint);return constraint;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#worldConstraint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} bodyB - [description]\r\n     * @param {number} length - [description]\r\n     * @param {number} [stiffness=1] - [description]\r\n     * @param {object} [options={}] - [description]\r\n     *\r\n     * @return {MatterJS.Constraint} A Matter JS Constraint.\r\n     */worldConstraint:function worldConstraint(bodyB,length,stiffness,options){if(stiffness===undefined){stiffness=1;}if(options===undefined){options={};}options.bodyB=bodyB.type==='body'?bodyB:bodyB.body;options.length=length;options.stiffness=stiffness;var constraint=Constraint.create(options);this.world.add(constraint);return constraint;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#mouseSpring\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {MatterJS.Constraint} A Matter JS Constraint.\r\n     */mouseSpring:function mouseSpring(options){return this.pointerConstraint(options);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#pointerConstraint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {MatterJS.Constraint} A Matter JS Constraint.\r\n     */pointerConstraint:function pointerConstraint(options){var pointerConstraint=new PointerConstraint(this.scene,this.world,options);this.world.add(pointerConstraint.constraint);return pointerConstraint;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#image\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.\r\n     * @param {object} [options={}] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Matter.Image} [description]\r\n     */image:function image(x,y,key,frame,options){var image=new MatterImage(this.world,x,y,key,frame,options);this.sys.displayList.add(image);return image;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#tileBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile} tile - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} [description]\r\n     */tileBody:function tileBody(tile,options){var tileBody=new MatterTileBody(this.world,tile,options);return tileBody;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#sprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.\r\n     * @param {object} [options={}] - [description]\r\n     *\r\n     * @return {Phaser.Physics.Matter.Sprite} [description]\r\n     */sprite:function sprite(x,y,key,frame,options){var sprite=new MatterSprite(this.world,x,y,key,frame,options);this.sys.displayList.add(sprite);this.sys.updateList.add(sprite);return sprite;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Factory#gameObject\r\n     * @since 3.3.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to inject the Matter Body in to.\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that had the Matter Body injected into it.\r\n     */gameObject:function gameObject(_gameObject,options){return MatterGameObject(this.world,_gameObject,options);}});module.exports=Factory;/***/},/* 990 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Body=__webpack_require__(996);var Class=__webpack_require__(0);var COLLIDES=__webpack_require__(205);var CollisionMap=__webpack_require__(995);var EventEmitter=__webpack_require__(14);var GetFastValue=__webpack_require__(2);var HasValue=__webpack_require__(71);var Set=__webpack_require__(65);var Solver=__webpack_require__(1026);var TILEMAP_FORMATS=__webpack_require__(24);var TYPE=__webpack_require__(204);/**\r\n * @typedef {object} ImpactWorldConfig\r\n *\r\n * @property {number} [gravity=0] - [description]\r\n * @property {number} [cellSize=64] - [description]\r\n * @property {number} [timeScale=1] - [description]\r\n * @property {float} [maxStep=0.05] - [description]\r\n * @property {boolean} [debug=false] - [description]\r\n * @property {number} [maxVelocity=100] - [description]\r\n * @property {boolean} [debugShowBody=true] - [description]\r\n * @property {boolean} [debugShowVelocity=true] - [description]\r\n * @property {number} [debugBodyColor=0xff00ff] - [description]\r\n * @property {number} [debugVelocityColor=0x00ff00] - [description]\r\n * @property {number} [maxVelocityX=maxVelocity] - [description]\r\n * @property {number} [maxVelocityY=maxVelocity] - [description]\r\n * @property {number} [minBounceVelocity=40] - [description]\r\n * @property {number} [gravityFactor=1] - [description]\r\n * @property {number} [bounciness=0] - [description]\r\n * @property {(object|boolean)} [setBounds] - [description]\r\n * @property {number} [setBounds.x=0] - [description]\r\n * @property {number} [setBounds.y=0] - [description]\r\n * @property {number} [setBounds.width] - [description]\r\n * @property {number} [setBounds.height] - [description]\r\n * @property {number} [setBounds.thickness=64] - [description]\r\n * @property {boolean} [setBounds.left=true] - [description]\r\n * @property {boolean} [setBounds.right=true] - [description]\r\n * @property {boolean} [setBounds.top=true] - [description]\r\n * @property {boolean} [setBounds.bottom=true] - [description]\r\n *//**\r\n * An object containing the 4 wall bodies that bound the physics world.\r\n * @typedef {object} ImpactWorldDefaults\r\n *\r\n * @property {boolean} debugShowBody - [description]\r\n * @property {boolean} debugShowVelocity - [description]\r\n * @property {number} bodyDebugColor - [description]\r\n * @property {number} velocityDebugColor - [description]\r\n * @property {number} maxVelocityX - [description]\r\n * @property {number} maxVelocityY - [description]\r\n * @property {number} minBounceVelocity - [description]\r\n * @property {number} gravityFactor - [description]\r\n * @property {number} bounciness - [description]\r\n *//**\r\n * @typedef {object} ImpactWorldWalls\r\n *\r\n * @property {?Phaser.Physics.Impact.Body} left - [description]\r\n * @property {?Phaser.Physics.Impact.Body} right - [description]\r\n * @property {?Phaser.Physics.Impact.Body} top - [description]\r\n * @property {?Phaser.Physics.Impact.Body} bottom - [description]\r\n *//**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberOf Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {ImpactWorldConfig} config - [description]\r\n */var World=new Class({Extends:EventEmitter,initialize:function World(scene,config){EventEmitter.call(this);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#bodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Impact.Body>}\r\n         * @since 3.0.0\r\n         */this.bodies=new Set();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#gravity\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.gravity=GetFastValue(config,'gravity',0);/**\r\n         * Spatial hash cell dimensions\r\n         *\r\n         * @name Phaser.Physics.Impact.World#cellSize\r\n         * @type {integer}\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */this.cellSize=GetFastValue(config,'cellSize',64);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#collisionMap\r\n         * @type {Phaser.Physics.Impact.CollisionMap}\r\n         * @since 3.0.0\r\n         */this.collisionMap=new CollisionMap();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#timeScale\r\n         * @type {float}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */this.timeScale=GetFastValue(config,'timeScale',1);/**\r\n         * Impacts maximum time step is 20 fps.\r\n         *\r\n         * @name Phaser.Physics.Impact.World#maxStep\r\n         * @type {number}\r\n         * @default 0.05\r\n         * @since 3.0.0\r\n         */this.maxStep=GetFastValue(config,'maxStep',0.05);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.enabled=true;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#drawDebug\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.drawDebug=GetFastValue(config,'debug',false);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */this.debugGraphic;var _maxVelocity=GetFastValue(config,'maxVelocity',100);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#defaults\r\n         * @type {ImpactWorldDefaults}\r\n         * @since 3.0.0\r\n         */this.defaults={debugShowBody:GetFastValue(config,'debugShowBody',true),debugShowVelocity:GetFastValue(config,'debugShowVelocity',true),bodyDebugColor:GetFastValue(config,'debugBodyColor',0xff00ff),velocityDebugColor:GetFastValue(config,'debugVelocityColor',0x00ff00),maxVelocityX:GetFastValue(config,'maxVelocityX',_maxVelocity),maxVelocityY:GetFastValue(config,'maxVelocityY',_maxVelocity),minBounceVelocity:GetFastValue(config,'minBounceVelocity',40),gravityFactor:GetFastValue(config,'gravityFactor',1),bounciness:GetFastValue(config,'bounciness',0)};/**\r\n         * An object containing the 4 wall bodies that bound the physics world.\r\n         *\r\n         * @name Phaser.Physics.Impact.World#walls\r\n         * @type {ImpactWorldWalls}\r\n         * @since 3.0.0\r\n         */this.walls={left:null,right:null,top:null,bottom:null};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#delta\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.delta=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#_lastId\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this._lastId=0;if(GetFastValue(config,'setBounds',false)){var boundsConfig=config['setBounds'];if(typeof boundsConfig==='boolean'){this.setBounds();}else{var x=GetFastValue(boundsConfig,'x',0);var y=GetFastValue(boundsConfig,'y',0);var width=GetFastValue(boundsConfig,'width',scene.sys.game.config.width);var height=GetFastValue(boundsConfig,'height',scene.sys.game.config.height);var thickness=GetFastValue(boundsConfig,'thickness',64);var left=GetFastValue(boundsConfig,'left',true);var right=GetFastValue(boundsConfig,'right',true);var top=GetFastValue(boundsConfig,'top',true);var bottom=GetFastValue(boundsConfig,'bottom',true);this.setBounds(x,y,width,height,thickness,left,right,top,bottom);}}if(this.drawDebug){this.createDebugGraphic();}},/**\r\n     * Sets the collision map for the world either from a Weltmeister JSON level in the cache or from\r\n     * a 2D array. If loading from a Weltmeister level, the map must have a layer called \"collision\".\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollisionMap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer[][])} key - Either a string key that corresponds to a Weltmeister level\r\n     * in the cache, or a 2D array of collision IDs.\r\n     * @param {integer} tileSize - The size of a tile. This is optional if loading from a Weltmeister\r\n     * level in the cache.\r\n     *\r\n     * @return {?Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap, or null if the method failed to\r\n     * create the CollisionMap.\r\n     */setCollisionMap:function setCollisionMap(key,tileSize){if(typeof key==='string'){var tilemapData=this.scene.cache.tilemap.get(key);if(!tilemapData||tilemapData.format!==TILEMAP_FORMATS.WELTMEISTER){console.warn('The specified key does not correspond to a Weltmeister tilemap: '+key);return null;}var layers=tilemapData.data.layer;var collisionLayer;for(var i=0;i<layers.length;i++){if(layers[i].name==='collision'){collisionLayer=layers[i];break;}}if(tileSize===undefined){tileSize=collisionLayer.tilesize;}this.collisionMap=new CollisionMap(tileSize,collisionLayer.data);}else if(Array.isArray(key)){this.collisionMap=new CollisionMap(tileSize,key);}else{console.warn('Invalid Weltmeister collision map data: '+key);}return this.collisionMap;},/**\r\n     * Sets the collision map for the world from a tilemap layer. Only tiles that are marked as\r\n     * colliding will be used. You can specify the mapping from tiles to slope IDs in a couple of\r\n     * ways. The easiest is to use Tiled and the slopeTileProperty option. Alternatively, you can\r\n     * manually create a slopeMap that stores the mapping between tile indices and slope IDs.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollisionMapFromTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemap layer to use.\r\n     * @param {object} [options] - Options for controlling the mapping from tiles to slope IDs.\r\n     * @param {string} [options.slopeTileProperty=null] - Slope IDs can be stored on tiles directly\r\n     * using Tiled's tileset editor. If a tile has a property with the given slopeTileProperty string\r\n     * name, the value of that property for the tile will be used for its slope mapping. E.g. a 45\r\n     * degree slope upward could be given a \"slope\" property with a value of 2.\r\n     * @param {object} [options.slopeMap=null] - A tile index to slope definition map.\r\n     * @param {integer} [options.defaultCollidingSlope=null] - If specified, the default slope ID to\r\n     * assign to a colliding tile. If not specified, the tile's index is used.\r\n     * @param {integer} [options.defaultNonCollidingSlope=0] - The default slope ID to assign to a\r\n     * non-colliding tile.\r\n     *\r\n     * @return {Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap.\r\n     */setCollisionMapFromTilemapLayer:function setCollisionMapFromTilemapLayer(tilemapLayer,options){if(options===undefined){options={};}var slopeProperty=GetFastValue(options,'slopeProperty',null);var slopeMap=GetFastValue(options,'slopeMap',null);var collidingSlope=GetFastValue(options,'defaultCollidingSlope',null);var nonCollidingSlope=GetFastValue(options,'defaultNonCollidingSlope',0);var layerData=tilemapLayer.layer;var tileSize=layerData.baseTileWidth;var collisionData=[];for(var ty=0;ty<layerData.height;ty++){collisionData[ty]=[];for(var tx=0;tx<layerData.width;tx++){var tile=layerData.data[ty][tx];if(tile&&tile.collides){if(slopeProperty!==null&&HasValue(tile.properties,slopeProperty)){collisionData[ty][tx]=parseInt(tile.properties[slopeProperty],10);}else if(slopeMap!==null&&HasValue(slopeMap,tile.index)){collisionData[ty][tx]=slopeMap[tile.index];}else if(collidingSlope!==null){collisionData[ty][tx]=collidingSlope;}else{collisionData[ty][tx]=tile.index;}}else{collisionData[ty][tx]=nonCollidingSlope;}}}this.collisionMap=new CollisionMap(tileSize,collisionData);return this.collisionMap;},/**\r\n     * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n     * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n     * If none of the walls are given it will default to use the walls settings it had previously.\r\n     * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n     * the newly created bounds will also not have the left and right walls.\r\n     * Explicitly state them in the parameters to override this.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The x coordinate of the top-left corner of the bounds.\r\n     * @param {number} [y] - The y coordinate of the top-left corner of the bounds.\r\n     * @param {number} [width] - The width of the bounds.\r\n     * @param {number} [height] - The height of the bounds.\r\n     * @param {number} [thickness=64] - [description]\r\n     * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n     * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n     * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n     * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setBounds:function setBounds(x,y,width,height,thickness,left,right,top,bottom){if(x===undefined){x=0;}if(y===undefined){y=0;}if(width===undefined){width=this.scene.sys.game.config.width;}if(height===undefined){height=this.scene.sys.game.config.height;}if(thickness===undefined){thickness=64;}if(left===undefined){left=true;}if(right===undefined){right=true;}if(top===undefined){top=true;}if(bottom===undefined){bottom=true;}this.updateWall(left,'left',x-thickness,y,thickness,height);this.updateWall(right,'right',x+width,y,thickness,height);this.updateWall(top,'top',x,y-thickness,width,thickness);this.updateWall(bottom,'bottom',x,y+height,width,thickness);return this;},/**\r\n     * position = 'left', 'right', 'top' or 'bottom'\r\n     *\r\n     * @method Phaser.Physics.Impact.World#updateWall\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} add - [description]\r\n     * @param {string} position - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     */updateWall:function updateWall(add,position,x,y,width,height){var wall=this.walls[position];if(add){if(wall){wall.resetSize(x,y,width,height);}else{this.walls[position]=this.create(x,y,width,height);this.walls[position].name=position;this.walls[position].gravityFactor=0;this.walls[position].collides=COLLIDES.FIXED;}}else{if(wall){this.bodies.remove(wall);}this.walls[position]=null;}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} [description]\r\n     */createDebugGraphic:function createDebugGraphic(){var graphic=this.scene.sys.add.graphics({x:0,y:0});graphic.setDepth(Number.MAX_VALUE);this.debugGraphic=graphic;this.drawDebug=true;return graphic;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#getNextID\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */getNextID:function getNextID(){return this._lastId++;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} sizeX - [description]\r\n     * @param {number} sizeY - [description]\r\n     *\r\n     * @return {Phaser.Physics.Impact.Body} The Body that was added to this World.\r\n     */create:function create(x,y,sizeX,sizeY){var body=new Body(this,x,y,sizeX,sizeY);this.bodies.set(body);return body;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} object - The Body to remove from this World.\r\n     */remove:function remove(object){this.bodies.delete(object);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */pause:function pause(){this.enabled=false;this.emit('pause');return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */resume:function resume(){this.enabled=true;this.emit('resume');return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - [description]\r\n     * @param {number} delta - [description]\r\n     */update:function update(time,delta){if(!this.enabled||this.bodies.size===0){return;}//  Impact uses a divided delta value that is clamped to the maxStep (20fps) maximum\nvar clampedDelta=Math.min(delta/1000,this.maxStep)*this.timeScale;this.delta=clampedDelta;//  Update all active bodies\nvar i;var body;var bodies=this.bodies.entries;var len=bodies.length;var hash={};var size=this.cellSize;for(i=0;i<len;i++){body=bodies[i];if(body.enabled){body.update(clampedDelta);}}//  Run collision against them all now they're in the new positions from the update\nfor(i=0;i<len;i++){body=bodies[i];if(body&&!body.skipHash()){this.checkHash(body,hash,size);}}if(this.drawDebug){var graphics=this.debugGraphic;graphics.clear();for(i=0;i<len;i++){body=bodies[i];if(body&&body.willDrawDebug()){body.drawDebug(graphics);}}}},/**\r\n     * Check the body against the spatial hash.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#checkHash\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} body - [description]\r\n     * @param {object} hash - [description]\r\n     * @param {number} size - [description]\r\n     */checkHash:function checkHash(body,hash,size){var checked={};var xmin=Math.floor(body.pos.x/size);var ymin=Math.floor(body.pos.y/size);var xmax=Math.floor((body.pos.x+body.size.x)/size)+1;var ymax=Math.floor((body.pos.y+body.size.y)/size)+1;for(var x=xmin;x<xmax;x++){for(var y=ymin;y<ymax;y++){if(!hash[x]){hash[x]={};hash[x][y]=[body];}else if(!hash[x][y]){hash[x][y]=[body];}else{var cell=hash[x][y];for(var c=0;c<cell.length;c++){if(body.touches(cell[c])&&!checked[cell[c].id]){checked[cell[c].id]=true;this.checkBodies(body,cell[c]);}}cell.push(body);}}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#checkBodies\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} bodyA - [description]\r\n     * @param {Phaser.Physics.Impact.Body} bodyB - [description]\r\n     */checkBodies:function checkBodies(bodyA,bodyB){//  2 fixed bodies won't do anything\nif(bodyA.collides===COLLIDES.FIXED&&bodyB.collides===COLLIDES.FIXED){return;}//  bitwise checks\nif(bodyA.checkAgainst&bodyB.type){bodyA.check(bodyB);}if(bodyB.checkAgainst&bodyA.type){bodyB.check(bodyA);}if(bodyA.collides&&bodyB.collides&&bodyA.collides+bodyB.collides>COLLIDES.ACTIVE){Solver(this,bodyA,bodyB);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollidesNever\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setCollidesNever:function setCollidesNever(bodies){for(var i=0;i<bodies.length;i++){bodies[i].collides=COLLIDES.NEVER;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setLite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setLite:function setLite(bodies){for(var i=0;i<bodies.length;i++){bodies[i].collides=COLLIDES.LITE;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setPassive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setPassive:function setPassive(bodies){for(var i=0;i<bodies.length;i++){bodies[i].collides=COLLIDES.PASSIVE;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setActive:function setActive(bodies){for(var i=0;i<bodies.length;i++){bodies[i].collides=COLLIDES.ACTIVE;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setFixed\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setFixed:function setFixed(bodies){for(var i=0;i<bodies.length;i++){bodies[i].collides=COLLIDES.FIXED;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeNone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setTypeNone:function setTypeNone(bodies){for(var i=0;i<bodies.length;i++){bodies[i].type=TYPE.NONE;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setTypeA:function setTypeA(bodies){for(var i=0;i<bodies.length;i++){bodies[i].type=TYPE.A;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setTypeB:function setTypeB(bodies){for(var i=0;i<bodies.length;i++){bodies[i].type=TYPE.B;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setAvsB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setAvsB:function setAvsB(bodies){for(var i=0;i<bodies.length;i++){bodies[i].type=TYPE.A;bodies[i].checkAgainst=TYPE.B;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setBvsA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setBvsA:function setBvsA(bodies){for(var i=0;i<bodies.length;i++){bodies[i].type=TYPE.B;bodies[i].checkAgainst=TYPE.A;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstNone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setCheckAgainstNone:function setCheckAgainstNone(bodies){for(var i=0;i<bodies.length;i++){bodies[i].checkAgainst=TYPE.NONE;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setCheckAgainstA:function setCheckAgainstA(bodies){for(var i=0;i<bodies.length;i++){bodies[i].checkAgainst=TYPE.A;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */setCheckAgainstB:function setCheckAgainstB(bodies){for(var i=0;i<bodies.length;i++){bodies[i].checkAgainst=TYPE.B;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.removeAllListeners();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.removeAllListeners();this.scene=null;this.bodies.clear();this.bodies=null;this.collisionMap=null;}});module.exports=World;/***/},/* 991 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(471);var Sprite=__webpack_require__(41);/**\r\n * @classdesc\r\n * An Impact Physics Sprite Game Object.\r\n *\r\n * A Sprite Game Object is used for the display of both static and animated images in your game.\r\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\r\n * and animated.\r\n *\r\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\r\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\r\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\r\n *\r\n * @class ImpactSprite\r\n * @extends Phaser.GameObjects.Sprite\r\n * @memberOf Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Impact.Components.Acceleration\r\n * @extends Phaser.Physics.Impact.Components.BodyScale\r\n * @extends Phaser.Physics.Impact.Components.BodyType\r\n * @extends Phaser.Physics.Impact.Components.Bounce\r\n * @extends Phaser.Physics.Impact.Components.CheckAgainst\r\n * @extends Phaser.Physics.Impact.Components.Collides\r\n * @extends Phaser.Physics.Impact.Components.Debug\r\n * @extends Phaser.Physics.Impact.Components.Friction\r\n * @extends Phaser.Physics.Impact.Components.Gravity\r\n * @extends Phaser.Physics.Impact.Components.Offset\r\n * @extends Phaser.Physics.Impact.Components.SetGameObject\r\n * @extends Phaser.Physics.Impact.Components.Velocity\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Animation\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Physics.Impact.World} world - [description]\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var ImpactSprite=new Class({Extends:Sprite,Mixins:[Components.Acceleration,Components.BodyScale,Components.BodyType,Components.Bounce,Components.CheckAgainst,Components.Collides,Components.Debug,Components.Friction,Components.Gravity,Components.Offset,Components.SetGameObject,Components.Velocity],initialize:function ImpactSprite(world,x,y,texture,frame){Sprite.call(this,world.scene,x,y,texture,frame);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactSprite#body\r\n         * @type {Phaser.Physics.Impact.Body}\r\n         * @since 3.0.0\r\n         */this.body=world.create(x-this.frame.centerX,y-this.frame.centerY,this.width,this.height);this.body.parent=this;this.body.gameObject=this;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactSprite#size\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.size=this.body.size;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactSprite#offset\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.offset=this.body.offset;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactSprite#vel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.vel=this.body.vel;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactSprite#accel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.accel=this.body.accel;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactSprite#friction\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.friction=this.body.friction;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactSprite#maxVel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.maxVel=this.body.maxVel;}});module.exports=ImpactSprite;/***/},/* 992 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(471);var Image=__webpack_require__(73);/**\r\n * @classdesc\r\n * An Impact Physics Image Game Object.\r\n * \r\n * An Image is a light-weight Game Object useful for the display of static images in your game,\r\n * such as logos, backgrounds, scenery or other non-animated elements. Images can have input\r\n * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an\r\n * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.\r\n *\r\n * @class ImpactImage\r\n * @extends Phaser.GameObjects.Image\r\n * @memberOf Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Impact.Components.Acceleration\r\n * @extends Phaser.Physics.Impact.Components.BodyScale\r\n * @extends Phaser.Physics.Impact.Components.BodyType\r\n * @extends Phaser.Physics.Impact.Components.Bounce\r\n * @extends Phaser.Physics.Impact.Components.CheckAgainst\r\n * @extends Phaser.Physics.Impact.Components.Collides\r\n * @extends Phaser.Physics.Impact.Components.Debug\r\n * @extends Phaser.Physics.Impact.Components.Friction\r\n * @extends Phaser.Physics.Impact.Components.Gravity\r\n * @extends Phaser.Physics.Impact.Components.Offset\r\n * @extends Phaser.Physics.Impact.Components.SetGameObject\r\n * @extends Phaser.Physics.Impact.Components.Velocity\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScaleMode\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Physics.Impact.World} world - [description]\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n */var ImpactImage=new Class({Extends:Image,Mixins:[Components.Acceleration,Components.BodyScale,Components.BodyType,Components.Bounce,Components.CheckAgainst,Components.Collides,Components.Debug,Components.Friction,Components.Gravity,Components.Offset,Components.SetGameObject,Components.Velocity],initialize:function ImpactImage(world,x,y,texture,frame){Image.call(this,world.scene,x,y,texture,frame);/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactImage#body\r\n         * @type {Phaser.Physics.Impact.Body}\r\n         * @since 3.0.0\r\n         */this.body=world.create(x-this.frame.centerX,y-this.frame.centerY,this.width,this.height);this.body.parent=this;this.body.gameObject=this;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactImage#size\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.size=this.body.size;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactImage#offset\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.offset=this.body.offset;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactImage#vel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.vel=this.body.vel;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactImage#accel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.accel=this.body.accel;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactImage#friction\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.friction=this.body.friction;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactImage#maxVel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.maxVel=this.body.maxVel;}});module.exports=ImpactImage;/***/},/* 993 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Components=__webpack_require__(471);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ImpactBody\r\n * @memberOf Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Impact.Components.Acceleration\r\n * @extends Phaser.Physics.Impact.Components.BodyScale\r\n * @extends Phaser.Physics.Impact.Components.BodyType\r\n * @extends Phaser.Physics.Impact.Components.Bounce\r\n * @extends Phaser.Physics.Impact.Components.CheckAgainst\r\n * @extends Phaser.Physics.Impact.Components.Collides\r\n * @extends Phaser.Physics.Impact.Components.Debug\r\n * @extends Phaser.Physics.Impact.Components.Friction\r\n * @extends Phaser.Physics.Impact.Components.Gravity\r\n * @extends Phaser.Physics.Impact.Components.Offset\r\n * @extends Phaser.Physics.Impact.Components.SetGameObject\r\n * @extends Phaser.Physics.Impact.Components.Velocity\r\n *\r\n * @param {Phaser.Physics.Impact.World} world - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {number} width - [description]\r\n * @param {number} height - [description]\r\n */var ImpactBody=new Class({Mixins:[Components.Acceleration,Components.BodyScale,Components.BodyType,Components.Bounce,Components.CheckAgainst,Components.Collides,Components.Debug,Components.Friction,Components.Gravity,Components.Offset,Components.SetGameObject,Components.Velocity],initialize:function ImpactBody(world,x,y,width,height){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactBody#body\r\n         * @type {Phaser.Physics.Impact.Body}\r\n         * @since 3.0.0\r\n         */this.body=world.create(x,y,width,height);this.body.parent=this;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactBody#size\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.size=this.body.size;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactBody#offset\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.offset=this.body.offset;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactBody#vel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.vel=this.body.vel;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactBody#accel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.accel=this.body.accel;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactBody#friction\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.friction=this.body.friction;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactBody#maxVel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.maxVel=this.body.maxVel;}});module.exports=ImpactBody;/***/},/* 994 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var ImpactBody=__webpack_require__(993);var ImpactImage=__webpack_require__(992);var ImpactSprite=__webpack_require__(991);/**\r\n * @classdesc\r\n * The Impact Physics Factory allows you to easily create Impact Physics enabled Game Objects.\r\n * Objects that are created by this Factory are automatically added to the physics world.\r\n *\r\n * @class Factory\r\n * @memberOf Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Impact.World} world - [description]\r\n */var Factory=new Class({initialize:function Factory(world){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Factory#world\r\n         * @type {Phaser.Physics.Impact.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * A reference to the Scene.Systems this Impact Physics instance belongs to.\r\n         *\r\n         * @name Phaser.Physics.Impact.Factory#sys\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.sys=world.scene.sys;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Factory#body\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Physics.Impact.ImpactBody} The ImpactBody object that was created.\r\n     */body:function body(x,y,width,height){return new ImpactBody(this.world,x,y,width,height);},/**\r\n     * Adds an Impact Physics Body to the given Game Object.\r\n     *\r\n     * @method Phaser.Physics.Impact.Factory#existing\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object.\r\n     */existing:function existing(gameObject){var x=gameObject.x-gameObject.frame.centerX;var y=gameObject.y-gameObject.frame.centerY;var w=gameObject.width;var h=gameObject.height;gameObject.body=this.world.create(x,y,w,h);gameObject.body.parent=gameObject;gameObject.body.gameObject=gameObject;return gameObject;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Factory#image\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Physics.Impact.ImpactImage} The ImpactImage object that was created.\r\n     */image:function image(x,y,key,frame){var image=new ImpactImage(this.world,x,y,key,frame);this.sys.displayList.add(image);return image;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Factory#sprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Physics.Impact.ImpactSprite} The ImpactSprite object that was created.\r\n     */sprite:function sprite(x,y,key,frame){var sprite=new ImpactSprite(this.world,x,y,key,frame);this.sys.displayList.add(sprite);this.sys.updateList.add(sprite);return sprite;}});module.exports=Factory;/***/},/* 995 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var DefaultDefs=__webpack_require__(1040);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CollisionMap\r\n * @memberOf Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tilesize=32] - [description]\r\n * @param {array} [data] - [description]\r\n */var CollisionMap=new Class({initialize:function CollisionMap(tilesize,data){if(tilesize===undefined){tilesize=32;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#tilesize\r\n         * @type {integer}\r\n         * @default 32\r\n         * @since 3.0.0\r\n         */this.tilesize=tilesize;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#data\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */this.data=Array.isArray(data)?data:[];/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.width=Array.isArray(data)?data[0].length:0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.height=Array.isArray(data)?data.length:0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#lastSlope\r\n         * @type {integer}\r\n         * @default 55\r\n         * @since 3.0.0\r\n         */this.lastSlope=55;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#tiledef\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.tiledef=DefaultDefs;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#trace\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} objectWidth - [description]\r\n     * @param {number} objectHeight - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */trace:function trace(x,y,vx,vy,objectWidth,objectHeight){// Set up the trace-result\nvar res={collision:{x:false,y:false,slope:false},pos:{x:x+vx,y:y+vy},tile:{x:0,y:0}};if(!this.data){return res;}var steps=Math.ceil(Math.max(Math.abs(vx),Math.abs(vy))/this.tilesize);if(steps>1){var sx=vx/steps;var sy=vy/steps;for(var i=0;i<steps&&(sx||sy);i++){this.step(res,x,y,sx,sy,objectWidth,objectHeight,vx,vy,i);x=res.pos.x;y=res.pos.y;if(res.collision.x){sx=0;vx=0;}if(res.collision.y){sy=0;vy=0;}if(res.collision.slope){break;}}}else{this.step(res,x,y,vx,vy,objectWidth,objectHeight,vx,vy,0);}return res;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#step\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} res - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} rvx - [description]\r\n     * @param {number} rvy - [description]\r\n     * @param {number} step - [description]\r\n     */step:function step(res,x,y,vx,vy,width,height,rvx,rvy,_step){var t=0;var tileX;var tileY;var tilesize=this.tilesize;var mapWidth=this.width;var mapHeight=this.height;//  Horizontal\nif(vx){var pxOffsetX=vx>0?width:0;var tileOffsetX=vx<0?tilesize:0;var firstTileY=Math.max(Math.floor(y/tilesize),0);var lastTileY=Math.min(Math.ceil((y+height)/tilesize),mapHeight);tileX=Math.floor((res.pos.x+pxOffsetX)/tilesize);var prevTileX=Math.floor((x+pxOffsetX)/tilesize);if(_step>0||tileX===prevTileX||prevTileX<0||prevTileX>=mapWidth){prevTileX=-1;}if(tileX>=0&&tileX<mapWidth){for(tileY=firstTileY;tileY<lastTileY;tileY++){if(prevTileX!==-1){t=this.data[tileY][prevTileX];if(t>1&&t<=this.lastSlope&&this.checkDef(res,t,x,y,rvx,rvy,width,height,prevTileX,tileY)){break;}}t=this.data[tileY][tileX];if(t===1||t>this.lastSlope||t>1&&this.checkDef(res,t,x,y,rvx,rvy,width,height,tileX,tileY)){if(t>1&&t<=this.lastSlope&&res.collision.slope){break;}res.collision.x=true;res.tile.x=t;res.pos.x=tileX*tilesize-pxOffsetX+tileOffsetX;x=res.pos.x;rvx=0;break;}}}}//  Vertical\nif(vy){var pxOffsetY=vy>0?height:0;var tileOffsetY=vy<0?tilesize:0;var firstTileX=Math.max(Math.floor(res.pos.x/tilesize),0);var lastTileX=Math.min(Math.ceil((res.pos.x+width)/tilesize),mapWidth);tileY=Math.floor((res.pos.y+pxOffsetY)/tilesize);var prevTileY=Math.floor((y+pxOffsetY)/tilesize);if(_step>0||tileY===prevTileY||prevTileY<0||prevTileY>=mapHeight){prevTileY=-1;}if(tileY>=0&&tileY<mapHeight){for(tileX=firstTileX;tileX<lastTileX;tileX++){if(prevTileY!==-1){t=this.data[prevTileY][tileX];if(t>1&&t<=this.lastSlope&&this.checkDef(res,t,x,y,rvx,rvy,width,height,tileX,prevTileY)){break;}}t=this.data[tileY][tileX];if(t===1||t>this.lastSlope||t>1&&this.checkDef(res,t,x,y,rvx,rvy,width,height,tileX,tileY)){if(t>1&&t<=this.lastSlope&&res.collision.slope){break;}res.collision.y=true;res.tile.y=t;res.pos.y=tileY*tilesize-pxOffsetY+tileOffsetY;break;}}}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#checkDef\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} res - [description]\r\n     * @param {number} t - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} tileX - [description]\r\n     * @param {number} tileY - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */checkDef:function checkDef(res,t,x,y,vx,vy,width,height,tileX,tileY){var def=this.tiledef[t];if(!def){return false;}var tilesize=this.tilesize;var lx=(tileX+def[0])*tilesize;var ly=(tileY+def[1])*tilesize;var lvx=(def[2]-def[0])*tilesize;var lvy=(def[3]-def[1])*tilesize;var solid=def[4];var tx=x+vx+(lvy<0?width:0)-lx;var ty=y+vy+(lvx>0?height:0)-ly;if(lvx*ty-lvy*tx>0){if(vx*-lvy+vy*lvx<0){return solid;}var length=Math.sqrt(lvx*lvx+lvy*lvy);var nx=lvy/length;var ny=-lvx/length;var proj=tx*nx+ty*ny;var px=nx*proj;var py=ny*proj;if(px*px+py*py>=vx*vx+vy*vy){return solid||lvx*(ty-vy)-lvy*(tx-vx)<0.5;}res.pos.x=x+vx-px;res.pos.y=y+vy-py;res.collision.slope={x:lvx,y:lvy,nx:nx,ny:ny};return true;}return false;}});module.exports=CollisionMap;/***/},/* 996 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var COLLIDES=__webpack_require__(205);var GetVelocity=__webpack_require__(1042);var TYPE=__webpack_require__(204);var UpdateMotion=__webpack_require__(1041);/**\r\n * @callback BodyUpdateCallback\r\n *\r\n * @param {Phaser.Physics.Impact.Body} body - [description]\r\n *//**\r\n * @typedef {object} JSONImpactBody\r\n * @todo Replace object types\r\n *\r\n * @property {string} name - [description]\r\n * @property {object} size - [description]\r\n * @property {object} pos - [description]\r\n * @property {object} vel - [description]\r\n * @property {object} accel - [description]\r\n * @property {object} friction - [description]\r\n * @property {object} maxVel - [description]\r\n * @property {number} gravityFactor - [description]\r\n * @property {number} bounciness - [description]\r\n * @property {number} minBounceVelocity - [description]\r\n * @property {Phaser.Physics.Impact.TYPE} type - [description]\r\n * @property {Phaser.Physics.Impact.TYPE} checkAgainst - [description]\r\n * @property {Phaser.Physics.Impact.COLLIDES} collides - [description]\r\n *//**\r\n * @classdesc\r\n * An Impact.js compatible physics body.\r\n * This re-creates the properties you'd get on an Entity and the math needed to update them.\r\n *\r\n * @class Body\r\n * @memberOf Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Impact.World} world - [description]\r\n * @param {number} x - [description]\r\n * @param {number} y - [description]\r\n * @param {number} [sx=16] - [description]\r\n * @param {number} [sy=16] - [description]\r\n */var Body=new Class({initialize:function Body(world,x,y,sx,sy){if(sx===undefined){sx=16;}if(sy===undefined){sy=sx;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#world\r\n         * @type {Phaser.Physics.Impact.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.gameObject=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.enabled=true;/**\r\n         * The ImpactBody, ImpactSprite or ImpactImage object that owns this Body, if any.\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#parent\r\n         * @type {?(Phaser.Physics.Impact.ImpactBody|Phaser.Physics.Impact.ImpactImage|Phaser.Physics.Impact.ImpactSprite)}\r\n         * @since 3.0.0\r\n         */this.parent;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#id\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.id=world.getNextID();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */this.name='';/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#size\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.size={x:sx,y:sy};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#offset\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.offset={x:0,y:0};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#pos\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.pos={x:x,y:y};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#last\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.last={x:x,y:y};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#vel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.vel={x:0,y:0};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#accel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.accel={x:0,y:0};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#friction\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.friction={x:0,y:0};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#maxVel\r\n         * @type {{x: number, y: number}}\r\n         * @since 3.0.0\r\n         */this.maxVel={x:world.defaults.maxVelocityX,y:world.defaults.maxVelocityY};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#standing\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */this.standing=false;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#gravityFactor\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.gravityFactor=world.defaults.gravityFactor;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#bounciness\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.bounciness=world.defaults.bounciness;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#minBounceVelocity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */this.minBounceVelocity=world.defaults.minBounceVelocity;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#accelGround\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accelGround=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#accelAir\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.accelAir=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#jumpSpeed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */this.jumpSpeed=0;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#type\r\n         * @type {Phaser.Physics.Impact.TYPE}\r\n         * @since 3.0.0\r\n         */this.type=TYPE.NONE;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#checkAgainst\r\n         * @type {Phaser.Physics.Impact.TYPE}\r\n         * @since 3.0.0\r\n         */this.checkAgainst=TYPE.NONE;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#collides\r\n         * @type {Phaser.Physics.Impact.COLLIDES}\r\n         * @since 3.0.0\r\n         */this.collides=COLLIDES.NEVER;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#debugShowBody\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.debugShowBody=world.defaults.debugShowBody;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#debugShowVelocity\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */this.debugShowVelocity=world.defaults.debugShowVelocity;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#debugBodyColor\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */this.debugBodyColor=world.defaults.bodyDebugColor;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#updateCallback\r\n         * @type {?BodyUpdateCallback}\r\n         * @since 3.0.0\r\n         */this.updateCallback;/**\r\n         * min 44 deg, max 136 deg\r\n         *\r\n         * @name Phaser.Physics.Impact.Body#slopeStanding\r\n         * @type {{ min: number, max: number }}\r\n         * @since 3.0.0\r\n         */this.slopeStanding={min:0.767944870877505,max:2.3736477827122884};},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     */reset:function reset(x,y){this.pos={x:x,y:y};this.last={x:x,y:y};this.vel={x:0,y:0};this.accel={x:0,y:0};this.friction={x:0,y:0};this.maxVel={x:100,y:100};this.standing=false;this.gravityFactor=1;this.bounciness=0;this.minBounceVelocity=40;this.accelGround=0;this.accelAir=0;this.jumpSpeed=0;this.type=TYPE.NONE;this.checkAgainst=TYPE.NONE;this.collides=COLLIDES.NEVER;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - [description]\r\n     */update:function update(delta){var pos=this.pos;this.last.x=pos.x;this.last.y=pos.y;this.vel.y+=this.world.gravity*delta*this.gravityFactor;this.vel.x=GetVelocity(delta,this.vel.x,this.accel.x,this.friction.x,this.maxVel.x);this.vel.y=GetVelocity(delta,this.vel.y,this.accel.y,this.friction.y,this.maxVel.y);var mx=this.vel.x*delta;var my=this.vel.y*delta;var res=this.world.collisionMap.trace(pos.x,pos.y,mx,my,this.size.x,this.size.y);if(this.handleMovementTrace(res)){UpdateMotion(this,res);}var go=this.gameObject;if(go){go.x=pos.x-this.offset.x+go.displayOriginX*go.scaleX;go.y=pos.y-this.offset.y+go.displayOriginY*go.scaleY;}if(this.updateCallback){this.updateCallback(this);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#drawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphic - [description]\r\n     */drawDebug:function drawDebug(graphic){var pos=this.pos;if(this.debugShowBody){graphic.lineStyle(1,this.debugBodyColor,1);graphic.strokeRect(pos.x,pos.y,this.size.x,this.size.y);}if(this.debugShowVelocity){var x=pos.x+this.size.x/2;var y=pos.y+this.size.y/2;graphic.lineStyle(1,this.world.defaults.velocityDebugColor,1);graphic.lineBetween(x,y,x+this.vel.x,y+this.vel.y);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#willDrawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */willDrawDebug:function willDrawDebug(){return this.debugShowBody||this.debugShowVelocity;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#skipHash\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */skipHash:function skipHash(){return!this.enabled||this.type===0&&this.checkAgainst===0&&this.collides===0;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#touches\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} other - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */touches:function touches(other){return!(this.pos.x>=other.pos.x+other.size.x||this.pos.x+this.size.x<=other.pos.x||this.pos.y>=other.pos.y+other.size.y||this.pos.y+this.size.y<=other.pos.y);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#resetSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Physics.Impact.Body} This Body object.\r\n     */resetSize:function resetSize(x,y,width,height){this.pos.x=x;this.pos.y=y;this.size.x=width;this.size.y=height;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {JSONImpactBody} [description]\r\n     */toJSON:function toJSON(){var output={name:this.name,size:{x:this.size.x,y:this.size.y},pos:{x:this.pos.x,y:this.pos.y},vel:{x:this.vel.x,y:this.vel.y},accel:{x:this.accel.x,y:this.accel.y},friction:{x:this.friction.x,y:this.friction.y},maxVel:{x:this.maxVel.x,y:this.maxVel.y},gravityFactor:this.gravityFactor,bounciness:this.bounciness,minBounceVelocity:this.minBounceVelocity,type:this.type,checkAgainst:this.checkAgainst,collides:this.collides};return output;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#fromJSON\r\n     * @todo Code it!\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     */fromJSON:function fromJSON(){},/**\r\n     * Can be overridden by user code\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#check\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} other - [description]\r\n     */check:function check(){},/**\r\n     * Can be overridden by user code\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#collideWith\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} other - [description]\r\n     * @param {string} axis - [description]\r\n     */collideWith:function collideWith(other,axis){if(this.parent&&this.parent._collideCallback){this.parent._collideCallback.call(this.parent._callbackScope,this,other,axis);}},/**\r\n     * Can be overridden by user code but must return a boolean.\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#handleMovementTrace\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} res - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */handleMovementTrace:function handleMovementTrace(){return true;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Body#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.world.remove(this);this.enabled=false;this.world=null;this.gameObject=null;this.parent=null;}});module.exports=Body;/***/},,/* 997 *//* 998 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Renderer.WebGL.Pipelines\r\n */module.exports={BitmapMaskPipeline:__webpack_require__(386),FlatTintPipeline:__webpack_require__(385),ForwardDiffuseLightPipeline:__webpack_require__(180),TextureTintPipeline:__webpack_require__(179)};/***/},/* 999 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Renderer.WebGL\r\n */module.exports={Utils:__webpack_require__(38),WebGLPipeline:__webpack_require__(111),WebGLRenderer:__webpack_require__(388),Pipelines:__webpack_require__(998),// Constants\nBYTE:0,SHORT:1,UNSIGNED_BYTE:2,UNSIGNED_SHORT:3,FLOAT:4};/***/},/* 1000 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @callback SnapshotCallback\r\n *\r\n * @param {HTMLImageElement} snapshot - [description]\r\n *//**\r\n * @namespace Phaser.Renderer.Snapshot\r\n */module.exports={Canvas:__webpack_require__(391),WebGL:__webpack_require__(387)};/***/},/* 1001 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Renderer.Canvas\r\n */module.exports={BlitImage:__webpack_require__(392),CanvasRenderer:__webpack_require__(393),DrawImage:__webpack_require__(390),GetBlendModes:__webpack_require__(389)};/***/},/* 1002 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @typedef {object} RendererConfig\r\n *\r\n * @property {boolean} clearBeforeRender - [description]\r\n * @property {boolean} pixelArt - [description]\r\n * @property {Phaser.Display.Color} backgroundColor - [description]\r\n * @property {number} resolution - [description]\r\n * @property {boolean} autoResize - [description]\r\n * @property {boolean} roundPixels - [description]\r\n *//**\r\n * @namespace Phaser.Renderer\r\n */module.exports={Canvas:__webpack_require__(1001),Snapshot:__webpack_require__(1000),WebGL:__webpack_require__(999)};/***/},/* 1003 *//***/function(module,exports,__webpack_require__){var Matter=__webpack_require__(466);/**\r\n * A coordinate wrapping plugin for matter.js.\r\n * See the readme for usage and examples.\r\n * @module MatterWrap\r\n */var MatterWrap={// plugin meta\nname:'matter-wrap',// PLUGIN_NAME\nversion:'0.1.4',// PLUGIN_VERSION\nfor:'matter-js@^0.13.1',silent:true,// no console log please\n// installs the plugin where `base` is `Matter`\n// you should not need to call this directly.\ninstall:function install(base){base.after('Engine.update',function(){MatterWrap.Engine.update(this);});},Engine:{/**\r\n     * Updates the engine by wrapping bodies and composites inside `engine.world`.\r\n     * This is called automatically by the plugin.\r\n     * @function MatterWrap.Engine.update\r\n     * @param {Matter.Engine} engine The engine to update.\r\n     * @returns {void} No return value.\r\n     */update:function update(engine){var world=engine.world,bodies=Matter.Composite.allBodies(world),composites=Matter.Composite.allComposites(world);for(var i=0;i<bodies.length;i+=1){var body=bodies[i];if(body.plugin.wrap){MatterWrap.Body.wrap(body,body.plugin.wrap);}}for(i=0;i<composites.length;i+=1){var composite=composites[i];if(composite.plugin.wrap){MatterWrap.Composite.wrap(composite,composite.plugin.wrap);}}}},Bounds:{/**\r\n     * Returns a translation vector that wraps the `objectBounds` inside the `bounds`.\r\n     * @function MatterWrap.Bounds.wrap\r\n     * @param {Matter.Bounds} objectBounds The bounds of the object to wrap inside the bounds.\r\n     * @param {Matter.Bounds} bounds The bounds to wrap the body inside.\r\n     * @returns {?Matter.Vector} A translation vector (only if wrapping is required).\r\n     */wrap:function wrap(objectBounds,bounds){var x=null,y=null;if(typeof bounds.min.x!=='undefined'&&typeof bounds.max.x!=='undefined'){if(objectBounds.min.x>bounds.max.x){x=bounds.min.x-objectBounds.max.x;}else if(objectBounds.max.x<bounds.min.x){x=bounds.max.x-objectBounds.min.x;}}if(typeof bounds.min.y!=='undefined'&&typeof bounds.max.y!=='undefined'){if(objectBounds.min.y>bounds.max.y){y=bounds.min.y-objectBounds.max.y;}else if(objectBounds.max.y<bounds.min.y){y=bounds.max.y-objectBounds.min.y;}}if(x!==null||y!==null){return{x:x||0,y:y||0};}}},Body:{/**\r\n     * Wraps the `body` position such that it always stays within the given bounds. \r\n     * Upon crossing a boundary the body will appear on the opposite side of the bounds, \r\n     * while maintaining its velocity.\r\n     * This is called automatically by the plugin.\r\n     * @function MatterWrap.Body.wrap\r\n     * @param {Matter.Body} body The body to wrap.\r\n     * @param {Matter.Bounds} bounds The bounds to wrap the body inside.\r\n     * @returns {?Matter.Vector} The translation vector that was applied (only if wrapping was required).\r\n     */wrap:function wrap(body,bounds){var translation=MatterWrap.Bounds.wrap(body.bounds,bounds);if(translation){Matter.Body.translate(body,translation);}return translation;}},Composite:{/**\r\n     * Returns the union of the bounds of all of the composite's bodies\r\n     * (not accounting for constraints).\r\n     * @function MatterWrap.Composite.bounds\r\n     * @param {Matter.Composite} composite The composite.\r\n     * @returns {Matter.Bounds} The composite bounds.\r\n     */bounds:function bounds(composite){var bodies=Matter.Composite.allBodies(composite),vertices=[];for(var i=0;i<bodies.length;i+=1){var body=bodies[i];vertices.push(body.bounds.min,body.bounds.max);}return Matter.Bounds.create(vertices);},/**\r\n     * Wraps the `composite` position such that it always stays within the given bounds. \r\n     * Upon crossing a boundary the composite will appear on the opposite side of the bounds, \r\n     * while maintaining its velocity.\r\n     * This is called automatically by the plugin.\r\n     * @function MatterWrap.Composite.wrap\r\n     * @param {Matter.Composite} composite The composite to wrap.\r\n     * @param {Matter.Bounds} bounds The bounds to wrap the composite inside.\r\n     * @returns {?Matter.Vector} The translation vector that was applied (only if wrapping was required).\r\n     */wrap:function wrap(composite,bounds){var translation=MatterWrap.Bounds.wrap(MatterWrap.Composite.bounds(composite),bounds);if(translation){Matter.Composite.translate(composite,translation);}return translation;}}};module.exports=MatterWrap;/**\r\n * @namespace Matter.Body\r\n * @see http://brm.io/matter-js/docs/classes/Body.html\r\n *//**\r\n * This plugin adds a new property `body.plugin.wrap` to instances of `Matter.Body`.  \r\n * This is a `Matter.Bounds` instance that specifies the wrapping region.\r\n * @property {Matter.Bounds} body.plugin.wrap\r\n * @memberof Matter.Body\r\n *//**\r\n * This plugin adds a new property `composite.plugin.wrap` to instances of `Matter.Composite`.  \r\n * This is a `Matter.Bounds` instance that specifies the wrapping region.\r\n * @property {Matter.Bounds} composite.plugin.wrap\r\n * @memberof Matter.Composite\r\n *//***/},/* 1004 *//***/function(module,exports,__webpack_require__){var Matter=__webpack_require__(466);/**\r\n * An attractors plugin for matter.js.\r\n * See the readme for usage and examples.\r\n * @module MatterAttractors\r\n */var MatterAttractors={// plugin meta\nname:'matter-attractors',// PLUGIN_NAME\nversion:'0.1.7',// PLUGIN_VERSION\nfor:'matter-js@^0.13.1',silent:true,// no console log please\n// installs the plugin where `base` is `Matter`\n// you should not need to call this directly.\ninstall:function install(base){base.after('Body.create',function(){MatterAttractors.Body.init(this);});base.before('Engine.update',function(engine){MatterAttractors.Engine.update(engine);});},Body:{/**\r\n     * Initialises the `body` to support attractors.\r\n     * This is called automatically by the plugin.\r\n     * @function MatterAttractors.Body.init\r\n     * @param {Matter.Body} body The body to init.\r\n     * @returns {void} No return value.\r\n     */init:function init(body){body.plugin.attractors=body.plugin.attractors||[];}},Engine:{/**\r\n     * Applies all attractors for all bodies in the `engine`.\r\n     * This is called automatically by the plugin.\r\n     * @function MatterAttractors.Engine.update\r\n     * @param {Matter.Engine} engine The engine to update.\r\n     * @returns {void} No return value.\r\n     */update:function update(engine){var world=engine.world,bodies=Matter.Composite.allBodies(world);for(var i=0;i<bodies.length;i+=1){var bodyA=bodies[i],attractors=bodyA.plugin.attractors;if(attractors&&attractors.length>0){for(var j=i+1;j<bodies.length;j+=1){var bodyB=bodies[j];for(var k=0;k<attractors.length;k+=1){var attractor=attractors[k],forceVector=attractor;if(Matter.Common.isFunction(attractor)){forceVector=attractor(bodyA,bodyB);}if(forceVector){Matter.Body.applyForce(bodyB,bodyB.position,forceVector);}}}}}}},/**\r\n   * Defines some useful common attractor functions that can be used\r\n   * by pushing them to your body's `body.plugin.attractors` array.\r\n   * @namespace MatterAttractors.Attractors\r\n   * @property {number} gravityConstant The gravitational constant used by the gravity attractor.\r\n   */Attractors:{gravityConstant:0.001,/**\r\n     * An attractor function that applies Newton's law of gravitation.\r\n     * Use this by pushing `MatterAttractors.Attractors.gravity` to your body's `body.plugin.attractors` array.\r\n     * The gravitational constant defaults to `0.001` which you can change\r\n     * at `MatterAttractors.Attractors.gravityConstant`.\r\n     * @function MatterAttractors.Attractors.gravity\r\n     * @param {Matter.Body} bodyA The first body.\r\n     * @param {Matter.Body} bodyB The second body.\r\n     * @returns {void} No return value.\r\n     */gravity:function gravity(bodyA,bodyB){// use Newton's law of gravitation\nvar bToA=Matter.Vector.sub(bodyB.position,bodyA.position),distanceSq=Matter.Vector.magnitudeSquared(bToA)||0.0001,normal=Matter.Vector.normalise(bToA),magnitude=-MatterAttractors.Attractors.gravityConstant*(bodyA.mass*bodyB.mass/distanceSq),force=Matter.Vector.mult(normal,magnitude);// to apply forces to both bodies\nMatter.Body.applyForce(bodyA,bodyA.position,Matter.Vector.neg(force));Matter.Body.applyForce(bodyB,bodyB.position,force);}}};module.exports=MatterAttractors;/**\r\n * @namespace Matter.Body\r\n * @see http://brm.io/matter-js/docs/classes/Body.html\r\n *//**\r\n * This plugin adds a new property `body.plugin.attractors` to instances of `Matter.Body`.\r\n * This is an array of callback functions that will be called automatically\r\n * for every pair of bodies, on every engine update.\r\n * @property {Function[]} body.plugin.attractors\r\n * @memberof Matter.Body\r\n *//**\r\n * An attractor function calculates the force to be applied\r\n * to `bodyB`, it should either:\r\n * - return the force vector to be applied to `bodyB`\r\n * - or apply the force to the body(s) itself\r\n * @callback AttractorFunction\r\n * @param {Matter.Body} bodyA\r\n * @param {Matter.Body} bodyB\r\n * @returns {(Vector|undefined)} a force vector (optional)\r\n *//***/},/* 1005 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Factory=__webpack_require__(989);var GetFastValue=__webpack_require__(2);var GetValue=__webpack_require__(5);var MatterAttractors=__webpack_require__(1004);var MatterLib=__webpack_require__(984);var MatterWrap=__webpack_require__(1003);var Merge=__webpack_require__(84);var Plugin=__webpack_require__(465);var PluginManager=__webpack_require__(13);var World=__webpack_require__(979);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class MatterPhysics\r\n * @memberOf Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var MatterPhysics=new Class({initialize:function MatterPhysics(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.config=this.getConfig();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */this.world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#add\r\n         * @type {Phaser.Physics.Matter.Factory}\r\n         * @since 3.0.0\r\n         */this.add;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#getConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */getConfig:function getConfig(){var gameConfig=this.systems.game.config.physics;var sceneConfig=this.systems.settings.physics;var config=Merge(GetFastValue(sceneConfig,'matter',{}),GetFastValue(gameConfig,'matter',{}));return config;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){var config=this.config;this.world=new World(this.scene,config);this.add=new Factory(this.world);//  Matter plugins\nif(GetValue(config,'plugins.attractors',false)){Plugin.register(MatterAttractors);Plugin.use(MatterLib,MatterAttractors);}if(GetValue(config,'plugins.wrap',false)){Plugin.register(MatterWrap);Plugin.use(MatterLib,MatterWrap);}var eventEmitter=this.systems.events;eventEmitter.on('update',this.world.update,this.world);eventEmitter.on('postupdate',this.world.postUpdate,this.world);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#enableAttractorPlugin\r\n     * @since 3.0.0\r\n     * \r\n     * @return {Phaser.Physics.Matter.MatterPhysics} This Matter Physics instance.\r\n     */enableAttractorPlugin:function enableAttractorPlugin(){Plugin.register(MatterAttractors);Plugin.use(MatterLib,MatterAttractors);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#enableWrapPlugin\r\n     * @since 3.0.0\r\n     * \r\n     * @return {Phaser.Physics.Matter.MatterPhysics} This Matter Physics instance.\r\n     */enableWrapPlugin:function enableWrapPlugin(){Plugin.register(MatterWrap);Plugin.use(MatterLib,MatterWrap);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} The Matter World object.\r\n     */pause:function pause(){return this.world.pause();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} The Matter World object.\r\n     */resume:function resume(){return this.world.resume();},/**\r\n     * Sets the Matter Engine to run at fixed timestep of 60Hz and enables `autoUpdate`.\r\n     * If you have set a custom `getDelta` function then this will override it.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#set60Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.MatterPhysics} This Matter Physics instance.\r\n     */set60Hz:function set60Hz(){this.world.getDelta=this.world.update60Hz;this.world.autoUpdate=true;return this;},/**\r\n     * Sets the Matter Engine to run at fixed timestep of 30Hz and enables `autoUpdate`.\r\n     * If you have set a custom `getDelta` function then this will override it.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#set30Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.MatterPhysics} This Matter Physics instance.\r\n     */set30Hz:function set30Hz(){this.world.getDelta=this.world.update30Hz;this.world.autoUpdate=true;return this;},/**\r\n     * Manually advances the physics simulation by one iteration.\r\n     * \r\n     * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.\r\n     * If undefined they use the Matter defaults of 60Hz and no correction.\r\n     * \r\n     * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.\r\n     * \r\n     * It also ignores any custom `getDelta` functions, as you should be passing the delta\r\n     * value in to this call.\r\n     *\r\n     * You can adjust the number of iterations that Engine.update performs internally.\r\n     * Use the Scene Matter Physics config object to set the following properties:\r\n     *\r\n     * positionIterations (defaults to 6)\r\n     * velocityIterations (defaults to 4)\r\n     * constraintIterations (defaults to 2)\r\n     *\r\n     * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n     * of your game.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#step\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [delta=16.666] - [description]\r\n     * @param {number} [correction=1] - [description]\r\n     */step:function step(delta,correction){this.world.step(delta,correction);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.world.shutdown();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.world.destroy();}});PluginManager.register('MatterPhysics',MatterPhysics,'matterPhysics');module.exports=MatterPhysics;/***/},/* 1006 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\r\n*\r\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Svg\r\n*/var Svg={};module.exports=Svg;var Bounds=__webpack_require__(92);(function(){/**\r\n     * Converts an SVG path into an array of vector points.\r\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\r\n     * See `Bodies.fromVertices` which provides support for this.\r\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\r\n     * @method pathToVertices\r\n     * @param {SVGPathElement} path\r\n     * @param {Number} [sampleLength=15]\r\n     * @return {Vector[]} points\r\n     */Svg.pathToVertices=function(path,sampleLength){// https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\nvar i,il,total,point,segment,segments,segmentsQueue,lastSegment,lastPoint,segmentIndex,points=[],lx,ly,length=0,x=0,y=0;sampleLength=sampleLength||15;var addPoint=function addPoint(px,py,pathSegType){// all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\nvar isRelative=pathSegType%2===1&&pathSegType>1;// when the last point doesn't equal the current point add the current point\nif(!lastPoint||px!=lastPoint.x||py!=lastPoint.y){if(lastPoint&&isRelative){lx=lastPoint.x;ly=lastPoint.y;}else{lx=0;ly=0;}var point={x:lx+px,y:ly+py};// set last point\nif(isRelative||!lastPoint){lastPoint=point;}points.push(point);x=lx+px;y=ly+py;}};var addSegmentPoint=function addSegmentPoint(segment){var segType=segment.pathSegTypeAsLetter.toUpperCase();// skip path ends\nif(segType==='Z')return;// map segment to x and y\nswitch(segType){case'M':case'L':case'T':case'C':case'S':case'Q':x=segment.x;y=segment.y;break;case'H':x=segment.x;break;case'V':y=segment.y;break;}addPoint(x,y,segment.pathSegType);};// ensure path is absolute\n_svgPathToAbsolute(path);// get total length\ntotal=path.getTotalLength();// queue segments\nsegments=[];for(i=0;i<path.pathSegList.numberOfItems;i+=1){segments.push(path.pathSegList.getItem(i));}segmentsQueue=segments.concat();// sample through path\nwhile(length<total){// get segment at position\nsegmentIndex=path.getPathSegAtLength(length);segment=segments[segmentIndex];// new segment\nif(segment!=lastSegment){while(segmentsQueue.length&&segmentsQueue[0]!=segment){addSegmentPoint(segmentsQueue.shift());}lastSegment=segment;}// add points in between when curving\n// TODO: adaptive sampling\nswitch(segment.pathSegTypeAsLetter.toUpperCase()){case'C':case'T':case'S':case'Q':case'A':point=path.getPointAtLength(length);addPoint(point.x,point.y,0);break;}// increment by sample value\nlength+=sampleLength;}// add remaining segments not passed by sampling\nfor(i=0,il=segmentsQueue.length;i<il;++i){addSegmentPoint(segmentsQueue[i]);}return points;};var _svgPathToAbsolute=function _svgPathToAbsolute(path){// http://phrogz.net/convert-svg-path-to-all-absolute-commands\n// Copyright (c) Gavin Kistner\n// http://phrogz.net/js/_ReuseLicense.txt\n// Modifications: tidy formatting and naming\nvar x0,y0,x1,y1,x2,y2,segs=path.pathSegList,x=0,y=0,len=segs.numberOfItems;for(var i=0;i<len;++i){var seg=segs.getItem(i),segType=seg.pathSegTypeAsLetter;if(/[MLHVCSQTA]/.test(segType)){if('x'in seg)x=seg.x;if('y'in seg)y=seg.y;}else{if('x1'in seg)x1=x+seg.x1;if('x2'in seg)x2=x+seg.x2;if('y1'in seg)y1=y+seg.y1;if('y2'in seg)y2=y+seg.y2;if('x'in seg)x+=seg.x;if('y'in seg)y+=seg.y;switch(segType){case'm':segs.replaceItem(path.createSVGPathSegMovetoAbs(x,y),i);break;case'l':segs.replaceItem(path.createSVGPathSegLinetoAbs(x,y),i);break;case'h':segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x),i);break;case'v':segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y),i);break;case'c':segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x,y,x1,y1,x2,y2),i);break;case's':segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x,y,x2,y2),i);break;case'q':segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x,y,x1,y1),i);break;case't':segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x,y),i);break;case'a':segs.replaceItem(path.createSVGPathSegArcAbs(x,y,seg.r1,seg.r2,seg.angle,seg.largeArcFlag,seg.sweepFlag),i);break;case'z':case'Z':x=x0;y=y0;break;}}if(segType=='M'||segType=='m'){x0=x;y0=y;}}};})();/***/},/* 1007 *//***/function(module,exports,__webpack_require__){// @if DEBUG\n/**\r\n* _Internal Class_, not generally used outside of the engine's internals.\r\n*\r\n*/var Metrics={};module.exports=Metrics;var Composite=__webpack_require__(122);var Common=__webpack_require__(37);(function(){/**\r\n     * Creates a new metrics.\r\n     * @method create\r\n     * @private\r\n     * @return {metrics} A new metrics\r\n     */Metrics.create=function(options){var defaults={extended:false,narrowDetections:0,narrowphaseTests:0,narrowReuse:0,narrowReuseCount:0,midphaseTests:0,broadphaseTests:0,narrowEff:0.0001,midEff:0.0001,broadEff:0.0001,collisions:0,buckets:0,bodies:0,pairs:0};return Common.extend(defaults,false,options);};/**\r\n     * Resets metrics.\r\n     * @method reset\r\n     * @private\r\n     * @param {metrics} metrics\r\n     */Metrics.reset=function(metrics){if(metrics.extended){metrics.narrowDetections=0;metrics.narrowphaseTests=0;metrics.narrowReuse=0;metrics.narrowReuseCount=0;metrics.midphaseTests=0;metrics.broadphaseTests=0;metrics.narrowEff=0;metrics.midEff=0;metrics.broadEff=0;metrics.collisions=0;metrics.buckets=0;metrics.pairs=0;metrics.bodies=0;}};/**\r\n     * Updates metrics.\r\n     * @method update\r\n     * @private\r\n     * @param {metrics} metrics\r\n     * @param {engine} engine\r\n     */Metrics.update=function(metrics,engine){if(metrics.extended){var world=engine.world,bodies=Composite.allBodies(world);metrics.collisions=metrics.narrowDetections;metrics.pairs=engine.pairs.list.length;metrics.bodies=bodies.length;metrics.midEff=(metrics.narrowDetections/(metrics.midphaseTests||1)).toFixed(2);metrics.narrowEff=(metrics.narrowDetections/(metrics.narrowphaseTests||1)).toFixed(2);metrics.broadEff=(1-metrics.broadphaseTests/(bodies.length||1)).toFixed(2);metrics.narrowReuse=(metrics.narrowReuseCount/(metrics.narrowphaseTests||1)).toFixed(2);//var broadphase = engine.broadphase[engine.broadphase.current];\n//if (broadphase.instance)\n//    metrics.buckets = Common.keys(broadphase.instance.buckets).length;\n}};})();// @endif\n/***/},/* 1008 *//***/function(module,exports,__webpack_require__){/**\r\n* The `Matter.Query` module contains methods for performing collision queries.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Query\r\n*/var Query={};module.exports=Query;var Vector=__webpack_require__(83);var SAT=__webpack_require__(467);var Bounds=__webpack_require__(92);var Bodies=__webpack_require__(123);var Vertices=__webpack_require__(93);(function(){/**\r\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\r\n     * @method ray\r\n     * @param {body[]} bodies\r\n     * @param {vector} startPoint\r\n     * @param {vector} endPoint\r\n     * @param {number} [rayWidth]\r\n     * @return {object[]} Collisions\r\n     */Query.ray=function(bodies,startPoint,endPoint,rayWidth){rayWidth=rayWidth||1e-100;var rayAngle=Vector.angle(startPoint,endPoint),rayLength=Vector.magnitude(Vector.sub(startPoint,endPoint)),rayX=(endPoint.x+startPoint.x)*0.5,rayY=(endPoint.y+startPoint.y)*0.5,ray=Bodies.rectangle(rayX,rayY,rayLength,rayWidth,{angle:rayAngle}),collisions=[];for(var i=0;i<bodies.length;i++){var bodyA=bodies[i];if(Bounds.overlaps(bodyA.bounds,ray.bounds)){for(var j=bodyA.parts.length===1?0:1;j<bodyA.parts.length;j++){var part=bodyA.parts[j];if(Bounds.overlaps(part.bounds,ray.bounds)){var collision=SAT.collides(part,ray);if(collision.collided){collision.body=collision.bodyA=collision.bodyB=bodyA;collisions.push(collision);break;}}}}}return collisions;};/**\r\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\r\n     * @method region\r\n     * @param {body[]} bodies\r\n     * @param {bounds} bounds\r\n     * @param {bool} [outside=false]\r\n     * @return {body[]} The bodies matching the query\r\n     */Query.region=function(bodies,bounds,outside){var result=[];for(var i=0;i<bodies.length;i++){var body=bodies[i],overlaps=Bounds.overlaps(body.bounds,bounds);if(overlaps&&!outside||!overlaps&&outside)result.push(body);}return result;};/**\r\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\r\n     * @method point\r\n     * @param {body[]} bodies\r\n     * @param {vector} point\r\n     * @return {body[]} The bodies matching the query\r\n     */Query.point=function(bodies,point){var result=[];for(var i=0;i<bodies.length;i++){var body=bodies[i];if(Bounds.contains(body.bounds,point)){for(var j=body.parts.length===1?0:1;j<body.parts.length;j++){var part=body.parts[j];if(Bounds.contains(part.bounds,point)&&Vertices.contains(part.vertices,point)){result.push(body);break;}}}}return result;};})();/***/},/* 1009 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Bounds=__webpack_require__(92);var Class=__webpack_require__(0);var Composite=__webpack_require__(122);var Constraint=__webpack_require__(177);var Detector=__webpack_require__(468);var GetFastValue=__webpack_require__(2);var Merge=__webpack_require__(84);var Sleeping=__webpack_require__(203);var Vector2=__webpack_require__(6);var Vertices=__webpack_require__(93);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class PointerConstraint\r\n * @memberOf Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n * @param {object} options - [description]\r\n */var PointerConstraint=new Class({initialize:function PointerConstraint(scene,world,options){if(options===undefined){options={};}//  Defaults\nvar defaults={label:'Pointer Constraint',pointA:{x:0,y:0},pointB:{x:0,y:0},damping:0,length:0.01,stiffness:0.1,angularStiffness:1,collisionFilter:{category:0x0001,mask:0xFFFFFFFF,group:0}};/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */this.world=world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @since 3.0.0\r\n         */var camera=GetFastValue(options,'camera',null);if(!camera){this.camera=scene.sys.cameras.main;}else{this.camera=camera;delete options.camera;}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#pointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */this.pointer=null;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */this.active=true;/**\r\n         * The transformed position.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */this.position=new Vector2();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#constraint\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.constraint=Constraint.create(Merge(options,defaults));this.world.on('beforeupdate',this.update,this);scene.sys.input.on('pointerdown',this.onDown,this);scene.sys.input.on('pointerup',this.onUp,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#onDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - [description]\r\n     */onDown:function onDown(pointer){this.pointer=pointer;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#onUp\r\n     * @since 3.0.0\r\n     */onUp:function onUp(){this.pointer=null;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#getBodyPart\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} body - [description]\r\n     * @param {Phaser.Math.Vector2} position - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */getBodyPart:function getBodyPart(body,position){var constraint=this.constraint;var start=body.parts.length>1?1:0;for(var i=start;i<body.parts.length;i++){var part=body.parts[i];if(Vertices.contains(part.vertices,position)){constraint.bodyB=body;constraint.pointA.x=position.x;constraint.pointA.y=position.y;constraint.pointB.x=position.x-body.position.x;constraint.pointB.y=position.y-body.position.y;constraint.angleB=body.angle;Sleeping.set(body,false);return true;}}return false;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#update\r\n     * @since 3.0.0\r\n     */update:function update(){if(!this.active){return;}var pointer=this.pointer;var constraint=this.constraint;if(!pointer){//  Pointer is up / released\nif(constraint.bodyB){constraint.bodyB=null;}}else{var pos=this.position;this.camera.getWorldPoint(pointer.x,pointer.y,pos);if(constraint.bodyB){//  Pointer is down and we have bodyB, so wake it up\nSleeping.set(constraint.bodyB,false);constraint.pointA.x=pos.x;constraint.pointA.y=pos.y;}else{var bodies=Composite.allBodies(this.world.localWorld);//  Pointer is down and no bodyB, so check if we've hit anything\nfor(var i=0;i<bodies.length;i++){var body=bodies[i];if(!body.ignorePointer&&Bounds.contains(body.bounds,pos)&&Detector.canCollide(body.collisionFilter,constraint.collisionFilter)){if(this.getBodyPart(body,pos)){break;}}}}}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.world.removeConstraint(this.constraint);this.constraint=null;this.world.off('beforeupdate',this.update);this.scene.sys.input.off('pointerdown',this.onDown,this);this.scene.sys.input.off('pointerup',this.onUp,this);}});module.exports=PointerConstraint;/***/},/* 1010 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Body=__webpack_require__(51);/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Velocity\r\n * @since 3.0.0\r\n */var Velocity={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Velocity#setAngularVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAngularVelocity:function setAngularVelocity(value){Body.setAngularVelocity(this.body,value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Velocity#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocityX:function setVelocityX(x){this._tempVec2.set(x,this.body.velocity.y);Body.setVelocity(this.body,this._tempVec2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Velocity#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocityY:function setVelocityY(y){this._tempVec2.set(this.body.velocity.x,y);Body.setVelocity(this.body,this._tempVec2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Velocity#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocity:function setVelocity(x,y){this._tempVec2.set(x,y);Body.setVelocity(this.body,this._tempVec2);return this;}};module.exports=Velocity;/***/},/* 1011 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Body=__webpack_require__(51);var MATH_CONST=__webpack_require__(16);var WrapAngle=__webpack_require__(182);var WrapAngleDegrees=__webpack_require__(181);//  global bitmask flag for GameObject.renderMask (used by Scale)\nvar _FLAG=4;// 0100\n//  Transform Component\n/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Transform\r\n * @since 3.0.0\r\n */var Transform={/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */x:{get:function get(){return this.body.position.x;},set:function set(value){this._tempVec2.set(value,this.y);Body.setPosition(this.body,this._tempVec2);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */y:{get:function get(){return this.body.position.y;},set:function set(value){this._tempVec2.set(this.x,value);Body.setPosition(this.body,this._tempVec2);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */scaleX:{get:function get(){return this._scaleX;},set:function set(value){this._scaleX=value;if(this._scaleX===0){this.renderFlags&=~_FLAG;}else{this.renderFlags|=_FLAG;}Body.scale(this.body,value,this._scaleY);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */scaleY:{get:function get(){return this._scaleY;},set:function set(value){this._scaleY=value;if(this._scaleY===0){this.renderFlags&=~_FLAG;}else{this.renderFlags|=_FLAG;}Body.scale(this.body,this._scaleX,value);}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#angle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */angle:{get:function get(){return WrapAngleDegrees(this.body.angle*MATH_CONST.RAD_TO_DEG);},set:function set(value){//  value is in degrees\nthis.rotation=WrapAngleDegrees(value)*MATH_CONST.DEG_TO_RAD;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */rotation:{get:function get(){return this.body.angle;},set:function set(value){//  value is in radians\nthis._rotation=WrapAngle(value);Body.setAngle(this.body,this._rotation);}},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return{Phaser.GameObjects.GameObject} This Game Object.\r\n     */setPosition:function setPosition(x,y){if(x===undefined){x=0;}if(y===undefined){y=x;}this._tempVec2.set(x,y);Body.setPosition(this.body,this._tempVec2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setRotation:function setRotation(radians){if(radians===undefined){radians=0;}this._rotation=WrapAngle(radians);Body.setAngle(this.body,radians);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setFixedRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFixedRotation:function setFixedRotation(){Body.setInertia(this.body,Infinity);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAngle:function setAngle(degrees){if(degrees===undefined){degrees=0;}this.angle=degrees;Body.setAngle(this.body,this.rotation);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=1] - [description]\r\n     * @param {number} [y=x] - [description]\r\n     * @param {Phaser.Math.Vector2} [point] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setScale:function setScale(x,y,point){if(x===undefined){x=1;}if(y===undefined){y=x;}this._scaleX=x;this._scaleY=y;Body.scale(this.body,x,y,point);return this;}};module.exports=Transform;/***/},/* 1012 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var MatterEvents=__webpack_require__(178);/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Sleep\r\n * @since 3.0.0\r\n */var Sleep={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setSleepThreshold\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=60] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setSleepThreshold:function setSleepThreshold(value){if(value===undefined){value=60;}this.body.sleepThreshold=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setSleepEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} start - [description]\r\n     * @param {boolean} end - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setSleepEvents:function setSleepEvents(start,end){this.setSleepStartEvent(start);this.setSleepEndEvent(end);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setSleepStartEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setSleepStartEvent:function setSleepStartEvent(value){if(value){var world=this.world;MatterEvents.on(this.body,'sleepStart',function(event){world.emit('sleepstart',event,this);});}else{MatterEvents.off(this.body,'sleepStart');}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setSleepEndEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setSleepEndEvent:function setSleepEndEvent(value){if(value){var world=this.world;MatterEvents.on(this.body,'sleepEnd',function(event){world.emit('sleepend',event,this);});}else{MatterEvents.off(this.body,'sleepEnd');}return this;}};module.exports=Sleep;/***/},/* 1013 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Bodies=__webpack_require__(123);var Body=__webpack_require__(51);var GetFastValue=__webpack_require__(2);/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.SetBody\r\n * @since 3.0.0\r\n */var SetBody={//  Calling any of these methods resets previous properties you may have set on the body, including plugins, mass, etc\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setRectangle:function setRectangle(width,height,options){return this.setBody({type:'rectangle',width:width,height:height},options);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCircle:function setCircle(radius,options){return this.setBody({type:'circle',radius:radius},options);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setPolygon\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - [description]\r\n     * @param {number} sides - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setPolygon:function setPolygon(radius,sides,options){return this.setBody({type:'polygon',sides:sides,radius:radius},options);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setTrapezoid\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} slope - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setTrapezoid:function setTrapezoid(width,height,slope,options){return this.setBody({type:'trapezoid',width:width,height:height,slope:slope},options);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setExistingBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} body - [description]\r\n     * @param {boolean} [addToWorld=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setExistingBody:function setExistingBody(body,addToWorld){if(addToWorld===undefined){addToWorld=true;}if(this.body){this.world.remove(this.body);}this.body=body;this.body.gameObject=this;var _this=this;body.destroy=function destroy(){_this.world.remove(_this.body);_this.body.gameObject=null;};if(addToWorld){this.world.add(body);}if(this._originComponent){this.setOrigin(body.render.sprite.xOffset,body.render.sprite.yOffset);}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     * @param {object} options - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBody:function setBody(config,options){if(!config){return this;}var body;//  Allow them to do: shape: 'circle' instead of shape: { type: 'circle' }\nif(typeof config==='string'){//  Using defaults\nconfig={type:config};}var shapeType=GetFastValue(config,'type','rectangle');var bodyX=GetFastValue(config,'x',this._tempVec2.x);var bodyY=GetFastValue(config,'y',this._tempVec2.y);var bodyWidth=GetFastValue(config,'width',this.width);var bodyHeight=GetFastValue(config,'height',this.height);switch(shapeType){case'rectangle':body=Bodies.rectangle(bodyX,bodyY,bodyWidth,bodyHeight,options);break;case'circle':var radius=GetFastValue(config,'radius',Math.max(bodyWidth,bodyHeight)/2);var maxSides=GetFastValue(config,'maxSides',25);body=Bodies.circle(bodyX,bodyY,radius,options,maxSides);break;case'trapezoid':var slope=GetFastValue(config,'slope',0.5);body=Bodies.trapezoid(bodyX,bodyY,bodyWidth,bodyHeight,slope,options);break;case'polygon':var sides=GetFastValue(config,'sides',5);var pradius=GetFastValue(config,'radius',Math.max(bodyWidth,bodyHeight)/2);body=Bodies.polygon(bodyX,bodyY,sides,pradius,options);break;case'fromVertices':case'fromVerts':var verts=GetFastValue(config,'verts',[]);if(this.body){Body.setVertices(this.body,verts);body=this.body;}else{var flagInternal=GetFastValue(config,'flagInternal',false);var removeCollinear=GetFastValue(config,'removeCollinear',0.01);var minimumArea=GetFastValue(config,'minimumArea',10);body=Bodies.fromVertices(bodyX,bodyY,verts,options,flagInternal,removeCollinear,minimumArea);}break;}this.setExistingBody(body,config.addToWorld);return this;}};module.exports=SetBody;/***/},/* 1014 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Sensor\r\n * @since 3.0.0\r\n */var Sensor={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sensor#setSensor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setSensor:function setSensor(value){this.body.isSensor=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sensor#isSensor\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isSensor:function isSensor(){return this.body.isSensor;}};module.exports=Sensor;/***/},/* 1015 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Body=__webpack_require__(51);/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Static\r\n * @since 3.0.0\r\n */var Static={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Static#setStatic\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setStatic:function setStatic(value){Body.setStatic(this.body,value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Static#isStatic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} [description]\r\n     */isStatic:function isStatic(){return this.body.isStatic;}};module.exports=Static;/***/},/* 1016 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Body=__webpack_require__(51);/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Mass\r\n * @since 3.0.0\r\n */var Mass={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Mass#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setMass:function setMass(value){Body.setMass(this.body,value);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Mass#setDensity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setDensity:function setDensity(value){Body.setDensity(this.body,value);return this;}};module.exports=Mass;/***/},/* 1017 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Gravity\r\n * @since 3.0.0\r\n */var Gravity={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Gravity#setIgnoreGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setIgnoreGravity:function setIgnoreGravity(value){this.body.ignoreGravity=value;return this;}};module.exports=Gravity;/***/},/* 1018 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Friction\r\n * @since 3.0.0\r\n */var Friction={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Friction#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     * @param {number} [air] - [description]\r\n     * @param {number} [fstatic] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFriction:function setFriction(value,air,fstatic){this.body.friction=value;if(air!==undefined){this.body.frictionAir=air;}if(fstatic!==undefined){this.body.frictionStatic=fstatic;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Friction#setFrictionAir\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFrictionAir:function setFrictionAir(value){this.body.frictionAir=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Friction#setFrictionStatic\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFrictionStatic:function setFrictionStatic(value){this.body.frictionStatic=value;return this;}};module.exports=Friction;/***/},/* 1019 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Body=__webpack_require__(51);/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Force\r\n * @since 3.0.0\r\n */var Force={//  force = vec2 / point\n/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#applyForce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} force - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */applyForce:function applyForce(force){this._tempVec2.set(this.body.position.x,this.body.position.y);Body.applyForce(this.body,this._tempVec2,force);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#applyForceFrom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} position - [description]\r\n     * @param {Phaser.Math.Vector2} force - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */applyForceFrom:function applyForceFrom(position,force){Body.applyForce(this.body,position,force);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#thrust\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} speed - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */thrust:function thrust(speed){var angle=this.body.angle;this._tempVec2.set(speed*Math.cos(angle),speed*Math.sin(angle));Body.applyForce(this.body,{x:this.body.position.x,y:this.body.position.y},this._tempVec2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#thrustLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} speed - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */thrustLeft:function thrustLeft(speed){var angle=this.body.angle-Math.PI/2;this._tempVec2.set(speed*Math.cos(angle),speed*Math.sin(angle));Body.applyForce(this.body,{x:this.body.position.x,y:this.body.position.y},this._tempVec2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#thrustRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} speed - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */thrustRight:function thrustRight(speed){var angle=this.body.angle+Math.PI/2;this._tempVec2.set(speed*Math.cos(angle),speed*Math.sin(angle));Body.applyForce(this.body,{x:this.body.position.x,y:this.body.position.y},this._tempVec2);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#thrustBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} speed - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */thrustBack:function thrustBack(speed){var angle=this.body.angle-Math.PI;this._tempVec2.set(speed*Math.cos(angle),speed*Math.sin(angle));Body.applyForce(this.body,{x:this.body.position.x,y:this.body.position.y},this._tempVec2);return this;}};module.exports=Force;/***/},/* 1020 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Collision\r\n * @since 3.0.0\r\n */var Collision={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollisionCategory\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Unique category bitfield.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCollisionCategory:function setCollisionCategory(value){this.body.collisionFilter.category=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Unique group index.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCollisionGroup:function setCollisionGroup(value){this.body.collisionFilter.group=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollidesWith\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCollidesWith:function setCollidesWith(categories){var flags=0;if(!Array.isArray(categories)){flags=categories;}else{for(var i=0;i<categories.length;i++){flags|=categories[i];}}this.body.collisionFilter.mask=flags;return this;}};module.exports=Collision;/***/},/* 1021 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Matter.Components.Bounce\r\n * @since 3.0.0\r\n */var Bounce={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Bounce#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {float} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBounce:function setBounce(value){this.body.restitution=value;return this;}};module.exports=Bounce;/***/},/* 1022 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Components=__webpack_require__(384);var GetFastValue=__webpack_require__(2);var Vector2=__webpack_require__(6);/**\r\n * [description]\r\n *\r\n * @function hasGetterOrSetter\r\n * @private\r\n *\r\n * @param {object} def - The object to check.\r\n *\r\n * @return {boolean} True if it has a getter or setter, otherwise false.\r\n */function hasGetterOrSetter(def){return!!def.get&&typeof def.get==='function'||!!def.set&&typeof def.set==='function';}/**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Matter.MatterGameObject\r\n * @since 3.3.0\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n * @param {object} options - [description]\r\n *\r\n * @return {Phaser.GameObjects.GameObject} [description]\r\n */var MatterGameObject=function MatterGameObject(world,gameObject,options){if(options===undefined){options={};}var x=gameObject.x;var y=gameObject.y;//  Temp body pos to avoid body null checks\ngameObject.body={position:{x:x,y:y}};var mixins=[Components.Bounce,Components.Collision,Components.Force,Components.Friction,Components.Gravity,Components.Mass,Components.Sensor,Components.SetBody,Components.Sleep,Components.Static,Components.Transform,Components.Velocity];//  First let's inject all of the components into the Game Object\nmixins.forEach(function(mixin){for(var key in mixin){if(hasGetterOrSetter(mixin[key])){Object.defineProperty(gameObject,key,{get:mixin[key].get,set:mixin[key].set});}else{Object.defineProperty(gameObject,key,{value:mixin[key]});}}});gameObject.world=world;gameObject._tempVec2=new Vector2(x,y);var shape=GetFastValue(options,'shape',null);if(!shape){shape='rectangle';}gameObject.setBody(shape,options);return gameObject;};module.exports=MatterGameObject;/***/},/* 1023 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Physics.Matter\r\n */module.exports={Factory:__webpack_require__(989),Image:__webpack_require__(986),Matter:__webpack_require__(466),MatterPhysics:__webpack_require__(1005),PolyDecomp:__webpack_require__(988),Sprite:__webpack_require__(985),TileBody:__webpack_require__(469),World:__webpack_require__(979)};/**\r\n * @namespace MatterJS\r\n *//**\r\n * @classdesc\r\n * The `Matter.Body` module contains methods for creating and manipulating body models.\r\n * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\r\n * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\r\n *\r\n * @class MatterJS.Body\r\n *//**\r\n * @classdesc\r\n * The `Matter.Composite` module contains methods for creating and manipulating composite bodies.\r\n * A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.\r\n * It is important to use the functions in this module to modify composites, rather than directly modifying their properties.\r\n * Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.\r\n *\r\n * @class MatterJS.Composite\r\n *//**\r\n * @classdesc\r\n * The `Matter.World` module contains methods for creating and manipulating the world composite.\r\n * A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.\r\n * A `Matter.World` has a few additional properties including `gravity` and `bounds`.\r\n * It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.\r\n * There are also a few methods here that alias those in `Matter.Composite` for easier readability.\r\n *\r\n * @class MatterJS.World\r\n * @extends MatterJS.Composite\r\n *//**\r\n * @classdesc\r\n * The `Matter.Constraint` module contains methods for creating and manipulating constraints.\r\n * Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\r\n * The stiffness of constraints can be modified to create springs or elastic.\r\n *\r\n * @class MatterJS.Constraint\r\n *//**\r\n * @classdesc\r\n * The `Matter.Engine` module contains methods for creating and manipulating engines.\r\n * An engine is a controller that manages updating the simulation of the world.\r\n *\r\n * @class MatterJS.Engine\r\n *//***/},/* 1024 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Impact.SeperateY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Impact.World} world - [description]\r\n * @param {Phaser.Physics.Impact.Body} top - [description]\r\n * @param {Phaser.Physics.Impact.Body} bottom - [description]\r\n * @param {Phaser.Physics.Impact.Body} [weak] - [description]\r\n */var SeperateY=function SeperateY(world,top,bottom,weak){var nudge=top.pos.y+top.size.y-bottom.pos.y;var nudgeX;var resTop;if(weak){var strong=top===weak?bottom:top;weak.vel.y=-weak.vel.y*weak.bounciness+strong.vel.y;// Riding on a platform?\nnudgeX=0;if(weak===top&&Math.abs(weak.vel.y-strong.vel.y)<weak.minBounceVelocity){weak.standing=true;nudgeX=strong.vel.x*world.delta;}var resWeak=world.collisionMap.trace(weak.pos.x,weak.pos.y,nudgeX,weak===top?-nudge:nudge,weak.size.x,weak.size.y);weak.pos.y=resWeak.pos.y;weak.pos.x=resWeak.pos.x;}else if(world.gravity&&(bottom.standing||top.vel.y>0)){resTop=world.collisionMap.trace(top.pos.x,top.pos.y,0,-(top.pos.y+top.size.y-bottom.pos.y),top.size.x,top.size.y);top.pos.y=resTop.pos.y;if(top.bounciness>0&&top.vel.y>top.minBounceVelocity){top.vel.y*=-top.bounciness;}else{top.standing=true;top.vel.y=0;}}else{var v2=(top.vel.y-bottom.vel.y)/2;top.vel.y=-v2;bottom.vel.y=v2;nudgeX=bottom.vel.x*world.delta;resTop=world.collisionMap.trace(top.pos.x,top.pos.y,nudgeX,-nudge/2,top.size.x,top.size.y);top.pos.y=resTop.pos.y;var resBottom=world.collisionMap.trace(bottom.pos.x,bottom.pos.y,0,nudge/2,bottom.size.x,bottom.size.y);bottom.pos.y=resBottom.pos.y;}};module.exports=SeperateY;/***/},/* 1025 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Impact.SeperateX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Impact.World} world - [description]\r\n * @param {Phaser.Physics.Impact.Body} left - [description]\r\n * @param {Phaser.Physics.Impact.Body} right - [description]\r\n * @param {Phaser.Physics.Impact.Body} [weak] - [description]\r\n */var SeperateX=function SeperateX(world,left,right,weak){var nudge=left.pos.x+left.size.x-right.pos.x;// We have a weak entity, so just move this one\nif(weak){var strong=left===weak?right:left;weak.vel.x=-weak.vel.x*weak.bounciness+strong.vel.x;var resWeak=world.collisionMap.trace(weak.pos.x,weak.pos.y,weak===left?-nudge:nudge,0,weak.size.x,weak.size.y);weak.pos.x=resWeak.pos.x;}else{var v2=(left.vel.x-right.vel.x)/2;left.vel.x=-v2;right.vel.x=v2;var resLeft=world.collisionMap.trace(left.pos.x,left.pos.y,-nudge/2,0,left.size.x,left.size.y);left.pos.x=Math.floor(resLeft.pos.x);var resRight=world.collisionMap.trace(right.pos.x,right.pos.y,nudge/2,0,right.size.x,right.size.y);right.pos.x=Math.ceil(resRight.pos.x);}};module.exports=SeperateX;/***/},/* 1026 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var COLLIDES=__webpack_require__(205);var SeperateX=__webpack_require__(1025);var SeperateY=__webpack_require__(1024);/**\r\n * Impact Physics Solver\r\n *\r\n * @function Phaser.Physics.Impact.Solver\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Impact.World} world - [description]\r\n * @param {Phaser.Physics.Impact.Body} bodyA - [description]\r\n * @param {Phaser.Physics.Impact.Body} bodyB - [description]\r\n */var Solver=function Solver(world,bodyA,bodyB){var weak=null;if(bodyA.collides===COLLIDES.LITE||bodyB.collides===COLLIDES.FIXED){weak=bodyA;}else if(bodyB.collides===COLLIDES.LITE||bodyA.collides===COLLIDES.FIXED){weak=bodyB;}if(bodyA.last.x+bodyA.size.x>bodyB.last.x&&bodyA.last.x<bodyB.last.x+bodyB.size.x){if(bodyA.last.y<bodyB.last.y){SeperateY(world,bodyA,bodyB,weak);}else{SeperateY(world,bodyB,bodyA,weak);}bodyA.collideWith(bodyB,'y');bodyB.collideWith(bodyA,'y');world.emit('collide',bodyA,bodyB,'y');}else if(bodyA.last.y+bodyA.size.y>bodyB.last.y&&bodyA.last.y<bodyB.last.y+bodyB.size.y){if(bodyA.last.x<bodyB.last.x){SeperateX(world,bodyA,bodyB,weak);}else{SeperateX(world,bodyB,bodyA,weak);}bodyA.collideWith(bodyB,'x');bodyB.collideWith(bodyA,'x');world.emit('collide',bodyA,bodyB,'x');}};module.exports=Solver;/***/},/* 1027 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Class=__webpack_require__(0);var Factory=__webpack_require__(994);var GetFastValue=__webpack_require__(2);var Merge=__webpack_require__(84);var PluginManager=__webpack_require__(13);var World=__webpack_require__(990);/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class ImpactPhysics\r\n * @memberOf Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */var ImpactPhysics=new Class({initialize:function ImpactPhysics(scene){/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactPhysics#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */this.scene=scene;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactPhysics#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */this.systems=scene.sys;if(!scene.sys.settings.isBooted){scene.sys.events.once('boot',this.boot,this);}/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactPhysics#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */this.config=this.getConfig();/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactPhysics#world\r\n         * @type {Phaser.Physics.Impact.World}\r\n         * @since 3.0.0\r\n         */this.world;/**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.ImpactPhysics#add\r\n         * @type {Phaser.Physics.Impact.Factory}\r\n         * @since 3.0.0\r\n         */this.add;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.ImpactPhysics#getConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} [description]\r\n     */getConfig:function getConfig(){var gameConfig=this.systems.game.config.physics;var sceneConfig=this.systems.settings.physics;var config=Merge(GetFastValue(sceneConfig,'impact',{}),GetFastValue(gameConfig,'impact',{}));return config;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.ImpactPhysics#boot\r\n     * @since 3.0.0\r\n     */boot:function boot(){this.world=new World(this.scene,this.config);this.add=new Factory(this.world);var eventEmitter=this.systems.events;eventEmitter.on('update',this.world.update,this.world);eventEmitter.on('shutdown',this.shutdown,this);eventEmitter.on('destroy',this.destroy,this);},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.ImpactPhysics#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} The Impact World object.\r\n     */pause:function pause(){return this.world.pause();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.ImpactPhysics#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} The Impact World object.\r\n     */resume:function resume(){return this.world.resume();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.ImpactPhysics#shutdown\r\n     * @since 3.0.0\r\n     */shutdown:function shutdown(){this.world.shutdown();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.ImpactPhysics#destroy\r\n     * @since 3.0.0\r\n     */destroy:function destroy(){this.world.destroy();}});PluginManager.register('ImpactPhysics',ImpactPhysics,'impactPhysics');module.exports=ImpactPhysics;/***/},/* 1028 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.Velocity\r\n * @since 3.0.0\r\n */var Velocity={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Velocity#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocityX:function setVelocityX(x){this.vel.x=x;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Velocity#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocityY:function setVelocityY(y){this.vel.y=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Velocity#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setVelocity:function setVelocity(x,y){if(y===undefined){y=x;}this.vel.x=x;this.vel.y=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Velocity#setMaxVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y=x] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setMaxVelocity:function setMaxVelocity(x,y){if(y===undefined){y=x;}this.maxVel.x=x;this.maxVel.y=y;return this;}};module.exports=Velocity;/***/},/* 1029 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.SetGameObject\r\n * @since 3.0.0\r\n */var SetGameObject={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.SetGameObject#setGameObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - [description]\r\n     * @param {boolean} [sync=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setGameObject:function setGameObject(gameObject,sync){if(sync===undefined){sync=true;}if(gameObject){this.body.gameObject=gameObject;if(sync){this.syncGameObject();}}else{this.body.gameObject=null;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.SetGameObject#syncGameObject\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */syncGameObject:function syncGameObject(){var gameObject=this.body.gameObject;if(gameObject){this.setBodySize(gameObject.width*gameObject.scaleX,gameObject.height*gameObject.scaleY);}return this;}};module.exports=SetGameObject;/***/},/* 1030 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.Offset\r\n * @since 3.0.0\r\n */var Offset={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Offset#setOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} [width] - [description]\r\n     * @param {number} [height] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setOffset:function setOffset(x,y,width,height){this.body.offset.x=x;this.body.offset.y=y;if(width){this.setBodySize(width,height);}return this;}};module.exports=Offset;/***/},/* 1031 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.Gravity\r\n * @since 3.0.0\r\n */var Gravity={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Gravity#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setGravity:function setGravity(value){this.body.gravityFactor=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.Components.Gravity#gravity\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */gravity:{get:function get(){return this.body.gravityFactor;},set:function set(value){this.body.gravityFactor=value;}}};module.exports=Gravity;/***/},/* 1032 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.Friction\r\n * @since 3.0.0\r\n */var Friction={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Friction#setFrictionX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFrictionX:function setFrictionX(x){this.friction.x=x;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Friction#setFrictionY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFrictionY:function setFrictionY(y){this.friction.y=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Friction#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFriction:function setFriction(x,y){this.friction.x=x;this.friction.y=y;return this;}};module.exports=Friction;/***/},/* 1033 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.Debug\r\n * @since 3.0.0\r\n */var Debug={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Debug#setDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} showBody - [description]\r\n     * @param {boolean} showVelocity - [description]\r\n     * @param {number} bodyColor - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setDebug:function setDebug(showBody,showVelocity,bodyColor){this.debugShowBody=showBody;this.debugShowVelocity=showVelocity;this.debugBodyColor=bodyColor;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Debug#setDebugBodyColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setDebugBodyColor:function setDebugBodyColor(value){this.body.debugBodyColor=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.Components.Debug#debugShowBody\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */debugShowBody:{get:function get(){return this.body.debugShowBody;},set:function set(value){this.body.debugShowBody=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.Components.Debug#debugShowVelocity\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */debugShowVelocity:{get:function get(){return this.body.debugShowVelocity;},set:function set(value){this.body.debugShowVelocity=value;}},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.Components.Debug#debugBodyColor\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */debugBodyColor:{get:function get(){return this.body.debugBodyColor;},set:function set(value){this.body.debugBodyColor=value;}}};module.exports=Debug;/***/},/* 1034 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var COLLIDES=__webpack_require__(205);/**\r\n * @callback CollideCallback\r\n *\r\n * @param {Phaser.Physics.Impact.Body} body - [description]\r\n * @param {Phaser.Physics.Impact.Body} other - [description]\r\n * @param {string} axis - [description]\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.Collides\r\n * @since 3.0.0\r\n */var Collides={_collideCallback:null,_callbackScope:null,/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Collides#setCollideCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {CollideCallback} callback - [description]\r\n     * @param {*} scope - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCollideCallback:function setCollideCallback(callback,scope){this._collideCallback=callback;if(scope){this._callbackScope=scope;}return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Collides#setCollidesNever\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCollidesNever:function setCollidesNever(){this.body.collides=COLLIDES.NEVER;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Collides#setLite\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setLite:function setLite(){this.body.collides=COLLIDES.LITE;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Collides#setPassive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setPassive:function setPassive(){this.body.collides=COLLIDES.PASSIVE;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Collides#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setActive:function setActive(){this.body.collides=COLLIDES.ACTIVE;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Collides#setFixed\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setFixed:function setFixed(){this.body.collides=COLLIDES.FIXED;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.Components.Collides#collides\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */collides:{get:function get(){return this.body.collides;},set:function set(value){this.body.collides=value;}}};module.exports=Collides;/***/},/* 1035 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var TYPE=__webpack_require__(204);/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.CheckAgainst\r\n * @since 3.0.0\r\n */var CheckAgainst={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.CheckAgainst#setAvsB\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAvsB:function setAvsB(){this.setTypeA();return this.setCheckAgainstB();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.CheckAgainst#setBvsA\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBvsA:function setBvsA(){this.setTypeB();return this.setCheckAgainstA();},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.CheckAgainst#setCheckAgainstNone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCheckAgainstNone:function setCheckAgainstNone(){this.body.checkAgainst=TYPE.NONE;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.CheckAgainst#setCheckAgainstA\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCheckAgainstA:function setCheckAgainstA(){this.body.checkAgainst=TYPE.A;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.CheckAgainst#setCheckAgainstB\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setCheckAgainstB:function setCheckAgainstB(){this.body.checkAgainst=TYPE.B;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.Components.CheckAgainst#checkAgainst\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */checkAgainst:{get:function get(){return this.body.checkAgainst;},set:function set(value){this.body.checkAgainst=value;}}};module.exports=CheckAgainst;/***/},/* 1036 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.Bounce\r\n * @since 3.0.0\r\n */var Bounce={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Bounce#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBounce:function setBounce(value){this.body.bounciness=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Bounce#setMinBounceVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setMinBounceVelocity:function setMinBounceVelocity(value){this.body.minBounceVelocity=value;return this;},/**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.Components.Bounce#bounce\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */bounce:{get:function get(){return this.body.bounciness;},set:function set(value){this.body.bounciness=value;}}};module.exports=Bounce;/***/},/* 1037 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var TYPE=__webpack_require__(204);/**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.BodyType\r\n * @since 3.0.0\r\n */var BodyType={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.BodyType#getBodyType\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */getBodyType:function getBodyType(){return this.body.type;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.BodyType#setTypeNone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setTypeNone:function setTypeNone(){this.body.type=TYPE.NONE;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.BodyType#setTypeA\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setTypeA:function setTypeA(){this.body.type=TYPE.A;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.BodyType#setTypeB\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setTypeB:function setTypeB(){this.body.type=TYPE.B;return this;}};module.exports=BodyType;/***/},/* 1038 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.BodyScale\r\n * @since 3.0.0\r\n */var BodyScale={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.BodyScale#setBodySize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} [height=width] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBodySize:function setBodySize(width,height){if(height===undefined){height=width;}this.body.size.x=Math.round(width);this.body.size.y=Math.round(height);return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.BodyScale#setBodyScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scaleX - [description]\r\n     * @param {number} [scaleY] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setBodyScale:function setBodyScale(scaleX,scaleY){if(scaleY===undefined){scaleY=scaleX;}var gameObject=this.body.gameObject;if(gameObject){gameObject.setScale(scaleX,scaleY);return this.setBodySize(gameObject.width*gameObject.scaleX,gameObject.height*gameObject.scaleY);}else{return this.setBodySize(this.body.size.x*scaleX,this.body.size.y*scaleY);}}};module.exports=BodyScale;/***/},/* 1039 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * [description]\r\n *\r\n * @name Phaser.Physics.Impact.Components.Acceleration\r\n * @since 3.0.0\r\n */var Acceleration={/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Acceleration#setAccelerationX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAccelerationX:function setAccelerationX(x){this.accel.x=x;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Acceleration#setAccelerationY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAccelerationY:function setAccelerationY(y){this.accel.y=y;return this;},/**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.Components.Acceleration#setAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */setAcceleration:function setAcceleration(x,y){this.accel.x=x;this.accel.y=y;return this;}};module.exports=Acceleration;/***/},/* 1040 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var H=0.5;var N=1/3;var M=2/3;//  Tile ID to Slope defs.\n//  First 4 elements = line data, final = solid or non-solid behind the line\nmodule.exports={2:[0,1,1,0,true],3:[0,1,1,H,true],4:[0,H,1,0,true],5:[0,1,1,M,true],6:[0,M,1,N,true],7:[0,N,1,0,true],8:[H,1,0,0,true],9:[1,0,H,1,true],10:[H,1,1,0,true],11:[0,0,H,1,true],12:[0,0,1,0,false],13:[1,1,0,0,true],14:[1,H,0,0,true],15:[1,1,0,H,true],16:[1,N,0,0,true],17:[1,M,0,N,true],18:[1,1,0,M,true],19:[1,1,H,0,true],20:[H,0,0,1,true],21:[0,1,H,0,true],22:[H,0,1,1,true],23:[1,1,0,1,false],24:[0,0,1,1,true],25:[0,0,1,H,true],26:[0,H,1,1,true],27:[0,0,1,N,true],28:[0,N,1,M,true],29:[0,M,1,1,true],30:[N,1,0,0,true],31:[1,0,M,1,true],32:[M,1,1,0,true],33:[0,0,N,1,true],34:[1,0,1,1,false],35:[1,0,0,1,true],36:[1,H,0,1,true],37:[1,0,0,H,true],38:[1,M,0,1,true],39:[1,N,0,M,true],40:[1,0,0,N,true],41:[M,1,N,0,true],42:[M,0,N,1,true],43:[N,1,M,0,true],44:[N,0,M,1,true],45:[0,1,0,0,false],52:[1,1,M,0,true],53:[N,0,0,1,true],54:[0,1,N,0,true],55:[M,0,1,1,true]};/***/},/* 1041 *//***/function(module,exports){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * Set up the trace-result\r\n * var res = {\r\n *     collision: {x: false, y: false, slope: false},\r\n *     pos: {x: x, y: y},\r\n *     tile: {x: 0, y: 0}\r\n * };\r\n *\r\n * @function Phaser.Physics.Impact.UpdateMotion\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Impact.Body} body - [description]\r\n * @param {object} res - [description]\r\n */var UpdateMotion=function UpdateMotion(body,res){body.standing=false;//  Y\nif(res.collision.y){if(body.bounciness>0&&Math.abs(body.vel.y)>body.minBounceVelocity){body.vel.y*=-body.bounciness;}else{if(body.vel.y>0){body.standing=true;}body.vel.y=0;}}//  X\nif(res.collision.x){if(body.bounciness>0&&Math.abs(body.vel.x)>body.minBounceVelocity){body.vel.x*=-body.bounciness;}else{body.vel.x=0;}}//  SLOPE\nif(res.collision.slope){var s=res.collision.slope;if(body.bounciness>0){var proj=body.vel.x*s.nx+body.vel.y*s.ny;body.vel.x=(body.vel.x-s.nx*proj*2)*body.bounciness;body.vel.y=(body.vel.y-s.ny*proj*2)*body.bounciness;}else{var lengthSquared=s.x*s.x+s.y*s.y;var dot=(body.vel.x*s.x+body.vel.y*s.y)/lengthSquared;body.vel.x=s.x*dot;body.vel.y=s.y*dot;var angle=Math.atan2(s.x,s.y);if(angle>body.slopeStanding.min&&angle<body.slopeStanding.max){body.standing=true;}}}body.pos.x=res.pos.x;body.pos.y=res.pos.y;};module.exports=UpdateMotion;/***/},/* 1042 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */var Clamp=__webpack_require__(50);/**\r\n * [description]\r\n *\r\n * @function Phaser.Physics.Impact.GetVelocity\r\n * @since 3.0.0\r\n *\r\n * @param {number} delta - [description]\r\n * @param {number} vel - [description]\r\n * @param {number} accel - [description]\r\n * @param {number} friction - [description]\r\n * @param {number} max - [description]\r\n *\r\n * @return {number} [description]\r\n */var GetVelocity=function GetVelocity(delta,vel,accel,friction,max){if(accel){return Clamp(vel+accel*delta,-max,max);}else if(friction){var frictionDelta=friction*delta;if(vel-frictionDelta>0){return vel-frictionDelta;}else if(vel+frictionDelta<0){return vel+frictionDelta;}else{return 0;}}return Clamp(vel,-max,max);};module.exports=GetVelocity;/***/},/* 1043 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * An Impact.js compatible physics world, body and solver, for those who are used\r\n * to the Impact way of defining and controlling physics bodies. Also works with\r\n * the new Loader support for Weltmeister map data.\r\n *\r\n * World updated to run off the Phaser main loop.\r\n * Body extended to support additional setter functions.\r\n *\r\n * To create the map data you'll need Weltmeister, which comes with Impact\r\n * and can be purchased from http://impactjs.com\r\n *\r\n * My thanks to Dominic Szablewski for his permission to support Impact in Phaser.\r\n *\r\n * @namespace Phaser.Physics.Impact\r\n */module.exports={Body:__webpack_require__(996),COLLIDES:__webpack_require__(205),CollisionMap:__webpack_require__(995),Factory:__webpack_require__(994),Image:__webpack_require__(992),ImpactBody:__webpack_require__(993),ImpactPhysics:__webpack_require__(1027),Sprite:__webpack_require__(991),TYPE:__webpack_require__(204),World:__webpack_require__(990)};/***/},/* 1044 *//***/function(module,exports,__webpack_require__){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n *//**\r\n * @namespace Phaser.Physics\r\n */module.exports={Arcade:__webpack_require__(493),Impact:__webpack_require__(1043),Matter:__webpack_require__(1023)};/***/},/* 1045 *//***/function(module,exports,__webpack_require__){/* WEBPACK VAR INJECTION */(function(global){/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */__webpack_require__(978);var CONST=__webpack_require__(22);var Extend=__webpack_require__(18);/**\r\n* @namespace Phaser\r\n*/var Phaser={Actions:__webpack_require__(380),Animation:__webpack_require__(904),Cache:__webpack_require__(903),Cameras:__webpack_require__(902),Class:__webpack_require__(0),Create:__webpack_require__(893),Curves:__webpack_require__(887),Data:__webpack_require__(884),Display:__webpack_require__(882),DOM:__webpack_require__(850),EventEmitter:__webpack_require__(848),Game:__webpack_require__(847),GameObjects:__webpack_require__(811),Geom:__webpack_require__(247),Input:__webpack_require__(568),Loader:__webpack_require__(554),Math:__webpack_require__(536),Physics:__webpack_require__(1044),Renderer:__webpack_require__(1002),Scene:__webpack_require__(298),Scenes:__webpack_require__(463),Sound:__webpack_require__(461),Structs:__webpack_require__(460),Textures:__webpack_require__(459),Tilemaps:__webpack_require__(457),Time:__webpack_require__(408),Tweens:__webpack_require__(406),Utils:__webpack_require__(402)};//   Merge in the consts\nPhaser=Extend(false,Phaser,CONST);//  Export it\nmodule.exports=Phaser;global.Phaser=Phaser;/*\r\n * \"Documentation is like pizza: when it is good, it is very, very good;\r\n * and when it is bad, it is better than nothing.\"\r\n *  -- Dick Brandon\r\n *//* WEBPACK VAR INJECTION */}).call(this,__webpack_require__(382));/***/}]/******/));});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./src/phaser.js?");

/***/ }),

/***/ "./src/scenes/MainScene.js":
/*!*********************************!*\
  !*** ./src/scenes/MainScene.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _phaser = __webpack_require__(/*! ../phaser */ \"./src/phaser.js\");\n\nvar _phaser2 = _interopRequireDefault(_phaser);\n\nvar _Player = __webpack_require__(/*! ../characters/Player */ \"./src/characters/Player.js\");\n\nvar _Player2 = _interopRequireDefault(_Player);\n\nvar _EffectManager = __webpack_require__(/*! ../effects/EffectManager */ \"./src/effects/EffectManager.js\");\n\nvar _EffectManager2 = _interopRequireDefault(_EffectManager);\n\nvar _TimeSurvival = __webpack_require__(/*! ../modes/TimeSurvival */ \"./src/modes/TimeSurvival.js\");\n\nvar _TimeSurvival2 = _interopRequireDefault(_TimeSurvival);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = MainScene = new _phaser2.default.Class({\n\n  Extends: _phaser2.default.Scene,\n\n  caption: null,\n  captionFormat: null,\n  enemies: [],\n  enemiesTotal: 20,\n  enemiesAlive: null,\n  effectManager: null,\n  gameMode: null,\n  land: null,\n  player: null,\n  isPaused: false,\n  inputBindings: null,\n\n  initialize: function initialize() {\n    _phaser2.default.Scene.call(this, { key: 'mainScene' });\n  },\n\n  preload: function preload() {\n    // WORLD\n    this.load.image('earth', 'assets/images/tanks/scorched_earth.png');\n\n    // CHARACTERS\n    this.load.image('player', 'assets/images/topdown/player machinegun.gif');\n    this.load.image('zombie1', 'assets/images/topdown/zombie.gif');\n    this.load.image('zombie2', 'assets/images/topdown/zombie 2.gif');\n\n    // AUDIO\n    this.load.audio('gunshot', 'assets/audio/gunshot.wav');\n\n    // WEAPONS\n    this.load.image('bullet', 'assets/images/tanks/bullet.png');\n\n    // EFFECTS\n    this.load.image('corpse', 'assets/images/blood/corpse.png');\n  },\n\n  create: function create() {\n    // WORLD\n    this.physics.world.setBounds(-1000, -1000, 2000, 2000);\n\n    // LAND (background)\n    this.land = this.add.tileSprite(0, 0, 2000, 2000, 'earth').setDepth(-2);\n    this.land.fixedToCamera = true;\n\n    // PLAYER\n    this.player = new _Player2.default(this);\n\n    // GAME MODE\n    this.gameMode = new _TimeSurvival2.default(this, this.player);\n    this.gameMode.init();\n\n    // CAMERAS\n    this.cameras.main.setBounds(-1000, -1000, 1000, 1000).setName('main');\n    this.cameras.main.startFollow(this.player.sprite);\n\n    // EFFECTS\n    this.effectManager = new _EffectManager2.default(this);\n\n    // ON-SCREEN TEXT\n    var captionStyle = {\n      fill: '#fff',\n      fontFamily: 'monospace',\n      lineSpacing: 4\n    };\n\n    this.captionFormat = 'Time Survived:     %1s\\n' + 'Difficulty:       x%2\\n' + 'Enemies killed:    %3\\n' + 'Health:            %4\\n' + 'Shots fired:       %5\\n' + 'Accuracy:          %6%\\n';\n    this.caption = this.add.text(16, 16, '', captionStyle);\n    this.caption.setScrollFactor(0, 0);\n    this.caption.setDepth(999);\n  },\n\n  update: function update() {\n\n    this.player.update();\n    this.gameMode.update();\n\n    // UPDATE CAPTION TEXT\n    this.caption.setText(_phaser2.default.Utils.String.Format(this.captionFormat, [this.gameMode.timeSurvived, parseFloat(this.gameMode.difficulty).toFixed(1), this.player.enemiesKilled, 'N/A', this.player.shotsFired, Math.floor(this.player.shotsHit / this.player.shotsFired * 100)]));\n  }\n});\n\n//# sourceURL=webpack:///./src/scenes/MainScene.js?");

/***/ }),

/***/ "./src/weapons/Gun.js":
/*!****************************!*\
  !*** ./src/weapons/Gun.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n      value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _InputBindings = __webpack_require__(/*! ../input/InputBindings */ \"./src/input/InputBindings.js\");\n\nvar _InputBindings2 = _interopRequireDefault(_InputBindings);\n\nvar _EffectManager = __webpack_require__(/*! ../effects/EffectManager */ \"./src/effects/EffectManager.js\");\n\nvar _EffectManager2 = _interopRequireDefault(_EffectManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Gun = function () {\n      function Gun(game, player, fireRate) {\n            _classCallCheck(this, Gun);\n\n            this.game = game;\n            this.player = player;\n            this.fireRate = fireRate;\n            this.nextFire = 0;\n            this.bullets = this.game.physics.add.group({\n                  defaultKey: 'bullet'\n            });\n            this.input = new _InputBindings2.default(this.game);\n            this.effects = new _EffectManager2.default(this.game);\n      }\n\n      _createClass(Gun, [{\n            key: 'fire',\n            value: function fire() {\n                  if (this.game.time.now > this.nextFire) {\n\n                        // Limit fire rate\n                        this.nextFire = this.game.time.now + this.fireRate;\n\n                        // Bullet spawn\n                        var bullet = this.bullets.getFirstDead(true);\n                        bullet.rotation = this.player.sprite.rotation;\n                        bullet.displayOriginX -= 50;\n                        bullet.displayOriginY -= 23;\n                        bullet.setScale(0.5);\n                        bullet.setPosition(this.player.sprite.x, this.player.sprite.y);\n\n                        // Bullet movement\n                        this.game.physics.moveTo(bullet, this.input.pointer.x + this.game.cameras.main.scrollX, this.input.pointer.y + this.game.cameras.main.scrollY, 1500);\n\n                        this.player.shotsFired++;\n\n                        // Effects\n                        this.game.cameras.main.shake(100, 0.002); // duration, intensity\n                        this.effects.playGunshot();\n\n                        // Limit spawned bullets for performance\n                        if (this.bullets.getChildren().length > 20) this.bullets.clear();\n                  }\n            }\n      }]);\n\n      return Gun;\n}();\n\nexports.default = Gun;\n\n//# sourceURL=webpack:///./src/weapons/Gun.js?");

/***/ })

/******/ });